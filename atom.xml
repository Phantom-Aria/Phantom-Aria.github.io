<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>我的小破站</title>
  
  
  <link href="http://www.shelven.com/atom.xml" rel="self"/>
  
  <link href="http://www.shelven.com/"/>
  <updated>2023-04-13T09:39:32.000Z</updated>
  <id>http://www.shelven.com/</id>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基因组注释（5）——预测基因筛选</title>
    <link href="http://www.shelven.com/2023/04/11/a.html"/>
    <id>http://www.shelven.com/2023/04/11/a.html</id>
    <published>2023-04-11T14:58:20.000Z</published>
    <updated>2023-04-13T09:39:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>注释得到的基因集中，可能某些基因存在被转座子插入的情况，该基因会在后续功能注释的时候被注释上，但实际在基因组中该基因可能已经被插入失活。因此在基因组的功能注释前，需要用检测转座子软件（如TransposonPSI、TEsorter等）将含有转座子的基因找出并去除。</p><span id="more"></span><p>这里记录下<code>TEsorter</code>软件筛选预测基因的方法。</p><h2 id="1-TEsorter安装"><a href="#1-TEsorter安装" class="headerlink" title="1. TEsorter安装"></a>1. TEsorter安装</h2><div class="story post-story"><p><a href="https://github.com/zhangrengang/TEsorter">TEsorter</a>原本是用于调用<a href="https://github.com/oushujun/LTR_retriever">LTR_retriever</a>鉴别长末端重复序列反转座子（LTR-RTs），也可以用于其他类型TE的鉴别，其鉴定原理为将待测序列与数据库<a href="http://repeatexplorer.org/?page_id=918">REXdb</a>（整合viridiplantae_v3.0 + metazoa_v3）的TE序列进行比对。</p><p>也可以使用<a href="http://gydb.org/">GyDB</a>数据库进行比对，官网上有具体的参数用法。</p><p><a href="https://github.com/zhangrengang/TEsorter">zhangrengang&#x2F;TEsorter: TEsorter: an accurate and fast method to classify LTR-retrotransposons in plant genomes (github.com)</a></p><p><code>TEsorter</code>提供conda安装，但是我没有安装成功，这里还是新建conda环境后手动安装各种依赖：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">conda create -n &quot;TEs&quot;</span><br><span class="line">conda activate TEs</span><br><span class="line"></span><br><span class="line">conda install python==3.11# 官方要求python版本高于3，否则运行会报错</span><br><span class="line">conda install biopython</span><br><span class="line">conda install xopen</span><br><span class="line">conda install hmmer</span><br><span class="line">conda install blast</span><br><span class="line"></span><br><span class="line">git clone https://ghproxy.com/https://github.com/zhangrengang/TEsorter.git# 从github镜像网站下载</span><br><span class="line">cd TEsorter</span><br><span class="line">python setup.py install</span><br><span class="line"></span><br><span class="line">TEsorter TEsorter/test/rice6.9.5.liban# 测试</span><br></pre></td></tr></table></figure></div><h2 id="2-TEsorter运行"><a href="#2-TEsorter运行" class="headerlink" title="2. TEsorter运行"></a>2. TEsorter运行</h2><div class="story post-story"><p>这里有一个问题，Braker预测基因有<code>gtf</code>和<code>gff3</code>两种格式的输出结果，<strong>但是两者的行数不一样</strong>。<code>braker.aa</code>蛋白序列和<code>braker.codingseq</code>基因序列的条数与<code>gtf</code>文件中的<code>transcript</code>条数一致，但是比<code>gff3</code>文件中的<code>mRNA</code>条数多（按理来说两者应该是一致的）。</p><p>后来发现Braker加入<code>--gff3</code>参数生成的<code>gff3文件mRNA数量 + gtf文件的mRNA数量 = gtf文件的transcript数量</code>，不理解为什么有这种关系，方便起见我这里处理了<code>gtf</code>结果文件。</p><p>TEsorter软件可以输入<strong>基因序列</strong>或者<strong>蛋白序列</strong>，以基因序列为例，简单编写脚本如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -n 8</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -t 7200</span></span><br><span class="line"></span><br><span class="line">TEsorter /public/home/wlxie/baima_pre_mydb/braker.codingseq -eval 1e-6 -p 8</span><br></pre></td></tr></table></figure><p>大约十几分钟运行完毕。</p></div><h2 id="3-结果文件处理"><a href="#3-结果文件处理" class="headerlink" title="3. 结果文件处理"></a>3. 结果文件处理</h2><div class="story post-story"><p>结果文件如下：</p><p><img src="https://www.shelven.com/tuchuang/20230411/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230411/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><code>.tsv</code>后缀的文件中以列表形式列出了所有预测的TE类型，一个基因可能有多种类型的TE插入，因此需要处理结果文件，统计含有TE的基因，并在<code>gtf</code>结果文件中将该基因去除。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">筛选含有TE的基因</span></span><br><span class="line">grep -v &quot;^#&quot; braker.codingseq.rexdb.cls.tsv | cut -f1 | sort | uniq | cut -f1 -d &quot;_&quot; | sort | uniq &gt; TE-genes.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">去除含有TE的基因序列</span></span><br><span class="line">grep -Fvf /public/home/wlxie/biosoft/TEsorter/baima_mydb/TE-genes.txt braker.gtf | awk &#x27;$3 ~ /gene/&#x27; &gt; baima_gene_only.gtf</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">去除含有TE的转录本序列</span></span><br><span class="line">grep -Fvf /public/home/wlxie/biosoft/TEsorter/baima_mydb/TE-genes.txt braker.gtf | awk &#x27;$3 ~ /transcript/&#x27; &gt; baima_transcript.gtf </span><br></pre></td></tr></table></figure><p>可以看看去除TE序列后的转录本和基因数量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(base) wlxie 17:03:52 ~/baima_pre_mydb</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> baima_transcript.gtf | <span class="built_in">wc</span> -l</span></span><br><span class="line">23716</span><br><span class="line">(base) wlxie 17:04:05 ~/baima_pre_mydb</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> baima_gene_only.gtf | <span class="built_in">wc</span> -l</span></span><br><span class="line">20742</span><br></pre></td></tr></table></figure><p>本想通过<code>gffread</code>软件根据处理后的gtf文件重新提取基因组的蛋白序列，但是运行过程中总是报错<code>no genomic sequence available</code>，原因暂时未知（可能是因为braker预测结果braker.gtf不是标准的gtf文件格式，同样用gffread做gtf2gff转换的时候会有部分信息丢失）。</p><p>可以直接写一个脚本处理<code>braker.aa</code>文件，根据前面筛选的<code>TE-genes.txt</code>文件，去除含有TE的蛋白序列，这里后续用到再做更新。</p></div><h2 id="2023-4-13-更新"><a href="#2023-4-13-更新" class="headerlink" title="2023.4.13 更新"></a>2023.4.13 更新</h2><div class="story post-story"><p><code>gffread</code>报错的原因找到了：</p><blockquote><ul><li>基因组文件的序列编号有空格</li><li>gtf文件缺少必要的位置信息</li></ul></blockquote><p>主要还是跑braker过程的疏忽和对gtf以及gff3数据格式的不了解。</p><p><img src="https://www.shelven.com/tuchuang/20230411/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230411/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>在<code>braker.log</code>日志文件中有提示，基因组的fasta文件的header中包含了空格，可能会导致后续的错误，<strong>因此braker运行时自动将空格替换为了下划线“_”</strong>，这就导致了预测后的gtf文件与基因组文件无法匹配上，自然就报错<code>no genomic sequence available</code>。</p><blockquote><p><strong>解决方法：</strong></p><p>手动将基因组文件中的header部分的空格用下划线“_”代替（我的基因组是59条contig，也就是手动改59个空格），并删除原<code>fai</code>索引文件（一定要删除，否则仍然无法找到基因序列）。</p></blockquote><p>用<code>gffread</code>软件做gtf和gff3格式相互转换的时候，确实会损失一部分信息，但仍然会保留最基本的CDS信息。如果直接从gtf文件的第三列提取<code>gene</code>和<code>transcript</code>信息保存成新的gtf文件，<strong>这个新的gtf文件是无法用gffread定位和提取蛋白序列的。</strong></p><p>这一点在<a href="http://mblab.wustl.edu/GTF22.html#fields">GTF官方文档</a>对第三列的&lt;feature&gt;解释中有提到：</p><blockquote><p><strong><feature></strong><br>The following feature types are required: “CDS”, “start_codon”, “stop_codon”. The features “5UTR”, “3UTR”, “inter”, “inter_CNS”, “intron_CNS” and “exon” are optional. All other features will be ignored. The types must have the correct capitalization shown here.</p><p>也就是说我如果从第三列只提取gene或者transcript，这些feature是会被忽略的，使用gffread提取蛋白序列会提示这是一个非法的GTF文件。</p></blockquote><p>因此，正确的筛选方式和提取蛋白的方式应该为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">筛选含有TE的基因</span></span><br><span class="line">grep -v &quot;^#&quot; braker.codingseq.rexdb.cls.tsv | cut -f1 | sort | uniq | cut -f1 -d &quot;_&quot; | sort | uniq &gt; TE-genes.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">去除含有TE的序列</span></span><br><span class="line">grep -Fvf /public/home/wlxie/biosoft/TEsorter/baima_mydb/TE-genes.txt braker.gtf &gt; baima_rmTE.gtf</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从基因组重新提取去除了TE的蛋白序列</span></span><br><span class="line">gffread baima_rmTE.gtf -g /public/home/wlxie/biosoft/db_data/RepeatMasker_soft/genome.nextpolish.fasta.masked -y pep_rmTE.fa</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;注释得到的基因集中，可能某些基因存在被转座子插入的情况，该基因会在后续功能注释的时候被注释上，但实际在基因组中该基因可能已经被插入失活。因此在基因组的功能注释前，需要用检测转座子软件（如TransposonPSI、TEsorter等）将含有转座子的基因找出并去除。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="基因组三代测序分析" scheme="http://www.shelven.com/categories/%E5%9F%BA%E5%9B%A0%E7%BB%84%E4%B8%89%E4%BB%A3%E6%B5%8B%E5%BA%8F%E5%88%86%E6%9E%90/"/>
    
    
    <category term="TEsorter" scheme="http://www.shelven.com/tags/TEsorter/"/>
    
  </entry>
  
  <entry>
    <title>基因组注释（4）——基因预测</title>
    <link href="http://www.shelven.com/2023/04/03/a.html"/>
    <id>http://www.shelven.com/2023/04/03/a.html</id>
    <published>2023-04-03T14:09:26.000Z</published>
    <updated>2023-04-08T02:38:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>在对基因组重复序列和ncRNA进行注释后，接下来是基因预测和功能注释，这也是寻找功能基因的基础和前提。这里主要记录下怎么用Braker3进行基因组的基因预测（也就是结构注释）。</p><span id="more"></span><p>基因预测的方法主要有三种：</p><ul><li>基于隐马尔可夫模型的自训练和迭代，获得从头预测的基因结构模型（软件Augustus、GeneMark-ES等）</li><li>基于已发表的近缘物种基因序列、蛋白序列的同源预测（软件DIAMOND、GeMoMa等）</li><li>基于本物种的RNA-Seq转录组数据，比对基因组内含子结构模型和基因侧翼序列信息（软件Hisat2、STAR等）</li></ul><p>一般的流程是将以上三种基因预测结果通过软件EvidenceModeler（EVM）进行整合，最终得到预测结果gff文件。网上对于上面的流程有很多教程，针对不同软件有不同的设置，比如知乎的这篇文章<a href="https://zhuanlan.zhihu.com/p/379464361">使用AUGSTUS + Geneid + GeneMark + GeMoMa + GenomeThreader + Exonerate 进行基因结构预测 - 知乎 (zhihu.com)</a></p><p>为了简化流程，现在也有越来越多的基因预测pipeline工具得以开发，比较有名的就是<a href="https://github.com/Gaius-Augustus/BRAKER">Braker</a>和<a href="https://www.yandell-lab.org/software/maker.html">Maker</a>，感兴趣的话可以做两者预测结果的比较，我这里就用发表时间比较近的Braker3为例。</p><p>Braker本质上是一个结合了多种基因组注释工具的perl程序，其核心为braker.pl文件。</p><h2 id="1-安装Braker3"><a href="#1-安装Braker3" class="headerlink" title="1. 安装Braker3"></a>1. 安装Braker3</h2><div class="story post-story"><p>目前为止（2023年4月3日）Braker的最新版本为3.0.2，conda上能搜到的最新版本只有2.1.6，<strong>因此不建议用conda安装</strong>，尤其是最新的版本Braker可以直接使用RNA-seq和蛋白数据，整合GeneMark-ETP和AUGUSTUS训练和预测基因，对于预测结果有较高的支持度。</p><p>因为整个pipeline包含了十几个注释用的软件，用到的perl模块也非常多（数了一下配置环境需要安装20个perl模块），还是推荐用给官方给的**<a href="https://hub.docker.com/r/teambraker/braker3">container</a>**。</p><h3 id="1-1-申请和下载GeneMark-ETP密钥"><a href="#1-1-申请和下载GeneMark-ETP密钥" class="headerlink" title="1.1 申请和下载GeneMark-ETP密钥"></a>1.1 申请和下载GeneMark-ETP密钥</h3><p>在Braker3中使用RNA-seq数据和蛋白数据预测基因，都要用到GeneMark-ETP这个软件。但是这个软件不能直接用，需要到<a href="http://topaz.gatech.edu/genemark/license_download.cgi">GeneMark网站</a>申请和下载对应的密钥文件放在集群用户的家目录中。</p><img src="https://www.shelven.com/tuchuang/20230403/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230403/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" style="zoom:80%;" /><img src="https://www.shelven.com/tuchuang/20230403/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230403/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" style="zoom:80%;" /><p>申请完成之后获得名称为<code>gm_key_64.gz</code>的密钥文件，解压之后命名为<code>.gm_key</code>（注意点号）并上传到集群用户的家目录下即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gunzip gm_key_64.gz</span><br><span class="line">mv gm_key_64 .gm_key</span><br></pre></td></tr></table></figure><h3 id="1-2-创建Braker3镜像"><a href="#1-2-创建Braker3镜像" class="headerlink" title="1.2 创建Braker3镜像"></a>1.2 创建Braker3镜像</h3><p>这一步在dockerhub网站的Braker3仓库中有详细说明，我这里选择创建singularity镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">singularity build braker3.sif docker://teambraker/braker3:latest</span><br></pre></td></tr></table></figure><p>得到的<code>braker3.sif</code>就是Braker3的singularity image</p><p>创建braker3镜像文件的环境变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export BRAKER_SIF=/your/path/to/braker3.sif</span><br></pre></td></tr></table></figure><p>可以复制三个示例脚本到当前目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">singularity exec -B $PWD:$PWD braker3.sif cp /opt/BRAKER/example/singularity-tests/test1.sh .</span><br><span class="line">singularity exec -B $PWD:$PWD braker3.sif cp /opt/BRAKER/example/singularity-tests/test2.sh .</span><br><span class="line">singularity exec -B $PWD:$PWD braker3.sif cp /opt/BRAKER/example/singularity-tests/test3.sh .</span><br></pre></td></tr></table></figure><p>在本地申请计算资源并跑一下三个示例脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">salloc -n 50# 申请50个核跑test.sh，注意不要在登录节点直接运行计算程序</span><br><span class="line">bash test1.sh # tests BRAKER1</span><br><span class="line">bash test2.sh # tests BRAKER2</span><br><span class="line">bash test3.sh # tests BRAKER3</span><br><span class="line">exit# 退出并释放计算资源</span><br></pre></td></tr></table></figure></div><h2 id="2-运行Braker3"><a href="#2-运行Braker3" class="headerlink" title="2. 运行Braker3"></a>2. 运行Braker3</h2><div class="story post-story"><p>官方提供了4种BRAKER pipeline 模式：</p><ul><li>RNA-Seq数据跑BRAKER</li><li>蛋白数据跑BRAKER</li><li>整合RNA-Seq数据以及蛋白数据跑BRAKER</li><li>整合短读长与长读长的RNA-Seq数据以及蛋白数据跑BRAKER</li></ul><p>4种pipeline模式在调用软件的方法上有区别，根据自己手上有的数据选择用哪种，我这里选择第三种。</p><p><img src="https://www.shelven.com/tuchuang/20230403/3.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230403/3.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>上图是整合RNA-Seq数据和蛋白数据跑Braker的流程图，需要注意基因组文件<code>genome.fa</code>在输入前需要需要进行softmasking（重复序列屏蔽为小写字母），官方建议不要用hardmasking（重复序列屏蔽为N），hardmasking后预测的基因数量会偏少，因为重复序列中可能也有功能基因的部分信息，屏蔽为N后就无法检测到了。</p><p>对RNA-Seq数据的处理，首先是通过<code>SRA tookit</code>将SRA ID对应的fastq数据下载下来（如果本来就是fastq格式就不需要这一步），用<code>Hisat2</code>比对到softmasking后的参考基因组并生成bam文件，再用<code>stringtie</code>进行转录本组装。</p><p><code>GeneMark-ETP</code>以组装后的转录本和同源蛋白数据库作为输入数据进行训练和预测，之后再用<code>AUGUSTUS</code>软件结合上一步的预测结果进行训练和预测，最后用<code>TSEBRA</code>对预测的基因集进行整合，得到最终的gtf结果文件。</p><p><code>barker.sh</code>脚本可以如下编写:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -n 48</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -t 7200</span></span><br><span class="line"></span><br><span class="line">wd=baima_pre</span><br><span class="line"></span><br><span class="line">if [ -d $wd ]; then</span><br><span class="line">    rm -r $wd</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">singularity exec -B $&#123;PWD&#125;:$&#123;PWD&#125; $&#123;BRAKER_SIF&#125; braker.pl --genome=/public/home/wlxie/biosoft/db_data/baima/RepeatMasker_soft/genome.nextpolish.fasta.masked --prot_seq=/public/home/wlxie/busco_soft/busco/test_data/eukaryota/busco_downloads/lineages/eudicots_odb10/refseq_db.faa --softmasking --threads 48 --workingdir=$&#123;wd&#125; --rnaseq_sets_dirs=/public/home/wlxie/RNAseq/BYT2022020901/rnaseq/baima --rnaseq_sets_ids=4-216031965_raw</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>几个参数的解释：</p><blockquote><p>genome    softmasking后的基因组文件位置</p><p>prot_seq    同源蛋白库的文件位置</p><p>–softmasking    mask的方式</p><p>–threads    跑程序用的核数</p><p>–workingdir    工作目录位置</p><p>rnaseq_sets_dirs    RNA-Seq数据所在目录</p><p>–rnaseq_sets_ids    双端测序数据文件前缀（比如我这里是4-216031965_raw_1.fq和4-216031965_raw_2.fq）</p></blockquote><p><del>说明一下同源蛋白来源于前面做BUSCO评估的真双子叶植物单拷贝直系同源库，怎么来的详情可见<a href="http://www.shelven.com/2023/03/01/a.html">这篇博客</a></del>（<strong>同源蛋白库建议用官方推荐的OrthoDB</strong>或者找几个模式植物的蛋白数据合并，见博客最下方的更新）</p><p><strong>前面说过塔大集群的计算节点没有安装singularity</strong>，所以在运行该容器的时候要在申请核在本地跑程序，并且用screen维持当前会话：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">screen -S singularity# 创建singularity会话</span><br><span class="line">salloc -n 48 -t 7200# 申请计算资源</span><br><span class="line">bash barker.sh</span><br><span class="line"></span><br><span class="line">screen -r singularity# 进入singularity会话</span><br><span class="line">exit# 退出会话</span><br><span class="line">exit# 运行结束释放计算资源</span><br></pre></td></tr></table></figure><p>正常跑完花费了9个小时时间（200Mbp大小的基因组），如果中途不幸出bug，braker支持有限度的断点重新运行，主要分为以下三个阶段：</p><p><img src="https://www.shelven.com/tuchuang/20230403/4.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230403/4.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>只要有中间文件存在，就可以在这三个阶段继续加入其他参数，跳过已经运行的阶段继续运行，详情可以看官方文档<a href="https://github.com/Gaius-Augustus/BRAKER#starting-braker-on-the-basis-of-previously-existing-braker-runs">https://github.com/Gaius-Augustus/BRAKER#starting-braker-on-the-basis-of-previously-existing-braker-runs</a></p></div><h2 id="3-结果文件"><a href="#3-结果文件" class="headerlink" title="3. 结果文件"></a>3. 结果文件</h2><div class="story post-story"><p>可以在前面给定的工作目录中看到如下结果文件:</p><p><img src="https://www.shelven.com/tuchuang/20230403/5.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230403/5.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><blockquote><ul><li>braker.gtf——Braker预测的基因集，包括了各种不同的基因结构预测结果</li><li>braker.codingseq——fasta格式的编码序列基因集（基因序列）</li><li>braker.aa——fasta格式的蛋白序列基因集（蛋白序列）</li><li>braker.gff3——需要–gff3参数指定，这里我没有，就是基因集的gff3格式</li><li>Augustus&#x2F;*——AUGUSTUS预测的基因集（包括gtf文件、基因序列和蛋白序列）</li><li>GeneMark-ETP&#x2F;*——GeneMark-ETP预测的基因集以及其他中间文件</li><li>hintsfile.gff——从RNA-Seq数据和蛋白库数据中提取的外部证据数据</li></ul></blockquote><p>可以通过awk命令查看gft文件的第三列，查看预测的编码蛋白基因数量和转录本数量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&#x27;$3==&quot;gene&quot;&#x27;</span> braker.gtf | <span class="built_in">wc</span> -l</span></span><br><span class="line">17869</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&#x27;$3==&quot;transcript&quot;&#x27;</span> braker.gtf | <span class="built_in">wc</span> -l</span></span><br><span class="line">20832</span><br></pre></td></tr></table></figure><p>后续就可以对这些预测的基因做质量评估，然后比对各数据库做功能注释。</p></div><h2 id="2023-4-7-更新"><a href="#2023-4-7-更新" class="headerlink" title="2023.4.7 更新"></a>2023.4.7 更新</h2><div class="story post-story"><h3 id="1-OrthoDB蛋白数据库下载"><a href="#1-OrthoDB蛋白数据库下载" class="headerlink" title="1. OrthoDB蛋白数据库下载"></a>1. OrthoDB蛋白数据库下载</h3><p>官方推荐使用OrthoDB数据库作为同源蛋白来源。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 真菌</span><br><span class="line">Fungi: https://v100.orthodb.org/download/odb10_fungi_fasta.tar.gz</span><br><span class="line"># 后生动物</span><br><span class="line">Metazoa: https://v100.orthodb.org/download/odb10_metazoa_fasta.tar.gz</span><br><span class="line"># 节肢动物</span><br><span class="line">- Arthropoda: https://v100.orthodb.org/download/odb10_arthropoda_fasta.tar.gz</span><br><span class="line"># 脊椎动物</span><br><span class="line">- Vertebrata: https://v100.orthodb.org/download/odb10_vertebrata_fasta.tar.gz</span><br><span class="line"># 单细胞生物</span><br><span class="line">Protozoa: https://v100.orthodb.org/download/odb10_protozoa_fasta.tar.gz</span><br><span class="line"># 绿色植物</span><br><span class="line">Viridiplantae: https://v100.orthodb.org/download/odb10_plants_fasta.tar.gz</span><br></pre></td></tr></table></figure><p>我这里要分析的物种是植物，所以下载最后一个绿色植物蛋白库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nohup wget https://v100.orthodb.org/download/odb10_plants_fasta.tar.gz &amp;</span><br><span class="line">tar zxvf odb10_plants_fasta.tar.gz</span><br><span class="line">cat plants/Rawdata/* &gt; plant_proteins.fasta</span><br></pre></td></tr></table></figure><p>绿色植物蛋白库约780Mb大小，<strong>建议用wget下载</strong>，如果windows下载再ftp拖拽上传到集群可能会损坏文件（并且没有md5效验码没办法确认是否真的损坏）。</p><p>解压并将所有数据合并到一个文件<code>plant_proteins.fasta</code>中，截至目前2023年4月7日为止，这个数据库共有3510742条蛋白序列，总文件大小为1.4Gb，比原来我比对的蛋白库大了1500倍。而蛋白比对是一个很缓慢的过程，因此这一步预测基因的时间将会很长，可以根据自己要做的物种确定用哪些注释比较完善的模式生物的蛋白库。</p><h3 id="2-自建蛋白数据库"><a href="#2-自建蛋白数据库" class="headerlink" title="2. 自建蛋白数据库"></a>2. 自建蛋白数据库</h3><p>在NCBI网站上直接找一些组装注释结果较好的模式生物和近缘物种蛋白：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 拟南芥（TAIR10.1）</span><br><span class="line">wget https://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/000/001/735/GCF_000001735.4_TAIR10.1/GCF_000001735.4_TAIR10.1_protein.faa.gz</span><br><span class="line"># 栽培烟草（Ntab-TN90）</span><br><span class="line">wget https://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/000/715/135/GCF_000715135.1_Ntab-TN90/GCF_000715135.1_Ntab-TN90_protein.faa.gz</span><br><span class="line"># 水稻（IRGSP-1.0）</span><br><span class="line">wget https://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/001/433/935/GCF_001433935.1_IRGSP-1.0/GCF_001433935.1_IRGSP-1.0_protein.faa.gz</span><br><span class="line"># 近缘物种coffea arabica</span><br><span class="line">wget https://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/003/713/225/GCF_003713225.1_Cara_1.0/GCF_003713225.1_Cara_1.0_protein.faa.gz</span><br><span class="line"># 近缘物种coffea canephora</span><br><span class="line">wget https://ftp.ncbi.nlm.nih.gov/genomes/all/GCA/900/059/795/GCA_900059795.1_AUK_PRJEB4211_v1/GCA_900059795.1_AUK_PRJEB4211_v1_protein.faa.gz</span><br><span class="line"></span><br><span class="line">gunzip *.gz</span><br><span class="line">cat *.faa &gt; mydb_proteins.fasta</span><br></pre></td></tr></table></figure><p>顺便记录一下近缘物种的同源蛋白是如何找到的：</p><p><a href="https://www.plabipd.de/">plant Biology - Usadel lab (plabipd.de)</a>这个网站记录了多种已发表的植物基因组文章和数据，点击<a href="https://www.plabipd.de/plant_genomes_pa.ep">cladogram view</a>可以直观地看到已测过基因组的植物学名和树状图，比如我要找的物种是夹竹桃科（Apocynaceae），直接<code>ctrl + F</code> 就可以定位到夹竹桃科所处的进化节点。</p><img src="https://www.shelven.com/tuchuang/20230403/6.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230403/6.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" style="zoom:80%;" /><p>然后用Apocynaceae祖先节点和子节点的已发表基因组的植物学名，一个一个去搜NCBI网站的Genome库，有protein序列的就可以直接下载。</p><p><img src="https://www.shelven.com/tuchuang/20230403/7.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230403/7.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>两种同源蛋白建库方式预测的基因数量和花费的时间：</p><table><thead><tr><th></th><th>OrthoDB Plant数据库</th><th>自建蛋白数据库</th></tr></thead><tbody><tr><td>花费时间</td><td>13 h</td><td>12.5 h</td></tr><tr><td>预测基因数</td><td>23746</td><td>23953</td></tr></tbody></table><p>用自建蛋白数据库跑braker预测的基因数更多，且花费时间更短。后续以该预测结果继续分析。</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;在对基因组重复序列和ncRNA进行注释后，接下来是基因预测和功能注释，这也是寻找功能基因的基础和前提。这里主要记录下怎么用Braker3进行基因组的基因预测（也就是结构注释）。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="基因组三代测序分析" scheme="http://www.shelven.com/categories/%E5%9F%BA%E5%9B%A0%E7%BB%84%E4%B8%89%E4%BB%A3%E6%B5%8B%E5%BA%8F%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Barker3" scheme="http://www.shelven.com/tags/Barker3/"/>
    
  </entry>
  
  <entry>
    <title>Apptainer/Singularity使用方法记录</title>
    <link href="http://www.shelven.com/2023/03/29/a.html"/>
    <id>http://www.shelven.com/2023/03/29/a.html</id>
    <published>2023-03-28T16:05:34.000Z</published>
    <updated>2023-03-28T16:21:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>在做生信分析的时候，难免会遇到一个pipeline上的软件存在冲突的情况，一般的解决方法是创建不同的conda环境，然后分别在不同的环境下跑不同的软件。这种操作可以解决环境冲突的问题但不适合写流程化的脚本，同时又非常占用空间。有的软件整合了pipeline流程的所有软件，按照顺序进行调用，这种软件虽然可以节省时间实现自动化分析，但是环境依赖的问题更加复杂，因此这一类的软件也往往提供容器来方便人们在一个封闭的环境中使用。</p><span id="more"></span><p>这篇博客主要讲一讲关于容器的一些基本常识，以及记录下学校集群中<code>singularity</code>的使用方法。</p><h2 id="1-容器（Container）"><a href="#1-容器（Container）" class="headerlink" title="1. 容器（Container）"></a>1. 容器（Container）</h2><div class="story post-story"><p>前面说到为了规避软件与现有环境依赖冲突，我们往往会把一个pipeline的软件封装到一个容器中。容器是一种在Linux系统上广泛采用的应用封装技术，它将可执行程序与依赖库打包成一个镜像文件，启动时与宿主节点共享操作系统内核。</p><blockquote><p>镜像（Image）：可执行的独立软件包，用于保存环境</p><p>实例（Instance）：基于镜像启动的运行实例，运行实际任务，不同实例之间互相隔离</p></blockquote><p>由于这个镜像文件自带了可执行文件和依赖库，因此不需要用到宿主机的依赖库，也就从源头上避免了环境冲突的情况。听起来这种实现方式类似于<strong>虚拟化技术</strong>，但还是有一些区别的：前面说过容器启动时与宿主机共享操作系统内核，没有运行独立的操作系统任务，在资源的占用上明显低于虚拟机。虚拟化可以认为它更全面和彻底一些，每个虚拟机从宿主机的物理框架中分割出来，有自己的一整套操作系统，会运行各种独立的操作系统任务，即使没有运行程序也会消耗内存和系统资源。</p><p><img src="https://www.shelven.com/tuchuang/20230329/11.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230329/11.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>上图来自Microsoft Azure容器与虚拟机的比较。总结来说，在安全性和隔离性上虚拟机优于容器，在资源占用、可移植性和运行速度上，容器优于虚拟机。</p><p>现有的容器软件比较多，<a href="https://github.com/jenkinsci/docker">Docker</a>（5.8k star）是代表性的软件之一，其他开源容器化工具还有<a href="https://github.com/containers/podman">Podman</a>（17.4k star，无守护进程的容器技术，无需root权限）、<a href="https://github.com/lxc/lxd">LXD</a>（3.8k star，可运行多个进程）、<a href="https://github.com/apptainer/singularity">Apptainer</a>（以前叫<strong>singularity</strong>，2.4k star，无需root权限）、<a href="https://github.com/containerd/containerd">Containerd</a>（13.5k star）和<a href="https://github.com/opencontainers/runc">RunC</a>（10.1k star）等。</p><p>这些开源的容器化技术软件各有其特点，详情可以点各自的链接了解，这里就不过多介绍了。主要说下塔大集群部署的singularity（现在已改名为Apptainer，很多人不知道改名了，两个名字就放一块儿说）的使用方法。</p></div><h2 id="2-Apptainer-x2F-Singularity"><a href="#2-Apptainer-x2F-Singularity" class="headerlink" title="2. Apptainer&#x2F;Singularity"></a>2. Apptainer&#x2F;Singularity</h2><div class="story post-story"><p>首先还是要说明以一下什么时候选择用容器，并不是说每一个软件都要用容器封装——反而这样是对系统资源的浪费。一般是在需要批量部署环境、或者快速部署一个pipeline环境的时候选择用容器。在HPC上进行大规模计算的时候，一般考虑安全性不会用Docker（需要root权限），Apptainer&#x2F;Singularity这种无需root权限的容器工具是最好的选择。</p><p>需要说明一下，两年前Singularity改名为Apptainer，并且整个项目已经转移成为了Linux Foundation的一部分。Apptainer用法和Singularity几乎一模一样，可以参考<br><a href="https://apptainer.org/docs/user/latest/quick_start.html">https://apptainer.org/docs/user/latest/quick_start.html</a><br><a href="https://docs.sylabs.io/guides/latest/user-guide/quick_start.html#">https://docs.sylabs.io/guides/latest/user-guide/quick_start.html#</a><br>两个官方手册。因为塔大超算预装了singularity，以下统一用Singularity命令来讲解。</p><p>Singularity的镜像文件以<code>.sif</code>为后缀（<strong>Singularity Image File, SIF</strong>），<strong>且该文件是只读的</strong>，这和Docker镜像文件有本质上的区别。</p><h3 id="2-1-使用镜像库获取镜像文件"><a href="#2-1-使用镜像库获取镜像文件" class="headerlink" title="2.1 使用镜像库获取镜像文件"></a>2.1 使用镜像库获取镜像文件</h3><p>Singularity image文件是基于Docker image创建的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">singularity -d build braker3.sif docker://teambraker/braker3:latest</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可以获取的镜像文件库（云平台）有以下几种</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Sylabs cloud librarylibrary://</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Dockerdocker://</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Shubshub://</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">OCI registryoras://</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建之后的文件名为braker3.sif</span></span><br></pre></td></tr></table></figure><blockquote><p>build&#x2F;pull 这两个命令都可以拉取镜像文件并创建为singularity的sif文件</p><p>创建的image路径、名字都可以在-d参数后根据需要自己改</p></blockquote><p>当一个软件提供docker镜像，我们就可以通过上面的方法下载并创建一个singularity镜像，需要注意这个镜像文件是<strong>只读的</strong>。</p><h3 id="2-2-创建自定义镜像文件"><a href="#2-2-创建自定义镜像文件" class="headerlink" title="2.2 创建自定义镜像文件"></a>2.2 创建自定义镜像文件</h3><p>这里顺带提一下如何制作自定义的SIF镜像文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">singularity -d build --sandbox ubuntu/ docker://ubuntu</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以沙盒的形式创建一个空的操作系统，放在ubuntu这个文件夹中</span></span><br><span class="line"></span><br><span class="line">singularity shell --writable ubuntu</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--writable或者-w以可修改模式进入沙盒。也可以不用这种方法进入，直接进入对应的文件位置修改即可</span></span><br><span class="line"></span><br><span class="line">singularity build name.sif ubuntu</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建sif镜像文件</span></span><br></pre></td></tr></table></figure><p>进入沙盒，就可以和正常的linux操作系统一样进行安装软件，最后build制作成名为name.sif的singularity镜像，和2.1从镜像库拉取创建的镜像后续是一样的用法。</p><p>第二步以可修改模式进入沙盒时可能会有如下提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WARNING: By using --writable, Singularity can&#x27;t create /public destination automatically without overlay or underlay</span><br><span class="line">FATAL:   container creation failed: mount /var/singularity/mnt/session/public-&gt;/public error: while mounting /var/singularity/mnt/session/public: destination /public doesn&#x27;t exist in container</span><br></pre></td></tr></table></figure><p>无法自动创建public这个文件夹，并且进入<code>/var/singularity/mnt/session/</code>这个文件夹下你会发现是空的，此时需要手动在你创建ubuntu的文件夹中创建public文件夹 <code>mkdir public</code>，提示缺少其他文件也是一样的处理方法，缺啥创建啥，就可以正常进入了。</p><p><strong>需要注意，塔大集群无法制作sif镜像文件！！！</strong>会在最后一步build的时候提示permission denied，因此，创建自定义镜像文件要在自己的计算机上（拥有root权限），制作完成之后的sif镜像文件可以上传到集群中再运行。</p><h3 id="2-3-运行镜像文件"><a href="#2-3-运行镜像文件" class="headerlink" title="2.3 运行镜像文件"></a>2.3 运行镜像文件</h3><p>singularity主要有两种运行方式，一种是执行镜像文件中的命令 <code>singularity exec</code>；一种是进入交互模式<code>singularity shell</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">singularity exec name.sif test/test.pl </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行name.sif镜像文件中<span class="built_in">test</span>文件夹下的test.pl程序</span></span><br><span class="line"></span><br><span class="line">singularity shell name.sif</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以交互模式进入name.sif镜像文件</span></span><br></pre></td></tr></table></figure><p>需要注意，运行镜像文件后，singularity会自动挂载当前目录<code>$PWD</code>、用户家目录<code>$HOME</code>和宿主机的<code>/tmp</code>目录，<strong>对这些目录的文件进行修改会影响到原文件</strong>。对于一般的程序来说已经足够了，如果需要访问宿主机的其他目录，需要用<code>--bind</code>将宿主机目录映射到容器内。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">singularity exec --bind /pub/software:/mnt name.sif python test.py</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--<span class="built_in">bind</span>挂载宿主机的文件夹，冒号前为宿主机的路径，冒号后为容器中的路径。内容挂载到/mnt中</span></span><br><span class="line"></span><br><span class="line">singularity exec --bind /pub/software name.sif python test.py</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不写挂载点，则与宿主机的目录一致。内容挂载到/pub/software中</span></span><br></pre></td></tr></table></figure><h3 id="2-4-在集群中提交singularity作业"><a href="#2-4-在集群中提交singularity作业" class="headerlink" title="2.4 在集群中提交singularity作业"></a>2.4 在集群中提交singularity作业</h3><p>一般来说登录节点预装了singularity，计算节点也会装singularity才对，但是无论我直接用singularity命令还是指定singularity命令的绝对路径，在sbatch提交作业后都是提示该命令不存在。很疑惑，又去查了一些资料，发现有的平台需要在作业里<code>module load singularity</code>之后才可以加载，但是塔大集群用这个指令仍然行不通，只有本地（登录节点）才可以使用该命令。</p><p>百思不得其解，询问集群管理员暂时没有答复，后续有新消息会更新。这里说一下我的解决方法：</p><p>既然可以在本地运行singularity，那就可以用<code>salloc</code>申请计算资源，在本地跑程序。但是我又不可能一直坐在电脑跟前，因此需要用到<code>screen</code>这个工具维持当前会话。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">screen -S test</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建名为<span class="built_in">test</span>的session对象</span></span><br><span class="line"></span><br><span class="line">salloc -n 50 -t 7200</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">申请50核的计算资源</span></span><br><span class="line"></span><br><span class="line">export BRAKER_SIF=\$PWD/braker3.sif</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">给host添加环境变量（非必须，打个比方）</span></span><br><span class="line"></span><br><span class="line">singularity esec braker3.sif braker.pl </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行容器中的程序</span></span><br></pre></td></tr></table></figure><p>运行之后就可以双手离开键盘，关上电脑，等待第二天程序运行结束了。</p><p>再次打开session的时候只需要运行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">screen -r test</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">再次打开session</span></span><br><span class="line"></span><br><span class="line">exit</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">退出session</span></span><br><span class="line"></span><br><span class="line">exit</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">释放计算资源</span></span><br></pre></td></tr></table></figure><p>注意需要两次exit之后才会回到原来的登录节点。</p><p>singularity还有很多其他参数，对我而言暂时用不到，需要用的时候再更新。</p><p>可以参考武大超算中心的文档<a href="http://docs.hpc.whu.edu.cn/files/whuhpcdocs.wiki/sbatch/singularity.html">运行 Singularity · GitBook (whu.edu.cn)</a>和北鲲云的介绍文档<a href="https://www.cloudam.cn/helpce/docs/2030/about2/%E3%80%82">https://www.cloudam.cn/helpce/docs/2030/about2/。</a><br><del>（可恶，我们学校集群什么时候能出一个详细的文档啊。好想吐槽，slurm调度系统和各种软件都要自己学，功能还不一定全，也不知道到底预装了哪些东西，以后要是我来管理集群一定会做详细的文档介绍所有花里胡哨的功能，而不是藏着不告诉用户）</del></p><h3 id="2023-3-29更新"><a href="#2023-3-29更新" class="headerlink" title="2023.3.29更新"></a>2023.3.29更新</h3><p>破案了，计算节点确实没装singularity（噎住.jpg）</p><p><img src="https://www.shelven.com/tuchuang/20230329/22.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230329/22.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;在做生信分析的时候，难免会遇到一个pipeline上的软件存在冲突的情况，一般的解决方法是创建不同的conda环境，然后分别在不同的环境下跑不同的软件。这种操作可以解决环境冲突的问题但不适合写流程化的脚本，同时又非常占用空间。有的软件整合了pipeline流程的所有软件，按照顺序进行调用，这种软件虽然可以节省时间实现自动化分析，但是环境依赖的问题更加复杂，因此这一类的软件也往往提供容器来方便人们在一个封闭的环境中使用。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="容器" scheme="http://www.shelven.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
    <category term="singularity" scheme="http://www.shelven.com/tags/singularity/"/>
    
  </entry>
  
  <entry>
    <title>基因组注释（3）——ncRNA注释</title>
    <link href="http://www.shelven.com/2023/03/22/a.html"/>
    <id>http://www.shelven.com/2023/03/22/a.html</id>
    <published>2023-03-21T16:29:28.000Z</published>
    <updated>2023-03-21T16:31:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>非编码RNA(non-coding RNA，ncRNA)指不编码蛋白质的RNA，包括rRNA、tRNA、snRNA、snoRNA 和 microRNA 等多种已知功能的 RNA，和未知功能的RNA。tRNA预测可以使用经典的<strong>tRNAscan-SE</strong>，其他类型的RNA都可以用<strong>Infernal+Rfam数据库</strong>方式预测。</p><span id="more"></span><h2 id="1-tRNAscan-SE"><a href="#1-tRNAscan-SE" class="headerlink" title="1. tRNAscan-SE"></a>1. tRNAscan-SE</h2><div class="story post-story"><p>tRNAscan-SE的安装需要依赖Infernal软件，因此可以用conda直接安装tRNAscan-SE顺带解决依赖问题：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install -c bioconda trnascan-se</span><br></pre></td></tr></table></figure><p>写一个脚本运行tRNAscan-SE：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -n 50</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -t 7200</span></span><br><span class="line"></span><br><span class="line">tRNAscan-SE --thread 50 -E -I -m tRNA_luobuma.stats -o tRNA_luobuma.out -f tRNA_luobuma.ss /public/home/wlxie/NextPolish/luobuma_rundir/genome.nextpolish.fasta</span><br></pre></td></tr></table></figure><p>参数解释：</p><blockquote><p>-E  搜寻真核生物tRNA</p><p>-I  使用Infernal软件进行搜索</p><p>-m  保存结果统计文件</p><p>-o  输出tRNA预测结果</p><p>-f  保存tRNA的二级结构</p></blockquote><p>也可以直接使用<code>-j</code>参数保存gff3格式，<code>-b</code>参数保存bed格式，详情可以见<code>tRNAscan-SE -h</code></p><p>生成的二级结构结果文件如下：</p><img src="https://www.shelven.com/tuchuang/20230320/3.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230320/3.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" style="zoom:80%;" /><p>str一行记录的二级结构信息，每个<code>&lt;&gt;</code>是互相配对的，代表在二级结构中这两个碱基连在一起。可以通过其他软件（如VARNA）绘制成图。</p><p>输出的out文件也推荐转成gff文件方便在基因组上可视化，因为我这里只是粗略统计一下tRNA数量，所以只看stat文件就可以了：</p><img src="https://www.shelven.com/tuchuang/20230320/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230320/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" style="zoom: 67%;" /><p>可以看到第一轮预测出526个tRNA，通过Infernal验证的有479个。</p></div><h2 id="2-Infernal-Rfam"><a href="#2-Infernal-Rfam" class="headerlink" title="2. Infernal + Rfam"></a>2. Infernal + Rfam</h2><div class="story post-story"><p><a href="http://eddylab.org/infernal/">Infernal（INFERence of RNA ALignment）</a>是Sanger实验室开发的ncRNA预测软件，他们建立了1600多个RNA家族，每个家族建立了一致性二级结构和协方差模型，也就是Rfam数据库。总体的注释思路是基因组与 Rfam数据库进行比对，Rfam是一个RNA分类数据库，其比对方法是调用软件Infernal中的程序<code>cmscan</code>，将提交的序列在<code>Rfam.cm</code>数据库中进行检索，从而得到其比对的结果。</p><p><code>cmscan</code>（search sequence(s) against a covariance model database, 针对协方差模型数据库的序列搜索），主要参考官方手册<a href="http://eddylab.org/infernal/Userguide.pdf">Userguide.pdf (eddylab.org)</a>中的<strong>Searching the Rfam CM database with a query sequence</strong>步骤。</p><p>前面已经安装了Infernal，这里需要再下载一个Rfam数据库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载Rfam数据库，注意两个文件版本必须一致</span></span><br><span class="line">wget ftp://ftp.ebi.ac.uk/pub/databases/Rfam/CURRENT/Rfam.cm.gz</span><br><span class="line">wget ftp://ftp.ebi.ac.uk/pub/databases/Rfam/CURRENT/Rfam.clanin</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压建库</span></span><br><span class="line">gunzip Rfam.cm.gz</span><br><span class="line">cmpress Rfam.cm</span><br></pre></td></tr></table></figure><p>官方手册这里使用默认参数运行<code>cmscan</code>，稍微注意下<code>-Z</code>，以下是官方对<code>-Z</code>参数的定义：</p><blockquote><p> -Z <x> Calculate  E-values as if the search space size was <x> megabases (Mb). Without the<br>            use of this option, the search space size changes for each query  sequence,  it  is<br>            defined  as  the length of the current query sequence times 2 (because both strands<br>            of the sequence will be searched) times the number of CMs in <cmdb>.</p></blockquote><p><code>Z</code>值代表搜索数据库的大小（database size），是和<code>E-Values</code>计算相关的，在默认情况下，每一个query sequence的-Z参数值是不同的，等于query sequence本身的碱基数*2*CM数据库中模型的数量，只有<code>E-Values</code>小于10的hits会被报道。</p><p>在作者的原文中，可以找到这么一句话：</p><blockquote><p>To manually set the database size used in the E-value calculation to <X> megabases when running cmsearch or cmscan on the command line, use the -Z <X> option. It makes sense to do this if, for example, a large sequence file has been split up into many smaller files, and searches have been performed in parallel on a compute cluster, with the results combined. In that scenario, if <X> is set as the total number of models used times the total number of nucleotides in all sequence files times two (for both strands), then the combined results should have appropriate E-values. That is, the expectation is that in the collection of all hits between all sequences and models there will be about 1 hit with an E-value of 1 or below by chance (not due to homology), about 10 with an E-value of 10 or below by chance, etc.</p><p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6754622/">Non-coding RNA analysis using the Rfam database - PMC (nih.gov)</a></p></blockquote><p>也就是说一个大的序列文件被分割成数个文件，并在一个集群上并行搜索，最终将结果文件整合的时候，设置Z值为使用的CM模型数量*所有序列文件的核苷酸总数*2，合并的结果会有一个适当的E-value值。</p><p>前面建库的时候可以看到CM数据库中模型的数量：</p><p><img src="https://www.shelven.com/tuchuang/20230320/4.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230320/4.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>CM模型的数量不可以直接用<code>cat Rfam.cm | grep &quot;ACC&quot; | wc -l</code>这种方式查询，你会发现这种只搜索<code>ACC</code>或者<code>NAME</code>字段查找到的数量是实际数量的两倍（包括了HMM filter）。</p><p>Z值&#x3D; <code>基因组核苷酸数*2*数据库中模型数量/1000000</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">esl-seqstat my-genome.fa# HMMER插件，统计基因组大小，计算Z值用</span><br></pre></td></tr></table></figure><p><img src="https://www.shelven.com/tuchuang/20230320/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230320/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>因此这里的Z值计算如下：<br>$$<br>Z &#x3D; 2<em>230888863</em>4108&#x2F;1000000&#x3D;1896982.90<br>$$<br><strong>但是很神奇的是</strong>，在Rfam的帮助文档中给了一个对古菌<em>Methanobrevibacter ruminantium</em>注释ncRNA的例子，其中也用了Rfam数据库的，计算Z值时没有乘以CM模型的数量，我也有点疑惑，以下是链接地址。</p><p><a href="https://docs.rfam.org/en/latest/genome-annotation.html#">Genome annotation — Rfam Help documentation</a></p><blockquote><p>For the purposes of Infernal, the total database size is the number of nucleotides that will be searched, in units of megabases (Mb, millions of nucleotides). So, it is the <strong>total number of nucleotides</strong> in all sequences that make up the genome, <strong>multiplied by two</strong> (because both strands will be searched), and <strong>divided by 1,000,000</strong> (to convert to millions of nucleotides).</p><p>就 Infernal 而言，数据库总大小是将要搜索的核苷酸数量，以兆碱基（Mb，百万核苷酸）为单位。因此，它是构成基因组的所有序列中的核苷酸总数乘以2（因为将搜索两条链），然后除以 1,000,000（转换为Mb）。</p></blockquote><p>两种方法计算Z值相差4000多倍，我无法断定哪种是正确的，后续有更深的理解再更新（也许是版本问题？）。</p><p>这里我<strong>按照文章作者给的默认参数对基因组进行注释</strong>（也就是没有指定Z值，每条序列的Z值是变动的）。</p><p>运行脚本如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -n 50</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -t 7200</span></span><br><span class="line"></span><br><span class="line">cmscan --cut_ga --rfam --nohmmonly --tblout luobuma.tblout --fmt 2 -o luobuma.out --clanin Rfam.clanin Rfam.cm /public/home/wlxie/NextPolish/luobuma_rundir/genome.nextpolish.fasta</span><br></pre></td></tr></table></figure><p>参数解释：</p><blockquote><p>–cut_ga  指定Rfam GA阈值，决定哪些hits可以报告。有多种标准，可以见<a href="https://docs.rfam.org/en/latest/glossary.html#gathering-cutoff">Glossary — Rfam Help documentation</a></p><p>–fram  以快速模式运行</p><p>–nohmmonly  决定所有模型都是CM模型（非HMM模型）</p><p>–tblout  表格形式输出结果</p><p>–fmt 2  输出格式2，包括overlapping hit的注释</p><p>-o  标准输出文件</p><p>–clanin  Rfam.clanin文件的位置，该文件记录哪些模型属于同一家族</p></blockquote><p>最终获得<code>luobuma.out</code>的标准输出文件和整理成表格的<code>luobuma.tblout</code>文件，这里整理一下表格文件：</p><p><img src="https://www.shelven.com/tuchuang/20230320/5.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230320/5.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><img src="https://www.shelven.com/tuchuang/20230320/6.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230320/6.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>27列对应预测ncRNA类型和信息；前后都有#键注释的行，除此之外每一行是预测的ncRNA具体内容</p><p>需要注意<code>olp</code>这一列，在<code>infernal 1.1.4版本</code>这一列有以下四个值：</p><blockquote><p>*  indicates this hit does not overlap with any other reported hits  这条序列与其他已报道的序列之间无重叠区域（保留）</p><p>ˆ  indicates that this hit does overlap with at least one other hit, but none of the hits that overlap with it have a lower E-value (occur above it in the hit list)  这条序列与至少一条已报道的序列之间有重叠区域，但是这条序列的E-value最低（保留）</p><p>$  indicates that this hit does overlap with at least one other hit that does have a lower E-value (occurs above it in the hit list) but none of those higher scoring hits have ˆ in this column  这条序列与至少一条已报道序列之间有重叠区域，且其他序列E-value更低但不是最低的（过滤，1.1.2版本的infernal中没有）</p><p>&#x3D;  indicates that this hit does overlap with at least one other hit that has a lower E-value (occurs above it in the hit list) and does itself have a ˆ in this column  这条序列与至少一条已报道序列之间有重叠区域，且其他序列的E-value值更低且是最低的（过滤）</p></blockquote><p>我们只关注预测结果中<strong>准确度最高的ncRNA</strong>，记录种类和长度，因此可以写个python脚本处理并统计数据。</p><p>因为这里输出的列表没有具体给出分类，因此对数据处理前要去Rfam官网的<strong>Entry type search</strong>栏下找到每个accession号对应的ncRNA类型<a href="https://rfam.org/search#tabview=tab5">Rfam: Search Rfam</a>：</p><img src="https://www.shelven.com/tuchuang/20230320/7.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230320/7.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" style="zoom:50%;" /><p>我这里只关心上面红框中的ncRNA（根据情况自己选择），勾选之后点击submit：</p><p><img src="https://www.shelven.com/tuchuang/20230320/8.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230320/8.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>拉到最底下看到官网提供未格式化的列表，点击show，将显示的列表复制粘贴到一个新建的<code>accession.txt</code>文档，接下来就是对<code>tblout</code>文件和<code>accession.txt</code>文件处理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Infernal预测ncRNA结果文件统计脚本</span></span><br><span class="line"><span class="string">2023.3.22</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 结果文件数据过滤，获取每条预测ncRNA的accession号和长度</span></span><br><span class="line">loci_length = []</span><br><span class="line">accession = []</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./luobuma.tblout&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> <span class="built_in">input</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">input</span>.readlines():</span><br><span class="line">        <span class="keyword">if</span> i.find(<span class="string">&#x27;#&#x27;</span>) != -<span class="number">1</span> <span class="keyword">or</span> i.find(<span class="string">&#x27;=&#x27;</span>) != -<span class="number">1</span> <span class="keyword">or</span> i.find(<span class="string">&#x27;$&#x27;</span>) != -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            lst = i.strip().split()</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(lst) &lt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            length = <span class="built_in">abs</span>(<span class="built_in">int</span>(lst[<span class="number">10</span>]) - <span class="built_in">int</span>(lst[<span class="number">9</span>]))</span><br><span class="line">            loci_length.append(length)</span><br><span class="line">            accession.append(lst[<span class="number">2</span>])</span><br><span class="line">len_sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> loci_length:</span><br><span class="line">    len_sum += i</span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理accession.txt,提取accession号和ncRNA类型的关系</span></span><br><span class="line">accession_num = []</span><br><span class="line">dicts = &#123;&#125;</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./accession.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> ac:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> ac.readlines():</span><br><span class="line">        m = i.strip().split(<span class="string">&#x27;\t&#x27;</span>)<span class="comment"># 以制表符分割</span></span><br><span class="line">        accession_num.append(m[<span class="number">0</span>])</span><br><span class="line">        nc_type = m[<span class="number">2</span>].split(<span class="string">&#x27;;&#x27;</span>)[<span class="number">1</span>].strip()<span class="comment"># 获取第三列第二个分号处的ncRNA类型</span></span><br><span class="line">        <span class="keyword">if</span> m[<span class="number">0</span>] <span class="keyword">not</span> <span class="keyword">in</span> dicts:</span><br><span class="line">            dicts[m[<span class="number">0</span>]] = nc_type</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计结果文件accession号对应的ncRNA类型数量</span></span><br><span class="line">mi = s = sn = lnc = t = r = other = <span class="number">0</span></span><br><span class="line">mi_len = s_len = sn_len = lnc_len = t_len= r_len = other_len =<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(accession)):</span><br><span class="line">    item = accession[i]</span><br><span class="line">    <span class="keyword">if</span> item <span class="keyword">in</span> dicts:</span><br><span class="line">        <span class="keyword">if</span> dicts[item] == <span class="string">&#x27;miRNA&#x27;</span>:</span><br><span class="line">            mi += <span class="number">1</span></span><br><span class="line">            mi_len += <span class="built_in">int</span>(loci_length[i])</span><br><span class="line">        <span class="keyword">elif</span> dicts[item] == <span class="string">&#x27;sRNA&#x27;</span>:</span><br><span class="line">            s += <span class="number">1</span></span><br><span class="line">            s_len += <span class="built_in">int</span>(loci_length[i])</span><br><span class="line">        <span class="keyword">elif</span> dicts[item] == <span class="string">&#x27;snRNA&#x27;</span>:</span><br><span class="line">            sn += <span class="number">1</span></span><br><span class="line">            sn_len += <span class="built_in">int</span>(loci_length[i])</span><br><span class="line">        <span class="keyword">elif</span> dicts[item] == <span class="string">&#x27;lncRNA&#x27;</span>:</span><br><span class="line">            lnc += <span class="number">1</span></span><br><span class="line">            lnc_len += <span class="built_in">int</span>(loci_length[i])</span><br><span class="line">        <span class="keyword">elif</span> dicts[item] == <span class="string">&#x27;tRNA&#x27;</span>:</span><br><span class="line">            t += <span class="number">1</span></span><br><span class="line">            t_len += <span class="built_in">int</span>(loci_length[i])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">            r_len += <span class="built_in">int</span>(loci_length[i])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        other += <span class="number">1</span></span><br><span class="line">        other_len += <span class="built_in">int</span>(loci_length[i])</span><br><span class="line"></span><br><span class="line">outputlst = [(<span class="string">&#x27;miRNA&#x27;</span>, mi, mi_len), (<span class="string">&#x27;sRNA&#x27;</span>, s, s_len), (<span class="string">&#x27;snRNA&#x27;</span>, sn, sn_len), (<span class="string">&#x27;lncRNA&#x27;</span>, lnc, lnc_len), (<span class="string">&#x27;tRNA&#x27;</span>, t, t_len), (<span class="string">&#x27;rRNA&#x27;</span>, r, r_len), (<span class="string">&#x27;others&#x27;</span>, other, other_len), (<span class="string">&#x27;total&#x27;</span>, <span class="built_in">len</span>(accession), len_sum)]</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./res.xls&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> output:</span><br><span class="line">    output.write(<span class="string">&#x27;Type\tCopy Number\tTotal length(bp)\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> outputlst:</span><br><span class="line">        <span class="built_in">type</span> = <span class="built_in">str</span>(i[<span class="number">0</span>])</span><br><span class="line">        number = <span class="built_in">str</span>(i[<span class="number">1</span>])</span><br><span class="line">        length = <span class="built_in">str</span>(i[<span class="number">2</span>])</span><br><span class="line">        output.write(<span class="built_in">type</span> + <span class="string">&#x27;\t&#x27;</span> + number + <span class="string">&#x27;\t&#x27;</span> + length + <span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure><p>我对python掌握的不好，统计的地方可以写个循环的，怕自己绕不清楚这里就用最笨的方法…..</p><p>结果统计如下：</p><p><img src="https://www.shelven.com/tuchuang/20230320/9.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230320/9.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><strong>tRNA这里预测470，与上面的tRNAscan-SE预测的479个基本没有差别。</strong></p><img src="https://www.shelven.com/tuchuang/20230320/10.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230320/10.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" style="zoom:80%;" /><p>顺带说一下，Rfam官网上也说了这种方法可以统计所有类型的RNA，如果针对不同ncRNA有特殊需求的话，可以用不同软件进行分析（但是RNAMMER现在似乎已经用不了了）。</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;非编码RNA(non-coding RNA，ncRNA)指不编码蛋白质的RNA，包括rRNA、tRNA、snRNA、snoRNA 和 microRNA 等多种已知功能的 RNA，和未知功能的RNA。tRNA预测可以使用经典的&lt;strong&gt;tRNAscan-SE&lt;/strong&gt;，其他类型的RNA都可以用&lt;strong&gt;Infernal+Rfam数据库&lt;/strong&gt;方式预测。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="基因组三代测序分析" scheme="http://www.shelven.com/categories/%E5%9F%BA%E5%9B%A0%E7%BB%84%E4%B8%89%E4%BB%A3%E6%B5%8B%E5%BA%8F%E5%88%86%E6%9E%90/"/>
    
    
    <category term="tRNAscan-SE" scheme="http://www.shelven.com/tags/tRNAscan-SE/"/>
    
    <category term="Rfam/Infernal" scheme="http://www.shelven.com/tags/Rfam-Infernal/"/>
    
  </entry>
  
  <entry>
    <title>SSL证书申请和部署</title>
    <link href="http://www.shelven.com/2023/03/17/a.html"/>
    <id>http://www.shelven.com/2023/03/17/a.html</id>
    <published>2023-03-17T10:00:39.000Z</published>
    <updated>2023-04-13T08:41:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>不知不觉这个小破站运行也快要一年整了，一年前网站刚开放，我天天修bug到凌晨两三点的情景还历历在目……主要还是自己对网站搭建框架不熟悉，看不懂代码整不清楚linux操作<del>（虽然现在也没好到哪儿去）</del>。一年过去了通过自学确实学习了很多计算机方面的知识，有空再做个总结吧~</p><p>一年前想写如何部署ssl证书的，如今一年快到了正好要续上ssl证书，这篇博客算是补档吧~记录下自己的操作</p><span id="more"></span><h2 id="1-SSL部署的意义"><a href="#1-SSL部署的意义" class="headerlink" title="1. SSL部署的意义"></a>1. SSL部署的意义</h2><div class="story post-story"><p>前面在<a href="https://www.shelven.com/2022/12/10/a.html">http原理</a>部分说过，HTTPS的安全基础是ssl，部署ssl之后有以下优点：</p><blockquote><ol><li>建立数据信息安全通道，保障信息安全</li><li>有https协议的网站更容易被google、baidu收录</li><li>用户浏览https协议的网站地址有锁头标志，不会显示信息安全提醒页面</li></ol></blockquote></div><h2 id="2-申请SSL证书"><a href="#2-申请SSL证书" class="headerlink" title="2. 申请SSL证书"></a>2. 申请SSL证书</h2><div class="story post-story"><p>我是在腾讯云上购买的轻量云服务器，在哪个服务器供应商买的服务器就到对应的平台，搜索SSL证书，点击申请免费证书</p><p><img src="https://www.shelven.com/tuchuang/20230317/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230317/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>选择第一个免费版即可，填写你要绑定的域名，验证方法选择手动DNS验证，提交申请</p><p><img src="https://www.shelven.com/tuchuang/20230317/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230317/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>这一步需要到对应的域名供应商那里进行DNS解析</p><p><img src="https://www.shelven.com/tuchuang/20230317/3.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230317/3.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>我是在阿里云买的域名，因此在阿里云控制台找到你要绑定的域名，添加记录，输入上面图红框里的对应信息</p><p><img src="https://www.shelven.com/tuchuang/20230317/4.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230317/4.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>回到腾讯云，点击<strong>验证域名</strong>即可，后续根据自己的服务器类型（我是Apache 服务器）选择对应的证书。第一次申请的话可能会让你完善身份信息。需要注意，如果域名被托管到其他平台，需要到对应的托管平台进行DNS解析，否则会查询不到解析记录。</p></div><h2 id="3-部署SSL证书"><a href="#3-部署SSL证书" class="headerlink" title="3. 部署SSL证书"></a>3. 部署SSL证书</h2><div class="story post-story"><p>申请成功后，进入SSL证书管理平台，点击已签发，就可以看到刚刚申请的SSL证书了，首先把证书下载到本地</p><p><img src="https://www.shelven.com/tuchuang/20230317/5.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230317/5.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>解压可以看到如下四个文件，<code>.crt</code>后缀的是证书链和证书文件，<code>.csr</code>后缀的是提供给CA的文件，<code>.key</code>后缀是私钥文件</p><p><img src="https://www.shelven.com/tuchuang/20230317/6.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230317/6.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>再次强调一下Apache服务器、Nginx服务器等等的部署目录是不同的，我这里是apache服务器，需要将上面的四个文件上传到服务器<code>/etc/httpd/ssl/</code>目录下。</p><p><strong>如果之前部署过ssl证书，到这一步以后直接<code>service network restart</code>重启http服务就行了。</strong></p><p>如果是第一次安装，进入<code>/etc/httpd/conf</code>目录，修改 <code>httpd.conf</code> 配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Include conf.modules.d/*.conf# 第56行确保该命令未被注释，用于加载SSL的配置目录</span><br></pre></td></tr></table></figure><p>进入<code>/etc/httpd/conf.modules.d</code>目录，修改<code>00-ssl.conf</code> 配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LoadModule ssl_module modules/mod_ssl.so# 第1行确保该命令未被注释，用于加载SSL模块</span><br></pre></td></tr></table></figure><p>进入<code>/etc/httpd/conf.d</code>目录，修改<code>ssl.conf</code>配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DocumentRoot &quot;/var/www/html&quot;# 配置虚拟主机的位置，路径可以改，建议还是用默认的</span><br><span class="line">ServerName xxxxx.com # 填写证书网站名称</span><br><span class="line">SSLEngine on# 确保SSL功能打开</span><br><span class="line">SSLCertificateFile /etc/httpd/ssl/xxxxx.com.crt# 确定证书路径</span><br><span class="line">SSLCertificateKeyFile /etc/httpd/ssl/xxxxx.com.key# 确定私钥路径</span><br><span class="line">SSLCertificateChainFile /etc/httpd/ssl/root_bundle.crt# 确定证书链路径</span><br></pre></td></tr></table></figure><p>以上配置完成后，重启网络服务<code>service network restart</code>，这个时候再访问网站就是https协议了。</p><p>参考自<a href="https://cloud.tencent.com/document/product/400/35243">SSL 证书 Apache 服务器 SSL 证书安装部署（Linux）-证书安装-文档中心-腾讯云 (tencent.com)</a></p><p>需要注意下，证书到期之后不会自动部署…一般这种免费的SSL证书时间都是1年，在到期前一个月会有提醒，申请完成之后直接覆盖快到期的原证书即可。<del>（省下了一笔自动部署的90块钱）</del></p></div><h2 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h2><div class="story post-story"><p>SSL证书部署后都是立即生效的，如果你发现网站仍然提示非安全连接，可以看看自己是否用了其他第三方加速。</p><p><strong>比如你的网站用了CDN加速，需要同时在第三方加速平台上进行HTTPS配置更改，否则SSL证书无法生效！</strong></p><p><img src="https://www.shelven.com/tuchuang/20230317/10.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230317/10.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>比如我这里用了又拍云的CDN加速，且设置了HTTPS访问，不更改成新申请的证书就无法生效。每个CDN加速平台设置HTTPS方法不一样，这里就不详细说了。</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;不知不觉这个小破站运行也快要一年整了，一年前网站刚开放，我天天修bug到凌晨两三点的情景还历历在目……主要还是自己对网站搭建框架不熟悉，看不懂代码整不清楚linux操作&lt;del&gt;（虽然现在也没好到哪儿去）&lt;/del&gt;。一年过去了通过自学确实学习了很多计算机方面的知识，有空再做个总结吧~&lt;/p&gt;
&lt;p&gt;一年前想写如何部署ssl证书的，如今一年快到了正好要续上ssl证书，这篇博客算是补档吧~记录下自己的操作&lt;/p&gt;</summary>
    
    
    
    <category term="个人主页" scheme="http://www.shelven.com/categories/%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5/"/>
    
    
    <category term="建站" scheme="http://www.shelven.com/tags/%E5%BB%BA%E7%AB%99/"/>
    
  </entry>
  
  <entry>
    <title>基因组注释（2）——散在重复序列注释</title>
    <link href="http://www.shelven.com/2023/03/16/a.html"/>
    <id>http://www.shelven.com/2023/03/16/a.html</id>
    <published>2023-03-16T15:13:10.000Z</published>
    <updated>2023-03-16T15:15:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>前面我们注释了串联重复序列（Tandem repeat，TR），接下来是对散在重复序列（也称转座子，transposable element，TE）进行注释。注释之后我们对所有重复序列在基因组上进行屏蔽，就可以进行后面的结构基因预测和注释了。</p><span id="more"></span><h2 id="1-散在重复序列"><a href="#1-散在重复序列" class="headerlink" title="1. 散在重复序列"></a>1. 散在重复序列</h2><div class="story post-story"><p>散在重复序列可以分为<strong>反转录转座子（class-I TEs）</strong>和<strong>DNA转座子（class-II TEs）</strong></p><blockquote><p>反转录转座子：通过RNA介导的copy and paste机制进行转座，主要由LTR（long terminal repeat）构成，而non-LTR根据长度又分为LINEs（long interspersed nuclear elements）和SINEs（short interspersed elements）。</p><p>DNA转座子：通过DNA介导的cut and paste机制进行转座。</p></blockquote><p>这里我们用<strong>RepeatModeler</strong>和<strong>RepeatMasker</strong>两个软件跑一遍基因组散在重复序列注释的流程，需要注意下因为前面做了TRF注释串联重复序列，我们运行RepeatMasker的时候要改下下参数设置。</p></div><h2 id="2-RepeatModeler和RepeatMasker安装"><a href="#2-RepeatModeler和RepeatMasker安装" class="headerlink" title="2. RepeatModeler和RepeatMasker安装"></a>2. RepeatModeler和RepeatMasker安装</h2><div class="story post-story"><p><strong>不建议用conda安装两款软件的本体（但是可以安装其他依赖）</strong></p><p>RepeatMasker配置成功过是RepeatModeler配置的前提条件，且两者之间有版本关联（比如最新的RepeatModeler版本为2.0.4，需要最新的RepeatMasker版本4.1.4安装为前提），conda直接安装RepeatMasker会导致RepeatModeler无法找到RepeatMasker的路径，且输入正确路径也会提示找不到（不知道是不是我的原因）。</p><p>下载源码包编译，可以看官网<a href="https://www.repeatmasker.org/">RepeatMasker Home Page</a>。</p><p><strong>本篇博客所使用RepeatMasker版本为4.1.2，RepeatModeler版本为2.0.3</strong></p><h3 id="2-1-RepeatMasker安装"><a href="#2-1-RepeatMasker安装" class="headerlink" title="2.1 RepeatMasker安装"></a>2.1 RepeatMasker安装</h3><p>本体安装过程不多说，主要说一下<strong>加载Repbase数据库</strong>：</p><p>RepeatMasker自带的重复序列数据库是Dfam数据库，这是一个转座子（TE）序列数据库，收录的物种比较少。Repbase是重复序列参考数据库，其中收录了大部分真核物种，适用于<strong>重复序列的同源预测</strong>。然而Repbase不是RepeatMasker自带的，需要额外下载，我这里提供20181026版本的Repbase下载地址：<a href="https://www.shelven.com/tuchuang/RepBaseRepeatMaskerEdition-20181026.tar">点击这里</a></p><p>下载Repbase数据库后用<code>tar -xvf</code>解压，将<code>RMRBSeqs.embl</code>和<code>README.RMRBSeqs</code>两个数据库文件放在RepeatMasker安装目录的<code>Libraries</code>目录下，注意不要修改后缀名。</p><p>在RepeatMasker安装目录下运行<code>perl ./configure</code>，一路回车确定路径，如果有缺失的依赖就用conda下载，一直到最后选择序列搜索比对的软件，我这里输入3回车，之后的界面再输入5回车确认：</p><p><img src="https://www.shelven.com/tuchuang/20230316/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230316/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>当看到提示信息Dfam和RBRM（也就是RepBase数据库）两个数据库版本的时候，就说明加载Repbase数据库成功了。</p><p>用<code>RepeatMasker -h</code>查看是否可以正常运行，如果提示<strong>Devel::Size</strong>这个perl模块缺失，可以用conda安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install -c bioconda perl-devel-size</span><br></pre></td></tr></table></figure><p><strong>最后需要修改一下环境变量（不修改运行的时候找不到pm文件）</strong>，将RepeatMasker 安装路径添加到<strong>PERL5LIB</strong>环境变量中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打开 ~/.bashrc</span></span><br><span class="line">export PERL5LIB=&quot;/public/home/wlxie/miniconda3/envs/biosoft/share/RepeatMasker:$PERL5LIB&quot;</span><br></pre></td></tr></table></figure><h3 id="2-2-RepeatModeler安装"><a href="#2-2-RepeatModeler安装" class="headerlink" title="2.2 RepeatModeler安装"></a>2.2 RepeatModeler安装</h3><p>安装过程与RepeatMasker差不多，有一个比较坑的地方是官方可选的一部分软件（比如CD-HIT）在configure过程中是必须指定的，所以还是按照github上的说明将所有依赖都用conda安装好。<a href="https://github.com/Dfam-consortium/RepeatModeler">Dfam-consortium&#x2F;RepeatModeler: De-Novo Repeat Discovery Tool (github.com)</a></p><p>接下来在RepeatModeler安装的目录下运行<code>perl ./configure</code>，同样是一路回车到底确定路径，最后会询问是否需要预测LTR结构，<strong>因为我在之前的求<a href="https://www.shelven.com/2023/03/01/a.html">LAI指数的博客</a>中已经做过LTR预测，因此这一步选择n跳过</strong>，后续我会说明如何利用LTR预测数据：</p><p><img src="https://www.shelven.com/tuchuang/20230316/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230316/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div><h2 id="3-TE注释策略"><a href="#3-TE注释策略" class="headerlink" title="3. TE注释策略"></a>3. TE注释策略</h2><div class="story post-story"><p>因为我要注释的生物是<strong>非模式生物</strong>，在Dfam库和Repbase库中均没有该物种信息（无法在RepeatMasker软件中指定特定的物种，-species 和 -lib的参数是冲突的，需要自建数据库），因此注释所用的数据库将由以下三种数据库组成：</p><blockquote><ol><li>LTR_retriever整合的LTR预测数据库（见<a href="https://www.shelven.com/2023/03/01/a.html">这篇博客</a>）</li><li>同源的（指该类群祖先和衍生节点）重复序列数据库</li><li>使用RepeatModeler从头预测序列，训练该物种的重复序列模型，构建预测的重复序列数据库</li></ol></blockquote><p>需要注意<strong>这三种数据库都需要fasta格式</strong>，将三种数据库合并之后，使用<code>RepeatMasker -lib</code>指定自建数据库，预测TE序列。</p></div><h2 id="4-注释流程"><a href="#4-注释流程" class="headerlink" title="4. 注释流程"></a>4. 注释流程</h2><div class="story post-story"><h3 id="4-1-导出同源物种重复序列库"><a href="#4-1-导出同源物种重复序列库" class="headerlink" title="4.1 导出同源物种重复序列库"></a>4.1 导出同源物种重复序列库</h3><p>前面2.1步骤将Repbase和Dfam数据库整合之后，<code>RepeatMasker/Libraries</code>目录下<code>RepeatMaskerLib.h5</code>这个文件为整合后构建的数据库文件，我们要在这个文件中导出同源物种的重复序列。</p><p>在RepeatMasker目录下提供了<code>famdb.py</code>这个程序查询目标近缘物种。如果你不知道自己的物种在什么分支上，我这里推荐一个查找已发表的<strong>植物基因组</strong>的网站<a href="https://www.plabipd.de/plant_genomes_pa.ep">Published Plant Genomes (plabipd.de)</a>，可以一级一级查看哪些近缘物种有人做过了。用以下命令查看物种重复序列否收录到库中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python famdb.py -i Libraries/RepeatMaskerLib.h5 lineage -ad lamiids# lamiids是我能查找到的最近的分支</span><br></pre></td></tr></table></figure><p><img src="https://www.shelven.com/tuchuang/20230316/3.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230316/3.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>找到最近的分支后，导出最近分支的祖先节点和衍生节点物种的重复序列库，使用内置的perl软件转换成fasta格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">python famdb.py -i Libraries/RepeatMaskerLib.h5 families -f embl -a -d lamiids &gt; lamiids.embl</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找近缘物种及其上祖先节点，其下所有类群repeat famlies，输出格式embl。 -a ancestor，-d descendent</span></span><br><span class="line"></span><br><span class="line">buildRMLibFromEMBL.pl lamiids.embl &gt; lamiids.fasta# 转换格式为fasta，方便后续合并</span><br></pre></td></tr></table></figure><h3 id="4-2-RepeatModeler从头预测"><a href="#4-2-RepeatModeler从头预测" class="headerlink" title="4.2 RepeatModeler从头预测"></a>4.2 RepeatModeler从头预测</h3><p>新建一个目录，用于存放RepeatModeler的预测结果，写一个repeatmodeler.slurm脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -n 100</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -t 7200</span></span><br><span class="line"></span><br><span class="line">BuildDatabase -name luobuma -engine ncbi /public/home/wlxie/NextPolish/luobuma_rundir/genome.nextpolish.fasta# 用基因组组装结果构建数据库</span><br><span class="line"></span><br><span class="line">RepeatModeler -pa 25 -database luobuma -engine ncbi# 自训练</span><br></pre></td></tr></table></figure><p>RepeatModeler以自身基因组数据做训练集，用三种重复序列分析软件（ RECON, RepeatScout 和 LtrHarvest&#x2F;Ltr_retriever）进行预测，最后给出de novo预测结果。需要i说明一下，程序结束之后会给出如下四个文件：</p><blockquote><ol><li>sample-families.fa    de novo预测重复序列家族文件，也就是预测的重复序列库</li><li>sample-familes.stk    Seed alignments</li><li>RM_123456.XXXXXXXXX    中间文件（记录每一轮训练的流程和结果，仅用于中间程序崩了以后可以识别并继续跑流程）</li><li>sample-rmod.log    log文件</li></ol></blockquote><p>最终得到的<code>luobuma-families.fa</code>文件是我们需要的，里面记录了各种de novo预测的重复序列家族。中间文件具体有什么可以参考<a href="https://github.com/Dfam-consortium/RepeatModeler">官方的github文档</a>，这里仅仅是起到Recover from a failure的作用，<strong>中间程序没有崩就不用管它</strong>。</p><p>注意下<code>RepeatModeler -pa</code>参数，1 pa可以运行4个线程，我申请了100个核，这里就是25 pa可以用完所有资源。</p><p>这一步运行时间最久，100个核对200Mbp大小的植物基因组进行de novo预测重复序列，跑了17个小时。</p><h3 id="4-3-整合数据库"><a href="#4-3-整合数据库" class="headerlink" title="4.3 整合数据库"></a>4.3 整合数据库</h3><p>将4.1、4.2步骤的结果，以及前面做的LTR预测结果进行整合（都是fasta格式）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat lamiids.fasta luobuma-families.fa luobuma.fasta.mod.LTRlib.fa &gt; final_luobuma_repeat.fasta# 合并同源数据库、RepeatModeler训练结果和LTR预测结果</span><br></pre></td></tr></table></figure><p>此时得到的<code>final_luobuma_repeat.fasta</code>就是后一步运行RepeatMarsker需要指定的自建数据库。</p><h3 id="4-4-RepeatMasker搜索重复序列"><a href="#4-4-RepeatMasker搜索重复序列" class="headerlink" title="4.4 RepeatMasker搜索重复序列"></a>4.4 RepeatMasker搜索重复序列</h3><p>根据需求确定参数，写一个repeatmasker.slurm脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -n 100</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -t 7200</span></span><br><span class="line"></span><br><span class="line">RepeatMasker -nolow -no_is -pa 25 -lib final_luobuma_repeat.fasta -engine ncbi -gff -norna -dir luobuma /public/home/wlxie/NextPolish/luobuma_rundir/luobuma.fasta </span><br></pre></td></tr></table></figure><p>RepeatMasker的参数非常多，介绍一下这里用到的：</p><blockquote><p>-nolowDoes <strong>not mask</strong> low_complexity DNA or simple repeats 不屏蔽低复杂度DNA或简单重复序列（有的学者认为simple repeat不算严格意义上的重复序列类型）</p><p>-nornaDoes <strong>not mask</strong> small RNA (pseudo) genes 不屏蔽sRNA</p><p>-no_isSkips bacterial insertion element check 跳过细菌插入元件检查</p><p>-pa和RepeatModeler一样，1 pa是4个线程</p><p>-lib指定自建数据库（与-species冲突）</p><p>-gff生成gff文件</p><p>-dir指定输出目录</p></blockquote><p>在输出目录下可以找到以下几种格式的文件:</p><blockquote><p>sample.fasta.cat.gz基因组和数据库中参考重复序列比对详情，i代表碱基转换，v代表碱基颠换</p><p>sample.fasta.masked重复序列屏蔽我iN后的序列</p><p>sample.fasta.out预测的重复序列详细信息，Smith-Waterman 算法得分等等</p><p>sample.fasta.out.gff上一个文件的gff格式</p><p>sample.fasta.tblRepeatMasker的结果报告</p></blockquote><p>主要看一下结果报告：</p><p><img src="https://www.shelven.com/tuchuang/20230316/4.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230316/4.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>TE的预测结果被分为逆转录转座子、DNA转座子和Unclassified三类，总的转座子序列数量和在基因组的占比见<code>Total interspersed repeats</code>统计结果。做到这里可以再结合前面做的TR分析，做一个基因组重复序列注释汇总表，我这里就不再演示了。</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;前面我们注释了串联重复序列（Tandem repeat，TR），接下来是对散在重复序列（也称转座子，transposable element，TE）进行注释。注释之后我们对所有重复序列在基因组上进行屏蔽，就可以进行后面的结构基因预测和注释了。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="基因组三代测序分析" scheme="http://www.shelven.com/categories/%E5%9F%BA%E5%9B%A0%E7%BB%84%E4%B8%89%E4%BB%A3%E6%B5%8B%E5%BA%8F%E5%88%86%E6%9E%90/"/>
    
    
    <category term="RepeatModeler" scheme="http://www.shelven.com/tags/RepeatModeler/"/>
    
    <category term="RepeatMasker" scheme="http://www.shelven.com/tags/RepeatMasker/"/>
    
  </entry>
  
  <entry>
    <title>基因组注释（1）——串联重复序列注释</title>
    <link href="http://www.shelven.com/2023/03/12/a.html"/>
    <id>http://www.shelven.com/2023/03/12/a.html</id>
    <published>2023-03-12T15:14:40.000Z</published>
    <updated>2023-03-12T15:18:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>本系列笔记开始记录如何对组装的植物基因组进行注释。前面通过一系列组装过程，我们拿到了组装好的基因组草图，而这个基因组草图只是研究的开始，我们关注的是基因组中有哪些我们感兴趣的功能基因或者结构基因，以及怎么用这些基因阐述生物学问题等等，这个时候一个高准确度的基因组注释结果就非常重要了。</p><span id="more"></span><p>基因组注释可以分为两部分：<strong>基因组的结构注释</strong>（重复序列识别、非编码基因预测、编码基因预测）和<strong>基因功能注释</strong>，结构注释是功能注释的基础。</p><p>这里先从结构注释中的重复序列注释开始。我们知道植物基因组多倍化频繁，且基因组中存在大量的重复序列（有的植物基因组中重复序列甚至能达到80%），这些重复序列控制植物表型调控中有非常重要的作用。基因组中的重复序列可以分为以下几种：</p><p><img src="https://www.shelven.com/tuchuang/20230312/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230312/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h2 id="1-串联重复序列注释"><a href="#1-串联重复序列注释" class="headerlink" title="1. 串联重复序列注释"></a>1. 串联重复序列注释</h2><div class="story post-story"><p>串联重复（Tandem Repeat, TR）指DNA中的一个或多个核苷酸前后相连接的重复。串联重复又分为卫星DNA(Satellite DNA)、小卫星（Minisatellite）、微卫星（Microsatellite）。微卫星在植物中一般称为SSR（Simple Sequence Repeats）SSR在植物基因组常被用做遗传标记使用。下面我用两款软件跑下串联重复序列注释。</p><h3 id="1-1-GMATA"><a href="#1-1-GMATA" class="headerlink" title="1.1 GMATA"></a>1.1 GMATA</h3><p>这个软件主要用来搜索重复单元较短的简单重复序列，也就是微卫星SSR序列。这软件运行速度比较快，而且可以同时设计SSR引物，还可以预测elect-PCR结果，或者将预测结果显示在基因组浏览器上，可以在github上找到项目地址：<a href="https://github.com/XuewenWangUGA/GMATA">XuewenWangUGA&#x2F;GMATA: software GMATA (github.com)</a></p><p>需要注意如果是在<strong>linux系统</strong>上跑一键流程的话，<strong>需要单独安装primer3和e-pcr（可以直接用conda安装）</strong>，分别是设计SSR引物和模拟PCR的时候需要调用。如果没有这方面需要，可以在设置文件<code>default_cfg.txt</code>修改为不启用后面的模块。我这里统一用linux系统演示，只演示命令行操作，<strong>这个软件在windows上运行有UI界面</strong>，还是比较直观的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -n 50</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -t 7200</span></span><br><span class="line"></span><br><span class="line">perl gmata.pl -c default_cfg.txt -i /public/home/wlxie/NextPolish/luobuma_rundir/genome.nextpolish.fasta</span><br></pre></td></tr></table></figure><p>我这里直接用了一键流程，修改默认的设置文件中三个模块<code>[set]:doprimer_smt</code>、<code>[set]:elctPCR</code>和<code>[set]:mk2gff3</code>的<code>ModulRun = N</code>，虽然可以批量设计引物，但是我这里用不着…..</p><p>预测的SSR结果在原fasta文件路径下，以<code>.ssr</code>和<code>.ssr.sat2</code>为后缀：</p><p><img src="https://www.shelven.com/tuchuang/20230312/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230312/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><img src="https://www.shelven.com/tuchuang/20230312/3.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230312/3.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>在sat结果文件中，最终结果以4个表格的方式呈现，分别统计motif k-mer、motif和成对的motif信息以及最后每个contig的SSR统计信息。以上是其中两个表格。</p><h3 id="1-2-TRF"><a href="#1-2-TRF" class="headerlink" title="1.2 TRF"></a>1.2 TRF</h3><p>这个软件和上面软件类似，可以统计整个基因组上的串联重复序列，在上面一个软件输出结果上稍微有些不同。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -n 50</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -t 7200</span></span><br><span class="line"></span><br><span class="line">trf /public/home/wlxie/NextPolish/luobuma_rundir/genome.nextpolish.fasta 2 7 7 80 10 50 500 -f -d -m -r -h</span><br></pre></td></tr></table></figure><p>说明一下这个软件使用过程中传参的一堆数字代表什么：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Match  = matching weight# 匹配上的权重，缺省值2</span><br><span class="line">Mismatch  = mismatching penalty# 未匹配上的权重，缺省值7</span><br><span class="line">Delta = indel penalty# 插入罚分，缺省值7</span><br><span class="line">PM = match probability (whole number)# 比对上的概率，可选值为80和75</span><br><span class="line">PI = indel probability (whole number)# 插入的概率，可选值为10和20</span><br><span class="line">Minscore = minimum alignment score to report# 串联重复序列的比对必须达到或超过要报告的比对分数</span><br><span class="line">MaxPeriod = maximum period size to report# 最大重复单元的bp数，不指定的话从1到2000</span><br><span class="line"></span><br><span class="line">其他主要可选参数（列一部分）:</span><br><span class="line">-m 输出屏蔽重复序列后的基因组</span><br><span class="line">-f 记录每个重复序列侧翼的500个核苷酸，主要用于PCR引物设计</span><br><span class="line">-d 生成屏蔽数据文件，与汇总表有相同的信息，不包含标签，主要方便做其他处理</span><br><span class="line">-h 不生成html结果文件（contig数量多的话建议使用，否则有大量的文件生成）</span><br></pre></td></tr></table></figure><p>运行结束后可以生成<code>.mask</code>后缀的屏蔽后的序列文件，还有一个<code>.dat</code>后缀的结果文件，包含了重复序列的详细信息。</p><p>主要讲解下这个dat文件，先<code>less -S</code>打开看看：</p><p><img src="https://www.shelven.com/tuchuang/20230312/4.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230312/4.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>上面记录的参数和其他信息就不说了，主要是底下的数据，每一行是一个重复序列的信息，每行分为15列：</p><blockquote><p>第1列和第2列是预测到的重复序列的起始和结束位点；</p><p>第3列是重复单元的长度；</p><p>第4列是重复单元的拷贝数，不一定是整数，因为可能存在插入缺失；</p><p>第5列是一致性序列的长度；</p><p>第6列是匹配的百分率；</p><p>第7列是插入缺失的百分率；</p><p>第8列是TRF软件给的分值，越高越可靠；</p><p>第9-12列分别为ACGT碱基的个数；</p><p>第13列表示比对的熵值；</p><p>第14列是一致性序列的具体碱基排列；</p><p>第15列是整个重复序列的具体碱基排列顺序。</p></blockquote><p>对于结果文件的处理有两种方法，一种是将<code>.dat</code>后缀的结果文件转换成标准的<code>.gff3</code>文件格式，然后用bedtools提取trf特征。转化gff的的方法github上有不少开源的项目，这里推荐一个<a href="https://github.com/Adamtaranto/TRF2GFF/">Adamtaranto&#x2F;TRF2GFF: Convert Tandem Repeat Finder dat file output into gff3 format (github.com)</a></p><p>还有一种方法就是自己写个脚本，可以看到同一位点处可能有多条预测的串联重复序列<strong>，也就是说这些串联重复序列之间可能存在交叠，思路是将同一位点预测的重复序列</strong>只保留最短的一条（起始位点相同保留前一条，结束位点相同保留后一条），然后统计第3列重复序列k-mer数量和类型，根据第1列和第2列计算长度，统计总长度和占比即可。</p><p><img src="https://www.shelven.com/tuchuang/20230312/5.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230312/5.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">自编TFR dat格式结果文件统计脚本</span></span><br><span class="line"><span class="string">2023.3.12</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据过滤</span></span><br><span class="line">loci_start = []</span><br><span class="line">loci_finish = []</span><br><span class="line">total_line = []</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./genome.baima.fasta.2.7.7.80.10.50.500.dat&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> <span class="built_in">input</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">input</span>.readlines()[<span class="number">15</span>:]:</span><br><span class="line">        <span class="keyword">if</span> i.find(<span class="string">&#x27;Sequence&#x27;</span>) != -<span class="number">1</span> <span class="keyword">or</span> i.find(<span class="string">&#x27;Parameters&#x27;</span>) != -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            lst = i.strip().split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(lst) &lt; <span class="number">15</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(loci_start) &lt; <span class="number">1</span> <span class="keyword">and</span> <span class="built_in">len</span>(loci_finish) &lt; <span class="number">1</span>:    <span class="comment"># 处理列表为空的情况</span></span><br><span class="line">                loci_start.append(lst[<span class="number">0</span>])</span><br><span class="line">                loci_finish.append(lst[<span class="number">1</span>])</span><br><span class="line">                total_line.append(lst)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> lst[<span class="number">0</span>] != loci_start[-<span class="number">1</span>] <span class="keyword">and</span> lst[<span class="number">1</span>] != loci_finish[-<span class="number">1</span>]:  <span class="comment"># 开始结束位点都不同，则记录数据</span></span><br><span class="line">                    loci_start.append(lst[<span class="number">0</span>])</span><br><span class="line">                    loci_finish.append(lst[<span class="number">1</span>])</span><br><span class="line">                    total_line.append(lst)</span><br><span class="line">                <span class="keyword">elif</span> lst[<span class="number">0</span>] == loci_start[-<span class="number">1</span>]:        <span class="comment"># 开始位点相同，跳过</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">elif</span> lst[<span class="number">1</span>] == loci_finish[-<span class="number">1</span>]:       <span class="comment"># 结束位点相同，删除列表最后一个元素并加入新元素</span></span><br><span class="line">                    <span class="keyword">del</span> loci_start[-<span class="number">1</span>]</span><br><span class="line">                    <span class="keyword">del</span> loci_finish[-<span class="number">1</span>]</span><br><span class="line">                    <span class="keyword">del</span> total_line[-<span class="number">1</span>]</span><br><span class="line">                    loci_start.append(lst[<span class="number">0</span>])</span><br><span class="line">                    loci_finish.append(lst[<span class="number">1</span>])</span><br><span class="line">                    total_line.append(lst)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取motif长度和重复序列长度</span></span><br><span class="line">motif_lst = []</span><br><span class="line">leng_lst = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> total_line:</span><br><span class="line">    motif_lst.append(i[<span class="number">2</span>])</span><br><span class="line">    leng = <span class="built_in">int</span>(i[<span class="number">1</span>]) - <span class="built_in">int</span>(i[<span class="number">0</span>]) + <span class="number">1</span></span><br><span class="line">    leng_lst.append(leng)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计相同motif的总长度和所有重复序列总长度</span></span><br><span class="line">total_leng = &#123;&#125;</span><br><span class="line">motif_sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(motif_lst)):</span><br><span class="line">    item = motif_lst[i]</span><br><span class="line">    motif_sum += leng_lst[i]</span><br><span class="line">    <span class="keyword">if</span> item <span class="keyword">in</span> total_leng:</span><br><span class="line">        total_leng[item] += leng_lst[i]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        total_leng[item] = leng_lst[i]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计motif-mer数量，总数，占比</span></span><br><span class="line">count_motif = Counter(motif_lst)</span><br><span class="line">count_lst = <span class="built_in">list</span>(count_motif.items())</span><br><span class="line">count_lst.sort(key = <span class="keyword">lambda</span> x : x[<span class="number">1</span>], reverse = <span class="literal">True</span>)</span><br><span class="line">lst_ = []</span><br><span class="line">hit_num = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> count_lst:</span><br><span class="line">    hit_num += i[<span class="number">1</span>] </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> count_lst:</span><br><span class="line">    ls = i[<span class="number">0</span>]</span><br><span class="line">    lst1 = <span class="built_in">list</span>(i)</span><br><span class="line">    <span class="keyword">if</span> ls <span class="keyword">in</span> total_leng:</span><br><span class="line">        lst1.append(total_leng[ls])</span><br><span class="line">    precentage = <span class="string">&#x27;%.2f%%&#x27;</span>%(<span class="number">100</span> * i[<span class="number">1</span>] / hit_num)</span><br><span class="line">    lst1.append(precentage)</span><br><span class="line">    lst_.append(lst1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计结果过滤（取前二十）</span></span><br><span class="line">lst_filted = []</span><br><span class="line">hit_ = <span class="number">0</span></span><br><span class="line">motif_ = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">20</span>):</span><br><span class="line">    lst_filted.append(lst_[i])</span><br><span class="line">    hit_ += lst_[i][<span class="number">1</span>]</span><br><span class="line">    motif_ += lst_[i][<span class="number">2</span>]</span><br><span class="line">lst_filted.append([<span class="string">&#x27;Other&#x27;</span>, <span class="built_in">int</span>(hit_num - hit_), <span class="built_in">int</span>(motif_sum - motif_), <span class="string">&#x27;%.2f%%&#x27;</span>%(<span class="number">100</span> - <span class="number">100</span> * hit_ / hit_num)])</span><br><span class="line">lst_filted.append([<span class="string">&#x27;Total&#x27;</span>, <span class="built_in">int</span>(hit_num), <span class="built_in">int</span>(motif_sum), <span class="string">&#x27;100%&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./stastics.xls&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> output:</span><br><span class="line">    output.write(<span class="string">&#x27;Motif(-mer)\tNumber\tLength(bp)\tPrecentage\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> lst_filted:</span><br><span class="line">        motif = i[<span class="number">0</span>]</span><br><span class="line">        number = i[<span class="number">1</span>]</span><br><span class="line">        length = i[<span class="number">2</span>]</span><br><span class="line">        pre = i[<span class="number">3</span>]</span><br><span class="line">        output.write(motif + <span class="string">&#x27;\t&#x27;</span> + <span class="built_in">str</span>(number) + <span class="string">&#x27;\t&#x27;</span> + <span class="built_in">str</span>(length) + <span class="string">&#x27;\t&#x27;</span> + <span class="built_in">str</span>(pre) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>**写的有点冗长，能实现统计功能就行…..**实现的结果如下：</p><p><img src="https://www.shelven.com/tuchuang/20230312/6.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230312/6.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>可以看到两个软件统计结果还是有比较大的出入的，<strong>可能是在算法上有不同</strong>。在单独分析SSR序列的时候还是用GMATA准确一些，如果是统计全基因组上的串联重复序列则使用老牌的TRF更为合适。</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;本系列笔记开始记录如何对组装的植物基因组进行注释。前面通过一系列组装过程，我们拿到了组装好的基因组草图，而这个基因组草图只是研究的开始，我们关注的是基因组中有哪些我们感兴趣的功能基因或者结构基因，以及怎么用这些基因阐述生物学问题等等，这个时候一个高准确度的基因组注释结果就非常重要了。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="基因组三代测序分析" scheme="http://www.shelven.com/categories/%E5%9F%BA%E5%9B%A0%E7%BB%84%E4%B8%89%E4%BB%A3%E6%B5%8B%E5%BA%8F%E5%88%86%E6%9E%90/"/>
    
    
    <category term="GMATA" scheme="http://www.shelven.com/tags/GMATA/"/>
    
    <category term="TRF" scheme="http://www.shelven.com/tags/TRF/"/>
    
  </entry>
  
  <entry>
    <title>绕过双重封锁部署ChatGPT到zhenxun_bot</title>
    <link href="http://www.shelven.com/2023/03/08/a.html"/>
    <id>http://www.shelven.com/2023/03/08/a.html</id>
    <published>2023-03-08T13:54:56.000Z</published>
    <updated>2023-03-08T14:01:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个从ChatGPT公测用到现在的用户，有些无奈很难言说。本来OpenAI就不对咱们这个区域开放，使用官方的API搭建应用可以不借助VPN访问，算是解除了区域限制。但是，从<strong>2023年3月2日傍晚</strong>开始，API接口就开始没有响应了，官网没有问题，四处查询发现可能是API的域名上了GFW名单（暂不确定，有可能重大会议过去后会恢复？）。</p><span id="more"></span><p>因此，现在摆在眼前的问题是如何绕过双重封锁调用OpenAI的API接口？最稳妥的方式当然是给服务器挂个全局代理，但是我的服务器本身就在作代理服务器，给服务器再上个代理会比较麻烦……这里记录下自己实现的方式，顺便记录下是如何部署ChatGPT到zhenxun_bot（这个bot真的超级好用！）上的。</p><p>本人在这方面是小白，只是记录实现过程。</p><p><strong>此部分内容需要以部署zhenxun_bot为前提、有一个未上GFW名单的域名（国内需要实名）</strong>。</p><h2 id="1-部署ChatGPT到zhenxun-bot"><a href="#1-部署ChatGPT到zhenxun-bot" class="headerlink" title="1. 部署ChatGPT到zhenxun_bot"></a>1. 部署ChatGPT到zhenxun_bot</h2><div class="story post-story"><p>时间过去太久，已经找不到写插件的原作者了…我是在原插件的基础上copy和修改了一部分代码，实际上就是在zhenxun_bot的AI插件基础上做的一点删改（可能有些没删干净，懒得查了）。如果没有修改路径的话，原文件路径是<code>/zhenxun_bot/plugins/ai/data_source.py</code>，下面代码替代原文件内容（原文件最好另存以防万一）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> utils.http_utils <span class="keyword">import</span> AsyncHttpx</span><br><span class="line"><span class="keyword">from</span> configs.path_config <span class="keyword">import</span> IMAGE_PATH, DATA_PATH</span><br><span class="line"><span class="keyword">from</span> services.log <span class="keyword">import</span> logger</span><br><span class="line"><span class="keyword">from</span> utils.message_builder <span class="keyword">import</span> image, face</span><br><span class="line"><span class="keyword">from</span> configs.config <span class="keyword">import</span> Config, NICKNAME</span><br><span class="line"><span class="keyword">from</span> .utils <span class="keyword">import</span> ai_message_manager</span><br><span class="line"><span class="keyword">from</span> copy <span class="keyword">import</span> deepcopy</span><br><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> GPT2TokenizerFast</span><br><span class="line"><span class="keyword">import</span> openai</span><br><span class="line"></span><br><span class="line">openai.api_key = <span class="string">&quot;xxxxxxxxxxxxxx&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">import</span> ujson <span class="keyword">as</span> json</span><br><span class="line"><span class="keyword">except</span> ModuleNotFoundError:</span><br><span class="line">    <span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">session_config = &#123;</span><br><span class="line">    <span class="string">&#x27;preset&#x27;</span>: <span class="string">&#x27;你是一个大型语言模型，可以回答我的问题。如果我有任何问题，请随时告诉你，你会尽力为我解答。&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;context&#x27;</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">sessions = &#123;&#125;</span><br><span class="line">tokenizer = GPT2TokenizerFast.from_pretrained(<span class="string">&quot;gpt2-large&quot;</span>)</span><br><span class="line">check_url = <span class="string">&quot;https://v2.alapi.cn/api/censor/text&quot;</span></span><br><span class="line">index = <span class="number">0</span></span><br><span class="line">anime_data = json.load(<span class="built_in">open</span>(DATA_PATH / <span class="string">&quot;anime.json&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf8&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取对话session</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_chat_session</span>(<span class="params">sessionid</span>):</span><br><span class="line">    <span class="keyword">if</span> sessionid <span class="keyword">not</span> <span class="keyword">in</span> sessions:</span><br><span class="line">        config = deepcopy(session_config)</span><br><span class="line">        config[<span class="string">&#x27;id&#x27;</span>] = sessionid</span><br><span class="line">        sessions[sessionid] = config</span><br><span class="line">    <span class="keyword">return</span> sessions[sessionid]</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">chat_with_gpt</span>(<span class="params">prompt</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        resp = openai.Completion.create(</span><br><span class="line">            model = <span class="string">&quot;text-davinci-003&quot;</span>, </span><br><span class="line">            temperature = <span class="number">0.9</span>,</span><br><span class="line">            max_tokens=<span class="number">3000</span>,</span><br><span class="line">            top_p=<span class="number">1</span>,</span><br><span class="line">            presence_penalty=<span class="number">0</span>,</span><br><span class="line">            frequency_penalty=<span class="number">0</span>,</span><br><span class="line">            prompt=prompt)</span><br><span class="line">        resp = resp[<span class="string">&#x27;choices&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;text&#x27;</span>]</span><br><span class="line">    <span class="keyword">except</span> openai.OpenAIError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;openai 接口报错: &#x27;</span> + <span class="built_in">str</span>(e))</span><br><span class="line">        resp = <span class="built_in">str</span>(e)</span><br><span class="line">    <span class="keyword">return</span> resp</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">get_chat_result</span>(<span class="params">text: <span class="built_in">str</span>, img_url: <span class="built_in">str</span>, user_id: <span class="built_in">int</span>, nickname: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    获取 AI 返回值，顺序： 特殊回复 -&gt; GPT3 -&gt; 青云客</span></span><br><span class="line"><span class="string">    :param text: 问题</span></span><br><span class="line"><span class="string">    :param img_url: 图片链接</span></span><br><span class="line"><span class="string">    :param user_id: 用户id</span></span><br><span class="line"><span class="string">    :param nickname: 用户昵称</span></span><br><span class="line"><span class="string">    :return: 回答</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">global</span> index</span><br><span class="line">    ai_message_manager.add_message(user_id, text)</span><br><span class="line">    special_rst = <span class="keyword">await</span> ai_message_manager.get_result(user_id, nickname)</span><br><span class="line">    <span class="keyword">if</span> special_rst:</span><br><span class="line">        ai_message_manager.add_result(user_id, special_rst)</span><br><span class="line">        <span class="keyword">return</span> special_rst</span><br><span class="line">    <span class="keyword">if</span> index == <span class="number">5</span>:</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(text) &lt; <span class="number">6</span> <span class="keyword">and</span> random.random() &lt; <span class="number">0.6</span>:</span><br><span class="line">        keys = anime_data.keys()</span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> keys:</span><br><span class="line">            <span class="keyword">if</span> text.find(key) != -<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> random.choice(anime_data[key]).replace(<span class="string">&quot;你&quot;</span>, nickname)</span><br><span class="line">    rst = <span class="keyword">await</span> GPT_3(text, user_id)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> rst:</span><br><span class="line">        rst = <span class="keyword">await</span> xie_ai(text)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> rst:</span><br><span class="line">        <span class="keyword">return</span> no_result()</span><br><span class="line">    <span class="keyword">if</span> nickname:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nickname) &lt; <span class="number">5</span>:</span><br><span class="line">            <span class="keyword">if</span> random.random() &lt; <span class="number">0.5</span>:</span><br><span class="line">                nickname = <span class="string">&quot;~&quot;</span>.join(nickname) + <span class="string">&quot;~&quot;</span></span><br><span class="line">                <span class="keyword">if</span> random.random() &lt; <span class="number">0.2</span>:</span><br><span class="line">                    <span class="keyword">if</span> nickname.find(<span class="string">&quot;大人&quot;</span>) == -<span class="number">1</span>:</span><br><span class="line">                        nickname += <span class="string">&quot;大~人~&quot;</span></span><br><span class="line">        rst = <span class="built_in">str</span>(rst).replace(<span class="string">&quot;小主人&quot;</span>, nickname).replace(<span class="string">&quot;小朋友&quot;</span>, nickname)</span><br><span class="line">    ai_message_manager.add_result(user_id, rst)</span><br><span class="line">    <span class="keyword">return</span> rst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># GPT3接口</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">GPT_3</span>(<span class="params">msg: <span class="built_in">str</span>, sessionid: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    获取GPT3接口的回复</span></span><br><span class="line"><span class="string">    指令如下(群内需@机器人)：1.[重置会话] 请发送 重置会话2.[设置人格] 请发送 设置人格+人格描述3.[重置人格] 请发送 重置人格。</span></span><br><span class="line"><span class="string">    注意：重置会话不会清空人格,重置人格会重置会话!设置人格后人格将一直存在，除非重置人格或重启逻辑端!</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> msg.strip() == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;您好，我是人工智能助手，如果您有任何问题，请随时告诉我，我将尽力回答。\n如果您需要重置我们的会话，请回复`重置会话`&#x27;</span></span><br><span class="line">        <span class="comment"># 获得对话session</span></span><br><span class="line">        session = get_chat_session(sessionid)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;重置会话&#x27;</span> == msg.strip():</span><br><span class="line">            session[<span class="string">&#x27;context&#x27;</span>] = <span class="string">&#x27;&#x27;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;会话已重置&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;重置人格&#x27;</span> == msg.strip():</span><br><span class="line">            session[<span class="string">&#x27;context&#x27;</span>] = <span class="string">&#x27;&#x27;</span></span><br><span class="line">            session[<span class="string">&#x27;preset&#x27;</span>] = session_config[<span class="string">&#x27;preset&#x27;</span>]</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;人格已重置&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> msg.strip().startswith(<span class="string">&#x27;设置人格&#x27;</span>):</span><br><span class="line">            session[<span class="string">&#x27;preset&#x27;</span>] = msg.strip().replace(<span class="string">&#x27;设置人格&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            session[<span class="string">&#x27;context&#x27;</span>] = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 处理上下文逻辑</span></span><br><span class="line">        token_limit = <span class="number">4096</span> - <span class="number">3000</span> - <span class="built_in">len</span>(tokenizer.encode(session[<span class="string">&#x27;preset&#x27;</span>])) - <span class="number">3</span></span><br><span class="line">        session[<span class="string">&#x27;context&#x27;</span>] = session[<span class="string">&#x27;context&#x27;</span>] + <span class="string">&quot;\n\nQ:&quot;</span> + msg + <span class="string">&quot;\nA:&quot;</span></span><br><span class="line">        ids = tokenizer.encode(session[<span class="string">&#x27;context&#x27;</span>])</span><br><span class="line">        tokens = tokenizer.decode(ids[-token_limit:])</span><br><span class="line">        <span class="comment"># 计算可发送的字符数量</span></span><br><span class="line">        char_limit = <span class="built_in">len</span>(<span class="string">&#x27;&#x27;</span>.join(tokens))</span><br><span class="line">        session[<span class="string">&#x27;context&#x27;</span>] = session[<span class="string">&#x27;context&#x27;</span>][-char_limit:]</span><br><span class="line">        <span class="comment"># 从最早的提问开始截取</span></span><br><span class="line">        pos = session[<span class="string">&#x27;context&#x27;</span>].find(<span class="string">&#x27;Q:&#x27;</span>)</span><br><span class="line">        session[<span class="string">&#x27;context&#x27;</span>] = session[<span class="string">&#x27;context&#x27;</span>][pos:]</span><br><span class="line">        <span class="comment"># 设置预设</span></span><br><span class="line">        msg = session[<span class="string">&#x27;preset&#x27;</span>] + <span class="string">&#x27;\n\n&#x27;</span> + session[<span class="string">&#x27;context&#x27;</span>]</span><br><span class="line">        <span class="built_in">print</span>(msg)</span><br><span class="line">        <span class="comment"># 与ChatGPT交互获得对话内容</span></span><br><span class="line">        message = chat_with_gpt(msg)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;会话ID: &quot;</span> + <span class="built_in">str</span>(sessionid))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;ChatGPT返回内容: &quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(message)</span><br><span class="line">        <span class="keyword">return</span> message </span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> error:</span><br><span class="line">        traceback.print_exc()</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(<span class="string">&#x27;异常: &#x27;</span> + <span class="built_in">str</span>(error)) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 屑 AI</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">xie_ai</span>(<span class="params">text: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    获取青云客回复</span></span><br><span class="line"><span class="string">    :param text: 问题</span></span><br><span class="line"><span class="string">    :return: 青云可回复</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    res = <span class="keyword">await</span> AsyncHttpx.get(<span class="string">f&quot;http://api.qingyunke.com/api.php?key=free&amp;appid=0&amp;msg=<span class="subst">&#123;text&#125;</span>&quot;</span>)</span><br><span class="line">    content = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        data = json.loads(res.text)</span><br><span class="line">        <span class="keyword">if</span> data[<span class="string">&quot;result&quot;</span>] == <span class="number">0</span>:</span><br><span class="line">            content = data[<span class="string">&quot;content&quot;</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;菲菲&quot;</span> <span class="keyword">in</span> content:</span><br><span class="line">                content = content.replace(<span class="string">&quot;菲菲&quot;</span>, NICKNAME)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;艳儿&quot;</span> <span class="keyword">in</span> content:</span><br><span class="line">                content = content.replace(<span class="string">&quot;艳儿&quot;</span>, NICKNAME)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;公众号&quot;</span> <span class="keyword">in</span> content:</span><br><span class="line">                content = <span class="string">&quot;&quot;</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;&#123;br&#125;&quot;</span> <span class="keyword">in</span> content:</span><br><span class="line">                content = content.replace(<span class="string">&quot;&#123;br&#125;&quot;</span>, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;提示&quot;</span> <span class="keyword">in</span> content:</span><br><span class="line">                content = content[: content.find(<span class="string">&quot;提示&quot;</span>)]</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;淘宝&quot;</span> <span class="keyword">in</span> content <span class="keyword">or</span> <span class="string">&quot;taobao.com&quot;</span> <span class="keyword">in</span> content:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                r = re.search(<span class="string">&quot;&#123;face:(.*)&#125;&quot;</span>, content)</span><br><span class="line">                <span class="keyword">if</span> r:</span><br><span class="line">                    id_ = r.group(<span class="number">1</span>)</span><br><span class="line">                    content = content.replace(</span><br><span class="line">                        <span class="string">&quot;&#123;&quot;</span> + <span class="string">f&quot;face:<span class="subst">&#123;id_&#125;</span>&quot;</span> + <span class="string">&quot;&#125;&quot;</span>, <span class="built_in">str</span>(face(<span class="built_in">int</span>(id_)))</span><br><span class="line">                    )</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            content</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> content <span class="keyword">and</span> <span class="keyword">not</span> Config.get_config(<span class="string">&quot;ai&quot;</span>, <span class="string">&quot;ALAPI_AI_CHECK&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">await</span> check_text(content)</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logger.error(<span class="string">f&quot;Ai xie_ai 发生错误 <span class="subst">&#123;<span class="built_in">type</span>(e)&#125;</span>：<span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>() -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    一些打招呼的内容</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    result = random.choice(</span><br><span class="line">        (</span><br><span class="line">            <span class="string">&quot;哦豁？！&quot;</span>,</span><br><span class="line">            <span class="string">&quot;你好！Ov&lt;&quot;</span>,</span><br><span class="line">            <span class="string">f&quot;库库库，呼唤<span class="subst">&#123;NICKNAME&#125;</span>做什么呢&quot;</span>,</span><br><span class="line">            <span class="string">&quot;我在呢！&quot;</span>,</span><br><span class="line">            <span class="string">&quot;呼呼，叫俺干嘛&quot;</span>,</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">    img = random.choice(os.listdir(IMAGE_PATH / <span class="string">&quot;zai&quot;</span>))</span><br><span class="line">    <span class="keyword">if</span> img[-<span class="number">4</span>:] == <span class="string">&quot;.gif&quot;</span>:</span><br><span class="line">        result += image(img, <span class="string">&quot;zai&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        result += image(img, <span class="string">&quot;zai&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment"># 没有回答时回复内容</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">no_result</span>() -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    没有回答时的回复</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        random.choice(</span><br><span class="line">            [</span><br><span class="line">                <span class="string">&quot;你在说啥子？&quot;</span>,</span><br><span class="line">                <span class="string">f&quot;纯洁的<span class="subst">&#123;NICKNAME&#125;</span>没听懂&quot;</span>,</span><br><span class="line">                <span class="string">&quot;下次再告诉你(下次一定)&quot;</span>,</span><br><span class="line">                <span class="string">&quot;你觉得我听懂了吗？嗯？&quot;</span>,</span><br><span class="line">                <span class="string">&quot;我！不！知！道！&quot;</span>,</span><br><span class="line">            ]</span><br><span class="line">        )</span><br><span class="line">        + image(random.choice(os.listdir(IMAGE_PATH / <span class="string">&quot;noresult&quot;</span>)), <span class="string">&quot;noresult&quot;</span>)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">check_text</span>(<span class="params">text: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    ALAPI文本检测，主要针对青云客API，检测为恶俗文本改为无回复的回答</span></span><br><span class="line"><span class="string">    :param text: 回复</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> Config.get_config(<span class="string">&quot;alapi&quot;</span>, <span class="string">&quot;ALAPI_TOKEN&quot;</span>):</span><br><span class="line">        <span class="keyword">return</span> text</span><br><span class="line">    params = &#123;<span class="string">&quot;token&quot;</span>: Config.get_config(<span class="string">&quot;alapi&quot;</span>, <span class="string">&quot;ALAPI_TOKEN&quot;</span>), <span class="string">&quot;text&quot;</span>: text&#125;</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        data = (<span class="keyword">await</span> AsyncHttpx.get(check_url, timeout=<span class="number">2</span>, params=params)).json()</span><br><span class="line">        <span class="keyword">if</span> data[<span class="string">&quot;code&quot;</span>] == <span class="number">200</span>:</span><br><span class="line">            <span class="keyword">if</span> data[<span class="string">&quot;data&quot;</span>][<span class="string">&quot;conclusion_type&quot;</span>] == <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logger.error(<span class="string">f&quot;检测违规文本错误...<span class="subst">&#123;<span class="built_in">type</span>(e)&#125;</span>：<span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> text</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong><code>openai.api_key</code>需要上官网获取后填入</strong></p><p>实际上就是把原来的图灵接口替换成GPT3接口。引入openai库和transformers库，使用了前者的<code>openai.Completion.create()</code>方法和后者<code>GPT2TokenizerFast.from_pretrained()</code>预训练的GPT2模型和分词器。</p><p>关键在于前者，因为OpenAI的API网站已经上了GFW名单，所以我们现在就算有api_key也无法调用API接口（会显示超时）。以下是解决方法。</p></div><h2 id="2-托管域名到CLOUDFLARE"><a href="#2-托管域名到CLOUDFLARE" class="headerlink" title="2. 托管域名到CLOUDFLARE"></a>2. 托管域名到CLOUDFLARE</h2><div class="story post-story"><p>后面我们要用到CLOUDFLARE，没有账户的话注册一个：<a href="https://dash.cloudflare.com/">https://dash.cloudflare.com/</a></p><p>注册之后点击右边的<code>Websites</code>，按照操作流程添加主域名，修改两个DNS服务器名字。</p><p><img src="https://www.shelven.com/tuchuang/20230308/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230308/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>比如我这里用阿里云买了一个域名，需要登录阿里云的域名控制台，点击管理，进入右边DNS修改页面</p><p><img src="https://www.shelven.com/tuchuang/20230308/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230308/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>修改原来默认的DNS服务器为<code>lorna.ns.cloudflare.com</code>和<code>ram.ns.cloudflare.com</code>。</p><p>中间可能还需要你邮件确认，按照提示操作就可以。</p></div><h2 id="3-创建CLOUDFLARE-Workers"><a href="#3-创建CLOUDFLARE-Workers" class="headerlink" title="3. 创建CLOUDFLARE Workers"></a>3. 创建CLOUDFLARE Workers</h2><div class="story post-story"><p>该步骤参考来自<a href="https://github.com/noobnooc/noobnooc/discussions/9">github [noobnooc]</a>，感谢大佬提供的解决方案！</p><p>回到CLOUDFLARE，点击右边的创建Workers——Create a Service，这里直接确认创建一个服务。</p><p><img src="https://www.shelven.com/tuchuang/20230308/3.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230308/3.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>创建之后点击<code>Quick edit</code>修改workers代码如下（<strong>起到代理api.openai.com的作用</strong>）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line">// Website you intended to retrieve <span class="keyword">for</span> users.</span><br><span class="line">const upstream = <span class="string">&#x27;api.openai.com&#x27;</span></span><br><span class="line"></span><br><span class="line">// Custom pathname <span class="keyword">for</span> the upstream website.</span><br><span class="line">const upstream_path = <span class="string">&#x27;/&#x27;</span></span><br><span class="line"></span><br><span class="line">// Website you intended to retrieve <span class="keyword">for</span> users using mobile devices.</span><br><span class="line">const upstream_mobile = upstream</span><br><span class="line"></span><br><span class="line">// Countries <span class="keyword">and</span> regions where you wish to suspend your service.</span><br><span class="line">const blocked_region = []</span><br><span class="line"></span><br><span class="line">// IP addresses which you wish to block <span class="keyword">from</span> using your service.</span><br><span class="line">const blocked_ip_address = [<span class="string">&#x27;0.0.0.0&#x27;</span>, <span class="string">&#x27;127.0.0.1&#x27;</span>]</span><br><span class="line"></span><br><span class="line">// Whether to use HTTPS protocol <span class="keyword">for</span> upstream address.</span><br><span class="line">const https = true</span><br><span class="line"></span><br><span class="line">// Whether to disable cache.</span><br><span class="line">const disable_cache = false</span><br><span class="line"></span><br><span class="line">// Replace texts.</span><br><span class="line">const replace_dict = &#123;</span><br><span class="line">    <span class="string">&#x27;$upstream&#x27;</span>: <span class="string">&#x27;$custom_domain&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addEventListener(<span class="string">&#x27;fetch&#x27;</span>, event =&gt; &#123;</span><br><span class="line">    event.respondWith(fetchAndApply(event.request));</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> function fetchAndApply(request) &#123;</span><br><span class="line">    const region = request.headers.get(<span class="string">&#x27;cf-ipcountry&#x27;</span>).toUpperCase();</span><br><span class="line">    const ip_address = request.headers.get(<span class="string">&#x27;cf-connecting-ip&#x27;</span>);</span><br><span class="line">    const user_agent = request.headers.get(<span class="string">&#x27;user-agent&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    let response = null;</span><br><span class="line">    let url = new URL(request.url);</span><br><span class="line">    let url_hostname = url.hostname;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (https == true) &#123;</span><br><span class="line">        url.protocol = <span class="string">&#x27;https:&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        url.protocol = <span class="string">&#x27;http:&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">await</span> device_status(user_agent)) &#123;</span><br><span class="line">        var upstream_domain = upstream;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        var upstream_domain = upstream_mobile;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    url.host = upstream_domain;</span><br><span class="line">    <span class="keyword">if</span> (url.pathname == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        url.pathname = upstream_path;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        url.pathname = upstream_path + url.pathname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (blocked_region.includes(region)) &#123;</span><br><span class="line">        response = new Response(<span class="string">&#x27;Access denied: WorkersProxy is not available in your region yet.&#x27;</span>, &#123;</span><br><span class="line">            status: <span class="number">403</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (blocked_ip_address.includes(ip_address)) &#123;</span><br><span class="line">        response = new Response(<span class="string">&#x27;Access denied: Your IP address is blocked by WorkersProxy.&#x27;</span>, &#123;</span><br><span class="line">            status: <span class="number">403</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        let method = request.method;</span><br><span class="line">        let request_headers = request.headers;</span><br><span class="line">        let new_request_headers = new Headers(request_headers);</span><br><span class="line"></span><br><span class="line">        new_request_headers.<span class="built_in">set</span>(<span class="string">&#x27;Host&#x27;</span>, upstream_domain);</span><br><span class="line">        new_request_headers.<span class="built_in">set</span>(<span class="string">&#x27;Referer&#x27;</span>, url.protocol + <span class="string">&#x27;//&#x27;</span> + url_hostname);</span><br><span class="line"></span><br><span class="line">        let original_response = <span class="keyword">await</span> fetch(url.href, &#123;</span><br><span class="line">            method: method,</span><br><span class="line">            headers: new_request_headers,</span><br><span class="line">            body: request.body</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        connection_upgrade = new_request_headers.get(<span class="string">&quot;Upgrade&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (connection_upgrade &amp;&amp; connection_upgrade.toLowerCase() == <span class="string">&quot;websocket&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> original_response;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        let original_response_clone = original_response.clone();</span><br><span class="line">        let original_text = null;</span><br><span class="line">        let response_headers = original_response.headers;</span><br><span class="line">        let new_response_headers = new Headers(response_headers);</span><br><span class="line">        let status = original_response.status;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (disable_cache) &#123;</span><br><span class="line">new_response_headers.<span class="built_in">set</span>(<span class="string">&#x27;Cache-Control&#x27;</span>, <span class="string">&#x27;no-store&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        new_response_headers.<span class="built_in">set</span>(<span class="string">&#x27;access-control-allow-origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">        new_response_headers.<span class="built_in">set</span>(<span class="string">&#x27;access-control-allow-credentials&#x27;</span>, true);</span><br><span class="line">        new_response_headers.delete(<span class="string">&#x27;content-security-policy&#x27;</span>);</span><br><span class="line">        new_response_headers.delete(<span class="string">&#x27;content-security-policy-report-only&#x27;</span>);</span><br><span class="line">        new_response_headers.delete(<span class="string">&#x27;clear-site-data&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (new_response_headers.get(<span class="string">&quot;x-pjax-url&quot;</span>)) &#123;</span><br><span class="line">            new_response_headers.<span class="built_in">set</span>(<span class="string">&quot;x-pjax-url&quot;</span>, response_headers.get(<span class="string">&quot;x-pjax-url&quot;</span>).replace(<span class="string">&quot;//&quot;</span> + upstream_domain, <span class="string">&quot;//&quot;</span> + url_hostname));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        const content_type = new_response_headers.get(<span class="string">&#x27;content-type&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (content_type != null &amp;&amp; content_type.includes(<span class="string">&#x27;text/html&#x27;</span>) &amp;&amp; content_type.includes(<span class="string">&#x27;UTF-8&#x27;</span>)) &#123;</span><br><span class="line">            original_text = <span class="keyword">await</span> replace_response_text(original_response_clone, upstream_domain, url_hostname);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            original_text = original_response_clone.body</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        response = new Response(original_text, &#123;</span><br><span class="line">            status,</span><br><span class="line">            headers: new_response_headers</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> function replace_response_text(response, upstream_domain, host_name) &#123;</span><br><span class="line">    let text = <span class="keyword">await</span> response.text()</span><br><span class="line"></span><br><span class="line">    var i, j;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> replace_dict) &#123;</span><br><span class="line">        j = replace_dict[i]</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="string">&#x27;$upstream&#x27;</span>) &#123;</span><br><span class="line">            i = upstream_domain</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="string">&#x27;$custom_domain&#x27;</span>) &#123;</span><br><span class="line">            i = host_name</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (j == <span class="string">&#x27;$upstream&#x27;</span>) &#123;</span><br><span class="line">            j = upstream_domain</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="string">&#x27;$custom_domain&#x27;</span>) &#123;</span><br><span class="line">            j = host_name</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        let re = new RegExp(i, <span class="string">&#x27;g&#x27;</span>)</span><br><span class="line">        text = text.replace(re, j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> text;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> function device_status(user_agent_info) &#123;</span><br><span class="line">    var agents = [<span class="string">&quot;Android&quot;</span>, <span class="string">&quot;iPhone&quot;</span>, <span class="string">&quot;SymbianOS&quot;</span>, <span class="string">&quot;Windows Phone&quot;</span>, <span class="string">&quot;iPad&quot;</span>, <span class="string">&quot;iPod&quot;</span>];</span><br><span class="line">    var flag = true;</span><br><span class="line">    <span class="keyword">for</span> (var v = <span class="number">0</span>; v &lt; agents.length; v++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (user_agent_info.indexOf(agents[v]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            flag = false;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改之后点击右下角<code>Save and deploy</code>，此时worker地址还不能直接代替openai的API地址，需要进一步绑定前面的域名（CLOUDFLARE Workers只能绑定托管到CLOUDFLARE的域名，所以有了前面一步）。</p></div><h2 id="4-绑定域名"><a href="#4-绑定域名" class="headerlink" title="4. 绑定域名"></a>4. 绑定域名</h2><div class="story post-story"><p>点击Workers进入管理页面，点击<code>Triggers</code>——<code>Add Custom Domain</code>，将前面托管的域名填进去，可以用自己喜欢的二级域名：</p><p><img src="https://www.shelven.com/tuchuang/20230308/4.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230308/4.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>大约过几分钟，custom domains显示Certificate 为 <code>Activate</code>即可。</p><p>这个时候就可以通过你绑定的域名来访问<code>api.openai.com</code>了，可以通过其他POST工具调试接口，就不多说了。</p></div><h2 id="5-修改openai库"><a href="#5-修改openai库" class="headerlink" title="5. 修改openai库"></a>5. 修改openai库</h2><div class="story post-story"><p>前面做的一系列步骤是让你可以通过其他域名访问openai的API网站，但是前面第一步写的插件调用了<code>openai.Completion.create()</code>方法函数，此时仍然会直接访问api.openai.com，这个时候就是扒源代码修改了。</p><p><code>locate openai</code>先找到服务器上openai下载的位置，在对应的路径修改，比如我的文件路径是<code>/root/anaconda3/lib/python3.9/site-packages/openai</code>，修改该路径下的__init__.py文件：</p><p><img src="https://www.shelven.com/tuchuang/20230308/5.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230308/5.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>第34行<code>api_base</code>后面的网址<strong>改为刚刚绑定的网址</strong>（&#x2F;v1的部分不要动）。</p><p>上述步骤完成后，重启zhenxun_bot就可以在<strong>不对自己服务器做任何代理的情况下正常调用OpenAI的API接口了</strong>。</p><p><img src="https://www.shelven.com/tuchuang/20230308/6.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230308/6.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>顺便说一下，2022年12月申请的openAI账号每个账户有18美元的额度，现在（2023年3月）申请的账号就只有5美元额度了，emmmmmmm…</p><p>不过上面的那个插件用的是<code>text-davinci-003</code>模型，和ChatGPT用的模型稍有不同，就在前几天ChatGPT公开了API，所使用的模型为<code>gpt-3.5-turbo</code>。并且我前面用的方法是<a href="https://platform.openai.com/docs/api-reference/completions/create">Create completion</a>，和ChatGPT创建实例的方法<a href="https://platform.openai.com/docs/api-reference/chat/create">Create chat completion</a>是不同的，且收费也不一样，现在ChatGPT API收费标准是0.002美元&#x2F;1000 tokens，token数和字数是不一样的，要看分词器怎么分，不过现在API输出上限均为4096 token。有空再更新一下模型方法，这里只是做个记录。</p><p>详细的API调用方法需要参考官网<a href="https://platform.openai.com/docs/api-reference/chat/create">API Reference - OpenAI API</a></p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;作为一个从ChatGPT公测用到现在的用户，有些无奈很难言说。本来OpenAI就不对咱们这个区域开放，使用官方的API搭建应用可以不借助VPN访问，算是解除了区域限制。但是，从&lt;strong&gt;2023年3月2日傍晚&lt;/strong&gt;开始，API接口就开始没有响应了，官网没有问题，四处查询发现可能是API的域名上了GFW名单（暂不确定，有可能重大会议过去后会恢复？）。&lt;/p&gt;</summary>
    
    
    
    <category term="网络相关" scheme="http://www.shelven.com/categories/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/"/>
    
    <category term="QQ机器人" scheme="http://www.shelven.com/categories/QQ%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    
    
    <category term="ChatGPT" scheme="http://www.shelven.com/tags/ChatGPT/"/>
    
  </entry>
  
  <entry>
    <title>0基础学习三代基因组测序组装（9）——GATK检测植物基因组SNP和INDEL变异</title>
    <link href="http://www.shelven.com/2023/03/07/a.html"/>
    <id>http://www.shelven.com/2023/03/07/a.html</id>
    <published>2023-03-07T09:53:32.000Z</published>
    <updated>2023-03-07T09:56:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>基因组组装完成之后，我们就可以对基因组进行变异分析了。这里主要介绍由 <a href="http://www.broadinstitute.org/">Broad Institute</a>开发的一款基因组分析工具GATK，这款工具设计之初是用于处理分析Illumina二代测序技术产生的人类全外显子和全基因组数据，经过多个版本的优化迭代，GATK集合了多种高通量测序数据处理和质控的软件，如今GATK可以说是对DNA和RNA-seq数据检测SNP和Indel的标准。</p><span id="more"></span><h2 id="1-GATK安装"><a href="#1-GATK安装" class="headerlink" title="1. GATK安装"></a>1. GATK安装</h2><div class="story post-story"><p>GATK的运行依赖于JAVA环境，目前（2023年3月6日）GATK更新到版本4.3.0，可以直接用conda下载。为了避免环境冲突，最好创建一个新环境专门用于GATK和相关变异检测工具运行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">conda create -n GATK</span><br><span class="line">conda install -c bioconda gatk</span><br><span class="line"></span><br><span class="line">conda install bwa-mem2</span><br><span class="line">conda install samtools</span><br></pre></td></tr></table></figure><p>bwa-mem2和samtools用于双端序列比对回基因组，需要单独下载这两个软件，后面再说。</p><p>安装完成之后可以通过<code>gatk --help</code>查看是否正常。</p></div><h2 id="2-流程详解"><a href="#2-流程详解" class="headerlink" title="2. 流程详解"></a>2. 流程详解</h2><div class="story post-story"><p>流程内容主要参考官网<a href="https://gatk.broadinstitute.org/hc/en-us/articles/360035535932-Germline-short-variant-discovery-SNPs-Indels-">Best Practices Workflows的文章</a>。</p><p>GATK工具的变异注释主要包括3个部分：<strong>数据预处理（Data Pre-processing）、变异检测（Variant Discovery）和变异优化（Callset Refinement）</strong>。</p><p>以Germline short variant discovery (SNPs + Indels) ，即胚系短变异的发现为例，官网对多个样本（群组数据，Cohort Data）的变异检测分析流程如下：</p><p><img src="https://www.shelven.com/tuchuang/20230306/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230306/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>单个样本（Single-Sample Data）的变异检测标准流程如下：</p><p><img src="https://www.shelven.com/tuchuang/20230306/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230306/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>分析流程基本类似，以我前面组装的三代<strong>植物</strong>基因组为例跑一下这两个流程，<strong>强调一下我用的是植物基因组，后续无法用Germline的注释数据资源对变异集进行功能注释！</strong>因此这里只跑到变异集过滤的步骤，拿到SNP和INDEL。</p><h3 id="2-1-数据预处理"><a href="#2-1-数据预处理" class="headerlink" title="2.1 数据预处理"></a>2.1 数据预处理</h3><ol><li><strong>构建参考基因组索引</strong>：组装的基因组作为reference参考基因组，首先需要对参考基因组建立索引，方便后续进行比对和对参考基因组进行查询。<strong>注意三个软件的索引文件不同，每个软件都必须建立索引</strong>。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">ref=$1</span><br><span class="line"></span><br><span class="line">bwa-mem2 index $ref</span><br><span class="line">samtools faidx $ref</span><br><span class="line">referencename=`basename $ref | sed  &quot;s/fasta/dict/&quot; `# .fasta文件后缀改为.dict</span><br><span class="line">gatk CreateSequenceDictionary -R $ref -O $referencename </span><br></pre></td></tr></table></figure><ol start="2"><li><strong>fasta文件转化uBAM文件，标记adapter 序列</strong>：组装好的基因组格式是fasta格式，需要转换成uBAM格式（umapped的BAM文件），接着标记illumina二代测序的adapter序列。本质上都是调用了Picard工具，也可以直接用java写脚本。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">sampleName=$1</span><br><span class="line"></span><br><span class="line">gatk FastqToSam -F1 raw_fastq/$&#123;sampleName&#125;_1.fq.gz -F2 raw_fastq/$&#123;sampleName&#125;_2.fq.gz -RG $sampleName -SM $sampleName -O ubam/$&#123;sampleName&#125;.bam</span><br><span class="line"></span><br><span class="line">gatk MarkIlluminaAdapters -I ubam/$&#123;sampleName&#125;.bam -O markadapeters/$&#123;sampleName&#125;.markadapeters.bam -M markadapeters/$&#123;sampleName&#125;.metrics.txt</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>标记后的序列转化成fastq格式，回比参考基因组，得到干净的BAM文件</strong>：第二和第三步来自官方的文章<a href="https://gatk.broadinstitute.org/hc/en-us/articles/360039568932--How-to-Map-and-clean-up-short-read-sequence-data-efficiently">(How to) Map and clean up short read sequence data efficiently</a>，通过联合SamToFastq、BWA - MEM和MergeBamAlignment三个程序，节省比对时间，绕过占用空间过大的SAM文件，MergeBamAlignment可以将已排序的SAM中的定义信息（我这里将SAM文件转换成BAM文件）与uBAM中的定义信息进行合并，得到干净的BAM并进行排序和构建索引。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">sampleName=$1</span><br><span class="line">threads=50</span><br><span class="line">ref=/public/home/wlxie/biosoft/GATK_file/gatk/ref/luobuma.fasta</span><br><span class="line"></span><br><span class="line">gatk SamToFastq -I markadapeters/$&#123;sampleName&#125;.markadapeters.bam -F  interleaved_fq/$&#123;sampleName&#125;_1.interleaved.fq.gz -F2  interleaved_fq/$&#123;sampleName&#125;_2.interleaved.fq.gz -CLIP_ATTR XT -CLIP_ACT 2</span><br><span class="line"></span><br><span class="line">bwa-mem2 mem -M -t $threads $ref  interleaved_fq/$&#123;sampleName&#125;_1.interleaved.fq.gz interleaved_fq/$&#123;sampleName&#125;_2.interleaved.fq.gz | samtools view -Sb - &gt; raw_bam/$&#123;sampleName&#125;.bam</span><br><span class="line"></span><br><span class="line">gatk MergeBamAlignment -R $ref -UNMAPPED  ubam/$&#123;sampleName&#125;.bam -O align_bam/$&#123;sampleName&#125;.bam -ALIGNED  raw_bam/$&#123;sampleName&#125;.bam -MC true --CREATE_INDEX true</span><br><span class="line"></span><br><span class="line">rm -rf markadapeters/$&#123;sampleName&#125;.markadapeters.ba interleaved_fq/$&#123;sampleName&#125;_1.interleaved.fq.gz  interleaved_fq/$&#123;sampleName&#125;_2.interleaved.fq.gz raw_bam/$&#123;sampleName&#125;.bam # 删除中间文件</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>标记重复序列</strong>：做SNP分析前最重要的一点就是标记重复序列（mark duplicate），二代测序是在PCR扩增的基础上进行的，因此PCR扩增产生的多拷贝会结合到flowcell的不同位置，生成完全相同的测序cluster，最后得到重复序列。这一步就是标记这些重复序列（但是没有删除，对结果应该不影响），最后得到一个<strong>metrics文件</strong>（duplicate的统计信息）和一个<strong>bam文件</strong>（duplicate的详细信息，注意要创建索引）。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">sampleName=$1</span><br><span class="line"></span><br><span class="line">gatk MarkDuplicates -I align_bam/$&#123;sampleName&#125;.bam -O markdup/$&#123;sampleName&#125;.markdup.bam -M markdup/$&#123;sampleName&#125;.markdup_metrics.txt --CREATE_INDEX true</span><br><span class="line"></span><br><span class="line">rm -rf  align_bam/$&#123;sampleName&#125;.bam # 删除中间文件</span><br></pre></td></tr></table></figure><p>最终生成的bam文件进行下一步变异检测，可以用<code>samtools -view</code> 查看bam文件的内容（也没啥好看的，感兴趣可以看看之前博客写的<a href="https://www.shelven.com/2022/04/15/a.html">sam文件格式解读</a>）。</p><p><img src="https://www.shelven.com/tuchuang/20230306/3.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230306/3.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><ul><li>注意：官网的数据预处理后续还有一步<strong>碱基质量重校正BQSR</strong>（Base Quality Scores Recallbrate），官方提供了两个工具BaseRecalibrator和ApplyBQSR。第一个工具计算需要校正的reads和特征值，输出校准表文件，需要注意的是，<strong>这个工具需要一个或者多个已知且可靠的物种变异位点数据库</strong>，比如人类就有千人基因组计划的各种变异位点数据库，1000G_omni2.5.hg38.vcf.gz、dbsnp_146.hg38.vcf.gz等等；第二个工具根据第一个工具生成校准表，重新调整原来BAM文件中的碱基质量值，重新输出到一个新的BAM文件中。</li></ul><p>因为我这个植物没有已知的可靠变异位点数据，因此不用做最后这一步。</p><p><strong>本部分程序需要运行10小时。</strong></p><h3 id="2-2-变异检测"><a href="#2-2-变异检测" class="headerlink" title="2.2 变异检测"></a>2.2 变异检测</h3><p>因为我只有一个样本，所以可以按照单个样本（Single-Sample Data）的标准流程来做，也可以按照多样本（Cohort Data）的流程做。该部分主要用到的工具是HaplotypeCaller，两个流程只是对HaplotypeCaller工具产生的结果做了不同的处理，最后都是得到包含SNP和Indel的VCF文件。我也将分别跑两个流程来对比下差异。</p><p>首先要明白HaplotypeCaller这个工具具体做了什么，是怎么找出单碱基变异的：</p><ul><li><strong>1.定义活跃区域</strong>（<a href="https://software.broadinstitute.org/gatk/documentation/article?id=4147">Define active regions</a>）：根据是否存在变异来确定需要操作的基因组的活跃区域。</li><li><strong>2.通过组装活跃区域确定单倍型</strong>（<a href="https://software.broadinstitute.org/gatk/documentation/article?id=4146">Determine haplotypes by assembly of the active region</a>）：对于每个活跃区域，构建一个类似De Bruijn图来重新组装活性区域，识别可能的单倍型，然后用Smith-Waterman算法将每个单倍型与参考基因组单倍型重新比对，发现潜在的变异位点。</li><li><strong>3.确定read单倍型似然值</strong>（<a href="https://software.broadinstitute.org/gatk/documentation/article?id=4441">Determine likelihoods of the haplotypes given the read data</a>）：对每个活跃区域使用PairHMM算法对每个read与每个单倍型进行两两比对，生成单倍型似然矩阵，将似然值边缘化，以获得每个潜在变异位点的等位基因的可能性。</li><li><strong>4.指定样本基因型</strong>（<a href="https://software.broadinstitute.org/gatk/documentation/article?id=4442">Assign sample genotypes</a>）：对每个潜在的变异位点使用贝叶斯算法，转化每个位点的基因型的似然值。然后将最可能的基因型指定为样本基因型。</li></ul><p>以上流程翻译自<a href="https://gatk.broadinstitute.org/hc/en-us/articles/360056969012-HaplotypeCaller">HaplotypeCaller – GATK (broadinstitute.org)</a>，这个工具可用参数非常之多，下面跑的流程就展示一些常用的。</p><h4 id="2-2-1-多样本的SNP和INDEL检测"><a href="#2-2-1-多样本的SNP和INDEL检测" class="headerlink" title="2.2.1 多样本的SNP和INDEL检测"></a>2.2.1 多样本的SNP和INDEL检测</h4><ol><li><strong>使用HaplotypeCaller的GVCF模式，找到每个样本SNP和INDEL变异</strong>。在GVCF模式下，每个样本的结果文件以gvcf（genomic vcf）格式文件呈现，实际上gvcf格式和vcf格式类似，gvcf记录所有位点的突变情况，并且提供这些位点是否是纯和的置信度，主要还是方便将所有样本的gvcf联合起来方便分析。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">sampleName=$1</span><br><span class="line">threads=50</span><br><span class="line">ref=/public/home/wlxie/biosoft/GATK_file/gatk/ref/luobuma.fasta</span><br><span class="line"></span><br><span class="line">gatk HaplotypeCaller -R $ref --native-pair-hmm-threads $&#123;threads&#125; --emit-ref-confidence GVCF -I ../../pre_processing/markdup/$&#123;sampleName&#125;.markdup.bam -O $&#123;sampleName&#125;.g.vcf.gz</span><br></pre></td></tr></table></figure><p>这一步是整个SNP和IDEL检测中运行时间最长，需要算力最多的一步（主要是Pair-HMM算法花时间），Pair-HMM算法在本地调用的线程数是可以更改的，官方是给定默认值为4。GATK4.0版本开始放弃了多线程任务，<strong>这个参数可能是更新后遗漏的，因为我这里用的50线程和默认的4线程跑几乎没有区别，都是在28小时左右完成，此处参数存疑</strong>。</p><ol start="2"><li><strong>建库合并所有样本的GVCF文件（单样本不用做这步），并将GVCF文件转化为VCF文件</strong>。对于多样本的GVCF合并，现在<a href="https://gatk.broadinstitute.org/hc/en-us/articles/360035890411?id=3893">官方建议</a>用GenomicsDBImport这个工具进行建库合并，速度会快很多。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">sampleName=$1</span><br><span class="line">threads=50</span><br><span class="line">ref=/public/home/wlxie/biosoft/GATK_file/gatk/ref/luobuma.fasta</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gatk GenomicsDBImport $(<span class="keyword">for</span> file <span class="keyword">in</span> `<span class="built_in">ls</span> *.g.vcf.gz`; <span class="keyword">do</span> <span class="built_in">echo</span> <span class="string">&quot;-V <span class="variable">$file</span>&quot;</span>; <span class="keyword">done</span>)  --genomicsdb-workspace-path database -L chr01<span class="comment"># 单样本不用做这步，因为就一个GVCF。多样本注意-L参数是建库必须的,根据fasta参考基因组的染色体名称命名，拆分</span></span></span><br><span class="line"></span><br><span class="line">gatk GenotypeGVCFs -R $ref -V $&#123;sampleName&#125;.g.vcf.gz -O raw_variants.vcf.gz# 多样本使用参数-V gendb://database 也就是上一步建的数据库名，单样本直接用gvcf文件</span><br></pre></td></tr></table></figure><p>可以看看最后生成的VCF文件：</p><p><img src="https://www.shelven.com/tuchuang/20230306/4.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230306/4.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>文件解读放在最后过滤和拆分SNP和INDEL的时候再说，这里是初步得到变异信息，需要经过过滤和筛选。</p><p><strong>本部分程序需要运行28小时。</strong></p><h4 id="2-2-2-单个样本的SNP和INDEL检测"><a href="#2-2-2-单个样本的SNP和INDEL检测" class="headerlink" title="2.2.2 单个样本的SNP和INDEL检测"></a>2.2.2 单个样本的SNP和INDEL检测</h4><p><strong>使用HaplotypeCaller默认的single-sample模式，直接生成统计SNP和INDEL变异的VCF文件</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">sampleName=$1</span><br><span class="line">threads=50</span><br><span class="line">ref=/public/home/wlxie/biosoft/GATK_file/gatk/ref/baima.fasta</span><br><span class="line"></span><br><span class="line">gatk HaplotypeCaller -R $ref --native-pair-hmm-threads $&#123;threads&#125; -I ../../pre_processing/markdup/$&#123;sampleName&#125;.markdup.bam -O $&#123;sampleName&#125;.vcf.gz</span><br></pre></td></tr></table></figure><p>同上一个步骤，此处参数<code>--native-pair-hmm-threads</code>对运算速度的提升存疑，最后同样是生成VCF文件，<strong>运行时间同样为28小时</strong>。</p><h3 id="2-3-变异过滤（优化）"><a href="#2-3-变异过滤（优化）" class="headerlink" title="2.3 变异过滤（优化）"></a>2.3 变异过滤（优化）</h3><p>变异集过滤方法主要有两种：</p><ul><li>1.软过滤：基于机器学习的方法，对原始vcf文件进行变异质量重矫正和过滤。比如有基于卷积神经网络CNN的CNNVariantTrain（有预训练的模型1D和2D），VariantRecalibrator、ApplyVQSR等可以用已知的人类变异数据集作为训练集，检测得到的SNP和INDEL的准确性（官方推荐用于人类变异过滤的方法，Variant Quality Score Recalibration，VQSR）。缺点显而易见，需要已知的真实变异数据集，<strong>除人类以外大多数生物都没有这方面的数据集</strong>。如果是研究人类基因组的话，可以从GATK官网资源处下载。</li><li>2.硬过滤：通过对6个指标的硬性阈值筛选质量合格的SNP和INDEL。</li></ul><p>记录下硬过滤的6个指标，有些说明看不懂干脆都放英文了，参考自官网<a href="https://gatk.broadinstitute.org/hc/en-us/articles/360035890471-Hard-filtering-germline-short-variants">Hard-filtering germline short variants</a>：</p><blockquote><p>（1）<a href="https://gatk.broadinstitute.org/hc/en-us/articles/9570266920219--Tool-Documentation-Index#QualByDepth">QualByDepth (QD)</a>：This is the variant confidence (from the QUAL field) divided by the unfiltered depth of non-hom-ref samples. 变异置信度，官方建议过滤该值小于2的变异。</p><p>（2）<a href="https://gatk.broadinstitute.org/hc/en-us/articles/9570266920219--Tool-Documentation-Index#FisherStrand">FisherStrand (FS)</a>：This is the Phred-scaled probability that there is strand bias at the site.</p><p>（3）<a href="https://gatk.broadinstitute.org/hc/en-us/articles/9570266920219--Tool-Documentation-Index#StrandOddsRatio">StrandOddsRatio (SOR)</a>：This is another way to estimate strand bias using a test similar to the symmetric odds ratio test.</p><p>（4）<a href="https://gatk.broadinstitute.org/hc/en-us/articles/9570266920219--Tool-Documentation-Index#RMSMappingQuality">RMSMappingQuality (MQ)</a>：This is the root mean square mapping quality over all the reads at the site.比对reads质量的平方根。</p><p>（5）<a href="https://gatk.broadinstitute.org/hc/en-us/articles/9570266920219--Tool-Documentation-Index#MappingQualityRankSumTest">MappingQualityRankSumTest (MQRankSum)</a>：This is the u-based z-approximation from the Rank Sum Test for mapping qualities. </p><p>（6）<a href="https://gatk.broadinstitute.org/hc/en-us/articles/9570266920219--Tool-Documentation-Index#ReadPosRankSumTest">ReadPosRankSumTest (ReadPosRankSum)</a>：This is the u-based z-approximation from the Rank Sum Test for site position within reads. </p></blockquote><p>看不懂没关系，官方给出了6个硬过滤指标在SNP和INDEL中的阈值设置，详情可以看<a href="https://gatk.broadinstitute.org/hc/en-us/articles/360035890471-Hard-filtering-germline-short-variants">Hard-filtering germline short variants – GATK (broadinstitute.org)</a>。以下例子均以官方的硬过滤指标为准，感兴趣可以去官网看各个参数的作用或者自己微调。</p><p>SelectVariants工具用于从vcf文件中提取SNP和INDEL信息，VariantFiltration工具用于硬过滤筛选：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">sampleName=$1</span><br><span class="line">threads=50</span><br><span class="line">VARIANTS=/public/home/wlxie/biosoft/GATK_file/gatk/variants_discover/luobuma/raw_variants.vcf.gz</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">SNP筛选、过滤和提取</span></span><br><span class="line">gatk SelectVariants -select-type SNP -V $VARIANTS --restrict-alleles-to BIALLELIC  -O $&#123;sampleName&#125;_SNP.vcf.gz# BIALLELIC 限制双等位基因，不考虑其他等位多态性</span><br><span class="line">gatk VariantFiltration -V $&#123;sampleName&#125;_SNP.vcf.gz --filter-expression &quot;QD &lt; 2.0 || MQ &lt; 40.0 || FS &gt; 60.0 || SOR &gt; 3.0 || MQRankSum &lt; -12.5 || ReadPosRankSum &lt; -8.0&quot; --filter-name &quot;Filter&quot; -O $&#123;sampleName&#125;_SNP.filter.vcf.gz</span><br><span class="line">gatk SelectVariants  -V $&#123;sampleName&#125;_SNP.filter.vcf.gz --exclude-filtered true -O final.$&#123;sampleName&#125;_SNP.vcf.gz# 只显示通过过滤的变异（pass）</span><br><span class="line">rm -rf $&#123;sampleName&#125;_SNP.vcf.gz*</span><br><span class="line">rm -rf $&#123;sampleName&#125;_SNP.filter.vcf.gz*</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">INDEL筛选、过滤和提取</span></span><br><span class="line">gatk SelectVariants -select-type INDEL -V $VARIANTS --restrict-alleles-to BIALLELIC  -O $&#123;sampleName&#125;_INDEL.vcf.gz# BIALLELIC 限制双等位基因，不考虑其他等位多态性</span><br><span class="line">gatk VariantFiltration -V $&#123;sampleName&#125;_INDEL.vcf.gz --filter-expression &quot;QD &lt; 2.0 || FS &gt; 200.0 || SOR &gt; 10.0 || MQRankSum &lt; -12.5 || ReadPosRankSum &lt; -8.0&quot; --filter-name &quot;Filter&quot; -O $&#123;sampleName&#125;_INDEL.filter.vcf.gz</span><br><span class="line">gatk SelectVariants  -V $&#123;sampleName&#125;_INDEL.filter.vcf.gz --exclude-filtered true -O final.$&#123;sampleName&#125;_INDEL.vcf.gz# 只显示通过过滤的变异（pass）</span><br><span class="line">rm -rf $&#123;sampleName&#125;_INDEL.vcf.gz*</span><br><span class="line">rm -rf $&#123;sampleName&#125;_INDEL.filter.vcf.gz*</span><br></pre></td></tr></table></figure><p>得到的<code>final.sampleName_SNP.vcf.gz</code>和<code>final.sampleName_INDEL.vcf.gz</code>为最终的变异集结果文件。</p></div><h2 id="3-结果文件解读"><a href="#3-结果文件解读" class="headerlink" title="3. 结果文件解读"></a>3. 结果文件解读</h2><div class="story post-story"><p>因为结果文件时一个压缩过后的vcf文件，且vcf文件中前面带<code>#</code>部分的注释内容是用不到的，后面每一行代表一个变异位点信息，因此可以直直接统计行数来得到最终的SNP和INDEL的数量。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zcat final.luobuma_SNP.vcf.gz | grep -v -P &quot;^#&quot; -c</span><br></pre></td></tr></table></figure><p><img src="https://www.shelven.com/tuchuang/20230306/5.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230306/5.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>用2.2.1多样本流程的SNP和INDEL结果文件为<code>final.luobuma_SNP.vcf.gz</code>和<code>final.luobuma_INDEL.vcf.gz</code>；用2.2.2单个样本流程的SNP和INDEL结果为<code>final.luobuma_sm_SNP.vcf.gz</code>和<code>final.luobuma_sm_INDEL.vcf.gz</code>。可以看到两者在统计SNP和INDEL数量上的差距非常小，<strong>说明这两个流程对单样本来说都是可以用的</strong>。</p><p>以<code>final.luobuma_SNP.vcf.gz</code>文件进行解读，通过<code>less -S</code>命令一行一条信息查看文件内容：</p><p><img src="https://www.shelven.com/tuchuang/20230306/6.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230306/6.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><img src="https://www.shelven.com/tuchuang/20230306/7.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230306/7.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>每列信息如下：</p><ul><li>1.CHROM：染色体信息</li><li>2.POS：变异所在参考基因组的位置</li><li>3.ID：变异的ID，如果有参考变异集，会给出id，否则为<code>.</code>表示新发现的变异</li><li>4.REF：变异在参考基因组上的信息，必须为ATCGN五个之一</li><li>5.ALT：突变之后的情况，类型同上，<code>.</code>表示缺失</li><li>6.QUAL：突变后的质量值，质量值越高越可靠，通常只用pass的数据</li><li>7.FILTER：是否通过过滤</li><li>8.INFO：每个位点的详细信息（包括硬过滤的指标，详细可以到header里找）</li><li>9.FORMAT：格式</li><li>10.样本名（实际是前面格式的具体值）</li></ul><p>主要解释一下第九列和第十列，就是上图中红色框框起来的部分，两列值是用冒号分隔且一一对应的，需要注意的值是<strong>GT</strong>：</p><ul><li><strong>GT</strong>：0表示和参考序列一致（REF allele），1表示和样本序列一致（ALT allele），双等位基因只有0和1，0&#x2F;1和0|1表示杂合，1&#x2F;1和1|1表示纯和。“|”和“&#x2F;”区别是前者是phased genotype，就是知道REF&#x2F;ALT allele是来自于父本还是母本，在这里对我这个植物基因组没有什么意义，全都统计进杂合和纯和SNP个数就行。</li><li>AD：REF和ALT allele的覆盖度，在二倍体是是用逗号分割的两个值表示，前一个代表参考基因组的基因型，后者代表样本基因型。</li><li>DP：样本中该位点覆盖度，AD两个数字的和。</li></ul><h3 id="3-1-杂合率统计"><a href="#3-1-杂合率统计" class="headerlink" title="3.1 杂合率统计"></a>3.1 杂合率统计</h3><p>分别统计SNP和INDEL文件中杂合单碱基变异的个数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zcat final.luobuma_SNP.vcf.gz | grep -c &quot;0/1&quot;</span><br><span class="line">zcat final.luobuma_SNP.vcf.gz | grep -c &quot;0|1&quot;</span><br><span class="line">zcat final.luobuma_INDEL.vcf.gz | grep -c &quot;0/1&quot;</span><br><span class="line">zcat final.luobuma_INDEL.vcf.gz | grep -c &quot;0|1&quot;</span><br></pre></td></tr></table></figure><p><strong>杂合率 &#x3D; (杂合SNP数 + 杂合INDEL数) &#x2F; 基因组大小</strong></p><table><thead><tr><th>杂合SNP数(Hetero SNP)</th><th>杂合INDEL数(Hetero Indel)</th><th>基因组大小(bp)</th><th>杂合率</th></tr></thead><tbody><tr><td>1,233,471</td><td>287,207</td><td>230,888,863</td><td>0.66%</td></tr></tbody></table><p>此处计算的杂合率可以和前面做的基因组Survey做个比较，说明基因组Survey的可靠性。</p><h3 id="3-2-单碱基准确度计算"><a href="#3-2-单碱基准确度计算" class="headerlink" title="3.2 单碱基准确度计算"></a>3.2 单碱基准确度计算</h3><p>我们知道测序过程中不可避免地存在错误，三代测序数据单碱基变异的来源，包括<u>真实的单碱基变异</u>和<u>测序错误导致的单碱基变异</u>。<strong>当测序错误导致的单碱基变异存在于参考基因组上时，利用二代测序数据进行单碱基变异的检测时，会将其识别为纯合单碱基变异</strong>。因此，可以将三代数据组装的最终版基因组作为参考基因组，利用二代数据将纯合子单碱基变异率作为组装结果的错误率，即:</p><p><strong>组装结果的准确率 &#x3D; 1 - 纯合子单碱基变异率</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zcat final.luobuma_SNP.vcf.gz | grep -c &quot;1/1&quot;</span><br><span class="line">zcat final.luobuma_SNP.vcf.gz | grep -c &quot;1|1&quot;</span><br><span class="line">zcat final.luobuma_INDEL.vcf.gz | grep -c &quot;1/1&quot;</span><br><span class="line">zcat final.luobuma_INDEL.vcf.gz | grep -c &quot;1|1&quot;</span><br></pre></td></tr></table></figure><table><thead><tr><th>纯和SNP数(Homo SNP)</th><th>纯和INDEL数(Homo Indel)</th><th>基因组大小(bp)</th><th>纯和子单碱基变异率</th><th>组装结果准确率</th></tr></thead><tbody><tr><td>4,176</td><td>8,580</td><td>230,888,863</td><td>0.005525%</td><td>99.994475%</td></tr></tbody></table><p>这种单碱基准确度的计算结果也可以作为基因组组装质量的评估指标之一，即<strong>序列一致性评估</strong>——利用高质量的二代测序数据来评估三代测序数据组装结果在单碱基水平上的准确性。</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;基因组组装完成之后，我们就可以对基因组进行变异分析了。这里主要介绍由 &lt;a href=&quot;http://www.broadinstitute.org/&quot;&gt;Broad Institute&lt;/a&gt;开发的一款基因组分析工具GATK，这款工具设计之初是用于处理分析Illumina二代测序技术产生的人类全外显子和全基因组数据，经过多个版本的优化迭代，GATK集合了多种高通量测序数据处理和质控的软件，如今GATK可以说是对DNA和RNA-seq数据检测SNP和Indel的标准。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="基因组三代测序分析" scheme="http://www.shelven.com/categories/%E5%9F%BA%E5%9B%A0%E7%BB%84%E4%B8%89%E4%BB%A3%E6%B5%8B%E5%BA%8F%E5%88%86%E6%9E%90/"/>
    
    
    <category term="GATK" scheme="http://www.shelven.com/tags/GATK/"/>
    
  </entry>
  
  <entry>
    <title>0基础学习基因组三代测序组装（8）——基因组组装质量评估（QUAST）</title>
    <link href="http://www.shelven.com/2023/03/02/a.html"/>
    <id>http://www.shelven.com/2023/03/02/a.html</id>
    <published>2023-03-02T15:24:41.000Z</published>
    <updated>2023-03-04T02:58:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>接上一篇博客，这一篇博客继续介绍一个常用的评估基因组组装质量的软件——<strong>QUAST</strong></p><span id="more"></span><h2 id="1-QUAST介绍"><a href="#1-QUAST介绍" class="headerlink" title="1. QUAST介绍"></a>1. QUAST介绍</h2><div class="story post-story"><p>QUAST（Quality Assessment Tool for Genome Assemblies）是一个比较综合的评估基因组组装质量的软件，主要包括四种分析工具：</p><ul><li>QUAST：常规基因组组装质量评估</li><li>MetaQUAST：宏基因组（元基因组）组装质量评估</li><li>QUAST-LG：大型基因组组装质量评估</li><li>Icarus：Contig比对可视化工具（类似IGV浏览器的感觉）</li></ul><p>QUAST用到的软件如下（参考自<a href="https://nmdc.cn/static/pdf/web/viewer.html?file=/static/file/analysis/QUAST.pdf">国家微生物科学数据中心</a>）：</p><blockquote><p>序列比对：Minimap2</p><p>基因和功能：GeneMarkS、GeneMark-ES、GlimmerHMM、Barrnap和BUSCO</p><p>查找结构变异：BWA、Sambamba</p><p>覆盖度计算：bedtools</p><p>MetaQUAST：MetaGeneMark、Krona tools、BLAST和SILVA数据库</p><p>QUAST-LG：KMC和Red</p></blockquote><p>这个软件优点是可以使用参考基因组或者<strong>无参考基因组</strong>情况对组装的基因组进行评估，可以快速进行<strong>大批量的基因组组装质量比较</strong>，最终的结果有图表、excel和latex等多种表现形式，也有个可以<strong>交互的网页结果</strong>，非常直观和方便。</p></div><h2 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h2><div class="story post-story"><p>如果从官网下载的话，需要安装非常多的依赖软件，好消息是：<strong>可以conda安装</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">conda install -c bioconda quast</span><br><span class="line"></span><br><span class="line">quast-download-busco</span><br><span class="line">quast-download-gridss# 检测基因组重排的软件</span><br><span class="line">quast-download-silva# 著名的16s数据库，提供最新的核糖体大小亚基rRNA注释信息</span><br></pre></td></tr></table></figure><p>截至2023年3月2日，最新版本为5.2.0</p><p>后续需要安装什么软件都可以<code>conda search</code>一下，能省好多功夫。注意一下conda安装之后会提醒缺两个工具和一个数据库，直接运行命令下载即可。</p></div><h2 id="3-运行实例"><a href="#3-运行实例" class="headerlink" title="3. 运行实例"></a>3. 运行实例</h2><div class="story post-story"><p>以我的植物基因组跑一个常规基因组组装质量评估的例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -n 50</span></span><br><span class="line"></span><br><span class="line">quast -t 50 -o quast_baima -1 /public/home/wlxie/clean_data/1.fq -2 /public/home/wlxie/2.fq /public/home/wlxie/NextPolish/baima_rundir/genome.nextpolish.fasta</span><br></pre></td></tr></table></figure><p>QUAST输入文件只有组装的基因组是必须的，同时也支持三代测序<code>--pacbio</code>、<code>--nanopore</code>数据，也支持二代数据输入。我这里同时输入了二代数据，因此结果文件中有组装基因组的质量评估，也有二代数据回贴组装基因组的分析数据。</p></div><h2 id="4-结果展示"><a href="#4-结果展示" class="headerlink" title="4. 结果展示"></a>4. 结果展示</h2><div class="story post-story"><p>运行结束后的输出日志如下：</p><p><img src="https://www.shelven.com/tuchuang/20230303/1111.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230303/1111.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>最终生成图表结果可以在report.pdf中找到，也可以看report.html，一次运行时常大约为6小时：</p><p><img src="https://www.shelven.com/tuchuang/20230303/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230303/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>左边红框框起来的部分就是二代数据回比基因组的结果，mapping率高于100%说明有多比对，<strong>完美比对率</strong>（配对reads中两条序列比对上同一个参考基因组序列的比例，Properly Paired）<strong>93.45%<strong>，</strong>覆盖度（coverage）98.63%<strong>。</strong>这个比对率说明二代测序reads与组装的基因组有较高的一致性（Properly paired 90%以上，coverage 95%以上）</strong>，可以进行后续的分析。</p><p>右边是contig长度累积图，横坐标从左到右contig长度依次减小，曲线越陡表明大片段越长、数量越多，也可以看到基因组组装的连续性良好。</p><p>左上角contig的具体数据，以及N50、GC含量可以在<code>transposed_report.txt</code>中查看，同时也提供了latex和excel格式的结果文件，非常贴心~或者可以在<code>basic_stats</code>文件夹中查看相应的pdf图表：</p><p><img src="https://www.shelven.com/tuchuang/20230303/3.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230303/3.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><img src="https://www.shelven.com/tuchuang/20230303/4.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230303/4.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>Nx图横轴是Nx百分比，比如50就是N50；纵轴是contig长度。这张图也可以反映组装结果的连续性。</p><p><img src="https://www.shelven.com/tuchuang/20230303/5.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230303/5.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>最后是icarus网页结果，前面说这个界面有点像IGV。。。总之就是将各个contig从长到短组装情况可视化的工具，可以拖动底下的黄色框左右移动来查看对应的contig情况。</p><p>在基因组组装质量评估方面，<strong>这个软件就可以一次给出序列一致性、组装完整性和测序覆盖均匀性评估</strong>，还是非常方便的~当然，如果你有参考基因组的话，就可以得到更多有效的评估信息。</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;接上一篇博客，这一篇博客继续介绍一个常用的评估基因组组装质量的软件——&lt;strong&gt;QUAST&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="基因组三代测序分析" scheme="http://www.shelven.com/categories/%E5%9F%BA%E5%9B%A0%E7%BB%84%E4%B8%89%E4%BB%A3%E6%B5%8B%E5%BA%8F%E5%88%86%E6%9E%90/"/>
    
    
    <category term="QUAST" scheme="http://www.shelven.com/tags/QUAST/"/>
    
  </entry>
  
  <entry>
    <title>0基础学习基因组三代测序组装（7）——基因组组装质量评估（BUSCO、LAI指数）</title>
    <link href="http://www.shelven.com/2023/03/01/a.html"/>
    <id>http://www.shelven.com/2023/03/01/a.html</id>
    <published>2023-03-01T12:39:05.000Z</published>
    <updated>2023-03-03T06:30:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>通过前面的纠错和校正步骤，我们得到了组装完成的基因组序列，接下来就是进行基因组的组装质量评估。质量评估的软件和方法比较多，这里分两篇博客记录，本篇主要演示如何用BUSCO和LAI指数评价基因组组装质量。</p><span id="more"></span><p>复习一下前面说到的contig N50，按照contig从短到长的顺序依次相加，当相加的长度达到Contig总长度的一半，最后一个Contig长度即为<strong>contig N50</strong>.</p><p>contig N50是基因组组装质量的第一指标，一般来说越高越好，但是contig N50不能完全代表一个基因组组装质量的高低，比如reads的错误连接也会使contig N50变高。接下来介绍几个现在常用的评估基因组组装质量的软件和方法。</p><h2 id="1-保守型基因评估"><a href="#1-保守型基因评估" class="headerlink" title="1. 保守型基因评估"></a>1. 保守型基因评估</h2><div class="story post-story"><p>BUSCO（Benchmarking Universal Single-Copy Orthologs）评估是在基因含量层面上评估基因组完整性。简单来说，通过已有的直系同源数据库进行基因组比对，同源的生物之间有保守基因序列，能比对上的基因数越多说明组装的结果越靠谱。</p><p>安装过程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1. 源码安装（需要安装前置软件）</span></span><br><span class="line">git clone https://gitlab.com/ezlab/busco.git</span><br><span class="line">cd busco/</span><br><span class="line">python setup.py install</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">前置软件：</span></span><br><span class="line">https://biopython.org/</span><br><span class="line">https://pandas.pydata.org/</span><br><span class="line">https://jgi.doe.gov/data-and-tools/software-tools/bbtools/</span><br><span class="line">https://ftp.ncbi.nlm.nih.gov/blast/executables/blast+/LATEST</span><br><span class="line">http://bioinf.uni-greifswald.de/augustus/</span><br><span class="line">https://github.com/soedinglab/metaeuk</span><br><span class="line">https://github.com/hyattpd/Prodigal</span><br><span class="line">http://hmmer.org/</span><br><span class="line">https://github.com/smirarab/sepp/</span><br><span class="line">https://www.r-project.org/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2. conda安装（推荐）</span></span><br><span class="line">conda install -c conda-forge -c bioconda busco=5.3.2</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>conda安装可能会比较慢，需要多试几次。实在不行就源码下载编译，不过需要下载非常多的前置软件，不同软件可能会有环境冲突问题、gcc版本问题等等<del>（我花了大半天时间在折腾环境）</del>。安装之后通过<code>busco -h</code>查看是否安装成功，如果提示缺什么软件就用conda补上（我当前环境中没有安装pandas就会有提示）。</p><p>通过<code>busco --list-datasets</code>可以查看当前有哪些物种的数据库，我的植物是双子叶龙胆目，这里的数据库只有<strong>真双子叶植物（eudicots）</strong>分支离的最近，因此选择这个数据库，v5版本所有单拷贝直系同源数据库网址<a href="https://busco-data.ezlab.org/v5/data/lineages/">https://busco-data.ezlab.org/v5/data/lineages/</a></p><p><img src="https://www.shelven.com/tuchuang/20230228/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230228/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>下载的数据库放在<code>busco_downloads</code>文件夹中，解压即可使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nohup wget https://busco-data.ezlab.org/v5/data/lineages/eudicots_odb10.2020-09-10.tar.gz &amp;</span><br><span class="line">tar -zxvf eudicots_odb10.2020-09-10.tar.gz</span><br></pre></td></tr></table></figure><p>busco的详细参数可以看官网的user guide <a href="https://busco.ezlab.org/busco_userguide.html">User guide BUSCO v5.4.4 (ezlab.org)</a></p><p>简单讲一讲格式和能用到的参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">busco -i [SEQUENCE_FILE] -l [LINEAGE] -o [OUTPUT_NAME] -m [MODE] [OTHER OPTIONS]</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">主要参数：</span><br><span class="line"> -i序列文件位置</span><br><span class="line"> -l下载的同源物种保守基因数据库位置</span><br><span class="line"> -o输出文件名</span><br><span class="line"> -m模式，分为genome,proteins,transcriptome三种</span><br><span class="line"> 其他参数：</span><br><span class="line"> --cpu设置cpu数量</span><br><span class="line"> --download在线下载数据库，根据分类有&quot;all&quot;、&quot;prokaryota&quot;、&quot;eukaryota&quot;和&quot;virus&quot; （不推荐，速度慢）</span><br><span class="line"> --offline离线模式，不会更新数据库</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><p>以下是我跑的程序，大约用了1个小时：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">busco -i /public/home/wlxie/NextPolish/01_rundir/genome.nextpolish.fasta -l /public/home/wlxie/busco_soft/busco/test_data/eukaryota/busco_downloads/lineages/eudicots_odb10 -o baima -m genome --cpu 8 --offline</span><br></pre></td></tr></table></figure><p>截至2023&#x2F;02&#x2F;28，<strong>真双子叶植物库有2326个保守BUSCO基因序列</strong>，比对结果文件在short_summary.specific.xxx.xxx.txt中，如下：</p><p><img src="https://www.shelven.com/tuchuang/20230228/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230228/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><ul><li>Complete BUSCOs (C)    多少个基因完全比对上BUSCOs</li><li>Complete and single-copy BUSCOs (S)    多少个基因比对上单拷贝的BUSCOs</li><li>Complete and duplicated BUSCOs (D)    多少个基因比对上多拷贝的BUSCOs</li><li>Fragmented BUSCOs (F)    多少个基因部分比对上BUSCOs，可能基因只是部分存在</li><li>Missing BUSCOs (M)    多少个基因没有比对上BUSCOs，可能这些直系同源基因是缺失的</li></ul><p>从上面的数据看，组装结果还是不错的。从中也可以看到BUSCO运行的<strong>两个步骤</strong>：<strong>用metaeuk进行基因预测</strong>（真核生物可以用tBLASTn与对应的BUSCO数据库序列进行比对从而确定候选区域，然后使用 Augustus 软件进行基因结构预测，两个软件可以替代metaeuk，详细参数见官网），以及<strong>HMMER进行同源基因的比对</strong>，从而评估基因组组装的完整性。</p><p>官方还提供了相应的python程序绘制结果图（调用了R包ggplot2），先将BUSCO结果文件放到新建的文件夹，运行相应的py程序，指定工作目录即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir summaries</span><br><span class="line"></span><br><span class="line">cp baima/short_summary.specific.eudicots_odb10.baima.txt summaries</span><br><span class="line"></span><br><span class="line">generate_plot.py -wd summaries</span><br></pre></td></tr></table></figure><p>结果图如下：</p><p><img src="https://www.shelven.com/tuchuang/20230228/3.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230228/3.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>当然，有结果数据就可以自己做更好看的图了，不一定要用官方的。</p></div><h2 id="2-长末端重复序列评估"><a href="#2-长末端重复序列评估" class="headerlink" title="2. 长末端重复序列评估"></a>2. 长末端重复序列评估</h2><div class="story post-story"><p>2018年发表在Nucleic Acids Research上的一篇文章<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6265445/">Assessing genome assembly quality using the LTR Assembly Index (LAI)</a>，研究者提出了一种对长末端重复序列（long terminal repeats,LTRs）评估从而评价基因组完整度的方法，并且开发了对应的分析工具<code>LTR_retriever</code></p><p>具体的LTR注释我会在后续的基因组注释笔记中更新，这里暂时跳过原理和背景部分，介绍下文章中提出的评估核心——LAI指数（LTR Assembly Index，LAI），也就是长末端重复序列组装指数。<code>raw LAI = (完整LTR-RTs长度/总LTR长度)*100</code>，修正后，<code>LAI = raw LAI + 2.8138 × (94 – 整个基因组LTR identity)</code>。</p><p>以下是一个完整的LTR-RTs的结构示意图：</p><p><img src="https://www.shelven.com/tuchuang/20230228/4.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230228/4.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>文章还阐明LAI独立于基因组大小、LTR-RT含量以及基因空间评估指标（如BUSCO和CEGMA）等参数，可以用于鉴定低质量的基因组区域。使用这个指标要求**基因组中完整的LTR-RTs应至少占基因组0.1%且总LTR-RTs长度至少占5%**。</p><p>文章最后给出了LAI评价基因组完整度的三个指标：</p><table><thead><tr><th>分类</th><th>LAI</th><th>举例</th></tr></thead><tbody><tr><td>Draft</td><td>0 ≤ LAI &lt; 10</td><td>Apple (v1.0), Cacao (v1.0)</td></tr><tr><td>Reference</td><td>10 ≤ LAI &lt; 20</td><td>Arabidopsis (TAIR10), Grape (12X)</td></tr><tr><td>Gold</td><td>20 ≤ LAI</td><td>Rice (MSUv7), Maize (B73 v4)</td></tr></tbody></table><h3 id="2-1-LTR序列预测"><a href="#2-1-LTR序列预测" class="headerlink" title="2.1 LTR序列预测"></a>2.1 LTR序列预测</h3><p><code>LTR_retriever</code>需要以<code>LTR_finder</code>和&#x2F;或<code>ltrharvest</code>的LTR预测结果文件为输入，也可以整合两个软件的预测结果作为输入（或者其他符合格式的LTR结果文件），因此需要先安装并运行以上软件，我这里以文章中提到的软件和参数运行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">LTR_finder、ltrharvest和LTR_retriever安装（ltrharvest是genometools软件的一部分）</span></span><br><span class="line"></span><br><span class="line">conda install -c bioconda ltr_finder</span><br><span class="line">conda install -c bioconda genometools-genometools</span><br><span class="line">conda install -c bioconda ltr_retriever</span><br></pre></td></tr></table></figure><p><strong>LTR_finder</strong>预测LTR序列（参数均由作者给出，只有文件是自己的）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -n 10</span></span><br><span class="line"></span><br><span class="line">ltr_finder -D 15000 -d 1000 -L 7000 -l 100 -p 20 -C -M 0.85 /public/home/wlxie/NextPolish/01_rundir/genome.nextpolish.fasta &gt; baima_ltrfinder.scn</span><br></pre></td></tr></table></figure><blockquote><p>参数解释：</p><p>-D NUM     Max distance between 5’&amp;3’LTR, default is 20000# 5’和3’LTR之间的最大距离</p><p>-d NUM     Min distance between 5’&amp;3’LTR, default is 1000</p><p>-L NUM     Max length of 5’&amp;3’LTR, default is 3500# 5’和3’LTR最大长度</p><p>-l NUM     Min length of 5’&amp;3’LTR, default is 100</p><p>-p NUM     min length of exact match pair, default is 20# 完全匹配最小长度</p><p>-C         detect Centriole, delete highly repeat regions# 检测中心粒，删除高度重复区域</p><p>-M NUM     min LTR similarity threshold, default is 0.00, [0,1]#最小LTR相似度</p></blockquote><p><strong>ltrharvest</strong>预测LTR序列（ltrharvest参数均由作者给出，只有文件是自己的）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -n 10</span></span><br><span class="line"></span><br><span class="line">mkdir index</span><br><span class="line"></span><br><span class="line">gt suffixerator -db /public/home/wlxie/NextPolish/01_rundir/genome.nextpolish.fasta -indexname index/baima -tis -suf -lcp -des -ssp -sds -dna</span><br><span class="line"></span><br><span class="line">gt ltrharvest -index index/baima -minlenltr 100 -maxlenltr 7000 -mintsd 4 -maxtsd 6 -motif TGCA -motifmis 1 -similar 85 -vic 10 -seed 20 -seqids yes &gt; baima_ltrharvest.scn</span><br></pre></td></tr></table></figure><p>这里要注意下要先使用genome tools里的suffixerator<strong>创建基因组索引文件</strong>，然后才可以使用ltrharvest进行LTR预测。</p><blockquote><p>创建基因组索引的参数不做解释了，可以 gt suffixerator -help 查看。稍微记录下ltrharvest参数：</p><p>-minlenltr  specify minimum length for each LTR，default: 100</p><p>-mintsd     specify minimum length for each TSD，default: 4</p><p>-motif      specify 2 nucleotides startmotif + 2 nucleotides endmotif: ****</p><p>-motifmis   specify maximum number of mismatches in motif [0,3]，default: 4</p><p>-similar    specify similaritythreshold in range [1..100%]，default: 85.00</p><p>-vic        specify the number of nucleotides (to the left and to the right) that will be searched for TSDs and&#x2F;or motifs around 5’ and 3’boundary of predicted LTR retrotransposons, default: 60</p><p>-seed       specify minimum seed length for exact repeats，default: 30</p><p>-seqids     use sequence descriptions instead of sequence numbers in GFF3 output，default: no</p></blockquote><p>以上两个软件以同样的LTR最小相似度0.85预测LTR，得到两个结果文件<code>baima_ltrfinder.scn</code>和<code>baima_ltrharvest.scn</code>。</p><h3 id="2-2-LAI指数计算"><a href="#2-2-LAI指数计算" class="headerlink" title="2.2 LAI指数计算"></a>2.2 LAI指数计算</h3><p>用上一步的输出的两个结果文件，运行<code>LTR_retriever</code>鉴定LTR和计算LAI指数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -n 20</span></span><br><span class="line"></span><br><span class="line">LTR_retriever -genome /public/home/wlxie/NextPolish/01_rundir/genome.nextpolish.fasta -inharvest baima_ltrharvest.scn -infinder baima_ltrfinder.scn -threads 20</span><br></pre></td></tr></table></figure><p>这一步运行结果如下：</p><p><img src="https://www.shelven.com/tuchuang/20230228/5.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230228/5.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><strong>其他文件可以后续做LTR分析用到</strong>，这里我们只要看最后一个LAI的计算结果文件：</p><p><img src="https://www.shelven.com/tuchuang/20230228/6.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230228/6.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>可以看到这个结果文件中包含了整个genome和各个contig的raw LAI和LAI指数，这里就只看整个genome的LAI指数15.37，根据上面文章作者提到的分类，属于Reference级别，也就是说可以认为达到参考基因组级别。</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;通过前面的纠错和校正步骤，我们得到了组装完成的基因组序列，接下来就是进行基因组的组装质量评估。质量评估的软件和方法比较多，这里分两篇博客记录，本篇主要演示如何用BUSCO和LAI指数评价基因组组装质量。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="基因组三代测序分析" scheme="http://www.shelven.com/categories/%E5%9F%BA%E5%9B%A0%E7%BB%84%E4%B8%89%E4%BB%A3%E6%B5%8B%E5%BA%8F%E5%88%86%E6%9E%90/"/>
    
    
    <category term="BUSCO" scheme="http://www.shelven.com/tags/BUSCO/"/>
    
    <category term="LAI" scheme="http://www.shelven.com/tags/LAI/"/>
    
  </entry>
  
  <entry>
    <title>0基础学习基因组三代测序组装（6）——基因组polish</title>
    <link href="http://www.shelven.com/2023/02/27/a.html"/>
    <id>http://www.shelven.com/2023/02/27/a.html</id>
    <published>2023-02-27T03:02:16.000Z</published>
    <updated>2023-02-27T03:05:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>三代基因组de novo组装后得到一系列contig，由于三代测序的错误率较高，我们需要对组装结果进行打磨（以下均用polish表示）以提高基因组的拼接指标如Contig N50，Scaffold N50。</p><span id="more"></span><p>常用软件主要有Pilon、Racon，针对PacBio的有Quiver &amp; Arrow，针对Nanopore的有NanoPolish，以及武汉希望组为NextDenovo配套开发的NextPolish等等。<strong>要注意下先进行三代测序数据矫正，再进行二代测序数据矫正，顺序不能反</strong>，因为三代数据读长长准确率低，二代读长短准确率高，利用二代测序测序数据对三代测序数据进行纠错可以将三代测序错误率降低到二代测序的水平。如果不先进行三代序列纠错，由于基因组上存在过高错误率，导致二代序列的错误比对，影响最终polish效果。</p><p>这里以前面用NextDenovo组装的植物三代基因组为例，介绍下Racon和NextPolish用法。</p><h2 id="1-Racon"><a href="#1-Racon" class="headerlink" title="1. Racon"></a>1. Racon</h2><div class="story post-story"><p>racon的基本用法如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">racon [options ...] &lt;sequences&gt; &lt;overlaps&gt; &lt;target sequences&gt;</span><br></pre></td></tr></table></figure><p>需要用到三种输入文件：sequences是指用来纠错的三代基因组测序数据（后面以原始数据称呼）；target sequences指<strong>需要校正的组装后的基因组数据</strong>（后面以组装基因组称呼）；overlaps指回比到组装基因组的原始数据文件，其中包含了所有的overlaps，其文件格式为MHAP&#x2F;PAF&#x2F;SAM三种之一。</p><p>因此在使用Racon之前需要使用其他比对工具将三代数据回贴到组装基因组上，在<a href="https://www.shelven.com/2022/04/15/a.html">转录组分析笔记</a>中有介绍过相关软件，我这里用minimap2进行比对，这是专门针对三代测序数据开发的比对工具，运行速度较快。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minimap2 -a -t 20 &lt;target sequences&gt; &lt;sequences&gt; &gt; minimap_1.sam</span><br></pre></td></tr></table></figure><p><code>-a</code>表示结果为sam格式，<code>&lt;target sequences&gt;</code>处传入组装基因组的绝对路径，<code>&lt;sequences&gt;</code>处传入原始数据的绝对路径，比对结果的sam文件命名为minimap_1.sam</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">racon -t 50 &lt;sequences&gt; minimap_1.sam &lt;target sequences&gt; &gt; racon_minimap_1.fasta</span><br></pre></td></tr></table></figure><p>如上一次循环下来（大约3小时），得到的racon_minimap_1.fasta就是经过一次三代数据校正的组装基因组。</p><p>一般要用三代数据polish 2-4次，之后用二代数据继续校正4次左右，可以写脚本循环，需要注意<strong>racon因为要一次读入三代原始数据和回比的sam数据，内存需求量非常大</strong>，申请的内核数需要自己计算一下，否则会报内存溢出的错误（220Mb的基因组，100X测序深度，申请50个核才能跑动）。</p><p>脚本文件racon.sh如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">minimap2 -a -t 50 $1 $2 &gt; minimap_1.sam</span><br><span class="line">racon -t 50 $2 minimap_1.sam $1 &gt; racon_minimap_1.fasta</span><br><span class="line"></span><br><span class="line">minimap2 -a -t 50 racon_minimap_1.fasta $2 &gt; minimap_2.sam</span><br><span class="line">racon -t 50 $2 minimap_2.sam racon_minimap_1.fasta &gt; racon_minimap_2.fasta</span><br></pre></td></tr></table></figure><p>recon.slurm：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -J recon</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -N 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -n 50</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -t 7200</span></span><br><span class="line"></span><br><span class="line">date</span><br><span class="line">bash racon.sh /public/home/wlxie/NextDenovo/03_rundir/03.ctg_graph/nd.asm.fasta /public/home/wlxie/luobuma/luobuma/baima_rawdata/Third_generation_sequencing/clean_filter.fq</span><br><span class="line">date</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sbatch recon.slurm</span><br></pre></td></tr></table></figure><p>可以从输出日志中看到，racon运行主要分两步，分别是校准overlap和生成共有序列（也就是去重），<strong>在生成共有序列（consensus sequence）之后再进行二代数据的纠错</strong>。</p><p>这一步的Racon检测出两个contig可能是嵌合体（chimeric），所谓嵌合contig，该contig的某段区域可能可以比对上不同的染色体，或者头尾部分可能分别属于不同的染色体。第一遍racon的时候没有检测到，第二遍racon才出现这个提示，我不确定这两个contig是否真的是嵌合体，最终还是需要Hi-C数据来验证。</p><p><img src="https://www.shelven.com/tuchuang/20230227/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230227/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>我这里两次循环得到polish的结果文件<code>racon_minimap_2.fasta</code>，接下来用NextPolish软件继续用二代数据polish。</p></div><h2 id="2-NextPolish"><a href="#2-NextPolish" class="headerlink" title="2. NextPolish"></a>2. NextPolish</h2><div class="story post-story"><p>NextPolish是武汉那希望组开发的与NextDenovo配套的基因组polish软件，支持二代短读长、三代长读长和HiFi数据进行纠错。</p><p>和之前的NextDenovo操作方法类似，首先需要准备一个input文件，写入二代数据的绝对路径到sgs.fofn：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">realpath ./1.fq ./2.fq &gt; sgs.fofn</span><br></pre></td></tr></table></figure><p>从doc文件夹中copy一份配置文件run.cfg，修改参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[General]</span><br><span class="line">job_type = slurm# local, slurm, sge, pbs, lsf塔大学校集群选择slurm</span><br><span class="line">job_prefix = nextPolish</span><br><span class="line">task = best# all, default, best, 1, 2, 5, 12, 1212…  1，2是两个不同的短读长算法模块，5是长读长算法模块，默认best</span><br><span class="line">rewrite = yes</span><br><span class="line">deltmp = yes# 删除临时结果文件</span><br><span class="line">rerun = 3# 重复执行polish次数</span><br><span class="line">parallel_jobs = 20# 每个job线程数</span><br><span class="line">multithread_jobs = 5# job数</span><br><span class="line">genome = /public/home/wlxie/baima_polish/racon_minimap_2.fasta</span><br><span class="line">genome_size = auto</span><br><span class="line">workdir = ./01_rundir</span><br><span class="line">polish_options = -p &#123;multithread_jobs&#125;</span><br><span class="line"></span><br><span class="line">[sgs_option] #optional</span><br><span class="line">sgs_fofn = ./sgs.fofn# 输入文件位置（一行一条）</span><br><span class="line">sgs_options = -max_depth 100 -bwa# 使用bwa进行比对</span><br></pre></td></tr></table></figure><p>长reads和HiFi的两段配置信息删除，<strong>只留下短读长sgs_options</strong>。</p><p>这个软件的优点是速度快（<strong>100线程，4次polish，220Mb的基因组，72G的二代数据量仅仅用了8小时</strong>），而且只需要提供配置和输入文件就可以到polish结束出结果，经过4次Polish结果的迭代，最终结果如下:</p><p><img src="https://www.shelven.com/tuchuang/20230227/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230227/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>Contig N50比一开始NextDenovo组装结果大，也就是组装效果更好。</p><p><img src="https://www.shelven.com/tuchuang/20230227/3.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230227/3.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;三代基因组de novo组装后得到一系列contig，由于三代测序的错误率较高，我们需要对组装结果进行打磨（以下均用polish表示）以提高基因组的拼接指标如Contig N50，Scaffold N50。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="基因组三代测序分析" scheme="http://www.shelven.com/categories/%E5%9F%BA%E5%9B%A0%E7%BB%84%E4%B8%89%E4%BB%A3%E6%B5%8B%E5%BA%8F%E5%88%86%E6%9E%90/"/>
    
    
    <category term="NextPolish" scheme="http://www.shelven.com/tags/NextPolish/"/>
    
    <category term="Racon" scheme="http://www.shelven.com/tags/Racon/"/>
    
  </entry>
  
  <entry>
    <title>0基础学习基因组三代测序组装（5）——三代数据组装</title>
    <link href="http://www.shelven.com/2023/02/23/a.html"/>
    <id>http://www.shelven.com/2023/02/23/a.html</id>
    <published>2023-02-23T14:22:00.000Z</published>
    <updated>2023-02-28T13:07:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间比较忙，现在继续整理基因组测序组装系列的学习笔记。<a href="https://www.shelven.com/2022/07/03/a.html">第四篇笔记</a>写的二代测序基因组组装，主要是演示二代测序数据组装的主流工具SOAPdenovo 2.0是如何应用的。我这里有了二代和三代的测序数据，后续组装还是以<strong>三代数据为主</strong>，这里就继续记录下几款三代测序数据组装的主流工具和用法。</p><span id="more"></span><p>现在主流的三代测序公司是Pacbio和Nanopore，两家测序公司测序原理不同，产生的数据类型也有区别。</p><h2 id="1-主流三代测序平台"><a href="#1-主流三代测序平台" class="headerlink" title="1. 主流三代测序平台"></a>1. 主流三代测序平台</h2><div class="story post-story"><h3 id="1-1-Pacbio测序平台"><a href="#1-1-Pacbio测序平台" class="headerlink" title="1.1 Pacbio测序平台"></a>1.1 Pacbio测序平台</h3><p>Pacbio测序平台是单分子实时测序（single molecule real time sequencing，SMRT），原理是当DNA与聚合酶形成的复合物被ZMW（零模波导孔）捕获后，4种不同荧光标记的dNTP随机进入检测区域并与聚合酶结合，与模板匹配的碱基生成化学键并激发荧光，生成化学键激发的荧光存在的时间远远长于其他碱基被激发荧光的时间，从而实现单碱基的实时检测。</p><p><img src="https://www.shelven.com/tuchuang/20230223/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230223/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>现在Pacbio有两种测序模式，一种是<strong>CLR测序模式</strong>（超长测序模式），产生数据基于单循环测序结果；一种是<strong>HiFi测序模式</strong>，也就是高保真测序模式，产生数据基于滚环一致序列（Circular Consensus Sequencing ，CCS）。具体原理就不说了，两种测序模式中HiFi数据相对来说准确率会高一些，所以不同软件对两种测序模式的数据也会有不同的处理。 </p><h3 id="1-2-Nanopore测序平台"><a href="#1-2-Nanopore测序平台" class="headerlink" title="1.2 Nanopore测序平台"></a>1.2 Nanopore测序平台</h3><p>Nanopore测序平台前面第一篇博客介绍过了，可以<a href="https://www.shelven.com/2022/06/17/b.html">点击这里</a>。需要了解ONT测序平台测序产生的原始数据是<strong>电信号</strong>，经过basecalling之后才可以转化成我们要的测序数据。</p></div><h2 id="2-三代基因组测序组装软件"><a href="#2-三代基因组测序组装软件" class="headerlink" title="2. 三代基因组测序组装软件"></a>2. 三代基因组测序组装软件</h2><div class="story post-story"><h3 id="2-1-NextDenovo"><a href="#2-1-NextDenovo" class="headerlink" title="2.1 NextDenovo"></a>2.1 NextDenovo</h3><p>NextDenovo是武汉希望组开发的集校正、比对和组装一体的，基于字符串图（string graph-based）的三代测序基因组组装软件。它的实现过程和另一款经典的三代基因组组装软件Canu类似，经过长读长数据的纠错校正后再进行组装。</p><p>官网上介绍原来可以对CLR、HiFi和ONT数据都可以组装，HiFi数据可以跳过数据的自我纠错过程，如今HiFi数据被划掉了，也许已经不再适用，但是对Pabio的CLR和Nanopore的ONT测序数据仍有较好的组装效果，其介绍是组装的准确率有98%-99.8%。</p><p>NextDenovo主要有两个核心模块 <strong>NextCorrect</strong>和<strong>NextGraph</strong>。NextCorrect用于原始数据纠错，NextGraph用于纠错后数据的组装。据作者介绍，与其他工具相比，NextDenovo在装配一致性和单碱基装配精度方面表现出较高的水平。我个人用起来是觉得这个软件<strong>运行时间相对Canu较短</strong>，需要的算力资源较小，可以很快地组装出结果（后面可以进行比较）。</p><p>安装并测试通过后，我们就可以开始使用这个工具了。</p><p>首先准备input文件，将前面质控后的三代测序数据的绝对路径写在<strong>input.fofn</strong>文件里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/public/home/wlxie/luobuma/luobuma/baima_rawdata/Third_generation_sequencing/clean_filter.fq</span><br></pre></td></tr></table></figure><p>接下来也是最重要的，修改配置文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[General]</span><br><span class="line">job_type = slurm # local, slurm, sge, pbs, lsf塔大学校集群选择slurm</span><br><span class="line">job_prefix = nextDenovo</span><br><span class="line">task = all # all, correct, assemble选择只进行correct还是只进行assemble，或者两者都进行，基因组小的话可以直接all</span><br><span class="line">rewrite = yes # yes/no覆写</span><br><span class="line">deltmp = yes </span><br><span class="line">parallel_jobs = 20 # number of tasks used to run in parallel线程数，咱学校的集群20勉强够</span><br><span class="line">input_type = raw # raw, corrected输入的数据情况</span><br><span class="line">read_type = ont # clr, ont, hifi数据类型</span><br><span class="line">input_fofn = input.fofn# 输入数据的位置信息</span><br><span class="line">workdir = 03_rundir# 输出的文件夹名字</span><br><span class="line"></span><br><span class="line">[correct_option]</span><br><span class="line">read_cutoff = 1k# 进行correct的时候截取的最小read</span><br><span class="line">genome_size = 230m # estimated genome size预估的基因组大小</span><br><span class="line">sort_options = -m 20g -t 15</span><br><span class="line">minimap2_options_raw = -t 8</span><br><span class="line">pa_correction = 3 # number of corrected tasks used to run in parallel, each corrected task requires ~TOTAL_INPUT_BASES/4 bytes of memory usage.</span><br><span class="line">correction_options = -p 15 -dbuf# 非常重要！-dbuf让每一步作业释放内存，防止节点卡死！</span><br><span class="line"></span><br><span class="line">[assemble_option]</span><br><span class="line">minimap2_options_cns = -t 8 </span><br><span class="line">nextgraph_options = -a 1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上是我的配置文件信息，<strong>中文标注的地方都很重要</strong>，根据情况修改。其他参数可以用默认。其中预估的基因大小也是很有必要的，前面在做基因组Survey的时候预测过，这里就直接写预测的基因组大小。</p><p>其他参数的设定和使用可以参考这篇博客<a href="https://blog.csdn.net/u012110870/article/details/102660023">使用NextDenovo组装Nanopore数据</a>，以及官方的参数说明手册<a href="https://nextdenovo.readthedocs.io/en/latest/OPTION.html">NextDenovo Parameter Reference — NextDenovo latest documentation</a></p><p>需要强调一点，<code>correction_options = -p 15 -dbuf</code>这项参数是我在华农的集群平台手册上看到的，之前确实一直会<strong>卡死</strong>在某一步直到24h后台强杀这个进程，目前未知原因，加上之后运行正常。以我的数据来看，一个200多Mb的植物基因组，测序深度100X左右，一次组装运行结束需要12小时左右，<strong>已经非常快了</strong>。</p><p>最后是运行程序，我写了一个run.slurm文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -n 40</span></span><br><span class="line"></span><br><span class="line">./nextDenovo run.cfg</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sbatch run.slurm</span><br></pre></td></tr></table></figure><p><strong>基因组比较大的话，建议分步运行，先correct，再assemble。</strong></p><p>因为是在集群中运行，所有输出都会在slurm-xxxx.out的文件夹中显示，打开以后可以看到每个时间节点完成了什么任务，当有任务卡住几个小时都没动的时候，就要检查是否是配置文件是否正确。</p><p><img src="https://www.shelven.com/tuchuang/20230223/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230223/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>最后组装的基因组在03.ctg_graph目录下，文件名称nd.asm.fasta。最底下输出了组装结果概况，contig N50为9Mb，总共组装出225Mb的基因组序列，contig总数为59，组装结果还算不错。</p><h3 id="2-2-Canu"><a href="#2-2-Canu" class="headerlink" title="2.2 Canu"></a>2.2 Canu</h3><p>Canu是三代测序数据组装的经典工具，也是主要用于Pacbio和Nanopore公司的测序结果组装。</p><p>这个软件在安装过程中有点曲折，从官网下数据包，最后一步编译的过程会报错。目前我暂时没办法解决，但是可以用conda安装（虽然官网不建议这么做）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install -c conda-forge -c bioconda -c defaults canu</span><br></pre></td></tr></table></figure><p>如果报错动态库出问题，可以参考<a href="https://www.shelven.com/2022/07/02/a.html">第三篇博客</a>中的方法，寻找根目录下的动态库中是否有对应的版本文件，如果有，<strong>直接修改软链接到对应的动态库下</strong>。</p><p>Canu运行分为三个步骤：<strong>纠错（Correct）、修剪（Trim）和组装（Assemble）</strong>。可以每一个步骤分开跑，比如纠错修剪之后的数据可以放到别的软件中组装，或者用别的软件纠错之后作为输入到Canu中组装。考虑到塔大集群24小时自动杀程序，保险起见还是三个步骤分开跑比较安全。</p><p>下面是官方的帮助文档，写的非常详细：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">usage:   canu [-version] [-citation] \</span><br><span class="line">              [-haplotype | -correct | -trim | -assemble | -trim-assemble] \</span><br><span class="line">              [-s &lt;assembly-specifications-file&gt;] \</span><br><span class="line">               -p &lt;assembly-prefix&gt; \# 输出文件前缀</span><br><span class="line">               -d &lt;assembly-directory&gt; \# 输出目录</span><br><span class="line">               genomeSize=&lt;number&gt;[g|m|k] \# 预测基因组大小</span><br><span class="line">              [other-options] \</span><br><span class="line">              [-haplotype&#123;NAME&#125; illumina.fastq.gz] \</span><br><span class="line">              [-corrected] \</span><br><span class="line">              [-trimmed] \</span><br><span class="line">              [-pacbio |</span><br><span class="line">               -nanopore |</span><br><span class="line">               -pacbio-hifi] file1 file2 ...</span><br><span class="line"></span><br><span class="line">example: canu -d run1 -p godzilla genomeSize=1g -nanopore-raw reads/*.fasta.gz </span><br><span class="line"></span><br><span class="line">  To restrict canu to only a specific stage, use:# 描述canu要执行的主程序</span><br><span class="line">    -haplotype     - generate haplotype-specific reads</span><br><span class="line">    -correct       - generate corrected reads</span><br><span class="line">    -trim          - generate trimmed reads</span><br><span class="line">    -assemble      - generate an assembly</span><br><span class="line">    -trim-assemble - generate trimmed reads and then assemble them</span><br><span class="line"></span><br><span class="line">  Reads can be either FASTA or FASTQ format, uncompressed, or compressed with gz, bz2 or xz.</span><br><span class="line"></span><br><span class="line">  Reads are specified by the technology they were generated with, and any processing performed.</span><br><span class="line"></span><br><span class="line">  [processing]# 描述reads状态</span><br><span class="line">    -corrected</span><br><span class="line">    -trimmed</span><br><span class="line"></span><br><span class="line">  [technology]# 描述测序平台（数据类型）</span><br><span class="line">    -pacbio      &lt;files&gt;</span><br><span class="line">    -nanopore    &lt;files&gt;</span><br><span class="line">    -pacbio-hifi &lt;files&gt;</span><br><span class="line">    </span><br><span class="line">  Some common options:</span><br><span class="line">    useGrid=string</span><br><span class="line">      - Run under grid control (true), locally (false), or set up for grid control</span><br><span class="line">        but don&#x27;t submit any jobs (remote)</span><br><span class="line">    rawErrorRate=fraction-error# 降低这个参数会提高第一步的速度</span><br><span class="line">      - The allowed difference in an overlap between two raw uncorrected reads.  For lower</span><br><span class="line">        quality reads, use a higher number.  The defaults are 0.300 for PacBio reads and</span><br><span class="line">        0.500 for Nanopore reads.  </span><br><span class="line">    correctedErrorRate=fraction-error# 降低这个参数可以提高组装效率</span><br><span class="line">      - The allowed difference in an overlap between two corrected reads.  Assemblies of</span><br><span class="line">        low coverage or data with biological differences will benefit from a slight increase</span><br><span class="line">        in this.  Defaults are 0.045 for PacBio reads and 0.144 for Nanopore reads.</span><br><span class="line">    gridOptions=string</span><br><span class="line">      - Pass string to the command used to submit jobs to the grid.  Can be used to set</span><br><span class="line">        maximum run time limits.  Should NOT be used to set memory limits; Canu will do</span><br><span class="line">        that for you.</span><br><span class="line">    minReadLength=number</span><br><span class="line">      - Ignore reads shorter than &#x27;number&#x27; bases long.  Default: 1000.</span><br><span class="line">    minOverlapLength=number</span><br><span class="line">      - Ignore read-to-read overlaps shorter than &#x27;number&#x27; bases long.  Default: 500.</span><br><span class="line">  A full list of options can be printed with &#x27;-options&#x27;.  All options can be supplied in</span><br><span class="line">  an optional sepc file with the -s option.# 可以用-s来提供自己修改的参数文件</span><br><span class="line"></span><br><span class="line">Complete documentation at http://canu.readthedocs.org/en/latest/</span><br></pre></td></tr></table></figure><p>也可以<a href="https://canu.readthedocs.io/en/latest/quick-start.html#">点击这里</a>，进官方手册看原文。下面用我自己的三代数据跑一个案例。</p><h4 id="2-2-1-纠错（Correct）"><a href="#2-2-1-纠错（Correct）" class="headerlink" title="2.2.1 纠错（Correct）"></a>2.2.1 纠错（Correct）</h4><p>因为三代测序数据错误率较高，纠错的步骤是通过序列之间的一致性比较获得高可信的碱基。</p><p>创建一个canu的空文件夹，写入以下内容到correct.slurm:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -N 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -n 40</span></span><br><span class="line"></span><br><span class="line">canu -correct -p baima -d baima_nanopore genomeSize=230m -nanopore-raw /public/home/wlxie/luobuma/luobuma/baima_rawdata/Third_generation_sequencing/pass.fq</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sbatch correct.slurm</span><br></pre></td></tr></table></figure><p>主要就是注意下参数，<code>-p</code>是输出文件的前缀，<code>-d</code>是输出文件的目录名，需要声明这个数据是什么平台测的，以及数据是什么状态。虽然我这里只申请了40个核，但是<strong>canu会自动提交作业直到你能申请的核数上限</strong>……在塔大集群我的权限是200个核，通过scontrol show job 可以查到，我这边一次性提交了136个作业，排队100多个任务，占用192个核…..</p><p><strong>纠错、修整和组装每一个步骤会依次进行以下各个阶段</strong>，需要的内存和核数挺高的，所以推荐在集群中运行。</p><p><img src="https://www.shelven.com/tuchuang/20230223/3.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230223/3.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>如果运行时间很长，<strong>建议到设置的输出文件夹目录下查看canu.out文件</strong>，详细记载了正在执行哪一步以及花了多少时间。如果不确定程序是否卡死，直接通过<code>scontrol show job</code>命令查看状态为RUNNING的作业，进入作业的输出目录，如果文件夹中的内容一直到最近的时间点都有更新，则可以放心地继续运行。</p><p><strong>仅仅这一个步骤花了30个小时。</strong>并且这一步会将<strong>100X的测序数据量降到40X（默认，可以调整，见官方<a href="https://canu.readthedocs.io/en/latest/parameter-reference.html#readsamplingcoverage">readSampleingCoverage</a>参数介绍）</strong>。最后生成文件<code>baima.correctedReads.fasta.gz</code>，我为了方便复制到了前一个文件夹，修改文件权限为0755。</p><h4 id="2-2-2-修整（trim）"><a href="#2-2-2-修整（trim）" class="headerlink" title="2.2.2 修整（trim）"></a>2.2.2 修整（trim）</h4><p>修整是在上一步纠错的基础上，再对reads进行修剪，删去可疑区域。</p><p>这一步经历的步骤与上一步是一样的，虽然上一步纠错已经将数据量降了一大半，对于我的基因组，<strong>这一步依然要跑32小时.</strong></p><p>同样在canu文件夹写入如下内容到trim.slurm：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -n 50</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -t 7200</span></span><br><span class="line"></span><br><span class="line">canu -trim -p baima -d baima_trim genomeSize=230m -corrected -nanopore /public/home/wlxie/canu/baima.correctedReads.fasta.gz</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sbatch trim.slurm</span><br></pre></td></tr></table></figure><p>注意修改参数以及reads所处的状态。</p><p>在canu.out输出文件中，可以找到trim步骤用了什么参数，处理了哪些类型的reads：</p><p><img src="https://www.shelven.com/tuchuang/20230223/4.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230223/4.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>生成的结果文件在baima_trim文件夹中，名称为<code>baima.trimmedReads.fasta.gz</code>，同样修改文件权限，移到前一个文件夹方便操作。</p><h4 id="2-2-3-组装（Assemble）"><a href="#2-2-3-组装（Assemble）" class="headerlink" title="2.2.3 组装（Assemble）"></a>2.2.3 组装（Assemble）</h4><p>经过前两步的数据纠错和修整，这一步才是正式组装基因组。</p><p>在canu文件夹写入如下内容到assemble.slurm：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -n 50</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -t 10800</span></span><br><span class="line"></span><br><span class="line">canu -assemble -p baima -d baima_assemble genomeSize=230m correctedErrorRate=0.144 -trimmed -corrected -nanopore /public/home/wlxie/canu/baima.trimmedReads.fasta.gz</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sbatch assemble.slurm</span><br></pre></td></tr></table></figure><p>在官方的介绍中，correctedErrorRate这个参数可以根据前面纠错和修整的reads质量做修改的，<strong>默认是Pacbio数据0.045，Nanopore数据0.144</strong>，降低这个参数值可以加快组装的效率，但是存在遗漏overlap和组装片段断裂的风险。低于30X测序深度以下的数据，官方建议可以略微提高这个值，对于60X测序深度以上的数据可以略微降低这个值，<strong>每次改变1%左右比较合适</strong>。</p><p>我这里就用默认参数了，组装时间可能会比较长，就将作业的时间调整为7天。</p><p>实际运行时间为30小时，最终组装结果如下：</p><p><img src="https://www.shelven.com/tuchuang/20230223/5.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230223/5.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>这个工具组装出的结果比预期大很多，<strong>前面基因组survey预测的基因组大小为230Mbp，实际通过canu组装出有276Mbp</strong>，且contig数明显比NextDenovo多，导致contig N50指标低。我觉得可能是<code>correctedErrorRate</code>这个值比较高，可以适当调低一些，过于严格的纠错标准可能导致组装的contig比较碎。</p><p>因为前面的NextDenovo组装的效果已经比较理想，因此这一步我也就不再细调参数了。以NextDenovo组装出的基因组继续后面的分析。以目前我的植物基因组来看，用NextDenovo组装三代基因组的效率和质量都比Canu高。</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;前段时间比较忙，现在继续整理基因组测序组装系列的学习笔记。&lt;a href=&quot;https://www.shelven.com/2022/07/03/a.html&quot;&gt;第四篇笔记&lt;/a&gt;写的二代测序基因组组装，主要是演示二代测序数据组装的主流工具SOAPdenovo 2.0是如何应用的。我这里有了二代和三代的测序数据，后续组装还是以&lt;strong&gt;三代数据为主&lt;/strong&gt;，这里就继续记录下几款三代测序数据组装的主流工具和用法。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="基因组三代测序分析" scheme="http://www.shelven.com/categories/%E5%9F%BA%E5%9B%A0%E7%BB%84%E4%B8%89%E4%BB%A3%E6%B5%8B%E5%BA%8F%E5%88%86%E6%9E%90/"/>
    
    
    <category term="NextDenovo" scheme="http://www.shelven.com/tags/NextDenovo/"/>
    
    <category term="Canu" scheme="http://www.shelven.com/tags/Canu/"/>
    
  </entry>
  
  <entry>
    <title>解决github DNS污染的三种方法</title>
    <link href="http://www.shelven.com/2023/02/21/a.html"/>
    <id>http://www.shelven.com/2023/02/21/a.html</id>
    <published>2023-02-21T13:47:13.000Z</published>
    <updated>2023-02-21T13:49:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近因为需要安装各种生信软件，用github比较多，每次登github都要翻墙很是麻烦。索性花了点时间研究了一下，下面分别列举三种情况下的解决github网站登录的问题。</p><span id="more"></span><p>知其然知其所以然，首先我们需要明白为什么github在国内经常无法登录。我们在浏览器地址栏输入网址以后，域名服务器会对输入的域名进行解析（DNS解析），解析成为计算机之间可以识别的ip地址。然而因为一些众所周知的因素，很多国外的网站在国内是无法直接访问的，其中一个限制方法就是<strong>DNS污染</strong>，将域名服务器中缓存的域名指向不正确的ip地址。<strong>这种限制手段就和你公司电脑会限制你浏览一些网站是一样的。</strong></p><p>因此要浏览这些被DNS污染的网站，我们需要跳过受污染的局域域名服务器，常用的方法就是<strong>代理服务器和VPN</strong>（VPN就是一个典型的正向代理），通过更远的服务器转发我们的http请求，在经过未污染的域名服务器解析之后，返回我们想要的网页内容。当然，如果仅仅只是用翻墙的方法的话，本篇博客这里可以结束了，下面通过三种情况分别讲一下如何通过修改host等其他方法访问github。</p><h2 id="1-Windows系统修改host"><a href="#1-Windows系统修改host" class="headerlink" title="1. Windows系统修改host"></a>1. Windows系统修改host</h2><div class="story post-story"><p><strong>首先注意一点，如果你正在用翻墙软件或者VPN等，需要先将所有代理都关闭（防止全局代理导致设置的host失效）。</strong></p><p>host文件是一个没有扩展名的系统文件，可以用notepad++打开编辑，其本质就是就是将访问的域名和ip地址建立关联。当浏览器中输入网址时，系统会首先从host文件中找到域名对应的ip地址，如果没有找到才会发送给域名解析器。所以我们只需要找到github相关域名对应的正确的ip地址，即可正常访问github（其他受DNS污染的网址同理）。</p><p>打开网址 <a href="https://www.ipaddress.com/">https://www.ipaddress.com/</a></p><p>主要查找以下github相关域名的ip地址，有多少个记录多少个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">github.com# 主站</span><br><span class="line">nodeload.github.com</span><br><span class="line">api.github.com# API</span><br><span class="line">codeload.github.com</span><br><span class="line">github.global.ssl.Fastly.net# git clone速度相关</span><br><span class="line">assets-cdn.github.com# 静态资源相关</span><br></pre></td></tr></table></figure><p><img src="https://www.shelven.com/tuchuang/20230221/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230221/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>windows系统中host文件位置</p><p><code>C:\WINDOWS\System32\drivers\etc\hosts</code></p><p>notepad++打开host文件，最后加入如下查到的ip地址，保存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># domain: github.com</span><br><span class="line"># 更新时间 2023年2月21日</span><br><span class="line"></span><br><span class="line">140.82.113.3 github.com</span><br><span class="line">140.82.114.10 nodeload.github.com</span><br><span class="line">140.82.112.6 api.github.com</span><br><span class="line">140.82.114.10 codeload.github.com</span><br><span class="line"></span><br><span class="line">151.101.1.194 github.global.ssl.Fastly.net</span><br><span class="line">151.101.65.194 github.global.ssl.Fastly.net</span><br><span class="line">151.101.129.194 github.global.ssl.Fastly.net</span><br><span class="line">151.101.193.194 github.global.ssl.Fastly.net</span><br><span class="line"></span><br><span class="line">185.199.108.153 assets-cdn.github.com</span><br><span class="line">185.199.110.153 assets-cdn.github.com</span><br><span class="line">185.199.111.153 assets-cdn.github.com</span><br></pre></td></tr></table></figure><p>最后一步打开cmd命令行，刷新缓存就可以正常登录github了</p><p><code>ipconfig /flushdns</code></p><p><img src="https://www.shelven.com/tuchuang/20230221/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230221/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div><h2 id="2-Linux系统修改host"><a href="#2-Linux系统修改host" class="headerlink" title="2. Linux系统修改host"></a>2. Linux系统修改host</h2><div class="story post-story"><p><strong>方法步骤同上，需要注意linux系统修改host需要root权限!</strong></p><p>linux系统host文件路径</p><p><code>/etc/hosts</code></p></div><h2 id="3-无root权限的linux系统访问github"><a href="#3-无root权限的linux系统访问github" class="headerlink" title="3. 无root权限的linux系统访问github"></a>3. 无root权限的linux系统访问github</h2><div class="story post-story"><p>有些时候我们会在集群中安装软件，这个时候是没有root权限的，无法通过修改host的方法直接访问，因此也无法用git clone的方法克隆仓库（<strong>会报错，错误代码443</strong>）。</p><p><img src="https://www.shelven.com/tuchuang/20230221/3.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230221/3.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>今天碰到这个问题，找贺师兄聊了聊才发现可以找镜像资源曲线救国……突然打开了新世界的大门hhhh</p><p>真的解决了困扰我很久的疑惑，按照往常我只能翻墙下载源代码，再解压后传回服务器，一来一回校园网的速度要传很久很久……</p><p>具体做法是先下载<strong>油猴（Tampermonkey）插件</strong>，这是个非常有名的脚本管理器，下载安装方式就不说了，网上一大把，自己搜下github官方也非常简单。<a href="https://github.com/Tampermonkey/tampermonkey">Tampermonkey&#x2F;tampermonkey</a></p><p>然后是安装github增强加速插件，插件地址 <a href="https://greasyfork.org/zh-CN/scripts/412245-github-%E5%A2%9E%E5%BC%BA-%E9%AB%98%E9%80%9F%E4%B8%8B%E8%BD%BD">https://greasyfork.org/zh-CN/scripts/412245-github-%E5%A2%9E%E5%BC%BA-%E9%AB%98%E9%80%9F%E4%B8%8B%E8%BD%BD</a></p><p>我因为安装过了，这里就只演示一下：</p><p><img src="https://www.shelven.com/tuchuang/20230221/4.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230221/4.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>安装之后再回到原来github页面，点击code按钮，就可以看到原来只有一个git clone地址，现在有好几个地址给出来了，在集群里随便git clone选择其他地址，就可以在成功下载啦。</p><p><img src="https://www.shelven.com/tuchuang/20230221/5.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230221/5.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>这个javascript脚本感兴趣的话可以在油猴中看看，本质上也是个CDN加速和代理，只不过用的都是公益资源，速度也相当不错了。</p></div><h2 id="4-写在最后"><a href="#4-写在最后" class="headerlink" title="4. 写在最后"></a>4. 写在最后</h2><div class="story post-story"><p>前面两个方法改host并不是一劳永逸的，<strong>隔一段时间github的ip地址就会更新（不定，可能几天，可能几周）。</strong>这种纯手动更新的方法仍然是不够智能不够优雅的，<strong>有能力的话以后写一个自动更新的脚本</strong>（间隔一段时间自动查找相关github域名的ip地址，自动更新到host文件中）。</p><p>目前为止，还是代理最为省心。</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近因为需要安装各种生信软件，用github比较多，每次登github都要翻墙很是麻烦。索性花了点时间研究了一下，下面分别列举三种情况下的解决github网站登录的问题。&lt;/p&gt;</summary>
    
    
    
    <category term="网络相关" scheme="http://www.shelven.com/categories/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="github" scheme="http://www.shelven.com/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>校园网代理服务器的搭建</title>
    <link href="http://www.shelven.com/2023/02/09/a.html"/>
    <id>http://www.shelven.com/2023/02/09/a.html</id>
    <published>2023-02-09T08:55:45.000Z</published>
    <updated>2023-02-09T08:58:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>以前的一篇博客讲过如何搭建反向代理服务器，从而实现在校外登录校内集群，<a href="https://www.shelven.com/2022/07/13/a.html">详情点击这里</a>。本篇博客主要记录下如果想要在校外登录学校教务平台、登录学校购买的数字资源库应该如何实现。</p><span id="more"></span><h2 id="1-实现思路"><a href="#1-实现思路" class="headerlink" title="1. 实现思路"></a>1. 实现思路</h2><div class="story post-story"><p>首先要更正一下前一篇博客的错误之处，<strong>学校集群是有公网ip的，只是限制了ip访问</strong>。</p><p>使用的工具仍然是frp，需要的设备是一台在校内24h不断电的服务器（本篇博客中的校内集群），以及一台有公网ip的校外服务器（本篇博客中是我的轻量云服务器）。</p><p>上篇内网穿透博客记录的是典型的<strong>反向代理过程</strong>，将校内集群ssh登录的端口映射到校外服务器的其他端口，通过访问该端口登录校内集群，整个代理过程客户端无法得知服务端的真实ip和端口，可以做到隐藏服务端真实信息、确保服务端安全。</p><p>而我们这里想要登录校园内的其他网站、使用校园网ip登录知网万方等数据库的话，就需要<strong>用校内集群转发我们的http请求，将请求返回的结果通过校外服务器中转后返回给我们</strong>，按照我的理解，这是一个正向代理+反向代理结合的过程。</p><p>反向代理：隐藏了服务端，我并不知道我访问的实际是校内集群（输入的是校外服务器的ip地址和端口）。</p><p>正向代理：隐藏了客户端，集群将http请求转发到校内网站和学校买的数据库网站（后者并不知道发出请求的实际是校外服务器）。</p><p><strong>校内集群在整个过程中信息完全被隐藏，校外服务器起到中转的作用，最后将http请求返回的结果传递给我们</strong>。</p></div><h2 id="2-frp配置"><a href="#2-frp配置" class="headerlink" title="2. frp配置"></a>2. frp配置</h2><div class="story post-story"><h3 id="2-1-service端配置"><a href="#2-1-service端配置" class="headerlink" title="2.1 service端配置"></a>2.1 service端配置</h3><p>frps安装在校外服务器上，frps.ini配置文件完全不用修改，这里就顺便展示一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_port = 7000# frp监听的端口，默认7000，可改</span><br><span class="line">bind_udp_port = 7400# UDP通讯端口，可不设置，用于点对点穿透</span><br><span class="line">token = xxxxxxxx# 安全考虑需要设置口令，client端需要用到</span><br><span class="line"></span><br><span class="line">dashboard_port = 7500# frp管理端口，可改</span><br><span class="line">dashboard_user = xxxx# 管理端口认证的用户名，用于身份识别，自己设置</span><br><span class="line">dashboard_pwd = xxxx# 管理端口认证的密码，用于身份识别，自己设置</span><br><span class="line">enable_prometheus = true</span><br><span class="line"></span><br><span class="line">subdomain_host = xxx.xxx.xxx# 设置子域名，主要方便登录管理界面。不用ip地址，用域名+端口的方式直接访问</span><br><span class="line"></span><br><span class="line">log_file = /usr/local/frp/frps.log# frp日志配置，这里是记录3天的日志信息</span><br><span class="line">log_level = info</span><br><span class="line">log_max_days = 3</span><br></pre></td></tr></table></figure><h3 id="2-2-client端配置"><a href="#2-2-client端配置" class="headerlink" title="2.2 client端配置"></a>2.2 client端配置</h3><p>frpc安装在校内集群，frpc.ini配置文件修改如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = xxx.xxx.xxx.xxx# 填写你的service端服务器公网ip，这里我写我的云服务器ip</span><br><span class="line">server_port = 7000# 前面设置的frp监听端口，需要保持一致</span><br><span class="line">token = xxxxxxxxx # 前面设置的口令</span><br><span class="line"></span><br><span class="line">[http_proxy]# 这里只演示http代理，有ssh需求的自行加入，其他参考frpc_full.ini</span><br><span class="line">type = tcp</span><br><span class="line">remote_port = xxxx# 映射的service端服务器的端口，自己定义</span><br><span class="line">plugin = http_proxy# http代理插件（frpc自带）</span><br></pre></td></tr></table></figure><h3 id="2-3-开放端口，开启frp服务"><a href="#2-3-开放端口，开启frp服务" class="headerlink" title="2.3 开放端口，开启frp服务"></a>2.3 开放端口，开启frp服务</h3><p>service端（也就是校外服务器）开放上一步client端设置的服务器端口，<strong>重载防火墙</strong>。</p><p>分别在service端和client端后台不挂起运行frps和frpc（对应文件夹中运行）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nohup ./frps -c frps.ini &amp;</span><br><span class="line">nohup ./frpc -c frpc.ini &amp;</span><br></pre></td></tr></table></figure><p>service端可以查看运行日志frps.log文件，端口监听成功即可；client端可以查看nohup文件的运行结果（最好定时清一下，否则这个文件会很大）。</p><p>如果想要停止frp服务，查看任意service端或者client端的frp程序进程，结束即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | grep frp# 查看任务进程号</span><br><span class="line">kill -9 进程号# 结束任务进程</span><br></pre></td></tr></table></figure></div><h2 id="3-代理实现"><a href="#3-代理实现" class="headerlink" title="3. 代理实现"></a>3. 代理实现</h2><div class="story post-story"><p>按照上面步骤搭建好代理服务器，我们只需要在电脑上设置代理地址和端口，就可以在电脑上用外网访问校园内网和数据库网站了。</p><p><img src="https://www.shelven.com/tuchuang/20230209/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230209/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>上面的图片我就不放真实信息了，根据图片意思设置即可，一般来说教程到这里就可以结束了，<strong>但是仅仅如此还不够优雅</strong>。</p><p>如果不对地址进行限制，那么所有http访问都将通过代理进行，即<strong>全局代理</strong>，一般情况下我们是不希望如此的。举个例子，如果访问的是localhost，我们一般是用直连（Direct）；访问限制ip的特定的网站走代理服务器（Proxy）；访问不限制ip的网站仍然用直连，因为直连速度最快，只受你电脑带宽限制。</p><p><strong>如果访问所有网站都用代理的话，比如我的小破服务器就1M带宽，速度就很感人了……</strong></p><p>简单讲一讲三种方法优雅地实现校园网代理</p><h3 id="3-1-使用设置脚本"><a href="#3-1-使用设置脚本" class="headerlink" title="3.1 使用设置脚本"></a>3.1 使用设置脚本</h3><p>没错就是手动设置代理上面那个选项，这个脚本是以**.PAC<strong>为扩展名的</strong>JavaScript脚本**，决定http请求是通过直连目标还是通过代理的方式连接。</p><p>pac文件中使用的JavaScript 函数可以在官方查到用法，这里做个示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">FindProxyForURL</span>(<span class="params">url, host</span>) &#123;</span><br><span class="line">    <span class="comment">//设置代理池</span></span><br><span class="line"><span class="keyword">var</span> proxy1 = <span class="string">&quot;PROXY xxx.xxx.xxx.xxx:xxxx&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> proxy2 = <span class="string">&quot;PROXY xxx.xxx.xxx.xxx:xxxx&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//本地地址直连</span></span><br><span class="line"><span class="keyword">if</span> (<span class="title function_">isPlainHostName</span>(host)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;DIRECT&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 代理1</span></span><br><span class="line"><span class="keyword">if</span> (<span class="title function_">shExpMatch</span>(url, <span class="string">&quot;*.cnki.com/*&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> proxy1;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 代理2</span></span><br><span class="line"><span class="keyword">if</span> (<span class="title function_">shExpMatch</span>(url, <span class="string">&quot;*.wanfangdata.com.cn/*&quot;</span>)) &#123;</span><br><span class="line">   <span class="keyword">return</span> proxy2;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;DIRECT&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的文件保存为.pac格式文件，代理池部分填写前面做的代理服务器ip和端口（当然我只有一个代理服务器，根据需要自己改），需要代理的网址这里可以用<strong>shExpMatch</strong>函数进行<strong>正则匹配</strong>，完成后再设置自动设置代理部分。打开自动检测设置和使用设置脚本，将.pac文件的地址（可以是本地地址或者放在你自己的服务器上，能访问到就行）贴到脚本地址栏。</p><p><img src="https://www.shelven.com/tuchuang/20230209/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230209/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><strong>接下来就可以愉快地访问学校购买的数字资源啦<del>并且上其他网站因为是直连网速也不会变慢</del></strong></p><p><img src="https://www.shelven.com/tuchuang/20230209/3.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230209/3.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="3-2-使用其他代理软件"><a href="#3-2-使用其他代理软件" class="headerlink" title="3.2 使用其他代理软件"></a>3.2 使用其他代理软件</h3><p>代理软件种类繁多，相比直接设置脚本，代理软件往往还提供更多更直观的方式控制http代理方式，这里就简单介绍个软件<strong>Proxifier</strong></p><p>设置方法与手动设置大同小异<del>（手动设置的代理规则比较反人类）</del>，同样是设置代理服务器ip，端口，可以设置不同的协议，还可以启用验证保证安全。</p><p><img src="https://www.shelven.com/tuchuang/20230209/4.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230209/4.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>设置代理规则</p><p><img src="https://www.shelven.com/tuchuang/20230209/5.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230209/5.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>代理规则就不一一细说了，这个软件就是比较直观，而且还可以记录代理产生的流量等等。</p><h3 id="3-3-做个切换全局代理工具"><a href="#3-3-做个切换全局代理工具" class="headerlink" title="3.3 做个切换全局代理工具"></a>3.3 做个切换全局代理工具</h3><p>如果是自己用的话，使用代理脚本是最简单最优雅又不费事的方法。</p><p>如果要给同一个实验室其他人分享，又怕别人电脑不安全（直接分享脚本会导致源码泄露，万一别人电脑被黑了自己服务器的信息就被暴露了），就可以做一个代理工具，别人用得着的时候开启，用不着的时候就关闭（<strong>全局代理的重要性，就算忘记关闭代理，看到别的网页速度变慢了，也就会想起来去关闭代理了</strong>），可以一定程度上保护自己服务器的安全，又简化别人设置代理的步骤，一举两得哈哈~</p><p><strong>实现方式就是做一个批处理，然后将bat转化为exe即可</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">for /f &quot;tokens=1,2,* &quot; %%i in (&#x27;REG QUERY &quot;HKCU\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot; /v ProxyEnable ^| find /i &quot;ProxyEnable&quot;&#x27;) do (set /A ProxyEnableValue=%%k)</span><br><span class="line"></span><br><span class="line">if %ProxyEnableValue% equ 0 (</span><br><span class="line">    echo 正在开启知网代理，请稍候...</span><br><span class="line">    ping -n 2 127.0.0.1&gt;nul</span><br><span class="line">    echo=</span><br><span class="line">    echo 获取注册表中代理启用状态......</span><br><span class="line">    reg add &quot;HKCU\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot; /v ProxyEnable /t REG_DWORD /d 1 /f</span><br><span class="line">    ping -n 2 127.0.0.1&gt;nul</span><br><span class="line">    echo=</span><br><span class="line">    echo 设置代理服务器......</span><br><span class="line">    reg add &quot;HKCU\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot; /v ProxyServer /d &quot;xxx.xxx.xxx.xxx:xxxx&quot; /f</span><br><span class="line">    ping -n 2 127.0.0.1&gt;nul</span><br><span class="line">    echo=</span><br><span class="line">    echo 代理已开启，请阅读弹窗内容并按确认键关闭本窗口...</span><br><span class="line">    echo=</span><br><span class="line">    echo 知网一键代理工具 Version 1.0</span><br><span class="line">    echo 版权所有 塔里木大学研发中心405. 保留所有权利。</span><br><span class="line">    echo 该工具由405实验室内部开发，仅供本实验室人员使用，切勿外传。</span><br><span class="line">    echo msgbox&quot;代理开启期间网速会变慢，使用完毕后请再次点击该工具结束代理！&quot;,0,&quot;提示&quot;&gt; %tmp%\\tmp.vbs</span><br><span class="line">    cscript /nologo %tmp%\\tmp.vbs</span><br><span class="line">    del %tmp%\\tmp.vbs</span><br><span class="line">) else if %ProxyEnableValue% equ 1 (</span><br><span class="line">    echo 正在关闭知网代理，请稍候...</span><br><span class="line">    ping -n 2 127.0.0.1&gt;nul</span><br><span class="line">    echo=</span><br><span class="line">    echo 获取注册表中代理启用状态......</span><br><span class="line">    reg add &quot;HKCU\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot; /v ProxyEnable /t REG_DWORD /d 0 /f </span><br><span class="line">    ping -n 2 127.0.0.1&gt;nul</span><br><span class="line">    echo=</span><br><span class="line">    echo 清除代理服务器设置......</span><br><span class="line">    reg add &quot;HKCU\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot; /v ProxyServer /d &quot;&quot; /f </span><br><span class="line">    ping -n 2 127.0.0.1&gt;nul</span><br><span class="line">    echo=</span><br><span class="line">    echo 代理已关闭，请按确认键退出本窗口...</span><br><span class="line">    echo=</span><br><span class="line">    echo 知网一键代理工具 Version 1.0</span><br><span class="line">    echo 版权所有 塔里木大学研发中心405. 保留所有权利。</span><br><span class="line">    echo 该工具由405实验室内部开发，仅供本实验室人员使用，切勿外传。</span><br><span class="line">    echo msgbox&quot;再见。&quot;,0,&quot;提示&quot;&gt; %tmp%\\tmp.vbs</span><br><span class="line">    cscript /nologo %tmp%\\tmp.vbs</span><br><span class="line">    del %tmp%\\tmp.vbs</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>上面的内容文件保存为.bat后缀文件（<strong>有中文的话，保存时编码格式要改为ANSI</strong>），只需修改xxx.xxx.xxx.xxx:xxxx部分为你前面设置的代理服务器ip和端口即可。</p><p>原理就是获取注册表中代理服务的开启状态，转化为另一种状态， <code>ping -n 2 127.0.0.1</code>这个只是为了使用者有<strong>参与感</strong>……延迟两秒进行下一步处理hhhhhh</p><p>最后网上找个图，转成icon格式作为图标，然后将bat批处理格式文件转化成exe可执行程序文件即可，我这里用的Bat_To_Exe_Converter这个软件，转成exe源码不容易被泄露，而且怎么说呢看上去给人感觉也稍微正式一点<del>（bushi）</del>。</p><p><img src="https://www.shelven.com/tuchuang/20230209/6.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230209/6.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>大概就是这样，<strong>每双击一次应用程序，切换全局代理的状态为开或者关</strong></p></div><h2 id="4-注意"><a href="#4-注意" class="headerlink" title="4. 注意"></a>4. 注意</h2><div class="story post-story"><p><strong>浏览器是会缓存ip信息的，无论使用何种方式开启代理，最好都先关闭浏览器之后重新打开。</strong></p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;以前的一篇博客讲过如何搭建反向代理服务器，从而实现在校外登录校内集群，&lt;a href=&quot;https://www.shelven.com/2022/07/13/a.html&quot;&gt;详情点击这里&lt;/a&gt;。本篇博客主要记录下如果想要在校外登录学校教务平台、登录学校购买的数字资源库应该如何实现。&lt;/p&gt;</summary>
    
    
    
    <category term="网络相关" scheme="http://www.shelven.com/categories/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="内网穿透" scheme="http://www.shelven.com/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    
    <category term="代理服务器" scheme="http://www.shelven.com/tags/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>基于requests和Xpath改进微信公众号爬虫</title>
    <link href="http://www.shelven.com/2022/12/18/a.html"/>
    <id>http://www.shelven.com/2022/12/18/a.html</id>
    <published>2022-12-18T15:00:18.000Z</published>
    <updated>2022-12-18T15:03:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>前面一篇博客讲了requests、Xpath和selenium的用法，最后用selenium模拟浏览器对搜狗微信文章做了自动化爬取。从搜狗微信网页爬取的公众号文章其实是不全的，不能保证公众号的所有文章都被搜狗收录，且selenium爬取速度相对较慢（但是对动态页面爬取很有用），因此可以选择另一种方式——直接从微信公众号后台进行爬取。</p><span id="more"></span><p>这两天改了下代码，就讲一讲从微信公众号后台爬文章的思路。</p><h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h2><div class="story post-story"><p>首先是申请微信公众号，自从2018年微信公众号加强用户管理以后，<strong>一个身份证只可以注册一个订阅号</strong>了，除非你有营业执照，以公司为主体注册名额还能加两个。比较建议多弄几个微信公众号，只要绑定自己是运营者就行，可以让朋友帮忙注册一下，<strong>从微信公众号后台直接爬是有可能被ban接口的</strong>，被反爬机制检测到第一次ban一小时，第二次可能ban一天，看情况而定。</p><p>我这里是准备了三个微信公众号，保证爬取过程不中断~</p><p>首先进入微信公众号后台，点击<strong>图文消息</strong>，在跳转的编辑页面上方点击<strong>超链接</strong>。</p><p><img src="https://www.shelven.com/tuchuang/20221218/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221218/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><img src="https://www.shelven.com/tuchuang/20221218/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221218/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>在这个页面按F12进入开发者工具，链接内容选择其他公众号，输入你想要爬的公众号名字，点击右边放大镜搜索后对返回数据抓包。</p><p>这里第一个返回的数据包是显示公众号搜索内容的，一个重要的参数<strong>fakeid</strong>就是公众号名字的内部编号。然后<strong>返回前面的标头，获取cookie</strong>，这是我们登录微信公众号的凭证，后面爬取网页必须带上cookie内容。</p><p><img src="https://www.shelven.com/tuchuang/20221218/3.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221218/3.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>点击我们要找的公众号（你名字输对的话肯定是第一个），又返回一个数据包，在负载里我们可以看到begin和count两个重要的参数。在试验过后可以发现，begin表示从哪一页开始，count表示一页显示多少天的推送，这里count值在我多次试验之后，发现最大值为5，<strong>传入超过5的数都会变成默认值5</strong>（<strong>也就是说不能通过一页获取所有文章的url</strong>）！</p><p><img src="https://www.shelven.com/tuchuang/20221218/4.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221218/4.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>而在响应体中，我们可以看到所有返回文章的title、link、update_time、digest等重要的信息都在app_msg_list中，上面的app_msg_count值我测试后发现是记录一共发布文章<strong>天数</strong>的。</p><p><img src="https://www.shelven.com/tuchuang/20221218/555.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221218/555.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>在这个公众号例子中，digest本来应该是摘要的，但在这里只是一段甚至半段内容，无法提取有用的信息，所以我直接忽略了这部分数据；而且一般公众号会把subtitle分离出来，这个公众号没有，因此需要写一段代码分离标题中的分类标题，以标题中的竖线来分割“副标题（分类）|标题”。</p><p>接下来可以随便点一个link，F12看看文章的html结构，记录文章内容的xpath地址（不记得xpath地址怎么找的话，<a href="https://www.shelven.com/2022/12/14/a.html">看前一篇xpath用法</a>）。这里文章的图片我就没有收集了，我只收集了文字部分内容。</p><p>每个公众号排版不一样，根据内容再写一个正则匹配一下不需要的内容，也就是对内容“去噪”。不详细讲，因公众号而异，我这里要去除的噪声是公众号底部的进群邀请内容。</p></div><h2 id="2-代码部分"><a href="#2-代码部分" class="headerlink" title="2. 代码部分"></a>2. 代码部分</h2><div class="story post-story"><p>截至目前为止（2022年12月28日），代码运行正常：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> requests, re</span><br><span class="line"><span class="keyword">from</span> requests.packages <span class="keyword">import</span> urllib3</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">import</span> xlwt</span><br><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> DataFrame</span><br><span class="line"></span><br><span class="line">key_word = <span class="string">&quot;植物生物技术Pbj&quot;</span></span><br><span class="line">xpath_string = <span class="string">&#x27;//*[@id=&quot;js_content&quot;]//text()&#x27;</span>    <span class="comment"># 文章内容的xpath路径</span></span><br><span class="line">last_date = <span class="number">2018</span>  <span class="comment"># 想要获得哪一年之后的文章</span></span><br><span class="line"><span class="comment"># 创建工作表格，存储爬取的临时数据</span></span><br><span class="line">book = xlwt.Workbook(encoding=<span class="string">&#x27;utf-8&#x27;</span>,style_compression=<span class="number">0</span>)</span><br><span class="line">sheet = book.add_sheet(key_word,cell_overwrite_ok=<span class="literal">True</span>)</span><br><span class="line">col = (<span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;author&#x27;</span>, <span class="string">&#x27;content&#x27;</span>,<span class="string">&#x27;category&#x27;</span>,<span class="string">&quot;link&quot;</span>,<span class="string">&quot;date&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">6</span>):</span><br><span class="line">    sheet.write(<span class="number">0</span>,i,col[i]) <span class="comment"># 第一行写入属性名称,write对应参数：行、列、值</span></span><br><span class="line"></span><br><span class="line">urllib3.disable_warnings()  <span class="comment"># 忽略警告</span></span><br><span class="line"><span class="comment"># 最终爬取数据存放列表</span></span><br><span class="line">title_list = []</span><br><span class="line">link_list = []</span><br><span class="line">cat_list = []</span><br><span class="line">date_list = []</span><br><span class="line">content_list = []</span><br><span class="line">author_list = []</span><br><span class="line"></span><br><span class="line">s = requests.Session()  <span class="comment"># 维持会话</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对微信公众号查找的headers</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:72.0) Gecko/20100101 Firefox/72.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Host&quot;</span>: <span class="string">&quot;mp.weixin.qq.com&quot;</span>,</span><br><span class="line">    <span class="string">&#x27;Referer&#x27;</span>: <span class="string">&#x27;https://mp.weixin.qq.com/&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">cookie_str = <span class="string">&quot;&quot;</span></span><br><span class="line">cookies = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载cookies，将字符串格式的cookies转化为字典形式</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_cookies</span>():</span><br><span class="line">    <span class="keyword">global</span> cookie_str, cookies</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> cookie_str.split(<span class="string">&#x27;;&#x27;</span>):</span><br><span class="line">        sep_index = item.find(<span class="string">&#x27;=&#x27;</span>)</span><br><span class="line">        cookies[item[:sep_index]] = item[sep_index + <span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 去噪函数，只适合该公众号</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quzao</span>(<span class="params">content</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(content) == <span class="built_in">str</span>:</span><br><span class="line">        i = re.sub(<span class="string">&#x27;植物生物技术Pbj交流群&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="built_in">str</span>(content))</span><br><span class="line">        i = re.sub(<span class="string">&#x27;为了能更有效地帮助广大的科研工作者获取相关信息.*&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="built_in">str</span>(i))</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 爬虫主函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spider</span>():</span><br><span class="line">    <span class="comment"># 加载cookies</span></span><br><span class="line">    load_cookies()</span><br><span class="line">    <span class="comment"># 访问官网主页</span></span><br><span class="line">    url = <span class="string">&#x27;https://mp.weixin.qq.com&#x27;</span></span><br><span class="line">    res = s.get(url = url, headers = headers, cookies = cookies, verify = <span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">if</span> res.status_code == <span class="number">200</span>:</span><br><span class="line">        <span class="comment"># 由于加载了cookies，相当于已经登陆了，系统作了重定义，response的url中含有我们需要的token</span></span><br><span class="line">        <span class="built_in">print</span>(res.url)</span><br><span class="line">        <span class="comment"># 获得token</span></span><br><span class="line">        token = re.findall(<span class="string">r&#x27;.*?token=(\d+)&#x27;</span>, res.url)</span><br><span class="line">        <span class="keyword">if</span> token:</span><br><span class="line">            token = token[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 没有token的话，说明cookies过时了，没有登陆成功，退出程序</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;登陆失败&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;token&#x27;</span>, token)</span><br><span class="line">        <span class="comment"># 检索公众号</span></span><br><span class="line">        url = <span class="string">&#x27;https://mp.weixin.qq.com/cgi-bin/searchbiz&#x27;</span></span><br><span class="line">        data = &#123;</span><br><span class="line">            <span class="string">&quot;action&quot;</span>: <span class="string">&quot;search_biz&quot;</span>,</span><br><span class="line">            <span class="string">&quot;begin&quot;</span>: <span class="string">&quot;0&quot;</span>,</span><br><span class="line">            <span class="string">&quot;count&quot;</span>: <span class="string">&quot;5&quot;</span>,</span><br><span class="line">            <span class="string">&quot;query&quot;</span>: key_word,</span><br><span class="line">            <span class="string">&quot;token&quot;</span>: token,</span><br><span class="line">            <span class="string">&quot;lang&quot;</span>: <span class="string">&quot;zh_CN&quot;</span>,</span><br><span class="line">            <span class="string">&quot;f&quot;</span>: <span class="string">&quot;json&quot;</span>,</span><br><span class="line">            <span class="string">&quot;ajax&quot;</span>: <span class="string">&quot;1&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># 继续使用会话发起请求</span></span><br><span class="line">        res = s.get(url = url, params = data, cookies = cookies, headers = headers, verify = <span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">if</span> res.status_code == <span class="number">200</span>:</span><br><span class="line">            <span class="comment"># 搜索结果的第一个提取它的fakeid</span></span><br><span class="line">            fakeid = res.json()[<span class="string">&#x27;list&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;fakeid&#x27;</span>]</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;微信公众号fakeid&#x27;</span>, fakeid)</span><br><span class="line">            page_size = <span class="number">5</span>  <span class="comment"># 默认是5天文章1页，这个参数似乎最大值只有5</span></span><br><span class="line">            page_count = <span class="number">278</span>  <span class="comment"># 公众号文章总页数（自己手动调整，爬取到第几页）</span></span><br><span class="line">            cur_page = <span class="number">1</span>    <span class="comment"># 爬取页数（从第几页开始爬取）</span></span><br><span class="line">            l = <span class="number">1</span> <span class="comment"># excel计数用</span></span><br><span class="line">            <span class="keyword">while</span> cur_page &lt;= page_count:</span><br><span class="line">                url = <span class="string">&#x27;https://mp.weixin.qq.com/cgi-bin/appmsg&#x27;</span></span><br><span class="line">                data = &#123;</span><br><span class="line">                    <span class="string">&quot;action&quot;</span>: <span class="string">&quot;list_ex&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;begin&quot;</span>: <span class="built_in">str</span>(page_size * (cur_page - <span class="number">1</span>)),</span><br><span class="line">                    <span class="string">&quot;count&quot;</span>: <span class="built_in">str</span>(page_size),</span><br><span class="line">                    <span class="string">&quot;fakeid&quot;</span>: fakeid,</span><br><span class="line">                    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;9&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;query&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;token&quot;</span>: token,</span><br><span class="line">                    <span class="string">&quot;lang&quot;</span>: <span class="string">&quot;zh_CN&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;f&quot;</span>: <span class="string">&quot;json&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;ajax&quot;</span>: <span class="string">&quot;1&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">                time.sleep(random.randint(<span class="number">1</span>, <span class="number">5</span>))</span><br><span class="line">                <span class="comment">#继续会话发起请求</span></span><br><span class="line">                res = s.get(url = url, params = data, cookies = cookies, headers = headers, verify  =<span class="literal">False</span>)</span><br><span class="line">                <span class="keyword">if</span> res.status_code == <span class="number">200</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&#x27;开始爬取页数：&#x27;</span>, cur_page)</span><br><span class="line">                    <span class="comment"># 文章列表位于app_msg_list字段中</span></span><br><span class="line">                    app_msg_list = res.json()[<span class="string">&#x27;app_msg_list&#x27;</span>]</span><br><span class="line">                    <span class="keyword">for</span> item <span class="keyword">in</span> app_msg_list:</span><br><span class="line">                        <span class="comment"># 通过更新时间戳获得文章的发布日期</span></span><br><span class="line">                        item[<span class="string">&#x27;post_date&#x27;</span>] = time.strftime(<span class="string">&quot;%Y-%m-%d&quot;</span>, time.localtime(<span class="built_in">int</span>(item[<span class="string">&#x27;update_time&#x27;</span>])))</span><br><span class="line">                        <span class="keyword">if</span> <span class="built_in">int</span>(item[<span class="string">&#x27;post_date&#x27;</span>].split(<span class="string">&#x27;-&#x27;</span>)[<span class="number">0</span>])&lt;last_date:</span><br><span class="line">                            <span class="keyword">continue</span></span><br><span class="line">                        <span class="comment"># 以下标题分离只适合该公众号</span></span><br><span class="line">                        <span class="keyword">if</span> item[<span class="string">&#x27;title&#x27;</span>].find(<span class="string">&quot;|&quot;</span>) != -<span class="number">1</span>:   <span class="comment"># 有竖线分离副标题</span></span><br><span class="line">                            title = item[<span class="string">&#x27;title&#x27;</span>].split(<span class="string">&quot;|&quot;</span>)[<span class="number">1</span>].strip()</span><br><span class="line">                            cat = item[<span class="string">&#x27;title&#x27;</span>].split(<span class="string">&quot;|&quot;</span>)[<span class="number">0</span>].strip()</span><br><span class="line">                        <span class="keyword">elif</span> item[<span class="string">&#x27;title&#x27;</span>].find(<span class="string">&quot;｜&quot;</span>) != -<span class="number">1</span>:</span><br><span class="line">                            title = item[<span class="string">&#x27;title&#x27;</span>].split(<span class="string">&quot;｜&quot;</span>)[<span class="number">1</span>].strip()    <span class="comment"># 分离中文竖线</span></span><br><span class="line">                            cat = item[<span class="string">&#x27;title&#x27;</span>].split(<span class="string">&quot;｜&quot;</span>)[<span class="number">0</span>].strip()</span><br><span class="line">                        <span class="keyword">elif</span> item[<span class="string">&#x27;title&#x27;</span>].find(<span class="string">&quot;│&quot;</span>) != -<span class="number">1</span>:</span><br><span class="line">                            title = item[<span class="string">&#x27;title&#x27;</span>].split(<span class="string">&quot;│&quot;</span>)[<span class="number">1</span>].strip()     <span class="comment"># 分离另一种很神奇的竖线</span></span><br><span class="line">                            cat = item[<span class="string">&#x27;title&#x27;</span>].split(<span class="string">&quot;│&quot;</span>)[<span class="number">0</span>].strip()</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            title = (item[<span class="string">&#x27;title&#x27;</span>])</span><br><span class="line">                            cat = <span class="string">&#x27;N/A&#x27;</span></span><br><span class="line">                        title_list.append(title)</span><br><span class="line">                        date_list.append(item[<span class="string">&#x27;post_date&#x27;</span>])</span><br><span class="line">                        link_list.append(item[<span class="string">&#x27;link&#x27;</span>])</span><br><span class="line">                        author_list.append(key_word)</span><br><span class="line">                        cat_list.append(cat)</span><br><span class="line">                        response = requests.get(url = item[<span class="string">&#x27;link&#x27;</span>], headers = headers)</span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">&quot;正在解析网页&quot;</span> + <span class="built_in">str</span>(item[<span class="string">&#x27;link&#x27;</span>]) + <span class="string">&#x27;......&#x27;</span>)</span><br><span class="line">                        time.sleep(random.randint(<span class="number">1</span>, <span class="number">5</span>))  <span class="comment"># 爬一个，休息1-5秒</span></span><br><span class="line">                        tree_content = etree.HTML(response.text)  <span class="comment"># 获取爬到的动态页面源码</span></span><br><span class="line">                        <span class="keyword">try</span>:    <span class="comment"># 解析xpath，去噪</span></span><br><span class="line">                            content = tree_content.xpath(xpath_string)</span><br><span class="line">                            content = re.sub(<span class="string">r&#x27;\s+&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>.join(content))  <span class="comment"># 获取到的文章内容（去空格）</span></span><br><span class="line">                            content = quzao(content)</span><br><span class="line">                        <span class="keyword">except</span>:</span><br><span class="line">                            content = <span class="string">&#x27;&#x27;</span>    <span class="comment"># 没有内容的可能是内容违规已撤销</span></span><br><span class="line">                        content_list.append(content)    </span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">&#x27;解析文章&quot;&#x27;</span>+title+<span class="string">&#x27;&quot;成功！&#x27;</span>)</span><br><span class="line">                        <span class="keyword">try</span>:</span><br><span class="line">                            <span class="comment"># 以下逐行写入，备份数据用，防止反爬造成数据丢失</span></span><br><span class="line">                            sheet.write(l , <span class="number">0</span>, title)</span><br><span class="line">                            sheet.write(l , <span class="number">1</span>, key_word)</span><br><span class="line">                            sheet.write(l , <span class="number">2</span>, content)</span><br><span class="line">                            sheet.write(l , <span class="number">3</span>, cat)</span><br><span class="line">                            sheet.write(l , <span class="number">4</span>, item[<span class="string">&#x27;link&#x27;</span>])</span><br><span class="line">                            sheet.write(l , <span class="number">5</span>, item[<span class="string">&#x27;post_date&#x27;</span>])</span><br><span class="line">                            savepath = <span class="string">&#x27;./微信公众号_&#x27;</span> + key_word + <span class="string">&#x27;_.xls&#x27;</span></span><br><span class="line">                            l += <span class="number">1</span></span><br><span class="line">                            <span class="keyword">if</span> l % <span class="number">20</span> == <span class="number">0</span>:     <span class="comment"># 每20行保存一次（适当调大一点，以免保存失败）</span></span><br><span class="line">                                book.save(savepath)</span><br><span class="line">                                <span class="built_in">print</span>(<span class="string">&quot;数据备份成功！已保存&quot;</span> + <span class="built_in">str</span>(l) + <span class="string">&quot;条！&quot;</span>)</span><br><span class="line">                        <span class="keyword">except</span>:</span><br><span class="line">                            <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 当前页面数+1</span></span><br><span class="line">                cur_page += <span class="number">1</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;over！开始保存&#x27;</span>)</span><br><span class="line">    <span class="comment"># 中途没有反爬的话，一次写入所有爬取数据</span></span><br><span class="line">    data = &#123;<span class="string">&#x27;title&#x27;</span>: title_list, <span class="string">&#x27;author&#x27;</span>: author_list, <span class="string">&#x27;content&#x27;</span>: content_list,<span class="string">&#x27;category&#x27;</span>: cat_list,<span class="string">&quot;link&quot;</span>:link_list,<span class="string">&quot;date&quot;</span>:date_list&#125;</span><br><span class="line">    df = DataFrame(data)</span><br><span class="line">    df.to_excel(<span class="string">&#x27;./微信公众号_&#x27;</span> + key_word + <span class="string">&#x27;_.xlsx&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;保存成功！&#x27;</span>)</span><br><span class="line">spider()</span><br></pre></td></tr></table></figure><p>代码只有cookie需要登录微信公众号后台手动获取，复制粘贴进去；page_count由刚才查文章的界面往下拉，找到一共有多少页，其他参数都不用修改。</p><p>为了防止半路被反爬，引入了xlwt库，作用是创建工作表，逐行写入保存爬到的临时数据，不然有可能爬到一半被检测到，最后所有数据都不会保存<del>（别问我为什么知道）</del>！最后一步是写入所有数据，名称和临时数据不一样，也是多一步保险措施。爬取过程显示的数据如下：</p><p><img src="https://www.shelven.com/tuchuang/20221218/111.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221218/111.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>如果中途被反爬机制检测到，换一个公众号cookie，然后从中断的cur_page处继续，excel另存。</p><p>通过以上代码，实现对公众号“植物生物技术Pbj”8447篇推送（从创建的第一天2019年3月1日至2022年12月18日）爬取：</p><p><img src="https://www.shelven.com/tuchuang/20221218/6.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221218/6.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><strong>上面的代码是根据“植物生物技术Pbj”这个公众号排版所特制的</strong>，一定要注意根据具体公众号决定制作怎么样的去噪函数，总页数其实也可以根据app_msg_count&#x2F;page_size值写一个函数自动计算出来，但是如果中途被反爬还是要手动改page值，这里就不多此一举了。还有，如果爬取的每页推送天数（也就是第二个data字典中的count值）可以突破5的话，就可以再写一个循环尽量一次拿到多的文章url，这样检测的机率就会大大降低（<strong>我每次被检测都是抓取app_msg_list的时候，而不是抓取文章内容的时候</strong>）。</p><p>经过半天的测试，有一点以下的经验之谈</p><ul><li>微信公众号反爬机制<strong>可能是检测你翻页的次数</strong>，一天翻页的次数在100-200次间比较保险，也就是一次爬500天-1000天内的推送数据</li><li>每次抓取数据sleep1-5秒比较靠谱，1-3秒也容易在爬100条左右的时候被抓……</li><li>有一个思路是通过保存所有文章url，再进行每个文章内容抓取，但是获取文章列表的data字典中count值最大只能是5，导致我们需要频繁翻页，这个地方如何突破是一个问题。</li><li>sheet.write方法有的时候会失效，在某一次打开excel之后可能没来得及写入数据就被保存，<strong>导致后续无法继续保存临时数据</strong>。解决方法之一是保存间隔大一点，这里我设置了每写入20行保存一次。</li><li>做好爬取数据的双保险！<strong>我这里做了临时数据保存，不要抱侥幸心，不然爬半天数据容易全部木大！</strong></li></ul></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;前面一篇博客讲了requests、Xpath和selenium的用法，最后用selenium模拟浏览器对搜狗微信文章做了自动化爬取。从搜狗微信网页爬取的公众号文章其实是不全的，不能保证公众号的所有文章都被搜狗收录，且selenium爬取速度相对较慢（但是对动态页面爬取很有用），因此可以选择另一种方式——直接从微信公众号后台进行爬取。&lt;/p&gt;</summary>
    
    
    
    <category term="网络相关" scheme="http://www.shelven.com/categories/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="python" scheme="http://www.shelven.com/tags/python/"/>
    
    <category term="爬虫" scheme="http://www.shelven.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>应用requests、Xpath和selenium编写爬虫脚本</title>
    <link href="http://www.shelven.com/2022/12/14/a.html"/>
    <id>http://www.shelven.com/2022/12/14/a.html</id>
    <published>2022-12-13T16:42:48.000Z</published>
    <updated>2022-12-13T16:47:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博客承接前面的HTTP基本原理，对requests、Xpath和selenium三个库&#x2F;工具做个简单介绍，并且用三个爬虫实例由浅到深理解爬虫的构思和实现过程，最后是用selenium+chromedriver模拟浏览器，实现对微信公众号文章的爬取。</p><span id="more"></span><h2 id="1-requests"><a href="#1-requests" class="headerlink" title="1. requests"></a>1. requests</h2><div class="story post-story"><p>requests是python最常见的HTTP客户端库，可以调用requests模块的API伪装成浏览器对网站发起请求。</p><p>前面一篇爬虫博客介绍了requests的六种方法，这里不多赘述，主要回顾下发送请求和获得响应的过程。</p><p>requests库有两个重要的对象，<strong>Request</strong>和<strong>Response</strong>，Request对象对应的是请求，向目标网址发送一个请求访问服务。而Response对象，是包含了爬虫返回的内容。</p><p>Request对象完整的发起get和post请求方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">requests.get(url, params=<span class="literal">None</span>, **kwargs)</span><br><span class="line">requests.post(url, data=<span class="literal">None</span>, **kwargs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># url：想要获取的网页链接</span></span><br><span class="line"><span class="comment"># params：显示在url中的参数，字典形式</span></span><br><span class="line"><span class="comment"># data：不显示在url中，通过提交表单的方式提交参数，也是字典形式</span></span><br><span class="line"><span class="comment"># **kwargs：控制访问的参数，字典形式</span></span><br></pre></td></tr></table></figure><p>当服务器正常响应时，返回<strong>状态码200</strong>，这个时候就可以用Response对象的属性来获取网页信息。</p><p>Response对象属性：</p><ul><li>.status_code：HTTP响应状态码，200表示成功，其他状态码详见上篇博客</li><li>.text：HTTP响应体内容的<strong>字符串格式</strong></li><li>.content：HTTP响应体内容的<strong>二进制格式</strong></li><li>.encoding：从HTTP header中猜测的响应内容编码方式</li><li>.apparent_encoding：从内容中分析出的响应内容编码方式（备选编码方式）</li></ul><p>这里需要注意，<strong>如果我们获得的响应内容是图片视频和音频的话，需要用二进制格式进行储存。</strong></p><p>有了以上基础知识，就可以用request写一个爬虫项目了，我们现在目的是爬取豆瓣电影古装排行榜前20的电影图片。</p><p>进入豆瓣电影排行榜网页，按F12进入浏览器开发者工具，点击网页页面分类中的“古装”，对网页数据进行抓包。当鼠标滚轮往下滚动的时候我们可以发现，每次滚动更新，有一个名字很长的数据包会不断更新，还伴随着一大堆jpg图片的出现，很明显这个数据包是我们要抓取的对象。</p><p><img src="https://www.shelven.com/tuchuang/20221213/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221213/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>点击表头选项的响应头，我们看到返回的数据是json格式，编码方式是utf-8。请求url栏中问号之前的部分是我们要的url，参数可以设置一个字典传入。</p><p><img src="https://www.shelven.com/tuchuang/20221213/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221213/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>在负载部分，多次抓包以后可以看到前三个参数是<strong>一直不变</strong>的，猜测这几个参数可能是和电影类型和页面布局相关，这个可以不用管。翻页刷新后总是固定显示20个电影，因此limit和数据包内抓取的电影数相关，start和这个数据库中起始的电影编号相关。</p><p>再看看响应的json数据中，有一个“cover_url”的键对应值是电影的图片地址，至此思路就很明确了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://movie.douban.com/j/chart/top_list&#x27;</span></span><br><span class="line"><span class="comment"># 传入的url参数设置</span></span><br><span class="line">param = &#123;</span><br><span class="line">    <span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;30&#x27;</span>,<span class="comment"># 影片类型代号</span></span><br><span class="line">    <span class="string">&#x27;interval_id&#x27;</span>: <span class="string">&#x27;100:90&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;action&#x27;</span>:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;start&#x27;</span>: <span class="string">&#x27;0&#x27;</span>,<span class="comment"># 从第一个影片开始</span></span><br><span class="line">    <span class="string">&#x27;limit&#x27;</span>: <span class="string">&#x27;10&#x27;</span>,<span class="comment"># 需要抓取的影片数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 伪装浏览器</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36 Edg/108.0.1462.46&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 抓取上面定义范围内所有影片信息</span></span><br><span class="line">response = requests.get(url = url, params = param, headers = headers)</span><br><span class="line"><span class="comment"># json字符串反序列化为list类型</span></span><br><span class="line">ls = response.json()</span><br><span class="line"><span class="comment"># 解析电影图片地址，并抓取和保存图片</span></span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> ls:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./&#x27;</span> + <span class="built_in">str</span>(p[<span class="string">&#x27;title&#x27;</span>]) + <span class="string">&#x27;.jpg&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> img:</span><br><span class="line">        response1 = requests.get(url = p[<span class="string">&quot;cover_url&quot;</span>], headers = headers)</span><br><span class="line">        img.write(response1.content)</span><br><span class="line">        </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;over!!!&#x27;</span>)</span><br></pre></td></tr></table></figure><p><code>.json()</code>这个requests库自带的函数还是挺有意思的，在这个例子中是将返回的字符串JSON数据反序列化为list数据，list中嵌套了字典数据，每个电影的信息都储存在字典中。因此这里也可以用<code>.json()[&#39;cover_url&#39;]</code>直接对图片网址进行抓取，注意下这里第二次抓取的是图片，返回的是二进制数据，所以用content而不是text。</p></div><h2 id="2-Xpath"><a href="#2-Xpath" class="headerlink" title="2. Xpath"></a>2. Xpath</h2><div class="story post-story"><p>前面例子抓包返回的是JSON字符串，所以可以直接提取我们要的信息。如果返回的是HTML源代码，就可以用<strong>正则或者Xpath</strong>来解析我们想要的数据。</p><p><strong>Xpath是一种解析XML文档信息的工具，我们可以通过lxml库（XML和HTML的解析库）中导入etree模块，实例化etree对象，使用xpath函数结合xpath表达式进行标签定位和指定数据的获取。</strong></p><p>Xpath常用规则：</p><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>nodename</td><td>选取此节点的所有子节点</td></tr><tr><td>&#x2F;</td><td>从当前节点选取直接子节点</td></tr><tr><td>&#x2F;&#x2F;</td><td>从当前节点选取所有子孙节点</td></tr><tr><td>.</td><td>选取当前节点</td></tr><tr><td>..</td><td>选取当前节点的父节点</td></tr><tr><td>@</td><td>选取属性</td></tr></tbody></table><p>Xpath常用表达式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">属性定位</span><br><span class="line">//div[@class=&quot;slist&quot;]# 找到所有class属性值为slist的div标签</span><br><span class="line">层级定位</span><br><span class="line">//div[@class=&quot;slist&quot;]/../li[2]# 找到class属性值为slist的div的父标签下的第二个直系子标签li</span><br><span class="line">多属性解析</span><br><span class="line">//div[@class=&quot;slist&quot; and @name=&quot;Id&quot;]# 找到class属性为slist以及name属性为Id的div标签</span><br><span class="line">模糊匹配</span><br><span class="line">//div[contains(@class, &quot;slist&quot;)]# 找到class属性中包含slist值得div标签</span><br><span class="line">文本获取</span><br><span class="line">//li[@class=&quot;item&quot;]//text()# 取出class属性值为item的所有li标签下的所有标签文本（包括子标签） </span><br><span class="line">获取属性</span><br><span class="line">//li/a/@href# 取出所有li标签下a标签下的href属性值</span><br></pre></td></tr></table></figure><p>etree对象实例化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">本地文件（解析保存在本地的HTML文件）：</span><br><span class="line">tree = etree.parse(文件名)</span><br><span class="line">tree.xpath(&quot;xpath表达式&quot;)</span><br><span class="line"></span><br><span class="line">网络数据（实例化一个html类）：</span><br><span class="line">tree = etree.HTML(网页内容字符串)</span><br><span class="line">tree.xpath(&quot;xpath表达式&quot;)</span><br></pre></td></tr></table></figure><p>注意下xpath解析出来的数据是以<strong>列表</strong>形式存储的，接下来示范一下requests结合Xpath写一个爬虫程序，目的是抓取<a href="https://pic.netbian.com/4kdongman/">彼岸图网</a>的4k动漫封面图。</p><p>进入页面以后同样F12审查元素，点击不同页抓取返回的数据包，发现翻到第x页能抓到index_x.html，但是第一页没有下划线和其他页稍有不同，为了方便起见就从第二页开始抓。</p><p><img src="https://www.shelven.com/tuchuang/20221213/3.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221213/3.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>仔细观察可以发现，所有封面图都在属性值为slist的div标签下的ul标签下的li标签中<del>（这么说着好绕&#x3D; &#x3D;）</del>，前面http原理的博客说过，这样的标签可以看出是是无序列表，我们要找的封面图片地址可以通过img标签的src属性获得，图片名称可以通过alt属性获得，因此可以写如下的爬虫代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># 举个例子，这里抓取的是第二页数据</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="number">3</span>):</span><br><span class="line">    url = <span class="string">&#x27;http://pic.netbian.com/4kdongman/index_&#x27;</span>+<span class="built_in">str</span>(i)+<span class="string">&#x27;.html&#x27;</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.3&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    response = requests.get(url = url, headers = headers)</span><br><span class="line">    <span class="comment"># 获取网页内容字符串</span></span><br><span class="line">    page_text = response.text</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化etree对象，获取所有图片li标签信息（列表格式）</span></span><br><span class="line">    tree = etree.HTML(page_text)</span><br><span class="line">    li_list = tree.xpath(<span class="string">&#x27;//div[@class=&quot;slist&quot;]/ul/li&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 创建文件夹</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">&#x27;./pic&#x27;</span>):</span><br><span class="line">            os.mkdir(<span class="string">&#x27;./pic&#x27;</span>)</span><br><span class="line">            </span><br><span class="line">    <span class="comment"># 解析li标签下孙子标签img的src属性和alt属性</span></span><br><span class="line">    <span class="keyword">for</span> li <span class="keyword">in</span> li_list:</span><br><span class="line">        img_src = <span class="string">&#x27;http://pic.netbian.com&#x27;</span> + li.xpath(<span class="string">&#x27;./a/img/@src&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">        img_name = li.xpath(<span class="string">&#x27;./a/img/@alt&#x27;</span>)[<span class="number">0</span>] + <span class="string">&#x27;.jpg&#x27;</span></span><br><span class="line">        <span class="comment"># 这里需要处理中文乱码问题，重新编码和解码，gbk是中文最常用的</span></span><br><span class="line">        img_name = img_name.encode(<span class="string">&#x27;iso-8859-1&#x27;</span>).decode(<span class="string">&#x27;gbk&#x27;</span>)</span><br><span class="line">        img_data = requests.get(url = img_src, headers = headers).content</span><br><span class="line">        img_path = <span class="string">&#x27;pic/&#x27;</span> + img_name</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(img_path,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">                fp.write(img_data)</span><br><span class="line">                <span class="built_in">print</span>(img_name,<span class="string">&#x27;下载成功！！！&#x27;</span>)</span><br></pre></td></tr></table></figure><p>当然，上面爬虫抓取的只是封面图片，并不是高清图片，因为高清图片是需要登录账号花钱下载的….我们只能合法地从我们能在浏览器中看到的图片爬取信息。而且如果你在短时间内发起大量请求的话，ip是很有可能被封的，以后再讲一些预防反爬的措施。</p></div><h2 id="3-selenium"><a href="#3-selenium" class="headerlink" title="3. selenium"></a>3. selenium</h2><div class="story post-story"><p>selenium是一个自动化测试工具，本质是通过驱动浏览器，<strong>完全模拟浏览器中的操作</strong>，比如拖动、点击下拉等等。为什么要模仿浏览器中的操作呢？因为很多网站是动态加载的，requests这一类的模块无法直接执行JavaScript代码，这个时候就可以通过测试工具selenium模仿人在浏览器中的操作，从而获得网页渲染之后的结果。</p><p>selenium官方网站：<a href="https://www.selenium.dev/">Selenium</a></p><p><del>（很暖心地有中文文档）</del>以最新的selenium指南为基础，简单介绍一下其用法。</p><p>强调两点：</p><ul><li>selenium在4.3版本做了代码重构，很多方法被改写，<strong>最重要的是find_element方法的改写</strong>，<a href="https://github.com/SeleniumHQ/selenium/blob/a4995e2c096239b42c373f26498a6c9bb4f2b3e7/py/CHANGES">具体点击这里查看官方消息</a>。本篇博客所有写法将按照最新的语法规则</li><li><strong>一定要注意自己的浏览器与驱动版本是否匹配</strong>，本篇博客以chrome浏览器为例，chrome浏览器驱动程序官方下载地址请点击<a href="http://chromedriver.storage.googleapis.com/index.html">http://chromedriver.storage.googleapis.com/index.html</a></li></ul><p>简单地以淘宝首页作为例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.chrome.service <span class="keyword">import</span> Service</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="comment"># 启动前先将驱动程序放在当前页面</span></span><br><span class="line">bro = Service(executable_path = <span class="string">&#x27;./chromedriver.exe&#x27;</span>)</span><br><span class="line"><span class="comment"># 启动谷歌浏览器</span></span><br><span class="line">driver = webdriver.Chrome(service = bro)</span><br><span class="line"><span class="comment"># 进入淘宝网页页面</span></span><br><span class="line">driver.get(<span class="string">&#x27;https://www.taobao.com/&#x27;</span>)</span><br><span class="line"><span class="comment"># 标签定位，输入栏id属性值为&#x27;q&#x27;，id属性是整个html中唯一的，不会重复</span></span><br><span class="line">search_input = driver.find_element(By.ID, <span class="string">&#x27;q&#x27;</span>)</span><br><span class="line"><span class="comment"># 节点交互，向输入栏中输入数据&#x27;Iphone&#x27;</span></span><br><span class="line">search_input.send_keys(<span class="string">&#x27;Iphone&#x27;</span>)</span><br><span class="line"><span class="comment"># 标签定位，找到搜索按钮（可以用css选择器、id值或者Xpath等定位，这里用css选择器）</span></span><br><span class="line">btn = driver.find_element(By.CSS_SELECTOR, <span class="string">&#x27;.btn-search&#x27;</span>)</span><br><span class="line"><span class="comment"># 节点交互，点击搜索按钮</span></span><br><span class="line">btn.click()</span><br><span class="line">driver.get(<span class="string">&#x27;https://www.baidu.com&#x27;</span>)</span><br><span class="line">sleep(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 回退</span></span><br><span class="line">driver.back()</span><br><span class="line">sleep(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 前进</span></span><br><span class="line">driver.forward()</span><br><span class="line">sleep(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 退出浏览器</span></span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure><p>简单来说，流程可以分为</p><ol><li>创建驱动实例开启会话    <code>driver = webdriver.Chrome()</code></li><li>在浏览器中执行操作    <code>driver.get(&quot;https://www.baidu.com&quot;)</code></li><li>请求浏览器信息    <code>title = driver.title</code></li><li>建立等待策略（隐式或显示）    <code>driver.implicitly_wait(0.5)或者用sleep（1）</code></li><li>定位标签    <code>text_box = driver.find_element(by=By.NAME, value=&quot;my-text&quot;)</code></li><li>节点交互    <code>text_box.send_keys(&quot;Selenium&quot;)</code></li><li>获取信息     <code>value = message.text</code></li><li>结束会话，关闭浏览器    <code>driver.quit()</code></li></ol><h3 id="浏览器创建"><a href="#浏览器创建" class="headerlink" title="浏览器创建"></a>浏览器创建</h3><p>selenium支持的浏览器有Chrome、Firefox、Edge、Internet Explorer和Safari。参考<a href="https://www.selenium.dev/zh-cn/documentation/webdriver/browsers/">支持的浏览器列表 | Selenium</a></p><h3 id="元素定位"><a href="#元素定位" class="headerlink" title="元素定位"></a>元素定位</h3><p>webdriver提供了8种内置的定位方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"></span><br><span class="line">find_element(By.ID, <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line">find_element(By.NAME, <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line">find_element(By.CLASS_NAME, <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line">find_element(By.TAG_NAME, <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line">find_element(By.LINK_TEXT, <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line">find_element(By.PARTIAL_LINK_TEXT, <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line">find_element(By,XPATH, <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line">find_element(By.CSS_SELECTOR, <span class="string">&#x27;value&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="节点交互"><a href="#节点交互" class="headerlink" title="节点交互"></a>节点交互</h3><p>常见的节点交互有以下内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">driver.get(<span class="string">&quot;https://www.baidu.com&quot;</span>)<span class="comment"># 打开网站</span></span><br><span class="line">driver.back()<span class="comment"># 浏览器后退</span></span><br><span class="line">driver.forward()<span class="comment"># 浏览器前进</span></span><br><span class="line">driver.refresh()<span class="comment"># 浏览器刷新</span></span><br><span class="line">driver.add_cookie(&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>: <span class="string">&quot;value&quot;</span>&#125;)<span class="comment"># 当前浏览器添加cookie</span></span><br><span class="line">driver.find_element(By.LINK_TEXT, <span class="string">&quot;new window&quot;</span>).click()<span class="comment"># 新窗口中打开链接</span></span><br><span class="line">driver.find_element(By.ID, <span class="string">&#x27;value&#x27;</span>).send_keys(<span class="string">&#x27;value&#x27;</span>)<span class="comment"># 定位并发送内容</span></span><br><span class="line">driver.switch_to.new_window(<span class="string">&#x27;tab&#x27;</span>)<span class="comment"># 打开新标签页并切换到新标签页</span></span><br><span class="line">driver.switch_to.new_window(<span class="string">&#x27;window&#x27;</span>)<span class="comment"># 打开新窗口并切换到新窗口</span></span><br><span class="line">driver.switch_to.window(original_window)<span class="comment"># 切回之前的标签页或窗口</span></span><br><span class="line">driver.close()<span class="comment"># 关闭标签页或窗口</span></span><br><span class="line">driver.quit()<span class="comment"># 关闭浏览器</span></span><br></pre></td></tr></table></figure><h3 id="动作链"><a href="#动作链" class="headerlink" title="动作链"></a>动作链</h3><p>上面说的交互是对页面中存在的标签或者说是元素进行交互，而对于没有特定对象的，比对<strong>鼠标的双击、拖拽，鼠标滚轮的操作，键盘的输入</strong>等，这些操作就需要动作链来执行。<a href="https://www.selenium.dev/zh-cn/documentation/webdriver/actions_api/">该部分内容官网有详细介绍</a>，这里就举个例子了解一下怎么用的就行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> ActionChains</span><br><span class="line"></span><br><span class="line">bro = webdriver.Chrome(executable_path = <span class="string">&#x27;./chromedriver&#x27;</span>)</span><br><span class="line">bro.get(<span class="string">&#x27;https://www.runoob.com/try/try.php?filename=jqueryui-api-droppable&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果定位的标签是存在于iframe标签之中的则必须通过如下操作在进行标签定位</span></span><br><span class="line">bro.switch_to.frame(<span class="string">&#x27;iframeResult&#x27;</span>)<span class="comment"># 切换浏览器标签定位的作用域</span></span><br><span class="line">div = bro.find_element(By.ID, <span class="string">&#x27;draggable&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 动作链</span></span><br><span class="line">action = ActionChains(bro)</span><br><span class="line"><span class="comment"># 点击长按指定的标签</span></span><br><span class="line">action.click_and_hold(div)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    action.move_by_offset(<span class="number">5</span>,<span class="number">0</span>)<span class="comment"># move_by_offset(x,y):x水平方向 y竖直方向</span></span><br><span class="line">    action.perform()<span class="comment"># 执行动作链操作</span></span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line"><span class="comment">#释放动作链</span></span><br><span class="line">action.release()</span><br><span class="line">bro.quit()</span><br></pre></td></tr></table></figure><h3 id="微信公众号爬虫范例"><a href="#微信公众号爬虫范例" class="headerlink" title="微信公众号爬虫范例"></a>微信公众号爬虫范例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> DataFrame</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.wait <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> ChromeOptions</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="comment"># moder可以为author或者article，前者为按公众号搜索，后者为按文章关键字搜索</span></span><br><span class="line">modern=<span class="string">&#x27;author&#x27;</span></span><br><span class="line"><span class="comment"># 搜索的关键字，如果modern = author，输入公众号名字，否则输入文章关键字</span></span><br><span class="line">keyword = <span class="string">&#x27;冷兔&#x27;</span></span><br><span class="line"><span class="comment"># 爬取多少页，建议先手动搜索最大页码数，page大于最大页码将会报错</span></span><br><span class="line">page = <span class="number">2</span></span><br><span class="line">headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment"># 实现规避检测</span></span><br><span class="line">option = ChromeOptions()</span><br><span class="line">option.add_experimental_option(<span class="string">&#x27;excludeSwitches&#x27;</span>, [<span class="string">&#x27;enable-automation&#x27;</span>])</span><br><span class="line">bro = webdriver.Chrome(executable_path = <span class="string">&#x27;./chromedriver&#x27;</span>, options=option)</span><br><span class="line">bro.get(<span class="string">&quot;https://www.sogou.com/index.php&quot;</span>)</span><br><span class="line">wait = WebDriverWait(bro, <span class="number">2</span>)</span><br><span class="line">search_input = bro.find_element(By.ID, <span class="string">&#x27;query&#x27;</span>)</span><br><span class="line">search_input.send_keys(keyword)</span><br><span class="line"><span class="comment"># 点击搜索按钮</span></span><br><span class="line">btn = bro.find_element(By.ID, <span class="string">&#x27;stb&#x27;</span>)</span><br><span class="line">btn.click()</span><br><span class="line"><span class="comment"># 点击微信登陆</span></span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line">btn = bro.find_element(By.XPATH, <span class="string">&#x27;//*[@id=&quot;loginBtn&quot;]&#x27;</span>)</span><br><span class="line">btn.click()</span><br><span class="line"><span class="comment"># 用微信扫码，只有十秒</span></span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line">btn = bro.find_element(By.XPATH, <span class="string">&#x27;/html/body/div[3]/div[3]/div[2]/div[4]/div/a[2]&#x27;</span>)</span><br><span class="line">btn.click()</span><br><span class="line">time.sleep(<span class="number">10</span>)</span><br><span class="line">button = bro.find_element(By.ID, <span class="string">&#x27;sogou_weixin&#x27;</span>)</span><br><span class="line">button.click()</span><br><span class="line">article_button = bro.find_element(By.XPATH, <span class="string">&#x27;//*[@id=&quot;scroll-header&quot;]/form/div/input[1]&#x27;</span>)</span><br><span class="line">article_button.click()</span><br><span class="line"><span class="comment"># 最后需要爬取的文章url都在这里</span></span><br><span class="line">url_list=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(page):</span><br><span class="line">    page_text = bro.page_source</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析</span></span><br><span class="line">    tree = etree.HTML(page_text)</span><br><span class="line">    author=tree.xpath(<span class="string">&#x27;/html/body/div[2]/div[1]/div[3]/ul/li/div[2]/div/a/text()&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(author)</span><br><span class="line">    url_page_list=tree.xpath(<span class="string">&#x27;/html/body/div[2]/div[1]/div[3]/ul/li/div[2]/h3/a/@href&#x27;</span>)</span><br><span class="line">    <span class="comment"># 下面这个循环判断按author爬取还是按照aiticle爬取</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(author)):</span><br><span class="line">        <span class="keyword">if</span> author[j]==keyword:</span><br><span class="line">            url_list.append(url_page_list[j])</span><br><span class="line">        <span class="keyword">elif</span> modern==<span class="string">&#x27;article&#x27;</span>:</span><br><span class="line">            url_list.append(url_page_list[j])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> i != page - <span class="number">1</span>:</span><br><span class="line">        next_button = bro.find_element(By.ID, <span class="string">&#x27;sogou_next&#x27;</span>)</span><br><span class="line">        next_button.click()</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 拼接地址</span></span><br><span class="line">url_list=[<span class="string">&#x27;https://weixin.sogou.com/&#x27;</span>+i <span class="keyword">for</span> i <span class="keyword">in</span> url_list]</span><br><span class="line">title_list=[]</span><br><span class="line">content_list=[]</span><br><span class="line">time_list=[]</span><br><span class="line">author_list=[]</span><br><span class="line"><span class="keyword">for</span> url <span class="keyword">in</span> url_list:</span><br><span class="line">    response = bro.get(url=url)</span><br><span class="line">    time.sleep(random.randint(<span class="number">1</span>, <span class="number">3</span>))    <span class="comment"># 爬一个，休息1-3秒，怕被抓</span></span><br><span class="line">    page_text = bro.page_source</span><br><span class="line">    tree_content = etree.HTML(page_text)<span class="comment"># 获取爬到的动态页面源码</span></span><br><span class="line">    title = tree_content.xpath(<span class="string">&#x27;/html/body/div[1]/div[2]/div[1]/div/div[1]/h1/text()&#x27;</span>)</span><br><span class="line">    title = re.sub(<span class="string">r&#x27;\s&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>.join(title))<span class="comment"># 获取到的文章题目</span></span><br><span class="line">    content = tree_content.xpath(<span class="string">&#x27;/html/body/div[1]/div[2]/div[1]/div/div[1]/div[3]//text()&#x27;</span>)</span><br><span class="line">    content = re.sub(<span class="string">r&#x27;\s*&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>.join(content))<span class="comment"># 获取到的文章内容</span></span><br><span class="line">    time1=tree_content.xpath(<span class="string">&#x27;//*[@id=&quot;publish_time&quot;]/text()&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">    author=tree_content.xpath(<span class="string">&#x27;//*[@id=&quot;js_name&quot;]/text()&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">    author=re.sub(<span class="string">r&#x27;\s&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>.join(author))</span><br><span class="line">    title_list.append(title)</span><br><span class="line">    content_list.append(content)</span><br><span class="line">    time_list.append(time1)</span><br><span class="line">    author_list.append(author)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入xlsx文件中</span></span><br><span class="line">data = &#123;<span class="string">&#x27;title&#x27;</span>: title_list, <span class="string">&#x27;time&#x27;</span>:time_list,<span class="string">&#x27;author&#x27;</span>:author_list,<span class="string">&#x27;content&#x27;</span>: content_list&#125;</span><br><span class="line">df = DataFrame(data)</span><br><span class="line">df.to_excel(<span class="string">&#x27;./微信公众号_&#x27;</span>+keyword+<span class="string">&#x27;.xlsx&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里规避检测识别是设置Chromedriver的启动参数，在启动Chromedriver之前，为Chrome开启实验性功能参数<code>excludeSwitches</code>，它的值为<code>[‘enable-automation’]</code>。这个参数有什么作用呢？</p><p><img src="https://www.shelven.com/tuchuang/20221213/4.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221213/4.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>我们正常运行selenium时，最上方是有提示”Chrome正受到自动测试软件的控制“的，这个参数设置就是<strong>禁用浏览器的提示</strong>。如果我们用selenium模拟chrome浏览器访问网站，网站可以通过检查<code>window.navigator.webdriver</code>返回值判断我们是用正常的浏览器访问还是用selenium模拟浏览器发起的访问。</p><p><strong>如果返回值为undefined，说明是正常浏览器；如果返回true说明用selenium模拟的浏览器</strong>。</p><p>为Chrome开启实验性功能参数excludeSwitches后，和正常浏览器一样返回的是undefined。</p><p>当然，反爬手段不仅仅是这一个，这个以后的有空再细说。上面的爬虫代码参考了刘丹老师，不是最终版本，还可以对输出内容和样式继续做优化。简单看一下实现的结果：</p><p><img src="https://www.shelven.com/tuchuang/20221213/5.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221213/5.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇博客承接前面的HTTP基本原理，对requests、Xpath和selenium三个库&amp;#x2F;工具做个简单介绍，并且用三个爬虫实例由浅到深理解爬虫的构思和实现过程，最后是用selenium+chromedriver模拟浏览器，实现对微信公众号文章的爬取。&lt;/p&gt;</summary>
    
    
    
    <category term="网络相关" scheme="http://www.shelven.com/categories/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="爬虫" scheme="http://www.shelven.com/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="requests" scheme="http://www.shelven.com/tags/requests/"/>
    
    <category term="Xpath" scheme="http://www.shelven.com/tags/Xpath/"/>
    
    <category term="selenium" scheme="http://www.shelven.com/tags/selenium/"/>
    
  </entry>
  
  <entry>
    <title>HTTP基本原理</title>
    <link href="http://www.shelven.com/2022/12/10/a.html"/>
    <id>http://www.shelven.com/2022/12/10/a.html</id>
    <published>2022-12-10T15:10:45.000Z</published>
    <updated>2022-12-10T16:00:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>以前写过一篇博客如何爬取微博热搜的前50条，当时是从代码出发理解爬虫实现的过程。这篇博客主要讲一下HTTP的基本知识，知道从浏览器中输入网址到我们获取网页内容的过程中发生了什么，有助于进一步了解爬虫的基本原理。</p><span id="more"></span><h2 id="1-URI、URL和URN"><a href="#1-URI、URL和URN" class="headerlink" title="1. URI、URL和URN"></a>1. URI、URL和URN</h2><div class="story post-story"><p>先放上这三个名词的定义：</p><ul><li>URI：Uniform Resource Identifier 统一资源标志符</li><li>URL：Uniform Resource Locator 统一资源定位符</li><li>URN：Uniform Resource Name 统一资源名称</li></ul><p>URI是一个抽象定义，只要能定位到一个资源，都叫做URI。</p><p>URL和URN都是URI的子集，简单来说，<strong>URL用地址定位资源，URN用名称定位资源</strong>。只是后来URN在互联网中使用非常少，导致现在几乎所有的URI都是URL，因此我们可以将一般网页链接称之为URI或者URL（后者用的最多）。</p><p>那么URL或者URI具体指什么呢？</p><p>举个例子，本站图标地址<code>https://www.shelven.com/tuchuang/bitbug_favicon.ico</code>，通过这个地址可以访问到一只32*32像素大小的可爱小猫，通过这个地址URL&#x2F;URI指定了它的访问方式，包括了<strong>访问协议</strong>https，<strong>访问路径</strong>和<strong>资源名称</strong>bitbug_favicon.ico。这个访问资源可以是一个图片，一个CSS文档，一个HTML页面等等。</p><p>以HTTPS协议访问web服务器为例，拆解一下完整的URL结构：</p><p><code>https://user:password@www.shelven.com:443/tuchuang/bitbug_favicon.ico</code></p><ul><li><strong>协议</strong>：URL开头部分必须是协议类型，常见的https、http、ftp和mailto，指明浏览器应当使用的访问方法，用&#x2F;&#x2F;做分隔符</li><li><strong>用户名&#x2F;密码</strong>：user:password这部分可以省略</li><li><strong>域名</strong>：我这里域名是<code>www.shelven.com</code>，我们在发送请求前会向DNS服务器解析这个域名的ip地址，域名只是方便我们人类记忆的，计算机访问的最终都是ip地址。当然，如果你能记得住ip地址也可以直接输入。</li><li><strong>端口</strong>：用来区分不同网络服务（web服务、ftp服务等），和域名之间用冒号:分隔，端口不是URL必须的部分，http默认端口80，https默认端口443，ftp默认端口21。</li><li><strong>文件路径&#x2F;文件名</strong>：从域名第一个<code>/</code>到最后一个<code>/</code>之间是虚拟目录；从域名最后一个<code>/</code>到<code>?</code>部分是文件名，没有<code>?</code>则是到<code>#</code>为止，都没有则是从最后一个<code>/</code>一直到结束都是文件名部分。文件名是可以缺省的。</li></ul></div><h2 id="2-超文本"><a href="#2-超文本" class="headerlink" title="2. 超文本"></a>2. 超文本</h2><div class="story post-story"><p>超文本（Hyper Text, HT）是用超链接的方法，将不同空间文字信息组织在一起的网状文本。</p><p>举个例子，<strong>浏览器中看到的网页就是超文本解析而来的</strong>，网页本身就是一个文本文件，而超文本指这种文件既可以包含文本信息，又可以包含图片、视频、链接等非文字信息。</p><p>网页的源代码是一系列HTML（Hyper Text Markup Language, 超文本标记语言）代码，里面包含了一系列标签（尖括号&lt;&gt;包围的关键词，<strong>一般</strong>成对出现）和属性值。在浏览器中打开任意一个页面，按F12就可以打开浏览器的开发者工具，选择<strong>元素（Elements）</strong>选项卡就可以看到当前网页的源代码，而这些源代码都是超文本。</p><p><img src="https://www.shelven.com/tuchuang/20221210/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221210/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>红框框住的左上角箭头，点击以后可以在页面中用鼠标悬停选中元素，右边对应的源代码部分会高亮，方便我们进行元素审查。</p><p>这里顺便记录下HTML常用的标签和属性：</p><table><thead><tr><th>标签名</th><th>用法</th></tr></thead><tbody><tr><td><strong>基本结构标签</strong></td><td></td></tr><tr><td>HTML标签（根标签）</td><td>&lt;html&gt;&lt;&#x2F;html&gt;</td></tr><tr><td>文档头标签</td><td>&lt;head&gt;&lt;&#x2F;head&gt;</td></tr><tr><td>文档标题标签（网页标题）</td><td>&lt;title&gt;&lt;&#x2F;title&gt;</td></tr><tr><td>文档主体标签（页面内容）</td><td>&lt;body&gt;&lt;&#x2F;body&gt;</td></tr><tr><td><strong>列表标签</strong></td><td>（这里因为渲染问题&amp;emsp无法显示空格…知道HTML有缩进的意思就行）</td></tr><tr><td>无序列表</td><td>&lt;ul type&#x3D;”disc&#x2F;circle&#x2F;square”&gt;<br>&amp;emsp;&lt;li&gt;条目内容&lt;&#x2F;li&gt;<br>&lt;&#x2F;ul&gt;</td></tr><tr><td>有序列表</td><td>&lt;ol type&#x3D;”1&#x2F;a&#x2F;A&#x2F;i&#x2F;I”&gt;<br>&amp;emsp;&lt;li&gt;条目内容&lt;&#x2F;li&gt;<br>&lt;&#x2F;ol&gt;</td></tr><tr><td>定义列表</td><td>&lt;dl&gt;<br>&amp;emsp;&lt;dt&gt;列表标题标签&lt;&#x2F;dt&gt;<br>&amp;emsp;&lt;dd&gt;具体列表项&lt;&#x2F;dd&gt;<br>&lt;&#x2F;dl&gt;</td></tr><tr><td><strong>表格标签</strong></td><td></td></tr><tr><td>表格标签（tr为行）</td><td>&lt;table&gt;<br>&amp;emsp;&lt;tr&gt;<br>&amp;emsp;&amp;emsp;&lt;td&gt;单元格内容&lt;&#x2F;td&gt;<br>&amp;emsp;&lt;&#x2F;tr&gt;<br>&lt;&#x2F;table&gt;</td></tr><tr><td><strong>常用标签</strong></td><td></td></tr><tr><td>标题标签（h1-h6）</td><td>&lt;h1&gt;一级标题&lt;&#x2F;h1&gt;</td></tr><tr><td>段落标签</td><td>&lt;p&gt;这里是内容&lt;&#x2F;p&gt;</td></tr><tr><td>字体标签</td><td>&lt;font size&#x3D;”10” color&#x3D;”black” face&#x3D;”微软雅黑”&gt;你好&lt;&#x2F;font&gt;</td></tr><tr><td>换行标签</td><td>&lt;br&#x2F;&gt;</td></tr><tr><td>水平线标签</td><td>&lt;hr size&#x3D;”10” color&#x3D;”red” width&#x3D;”50%” align&#x3D;”left”&#x2F;&gt;</td></tr><tr><td>盒子标签div</td><td>&lt;div&gt;div标签内容独占一行&lt;&#x2F;div&gt;</td></tr><tr><td>盒子标签span</td><td>&lt;span&gt;span标签内容一行可以多个&lt;&#x2F;span&gt;</td></tr><tr><td>图片标签</td><td>&lt;img src&#x3D;”地址” width&#x3D;’”宽度” height&#x3D;”高度”&gt;&lt;&#x2F;img&gt;</td></tr><tr><td>超链接标签</td><td>&lt;a href&#x3D;”跳转网址” target&#x3D;”窗口弹出方式”&gt;&lt;&#x2F;a&gt;</td></tr><tr><td>注释标签</td><td>&lt;!– 注释内容 –&gt;</td></tr></tbody></table><p>还有表单标签&lt;form&gt;&lt;&#x2F;form&gt;等等，太多了这里就不一一详细说了，如果以后有必要再出一个详细的HTML笔记，现在只要看到这些标签心里有个数就行，真正要做前端再去详细探究。</p></div><h2 id="3-协议"><a href="#3-协议" class="headerlink" title="3. 协议"></a>3. 协议</h2><div class="story post-story"><p>前面说URL的开头必须指明协议类型，常用的是ftp（文件传输协议）、http（超文本传输协议）、https（http的安全版）、mailto（电子邮件协议）和smb（通信协议）。不需要对所有协议了如指掌，前三中协议是我们日常用的最多的，http和https是我们访问网站web服务所必须的，爬虫也可以通过这两种协议伪装成浏览器访问，从而抓取我们需要的页面。</p><ul><li><p><strong>HTTP</strong>（Hyper Text Transfer Protocol, 超文本传输协议）就是一个简单的请求-响应协议，运行在TCP之上，指定客户端发送什么样的消息以及得到什么响应，服务器端实现程序有httpd<del>（本站就是用的这个）</del>和nginx。</p></li><li><p><strong>HTTPs</strong>（Hyper Text Transfer Protocol over Secure Socket Layer）以安全为目标的HTTP通道，说白了就是安全版HTTP，在HTTP下加入SSL层，传输内容经过SSL加密。</p></li></ul><p>本站建站之初，我当时绕了一大圈才签下来SSL证书……<strong>HTTPS的安全基础是SSL，主要作用是建立一个信息安全通道</strong>，保证数据传输的安全；确认网站的真实性，<strong>使用https的网站可以通过浏览器地址栏的锁头标志，查看网站认证的真实信息</strong>。</p><p><img src="https://www.shelven.com/tuchuang/20221210/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221210/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>有些网站使用了HTTPs协议但还是会被浏览器提示不安全，那有可能是证书过期了，或者颁发CA证书的机构不是被信任的，这样就会提示”您的连接不是私密连接“。而要用爬虫爬取这种页面的话，<strong>需要设置忽略证书</strong>，否则会提示SSL证书连接错误。</p><p><img src="https://www.shelven.com/tuchuang/20221210/3.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221210/3.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><img src="https://www.shelven.com/tuchuang/20221210/4.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221210/4.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div><h2 id="4-HTTP请求过程"><a href="#4-HTTP请求过程" class="headerlink" title="4. HTTP请求过程"></a>4. HTTP请求过程</h2><div class="story post-story"><p>我们在浏览器中输入一个 URL，回车之后便会在浏览器中观察到页面内容。这个过程是浏览器向网站所在的服务器发送了一个请求，网站服务器接收到这个请求后进行处理和解析，然后返回对应的响应，接着传回给浏览器。响应里包含了页面的源代码等内容，浏览器再对其进行解析，将网页呈现出来。</p><p><img src="https://www.shelven.com/tuchuang/20221210/5.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221210/5.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>以本站作为演示，打开浏览器，按下F12进入开发者工具，点击网络（Network）选项；搜索框输入<code>https://www.shelven.com</code>，回车。观察整个过程中发生了怎样的网络请求。</p><p><img src="https://www.shelven.com/tuchuang/20221210/6.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221210/6.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>看下第一个网络请求<a href="http://www.shelven.com，各列的含义如下：">www.shelven.com，各列的含义如下：</a></p><ul><li>名称name：请求的名称，返回的每一条都是对应的数据包</li><li>状态status：响应的状态码，通过状态码判断发送请求之后是否得到正常的响应</li><li>类型type：请求的文档类型，这里是返回document，内容就是一些html代码</li><li>发起程序initiator：请求源，标记是哪个对象或者进程发起的请求</li><li>大小size：从服务器下载的文件和请求资源的大小</li><li>时间time：发起请求到获取响应的总时间</li><li>时间线waterfall：网络请求的可视化瀑布流</li></ul><p>点击具体条目可以看到更详细的信息。</p><p><img src="https://www.shelven.com/tuchuang/20221210/7.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221210/7.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>主要看三个部分，<strong>常规（general）、响应头（Response Headers）和请求头（Request Headers）</strong>。常规部分是总的数据包概括。请求头带有请求信息，例如Cookies、user-agent等信息，服务器会根据请求头内的信息判断请求是否合法，进而作出对应的响应。响应头就是响应的一部分，包含了服务器的类型、文档类型、日期等信息，浏览器接受到响应后，会解析响应内容，进而呈现网页内容。</p></div><h2 id="5-请求"><a href="#5-请求" class="headerlink" title="5. 请求"></a>5. 请求</h2><div class="story post-story"><p>请求指的是从客户端到服务器端的请求消息，发给服务器的请求称为请求报文，可以分为请求行（request line），请求头（request header）和请求体（request body）。</p><h3 id="5-1-请求行"><a href="#5-1-请求行" class="headerlink" title="5.1 请求行"></a>5.1 请求行</h3><p>请求行中包括了请求方法，请求协议和版本。</p><p>以百度首页为例：</p><p><img src="https://www.shelven.com/tuchuang/20221210/8.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221210/8.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>小框框起来的地方为请求行，可以看到百度首页的请求方法为get，请求协议为HTTP版本1.1</p><p>常见的请求方法有两种：<strong>GET和POST</strong></p><ul><li>GET 请求中的参数包含在URL里面，数据可以在URL中看到，而POST请求的URL不会包含这些数据，数据是通过<strong>表单形式</strong>传输的，会包含在请求体中。</li><li>GET 请求提交的数据最多只有1024字节，而POST方式没有限制。</li></ul><p>因为GET请求方式不涉及和数据库的交换，所以我们浏览网页用的都是GET请求；如果要在一个网站登录，就需要提交用户名和密码的表单，这个时候用的就是POST请求。还有一个重要的因素，<strong>GET方式请求的数据是在URL中完全暴露的</strong>，所以也不会用GET方式发送请求，不然容易造成密码泄露。</p><p>其他请求方法在<a href="https://www.shelven.com/2022/05/03/a.html?keyword=%E7%88%AC%E8%99%AB">前面一篇爬虫博客</a>有提到，这里列个表格：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>GET</td><td>请求页面，并返回页面内容</td></tr><tr><td>POST</td><td>大多用于提交表单或上传文件，数据包含在请求体中</td></tr><tr><td>HEAD</td><td>类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头</td></tr><tr><td>PUT</td><td>从客户端向服务器传送的数据取代指定文档中的内容</td></tr><tr><td>DELETE</td><td>请求服务器删除指定的页面</td></tr><tr><td>CONNECT</td><td>把服务器当作跳板，让服务器代替客户端访问其他网页</td></tr><tr><td>OPTIONS</td><td>允许客户端查看服务器的性能</td></tr><tr><td>TRACE</td><td>回显服务器收到的请求，主要用于测试或诊断</td></tr></tbody></table><p>表格参考：<a href="https://www.runoob.com/http/http-methods.html">HTTP 请求方法 | 菜鸟教程 (runoob.com)</a></p><h3 id="5-2-请求头"><a href="#5-2-请求头" class="headerlink" title="5.2 请求头"></a>5.2 请求头</h3><p>请求头是用来说明服务器使用的附加信息的，上面那个百度首页例子的大框框住部分就是请求头的信息。</p><p>同样列个表格记录下常用的头信息。</p><table><thead><tr><th>头信息</th><th>描述</th></tr></thead><tbody><tr><td>Accept</td><td>请求报头域，用于指定客户端可接受哪些类型的信息</td></tr><tr><td>Accept-Language</td><td>指定客户端可接受的语言类型</td></tr><tr><td>Accept-Encoding</td><td>指定客户端可接受的内容编码</td></tr><tr><td>Host</td><td>指定请求资源的主机IP和端口号</td></tr><tr><td>Cookie</td><td>而存储在用户本地的数据，主要功能是<strong>维持当前访问会话</strong></td></tr><tr><td>Referer</td><td>标识请求是从哪个页面发过来的，服务器可以拿来做来源统计、防盗链处理</td></tr><tr><td>User-Agent</td><td><strong>服务器识别客户使用的操作系统及版本、浏览器及版本等信息</strong>，爬虫伪装浏览器必备</td></tr><tr><td>Content-Type</td><td>请求的数据类型信息<a href="https://tool.oschina.net/commons">HTTP Content-type 对照表 (oschina.net)</a></td></tr></tbody></table><h3 id="5-3-请求体"><a href="#5-3-请求体" class="headerlink" title="5.3 请求体"></a>5.3 请求体</h3><p>请求体承载POST请求中的表单数据，<strong>GET请求的请求体为空</strong>。</p><p>这里以登录github捕获的请求体为例：</p><p><img src="https://www.shelven.com/tuchuang/20221210/11.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221210/11.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>登录的时候填写的用户名和密码信息，提交的时候就会以表单形式提交给服务器，这个时候可以看到请求头中的Cotent-Type为application&#x2F;x-www-form-urlencoded，表示以表单数据的形式提交给服务器。可以设置不同的Cotent-Type，以不同的方式提交数据，如果在做爬虫的时候要构造POST请求，需要注意一下<strong>使用正确的Cotent-Type（类型&#x2F;子类型）</strong>，不然可能会提交后无法正常响应。</p><table><thead><tr><th>Cotent-Type</th><th>数据提交的方式</th></tr></thead><tbody><tr><td>application&#x2F;x-www-form-urlencoded</td><td>表单数据</td></tr><tr><td>multipart&#x2F;form-data</td><td>表单文件上传</td></tr><tr><td>application&#x2F;json</td><td>序列化JSON数据</td></tr><tr><td>text&#x2F;xml</td><td>XML数据</td></tr><tr><td>application&#x2F;pdf</td><td>pdf格式</td></tr><tr><td>application&#x2F;octet-stream</td><td>二进制流数据（如常见的文件下载）</td></tr></tbody></table></div><h2 id="6-响应"><a href="#6-响应" class="headerlink" title="6. 响应"></a>6. 响应</h2><div class="story post-story"><p>和请求类似的，服务器进行HTTP响应也是分为三个部分：<strong>响应状态行，响应头和响应体</strong></p><h3 id="6-1-响应状态行"><a href="#6-1-响应状态行" class="headerlink" title="6.1 响应状态行"></a>6.1 响应状态行</h3><p>回到之前百度首页的例子，我们点开百度首页审查元素，这次点开响应那一栏查看源。</p><p><img src="https://www.shelven.com/tuchuang/20221210/10.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221210/10.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>小框框起来的地方是响应状态行，我们可以看到响应的协议版本是HTTP&#x2F;1.1，<strong>响应状态码是200</strong>，说明返回正常。</p><p>响应状态码其实并不陌生，顾名思义表示服务器的响应状态。200说明服务器正常响应返回正常数据，经常能看到404报错，代表的是页面未找到，403表示服务器拒绝执行请求，503代表服务器不可用，301代表网页被永久转移到其他URL。</p><p>因为状态码非常多，这里就记录一下状态码的分类，详细状态码列表可以参考<a href="https://www.runoob.com/http/http-status-codes.html">HTTP 状态码 | 菜鸟教程 (runoob.com)</a></p><table><thead><tr><th>分类</th><th>分类描述</th></tr></thead><tbody><tr><td>100-199</td><td>信息响应，服务器收到请求，需要请求者继续执行操作</td></tr><tr><td>200-299</td><td><strong>成功响应</strong>，操作被成功接收并处理</td></tr><tr><td>300-399</td><td>重定向，需要进一步的操作以完成请求</td></tr><tr><td>400-499</td><td><strong>客户端错误</strong>，请求包含语法错误或无法完成请求</td></tr><tr><td>500-599</td><td><strong>服务器错误</strong>，服务器在处理请求的过程中发生了错误</td></tr></tbody></table><h3 id="6-2-响应头"><a href="#6-2-响应头" class="headerlink" title="6.2 响应头"></a>6.2 响应头</h3><p>上面例子中红色大框框住的部分就是响应头，包含服务器对请求的应答信息。</p><p>响应头主要有如下的信息：</p><table><thead><tr><th>头信息</th><th>描述</th></tr></thead><tbody><tr><td>Date</td><td>标识响应产生的时间</td></tr><tr><td>Last-Modified</td><td>指定资源的最后修改时间</td></tr><tr><td>Content-Encoding</td><td>指定响应内容的编码</td></tr><tr><td>Server</td><td>服务器的信息，比如名称、版本号</td></tr><tr><td>Content-Type</td><td>返回的数据类型信息</td></tr><tr><td>Set-Cookie</td><td>设置 Cookies，下次请求会携带这个cookies</td></tr><tr><td>Expires</td><td>指定响应的过期时间</td></tr></tbody></table><h3 id="6-3-响应体"><a href="#6-3-响应体" class="headerlink" title="6.3 响应体"></a>6.3 响应体</h3><p>响应体就是响应的内容，请求网页的时候响应体就是对应的HTML源代码，请求一张图片，响应体就是返回的二进制数据。爬虫就是通过请求到网页后，解析响应体中的内容（有的时候是HTML代码，有的时候是JSON数据等等，这两者比较常见），然后从中提取我们要的信息。</p><p>在edge浏览器中，进入开发者工具，点击network选项，选中需要解析的项目名称，点击响应就可以看到返回的响应体数据了。</p><p><img src="https://www.shelven.com/tuchuang/20221210/12.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221210/12.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>以上暂时总结这么多HTTP的基础，参考了相当多的内容，后面做爬虫练习自然会用到。</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;以前写过一篇博客如何爬取微博热搜的前50条，当时是从代码出发理解爬虫实现的过程。这篇博客主要讲一下HTTP的基本知识，知道从浏览器中输入网址到我们获取网页内容的过程中发生了什么，有助于进一步了解爬虫的基本原理。&lt;/p&gt;</summary>
    
    
    
    <category term="网络相关" scheme="http://www.shelven.com/categories/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="爬虫" scheme="http://www.shelven.com/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="HTTP" scheme="http://www.shelven.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>python自学笔记（7）——模块、包和库</title>
    <link href="http://www.shelven.com/2022/11/29/b.html"/>
    <id>http://www.shelven.com/2022/11/29/b.html</id>
    <published>2022-11-29T14:30:03.000Z</published>
    <updated>2022-12-03T15:51:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>前面介绍递归函数的时候用到了sys模块，介绍文件操作函数的时候用到了os模块，之前只是简单说了这两个模块下部分函数的用法，这里详细介绍一下对于模块、包和库的概念，以及一些常见的模块用法。</p><span id="more"></span><p>不需要记住每个模块下所有函数用法，但是平常看到python文件导入模块操作的时候，要大概知道这几个模块有什么作用。</p><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><div class="story post-story"><h3 id="1-1-模块（module）"><a href="#1-1-模块（module）" class="headerlink" title="1.1 模块（module）"></a>1.1 模块（module）</h3><p>函数可以理解为完成特定功能的一段程序，类是包含一组数据及操作这些数据或传递消息的函数的集合，而<strong>模块（module）是在函数和类的基础上，将一系列相关代码组织到一起的集合体</strong>。</p><p>在python中，扩展名为.py的源程序文件就是一个模块，这个和C语言的头文件以及JAVA的包是类似的。</p><p>python官方网站上可以查看当前标准库中的所有模块，<a href="https://docs.python.org/3/py-modindex.html">点击这里</a>。</p><h3 id="1-2-包（package）"><a href="#1-2-包（package）" class="headerlink" title="1.2 包（package）"></a>1.2 包（package）</h3><p>为了方便调用将一些功能相近的模块组织在一起，或是将一个较为复杂的模块拆分为多个组成部分，可以将 .py 源程序文件放在<strong>同一个文件夹下</strong>，按照 Python 的规则进行管理，<strong>这样的文件夹和其中的文件就称为包（package）</strong>。</p><p>包的目录下需要创建__init__.py 模块，可以是一个空文件，可以写一些初始化代码，其作用就是告诉 Python 要将该目录当成包来处理，让python认为你这是一个包而不是单纯的一个目录（否则会显示找不到包）。<strong>有的博客说python3.3版本之后不需要空的__init__.py 模块来声明这是一个包了，但是我在vscode和jupyter运行python3.10的时候发现还是需要__init__.py 模块声明的</strong>，这里先存疑，我保留自己的观点。</p><ul><li>2022.12.3更新：准确来说，从包里导入模块需要__init__.py 声明；直接导入同目录下的模块不需要（3.3版本以后）</li></ul><p>简单来说，包就是有层次地文件目录结构，里面装着各种扩展名.py的python源程序文件，包中也可以含有包。</p><h3 id="1-3-库"><a href="#1-3-库" class="headerlink" title="1.3 库"></a>1.3 库</h3><p>库顾名思义则是功能相关联的包的集合。python的三大特色之一：强大的标准库，第三方库以及自定义模块。</p></div><h2 id="2-常用模块-x2F-库"><a href="#2-常用模块-x2F-库" class="headerlink" title="2. 常用模块&#x2F;库"></a>2. 常用模块&#x2F;库</h2><div class="story post-story"><p>python的三大特色对应三种类型的模块，标准库的内置模块，第三方库开源模块和自定义的模块，这里简单记录一下常用的模块&#x2F;库。</p><table><thead><tr><th>模块名称</th><th>介绍</th></tr></thead><tbody><tr><td><strong>内置模块</strong></td><td></td></tr><tr><td>os</td><td>普遍的操作系统功能接口，包括前面介绍的文件操作函数</td></tr><tr><td>sys</td><td>提供了一系列有关Python运行环境的变量和函数，sys.path.append()</td></tr><tr><td>random</td><td>生成随机数，random() 返回0&lt;n&lt;&#x3D;1</td></tr><tr><td>time</td><td>各种提供日期、时间功能的类和函数，time.time() 时间戳</td></tr><tr><td>datetime</td><td>对time模块的一个高级封装</td></tr><tr><td>logging</td><td>日志打印到了标准输出中</td></tr><tr><td>re</td><td>可以直接调用来实现正则匹配，re.split() 分割字符串，格式化列表</td></tr><tr><td>pymysql</td><td>连接数据库,并实现简单的增删改查</td></tr><tr><td>threading</td><td>提供了更强大的多线程管理方案</td></tr><tr><td>json</td><td>用于字符串和数据类型间进行转换json</td></tr><tr><td>subprocess</td><td>像linux一样创建运行子进程</td></tr><tr><td>shutil</td><td>对压缩包的处理、对文件和文件夹的高级处理，os的补充</td></tr><tr><td>tkinter</td><td>Python的标准Tk GUI工具包的接口</td></tr><tr><td><strong>第三方模块&#x2F;库</strong></td><td></td></tr><tr><td>Requsests</td><td>python最有名的第三方HTTP客户端库</td></tr><tr><td>Scrapy</td><td>屏幕抓取和web抓取框架，编写爬虫用到（上面的也可以）</td></tr><tr><td>Pillow</td><td>常用的图像处理库</td></tr><tr><td>Matplotlib</td><td>绘制二维数据图的库，使用方式对标matlab</td></tr><tr><td>NumPy</td><td>提供大型矩阵计算公式，在很多领域都用到</td></tr><tr><td>Pandas</td><td>基于Numpy 和 Matplotlib，和上面两个组成数据分析三剑客</td></tr><tr><td>Django</td><td>开源的web开发框架</td></tr><tr><td>PyTorch</td><td>开源的深度学习框架，各种张量操作、梯度计算，方便构建各种动态神经网络</td></tr><tr><td>TensorFlow</td><td>也是机器学习库，张量的操作和运算，tensorboard可视化数据很强大</td></tr></tbody></table><p>第三方库实在太多，这里只列举了我知道的比较常见的库；内置模块可以见1.1章节的官网链接，里面有所有内置模块的具体用法。接下来说说怎么导入模块和制作模块。</p></div><h2 id="3-导入包和模块"><a href="#3-导入包和模块" class="headerlink" title="3. 导入包和模块"></a>3. 导入包和模块</h2><div class="story post-story"><h3 id="3-1-导入模块"><a href="#3-1-导入模块" class="headerlink" title="3.1 导入模块"></a>3.1 导入模块</h3><p>制作模块要注意，<strong>自定义的模块名不能和系统内置的模块重名</strong>，否则被重名的系统模块无法被导入。</p><p>python中用关键字<strong>import</strong>引入某个模块，在调用模块中的函数时，需要以 <strong>模块名.函数名</strong> 的方式进行引用。自定义模块名中的函数是可以重名的，因为模块名不会相同（同一层目录下文件名不同），调用的时候可以进行区分，这很好理解。</p><h3 id="3-2-导入包"><a href="#3-2-导入包" class="headerlink" title="3.2 导入包"></a>3.2 导入包</h3><p>有的时候我们只需要包里的某个模块或者模块里的某个函数，而不需要包或者模块里的全部内容，这个时候我们可以用关键词 <strong>from 包名&#x2F;模块名 import 模块名&#x2F;函数名</strong> 来进行调用。</p><p>举个例子，在如下的文件结构中，main.py作为主程序入口，test文件夹相当于一个包，里面有4个.py后缀的模块，分别定义了四则运算的函数，__init__.py 是个空文件（暂时不做处理），声明test文件夹是个python包而不是普通的目录。</p><p><img src="https://www.shelven.com/tuchuang/20221129/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221129/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># add.py文件内容——定义加法运算</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="comment"># sub.py文件内容——定义减法运算</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a - b</span><br><span class="line"></span><br><span class="line"><span class="comment"># mul.py文件内容——定义乘法运算</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mul</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a * b</span><br><span class="line"></span><br><span class="line"><span class="comment"># dev.py文件内容——定义除法运算</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dev</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a / b</span><br></pre></td></tr></table></figure><p>我现在要做的是，在main.py文件里，导入test包里四个模块，调用各自模块中对应的函数，有以下几种调用方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># main.py的文件内容</span></span><br><span class="line"><span class="keyword">import</span> test.add<span class="comment"># 导入test包下的add模块</span></span><br><span class="line"><span class="keyword">import</span> test.sub <span class="keyword">as</span> sb<span class="comment"># 导入test包下的sub模块，并重命名为sb</span></span><br><span class="line"><span class="keyword">from</span> test <span class="keyword">import</span> mul<span class="comment"># 从test包中导入mul模块</span></span><br><span class="line"><span class="keyword">from</span> test.dev <span class="keyword">import</span> dev<span class="comment"># 从test包的dev模块导入dev函数，注意这里导入的是函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculate</span>(<span class="params">x, y, operate</span>):</span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> operate == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">        result = test.add.add(x, y)<span class="comment"># 调用test.add模块中的add函数</span></span><br><span class="line">    <span class="keyword">elif</span> operate == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        result = sb.sub(x, y)<span class="comment"># test.sub被重命名为sb，调用sb中的sub函数</span></span><br><span class="line">    <span class="keyword">elif</span> operate == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">        result = mul.mul(x, y)<span class="comment"># 调用mul模块中的mul函数</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        result = dev(x, y)<span class="comment"># dev函数已经被导入，可以直接调用函数名</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(calculate(<span class="number">100</span>, <span class="number">100</span>, <span class="string">&#x27;+&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(calculate(<span class="number">100</span>, <span class="number">100</span>, <span class="string">&#x27;-&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(calculate(<span class="number">100</span>, <span class="number">100</span>, <span class="string">&#x27;*&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(calculate(<span class="number">100</span>, <span class="number">100</span>, <span class="string">&#x27;/&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">200</span></span><br><span class="line"><span class="string">0</span></span><br><span class="line"><span class="string">10000</span></span><br><span class="line"><span class="string">1.0</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></div><h2 id="4-包和模块导入的思考"><a href="#4-包和模块导入的思考" class="headerlink" title="4. 包和模块导入的思考"></a>4. 包和模块导入的思考</h2><div class="story post-story"><h3 id="4-1-init-py的作用"><a href="#4-1-init-py的作用" class="headerlink" title="4.1 __init__.py的作用"></a>4.1 __init__.py的作用</h3><p>在上面的例子中__init__.py 是个空文件，是声明test文件夹是python包所必须的（<strong>主程序和包的位置在同一个目录下</strong>）。然而我们在编写main.py的主程序文件的时候，仍然要在开头导入相当多的模块，比较繁琐，这个时候可以在__init__.py中批量导入我们所需要的模块（导入包其实就是导入__init__.py文件）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在__init__.py中添加如下内容</span></span><br><span class="line"><span class="keyword">import</span> test.add</span><br><span class="line"><span class="keyword">import</span> test.sub</span><br><span class="line"><span class="keyword">import</span> test.mul</span><br><span class="line"><span class="keyword">import</span> test.dev</span><br><span class="line"></span><br><span class="line">add = test.add.add</span><br><span class="line">sub = test.sub.sub</span><br><span class="line">mul = test.mul.mul</span><br><span class="line">dev = test.dev.dev</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># main.py相应的改为如下内容</span></span><br><span class="line"><span class="keyword">from</span> test <span class="keyword">import</span> *<span class="comment"># 导入包相当于执行包下的__init__.py，这个文件已经将包里的四个模块分别导入了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculate</span>(<span class="params">x, y, operate</span>):</span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> operate == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">        result = add(x, y)</span><br><span class="line">    <span class="keyword">elif</span> operate == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        result = sub(x, y)</span><br><span class="line">    <span class="keyword">elif</span> operate == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">        result = mul(x, y)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        result = dev(x, y)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(calculate(<span class="number">100</span>, <span class="number">100</span>, <span class="string">&#x27;+&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(calculate(<span class="number">100</span>, <span class="number">100</span>, <span class="string">&#x27;-&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(calculate(<span class="number">100</span>, <span class="number">100</span>, <span class="string">&#x27;*&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(calculate(<span class="number">100</span>, <span class="number">100</span>, <span class="string">&#x27;/&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">200</span></span><br><span class="line"><span class="string">0</span></span><br><span class="line"><span class="string">10000</span></span><br><span class="line"><span class="string">1.0</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>可以看到上面的主程序代码量少了很多，起到简化代码的作用。</p><h3 id="4-2-if-name-x3D-x3D-‘-main-‘"><a href="#4-2-if-name-x3D-x3D-‘-main-‘" class="headerlink" title="4.2 if __name__ &#x3D;&#x3D; ‘__main__‘"></a>4.2 if __name__ &#x3D;&#x3D; ‘__main__‘</h3><p>首先来看一个现象，如果在add.py文件中不仅仅有定义函数的代码，还有编写代码时做的测试内容，如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># add.py文件中最后一行对这个函数做了测试</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">3</span>, <span class="number">4</span>))</span><br></pre></td></tr></table></figure><p>其他文件全都不变，再次运行main.py，会发现输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span><span class="comment"># add.py中测试内容也被输出</span></span><br><span class="line"><span class="number">200</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">10000</span></span><br><span class="line"><span class="number">1.0</span></span><br></pre></td></tr></table></figure><p>这显然不是我们想看到的，我们在导入add模块调用add函数的时候，并不想要其他无关的输出结果。</p><p>稍稍改变一下add.py内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># add.py文件内容</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(add(<span class="number">3</span>, <span class="number">4</span>))</span><br></pre></td></tr></table></figure><p>此时再次运行main.py则不会输出add.py中的测试内容。</p><p>首先要了解一个概念，在每个python文件创建的时候都有一个记录名称的变量__name__，当这个python文件作为脚本直接运行，那么__name__的值为‘”__main__“；当这个文件作为模块被导入其他文件中运行的时候，这个__name__的值为模块的名字，也就是说</p><ul><li><p><strong>当.py文件被直接运行时，if __name__ &#x3D;&#x3D; ‘__main__‘ 之下的代码块将被运行</strong></p></li><li><p><strong>当.py文件以模块形式被导入时，if __name__ &#x3D;&#x3D; ‘__main__‘ 之下的代码块不被运行</strong></p></li></ul><p>在导入的模块中有选择性地执行代码，这在实际开发应用中非常普遍。</p><h3 id="4-3-导入模块在主程序的父目录下"><a href="#4-3-导入模块在主程序的父目录下" class="headerlink" title="4.3 导入模块在主程序的父目录下"></a>4.3 导入模块在主程序的父目录下</h3><p>前面的导入模块操作，导入模块要么在主程序的子目录下（加入__init__.py 声明这是一个包），要么和主程序在同一个目录（直接import），如果导入模块在<strong>主程序的父目录</strong>下，应该怎么导入呢？</p><p>首先，按照一般流程直接import导入和加入__init__.py声明都会报错找不到这个包，这里就不演示了。</p><p>其实这个问题在前面的笔记中有记录，<a href="https://www.shelven.com/2022/04/29/a.html">点击这里</a>。 当时是刚用vscode搭建python环境，对python调用一知半解都算不上，现在才有了初步的理解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 两种解决办法</span></span><br><span class="line"><span class="comment"># 1.在主程序内部临时添加python运行环境路径</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">&#x27;父目录绝对路径或者相对路径&#x27;</span>)</span><br><span class="line"><span class="keyword">import</span> module</span><br><span class="line"><span class="comment"># 缺点：只能调用一次（临时加入的环境变量路径），且每个想要导入的自定义模块都要写一次，比较麻烦</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.在python安装目录下Libsite-packages中创建扩展名为.pth的文件，添加想要加入的路径。</span></span><br><span class="line"><span class="comment"># python在遍历已知的库文件目录过程中，如果见到一个.pth 文件，就会将文件中所记录的路径加入到sys.path设置中，于是.pth文件指向的地址也就可以被Python运行环境找到了。</span></span><br><span class="line"><span class="comment"># 这个已知的库文件目录可以通过sys.path查看。</span></span><br></pre></td></tr></table></figure><h3 id="4-4-相对导入"><a href="#4-4-相对导入" class="headerlink" title="4.4 相对导入"></a>4.4 相对导入</h3><p>前面3.2的例子中，包和模块的导入都是用的<strong>绝对导入</strong>（absolute import），导入时写明了工作环境中包的具体位置。</p><p>还有一种导入方式称为相对导入（relative import），还是用3.2的例子理解一下，在如下的文件结构中，主程序入口main.py和test包在同一层目录下，test包中有__init__.py（空文件），add.py和dev.py两个模块的内容如下：</p><p><img src="https://www.shelven.com/tuchuang/20221129/222.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221129/222.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># add.py内容</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="comment"># dev.py内容</span></span><br><span class="line"><span class="keyword">from</span> .add <span class="keyword">import</span> add<span class="comment"># 相对导入，从当前导入包的目录中找到add模块</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dev</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a / b</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>(<span class="params">a, b</span>):</span><br><span class="line">    a = dev(a, b) + add(a, b)</span><br><span class="line">    <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure><p>上面的例子意思是，我现在要在test包的dev.py模块中用add.py模块的函数方法（同一个包中的模块相互引用，这在实际工程中很常见）。如果dev.py是主程序，我们可以直接<code>import add</code>；但是我们这里main是主程序，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># main.py内容</span></span><br><span class="line"><span class="keyword">from</span> test <span class="keyword">import</span> dev</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(dev.func1(<span class="number">1</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>主程序main.py功能是导入test包dev模块，打印dev模块的函数func1(1, 2)执行结果。</p><p>如果我们在dev.py中直接导入<code>from add import add</code>（没有点，也就是不加当前目录），这个时候再运行main.py会报错找不到模块（因为main.py同目录下没有add.py模块）。这个时候就有两种导入方式，要么完善包名字，使用绝对导入<code>from test.add import add</code>；要么使用相对导入<code>from .add import add</code>。</p><p>这个相对导入就像是linux的文件操作方式，一个点代表当前目录，两个点代表父目录，还能用三个点表示linux无法做到的祖父目录，依此类推。</p><p><strong>相对导入的优点就一目了然：就算改变了包的名字，这个时候调用也不会出错，也就是简化代码，方便迁移。</strong></p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;前面介绍递归函数的时候用到了sys模块，介绍文件操作函数的时候用到了os模块，之前只是简单说了这两个模块下部分函数的用法，这里详细介绍一下对于模块、包和库的概念，以及一些常见的模块用法。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="编程自学" scheme="http://www.shelven.com/categories/%E7%BC%96%E7%A8%8B%E8%87%AA%E5%AD%A6/"/>
    
    
    <category term="python" scheme="http://www.shelven.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python自学笔记（6）——函数的变量和高级用法</title>
    <link href="http://www.shelven.com/2022/11/29/a.html"/>
    <id>http://www.shelven.com/2022/11/29/a.html</id>
    <published>2022-11-28T18:37:37.000Z</published>
    <updated>2022-12-03T15:54:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>前面在通过讲什么是高阶函数（能够接受函数作为参数传入的函数，或者可以返回函数对象的函数）引出了装饰器的由来和存在的意义。这里对python函数的其他基础概念做个补充和记录。</p><span id="more"></span><h2 id="1-函数的变量"><a href="#1-函数的变量" class="headerlink" title="1. 函数的变量"></a>1. 函数的变量</h2><div class="story post-story"><p>之前笔记中的例子已经对函数参数传递过程做了总结，提到了怎么调用函数的返回值，怎么实现函数的嵌套，基本概念用法都已经提过，这里只是做个思考和补充。</p><h3 id="1-1-局部变量"><a href="#1-1-局部变量" class="headerlink" title="1.1 局部变量"></a>1.1 局部变量</h3><ul><li>函数内部的定义的变量</li><li>局部变量只在函数内部生效，不同函数可以拥有同名的局部变量，互不影响（作用域为本函数）</li><li>局部变量的作用，为了临时保存数据需要在函数中定义变量来进行存储</li><li>局部变量在函数执行时被创建，函数执行完成后，局部变量会被系统回收</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 局部变量重名互不影响，只作用在当前函数中</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">added</span>(<span class="params">a, b</span>):</span><br><span class="line">    c = a + b</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">a, b</span>):</span><br><span class="line">    c = <span class="built_in">str</span>(a) + <span class="built_in">str</span>(b)</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(added(<span class="number">4</span>, <span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span>(connect(<span class="string">&#x27;Phantom&#x27;</span>, <span class="string">&#x27;Aria&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">9</span></span><br><span class="line"><span class="string">PhantomAria</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="1-2-全局变量"><a href="#1-2-全局变量" class="headerlink" title="1.2 全局变量"></a>1.2 全局变量</h3><ul><li>函数外部定义的变量</li><li>全局变量可以在多个函数中使用（作用域为所有函数）</li><li>全局变量如果和局部变量重名，<strong>只会使用局部变量</strong>（就近原则）</li><li>如果<strong>在函数中修改不可变类型全局变量</strong>，需要使用<strong>global声明</strong></li></ul><p>这里有一个很有意思的现象，前面在数据类型里说过，数据可以分为可变数据类型（列表，字典，集合）和不可变数据类型（数字，元组，字符串），而<strong>python的所有参数传递都是引用传递而非值传递</strong>。因此，对于可变类型的全局变量，在函数中可以被修改；而对于不可变全局对象则无法在函数中直接修改，其本质是修改不可变数据系统会创建一个新的对象（分配一个新的内存地址），然而这个对象名已经被占用了（也就是变量名无法被指向，原来的变量名也没有被收回）。下面举个栗子。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不可变类型全局变量在函数内部可以传递使用但是无法直接修改</span></span><br><span class="line">x = <span class="number">100</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">added</span>():</span><br><span class="line">    x = x + <span class="number">1</span>       <span class="comment"># 不可变数据修改，系统会创建新的对象，而变量名x已经是全局变量的变量名，无法成为新的对象的变量名</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">added()</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">---------------------------------------------------------------------------</span></span><br><span class="line"><span class="string">UnboundLocalError                         Traceback (most recent call last)</span></span><br><span class="line"><span class="string">d:\zhuomian\python\test.ipynb Cell 47 in &lt;cell line: 6&gt;()</span></span><br><span class="line"><span class="string">      3     x = x + 1</span></span><br><span class="line"><span class="string">      4     return x</span></span><br><span class="line"><span class="string">----&gt; 6 added(4)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">d:\zhuomian\python\test.ipynb Cell 47 in added(a)</span></span><br><span class="line"><span class="string">      2 def added(a):</span></span><br><span class="line"><span class="string">----&gt; 3     x = x + 1</span></span><br><span class="line"><span class="string">      4     return x</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">UnboundLocalError: local variable &#x27;x&#x27; referenced before assignment</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>对于global是如何运作，使得python解释器可以将不可变全局变量进行修改的？这点以我的功底还无法解释……暂时只能知道是这么个用法。</p><p>顺带一提，还有个嵌套函数对外围函数的不可变变量进行修改，需要用到类似的<strong>nonlocal</strong>进行声明。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">100</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">added</span>():</span><br><span class="line">    <span class="keyword">global</span> x        <span class="comment"># global声明x为全局变量</span></span><br><span class="line">    x = x + <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line">added()</span><br><span class="line">added()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">A</span>():</span><br><span class="line">    y = <span class="number">200</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">B</span>():</span><br><span class="line">        <span class="keyword">nonlocal</span> y      <span class="comment"># nonlocal声明y为外围函数的变量（不是全局变量！）</span></span><br><span class="line">        y = y + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line">    <span class="keyword">return</span> B</span><br><span class="line">test = A()</span><br><span class="line"><span class="built_in">print</span>(test())</span><br><span class="line"><span class="built_in">print</span>(test())</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">101</span></span><br><span class="line"><span class="string">102</span></span><br><span class="line"><span class="string">201</span></span><br><span class="line"><span class="string">202</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>上面的例子本质上是一样的，对于嵌套函数来说，要修改外围函数的不可变类型的变量（看起来似乎矛盾，不可变的怎么能叫变量呢？前面已经说过，重新赋值造成数字和字符串看起来是“可变的”假象，这里分清两个变分别指什么意思），相当于是上面例子的在函数内修改不可变类型的全局变量（作用域不同，只能说相当于），只不过二者<strong>声明的方式不同</strong>。</p><h3 id="1-3-修改可变全局变量引起的思考"><a href="#1-3-修改可变全局变量引起的思考" class="headerlink" title="1.3 修改可变全局变量引起的思考"></a>1.3 修改可变全局变量引起的思考</h3><p>一个很有意思的现象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add1</span>(<span class="params">ls</span>):</span><br><span class="line">    ls = ls + ls</span><br><span class="line"></span><br><span class="line">b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add2</span>(<span class="params">ls</span>):</span><br><span class="line">    ls += ls</span><br><span class="line"></span><br><span class="line">add1(a)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">add2(b)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">[1, 2, 3]</span></span><br><span class="line"><span class="string">[1, 2, 3, 1, 2, 3]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>a列表和b列表都是<strong>可变全局变量</strong>，同一个算法，为什么a在传入函数执行之后没有发生改变呢？</p><p>这里需要对可变数据类型做个回顾，可变对象可以对自身内容进行<strong>原地修改</strong>而不改变存储地址。原地修改画个重点，意思是利用方法比如reverse、sort、append等在<strong>原有对象上直接修改</strong>。</p><ul><li><p>‘&#x3D;’ 是赋值语句，将右边的表达式的结果对象，引用绑定到等号左边的变量名上。赋值是<strong>创建一个新对象</strong>，赋值给目标，返回的也是新对象，<strong>引用地址会发生改变</strong>。</p></li><li><p>‘+&#x3D;’ 是增强赋值语句，对左边的对象进行<strong>原地修改</strong>，返回值为None，<strong>引用地址不变</strong>。</p></li></ul><p>看到这里就能明白上面两个看似“同样”的操作为什么会返回不一样的结果，也加深了“可变”与“不可变”的理解。</p></div><h2 id="2-函数的高级用法"><a href="#2-函数的高级用法" class="headerlink" title="2. 函数的高级用法"></a>2. 函数的高级用法</h2><div class="story post-story"><p>前一篇笔记写的<strong>装饰器</strong>就是函数的高级用法之一，这里做个完善补充。</p><h3 id="2-1-匿名函数"><a href="#2-1-匿名函数" class="headerlink" title="2.1 匿名函数"></a>2.1 匿名函数</h3><p>除了用def关键字命名函数这种基础方法之外，还可以使用lambda表达式创建匿名函数。</p><p>lambda语法格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> param1,...paramN:expression</span><br></pre></td></tr></table></figure><p>匿名函数的语法比较简洁，能接受任何数量的参数但只能返回一个表达式的值。因为匿名函数比较简洁小巧，也常用在作为参数进行传递。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义匿名函数</span></span><br><span class="line">func1 = <span class="keyword">lambda</span> x, y : x + y</span><br><span class="line">result = func1(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;匿名函数func1执行结果：&quot;</span>,result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 匿名函数作为参数传递</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func2</span>(<span class="params">x, y, opt</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;函数func2执行结果为：&#x27;</span>, opt(x, y))</span><br><span class="line"></span><br><span class="line">func2(<span class="number">4</span>, <span class="number">5</span>, <span class="keyword">lambda</span> x, y : x + y)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">匿名函数func1执行结果： 3</span></span><br><span class="line"><span class="string">函数func2执行结果为： 9</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-嵌套调用"><a href="#2-2-嵌套调用" class="headerlink" title="2.2 嵌套调用"></a>2.2 嵌套调用</h3><p>相比来说函数嵌套调用可能算不上是高级用法，不过这里还是补充一下。嵌套调用指一个函数里调用另一个函数，<strong>注意和嵌套函数区分</strong>。</p><p>一个简单的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>():        <span class="comment"># 定义一个函数</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;第一个函数输出Phantom&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func2</span>():        <span class="comment"># 定义第二个函数</span></span><br><span class="line">    func1()     <span class="comment"># 在第二个函数里调用第一个函数功能</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;第二个函数输出Aria&#x27;</span>)</span><br><span class="line"></span><br><span class="line">func2()     <span class="comment"># 执行一个函数，实际上两个函数都执行了一遍</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">第一个函数输出Phantom</span></span><br><span class="line"><span class="string">第二个函数输出Aria</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="2-3-递归函数"><a href="#2-3-递归函数" class="headerlink" title="2.3 递归函数"></a>2.3 递归函数</h3><p>递归函数就是在一个函数内部调用自身的函数，本质上是一个循环，循环结束的点就是递归出口。</p><p>用阶乘举个最简单的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用迭代实现阶乘算法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">factorial</span>(<span class="params">n</span>):</span><br><span class="line">    result = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n +<span class="number">1</span>):</span><br><span class="line">        result *= i</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用递归实现阶乘算法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">factorial_1</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> n * factorial_1(n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(factorial(<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(factorial_1(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">3628800</span></span><br><span class="line"><span class="string">3628800</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><ul><li><p>迭代的方法，从1开始，进入for循环对之前的结果累积乘以 i，直至 n（上例函数被调用了1次）。</p></li><li><p>递归的方式更为直观，每次通过递减数字的方式递归调用自己（上例函数被调用了10次）。</p></li></ul><p><strong>整体上看递归更简洁明了，但是相比迭代会占用更多内存，运行时间会更长</strong>。</p><p>递归有最大深度限制，在计算机中，函数名、参数、值类型等，都是存放在栈上的。每进行一次函数调用，就会在栈上加一层，函数返回就减一层，由于栈的大小是有限的，递归次数过多就会导致<strong>堆栈溢出</strong>。</p><p>可以调用sys模块，<code>sys.setrecursionlimit(2000)</code>将栈的大小调整为2000，<code>sys.getrecursionlimit()</code>查看当前设置的最大递归深度。这种调整递归深度的方式不是无限大的，我的jupyter在调用递归函数3000次的时候就会直接退出……模块定义和调用方式后一篇笔记再说。</p></div><h2 id="3-文件操作函数"><a href="#3-文件操作函数" class="headerlink" title="3. 文件操作函数"></a>3. 文件操作函数</h2><div class="story post-story"><h3 id="3-1-open-amp-close"><a href="#3-1-open-amp-close" class="headerlink" title="3.1 open() &amp; close()"></a>3.1 open() &amp; close()</h3><p>函数open()可以<strong>打开一个文件，或者创建一个新文件</strong>，函数close()可以关闭文件。两者语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;文件名&#x27;</span>, <span class="string">&#x27;访问模式&#x27;</span>)</span><br><span class="line">f.close()       <span class="comment"># 注意最后一定要有close()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;文件名&#x27;</span>, <span class="string">&#x27;访问模式&#x27;</span>) <span class="keyword">as</span> f:       <span class="comment"># 自动调用close()</span></span><br><span class="line">    f.方法()</span><br></pre></td></tr></table></figure><table><thead><tr><th>访问模式</th><th>说明</th></tr></thead><tbody><tr><td>r</td><td>只读方式打开文件，默认模式，打开文件必须存在。</td></tr><tr><td>w</td><td>写入方式打开文件，已存在的文件会覆盖内容（相当于linux重定向操作符&gt;）。</td></tr><tr><td>a</td><td>追加方式打开文件，已存在的文件会将内容写到最后（相当于linux重定向操作符&gt;&gt;）。</td></tr><tr><td>x</td><td>只写方式打开文件，新建一个文件，若文件存在则报错。</td></tr><tr><td>r+</td><td>读写方式打开文件，打开文件必须存在。</td></tr><tr><td>w+</td><td>读写方式打开文件，已存在的文件会覆盖内容。</td></tr><tr><td>a+</td><td>读写方式打开文件，已存在的文件会将内容写到最后。</td></tr></tbody></table><p>一般用 with open() as 的方式打开文件，这种方式会自动帮我们调用f.close()</p><h3 id="3-2-write-amp-read"><a href="#3-2-write-amp-read" class="headerlink" title="3.2 write() &amp; read()"></a>3.2 write() &amp; read()</h3><p>write()向文件写入数据，以w方式访问，如果文件名存在会先清空文件内容，文件名不存在则新建；以a方式访问，如果文件名存在则续写，文件名不存在则新建；以r方式访问则报错。</p><p>read()从文件中读取数据，括号里面的参数代表读取的数据长度（字节数），如果不传入参数则读取所有数据。</p><p>readline()读取一行，同时会读取一行最后的换行符\n，所以打印出来的时候会多一行空行。</p><p>readlines()按照行的方式读取整个文件数据，返回的是一个列表，每行数据是一个元素，同样会读到换行符\n并且显示出来。</p><p>需要注意一点，<strong>在多次读取的操作中，后一次读取会从上一次读完的位置开始。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:    <span class="comment"># 只写模式创建一个新文件</span></span><br><span class="line">    f.write(<span class="string">&#x27;My name is Phantom. \nI am Aria.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> f:    <span class="comment"># 追加模式进行续写</span></span><br><span class="line">    f.write(<span class="string">&#x27;\nWell, it\&#x27;s been so long.&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">生成的test.txt内容：        # 实际前面两行末尾都有换行符</span></span><br><span class="line"><span class="string">My name is Phantom.</span></span><br><span class="line"><span class="string">I am Aria.</span></span><br><span class="line"><span class="string">Well, it&#x27;s been so long.</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:    <span class="comment"># 只读方式打开文件</span></span><br><span class="line">    line = f.read(<span class="number">1</span>)        <span class="comment"># read读取第一个字节</span></span><br><span class="line">    <span class="built_in">print</span>(line)</span><br><span class="line">    line = f.readline()     <span class="comment"># readline读取第一个字节后的第一行，因为读取了换行符，所以运行结果多一行空行</span></span><br><span class="line">    <span class="built_in">print</span>(line)</span><br><span class="line">    line = f.readlines()    <span class="comment"># readlines读取接下来的两行，每行数据为一个元素，返回一个列表</span></span><br><span class="line">    <span class="built_in">print</span>(line)</span><br><span class="line">    </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">M</span></span><br><span class="line"><span class="string">y name is Phantom. </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[&#x27;I am Aria.\n&#x27;, &quot;Well, it&#x27;s been so long.&quot;]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="3-3-os模块的文件操作函数"><a href="#3-3-os模块的文件操作函数" class="headerlink" title="3.3 os模块的文件操作函数"></a>3.3 os模块的文件操作函数</h3><p>os模块和上面递归函数最后提到的sys模块用的非常多，下篇笔记再详细说明，这里就记一下用法。</p><p>这几个函数也非常直观，举个例子就知道分别有什么作用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.rename(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;TEST.txt&#x27;</span>)   <span class="comment"># 文件重命名</span></span><br><span class="line">os.remove(<span class="string">&#x27;TEST.txt&#x27;</span>)   <span class="comment"># 文件删除</span></span><br><span class="line">os.mkdir(<span class="string">&#x27;./test&#x27;</span>)      <span class="comment"># 创建文件夹，文件夹存在的话会报错,且只能创建一级目录</span></span><br><span class="line">os.rmdir(<span class="string">&#x27;./test&#x27;</span>)      <span class="comment"># 删除文件夹</span></span><br><span class="line">os.makedirs(<span class="string">&#x27;./TEST/TEST1/TEST2&#x27;</span>)   <span class="comment">#递归的方式创建多级目录</span></span><br></pre></td></tr></table></figure></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;前面在通过讲什么是高阶函数（能够接受函数作为参数传入的函数，或者可以返回函数对象的函数）引出了装饰器的由来和存在的意义。这里对python函数的其他基础概念做个补充和记录。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="编程自学" scheme="http://www.shelven.com/categories/%E7%BC%96%E7%A8%8B%E8%87%AA%E5%AD%A6/"/>
    
    
    <category term="python" scheme="http://www.shelven.com/tags/python/"/>
    
  </entry>
  
</feed>
