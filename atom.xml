<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>我的小破站</title>
  
  
  <link href="http://www.shelven.com/atom.xml" rel="self"/>
  
  <link href="http://www.shelven.com/"/>
  <updated>2022-04-20T05:03:08.389Z</updated>
  <id>http://www.shelven.com/</id>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>shell脚本基本语法总结</title>
    <link href="http://www.shelven.com/2022/04/20/a.html"/>
    <id>http://www.shelven.com/2022/04/20/a.html</id>
    <published>2022-04-19T19:55:58.000Z</published>
    <updated>2022-04-20T05:03:08.389Z</updated>
    
    <content type="html"><![CDATA[<p>简单记录下shell脚本语言的学习</p><h2 id="shell脚本运行方式"><a href="#shell脚本运行方式" class="headerlink" title="shell脚本运行方式"></a>shell脚本运行方式</h2><div class="story post-story"><p>首先要了解什么是脚本，脚本本质上是一个可运行的文件，使用特定格式的指令让系统通过脚本解析器解析并执行你的指令。系统提供的shell命令解析器有sh、bash和ash。可以通过<code>echo $SHELL</code>查看自己linux系统的默认解析方式</p><p>shell脚本文件的开头：<code>#!/bin/bash</code></p><p>#! 是特殊的用来声明脚本由什么shell解释，否则使用默认shell</p><p>sh文件有三种执行方式<code>./xxx.sh</code> <code>bash xxx.sh</code> <code>. xxx.sh</code></p><p><code>./xxx.sh</code>  先按照 文件中#!指定的解析器解析，如果#！指定指定的解析器不存在才会使用系统默认的解析器</p><p><code>bash xxx.sh</code>   指明先用bash解析器解析，如果bash不存在才会使用默认解析器</p><p><code>. xxx.sh</code>  直接使用默认解析器解析</p></div><h2 id="各种引号的区别"><a href="#各种引号的区别" class="headerlink" title="各种引号的区别"></a>各种引号的区别</h2><div class="story post-story"><p>vim创建脚本文件1111.sh：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo &quot;Phantom的SHELL练习&quot;</span><br><span class="line">num=123</span><br><span class="line">echo &quot;预设数字=$num&quot;</span><br><span class="line">read -p &quot;输入数字&quot; sum      # read可以识别标准输入（键盘输入），-p参数设置提示语</span><br><span class="line">echo &quot;输出结果=$sum+$num&quot;</span><br><span class="line">echo &quot;$sum&quot;     # &quot;&quot;解析变量值</span><br><span class="line">echo &#x27;$sum&#x27;     # &#x27;&#x27;不能解析变量值</span><br><span class="line">echo &quot;今天日期`date`&quot;       # ``识别为系统命令</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220420011514.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220420011514.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>变量名不能以数字开头</p><p>在变量赋值的过程中，等号两边不能接空格，若要接空格，则整个字符串都要用引号括起来</p><div class="note "><p><strong>各种引号区别</strong></p><p>双引号“”可以解析变量的值<br>单引号‘’不能解析变量的值，包含的变量会被当做字符串<br>反引号`` 反引号的内容作为系统命令并执行 如`date`</p></div></div><h2 id="各种括号的区别"><a href="#各种括号的区别" class="headerlink" title="各种括号的区别"></a>各种括号的区别</h2><div class="story post-story"><p>vim创建脚本文件xxx.sh：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">Num=1000</span><br><span class="line">&#123;                                       # 花括号表示在当前shell完成，会影响当前变量</span><br><span class="line">    Num=1234</span><br><span class="line">    echo &quot;()里面的数字是=$Num&quot;</span><br><span class="line">&#125;</span><br><span class="line">echo &quot;显示当前shell数字=$Num&quot;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220420012607.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220420012607.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>vim创建脚本文件xxxx.sh：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">Num=1000</span><br><span class="line">(                                       # 小括号表示在当前shell完成，不会影响当前变量</span><br><span class="line">    Num=1234</span><br><span class="line">    echo &quot;()里面的数字是=$Num&quot;</span><br><span class="line">)</span><br><span class="line">echo &quot;显示当前shell数字=$Num&quot;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220420013440.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220420013440.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><div class="note "><p><strong></strong></p><p>{命令序列} 在当前shell中执行，直接影响当前变量<br>(命令序列) 由子shell完成，不影响当前shell的变量<br>[判断条件]中括号是判断条件，进行数值判断。下面会说明</p></div></div><h2 id="数值判断"><a href="#数值判断" class="headerlink" title="数值判断"></a>数值判断</h2><div class="story post-story"><p>vim建立脚本文件xxxxx.sh：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">read -p &quot;请输入第一个数字&quot; m</span><br><span class="line">read -p &quot;请输入第二个数字&quot; n</span><br><span class="line">if [ $m -eq $n ]; then          # -eq 判断两个参数是否相等</span><br><span class="line">    echo &quot;输入的两个数字相等&quot;</span><br><span class="line">elif [ $m -lt $n ]; then        # -lt 判断左边参数是否小于右边参数</span><br><span class="line">    echo &quot;第一个数字小于第二个数字&quot;</span><br><span class="line">elif [ $m -gt $n ]; then        # -gt 判断左边参数是否大于右边参数</span><br><span class="line">    echo &quot;第一个数字大于第二个数字&quot;</span><br><span class="line">fi      # if控制语句格式：if elif else fi </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220420015758.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220420015758.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="> </p><div class="note "><p><strong>数值判断参数详解</strong></p><p>-eq  比较两个参数是否相等<br>-ne  比较两个参数是否不相等<br>-lt  左边参数是否小于右边参数<br>-le  左边参数是否小于等于右边参数<br>-gt  左边参数是否大于右边参数<br>-ge  左边参数是否大于等于右边参数</p></div></div><h2 id="字符串提取和替换"><a href="#字符串提取和替换" class="headerlink" title="字符串提取和替换"></a>字符串提取和替换</h2><div class="story post-story"><p>vim新建脚本文件1234.sh：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">ll=&quot;Phantom Aria f r u i t l e s s l o v e&quot;     # 定义字符串变量</span><br><span class="line">echo &quot;长度为:$&#123;#ll&#125;&quot;        # 字符串长度(包括空格)</span><br><span class="line">echo &quot;$&#123;ll:3&#125;&quot;          # 从第3个字符往后提取</span><br><span class="line">echo &quot;$&#123;ll:3:11&#125;&quot;       # 从第3个字符往后提取11个字符</span><br><span class="line">echo &quot;$&#123;ll/ /&#125;&quot;         # 字符串从左往右删除第一个空格（相当于替换的方式）</span><br><span class="line">echo &quot;$&#123;ll// /&#125;&quot;        # 删除字符串中所有空格（相当于全局替换的方式）</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220420024742.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220420024742.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div><h2 id="字符串匹配和删除"><a href="#字符串匹配和删除" class="headerlink" title="字符串匹配和删除"></a>字符串匹配和删除</h2><div class="story post-story"><p>vim新建脚本文件match.sh：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">ll=&quot;Phantom Aria fruitless love&quot;</span><br><span class="line">echo $&#123;ll% *&#125;   # 从右往左匹配第一个空格，删除右边所有字符串</span><br><span class="line">echo $&#123;ll%% *&#125;  # 从右往左匹配所有空格，删除右边所有字符串</span><br><span class="line">echo $&#123;ll#* &#125;   # 从左往右匹配第一个空格，删除左边所有字符串</span><br><span class="line">echo $&#123;ll##* &#125;  # 从左往右匹配所有空格，删除左边所有字符串</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220420031440.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220420031440.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><div class="note "><p><strong></strong></p><p>*号是通配符，可以是匹配的任意长度任意字符串<br>%和%%匹配原则：都是从右到左匹配，删除右边，%%称为<strong>贪婪匹配</strong><br>#和##匹配原则：都是从左往右匹配，删除左边，##同样称为贪婪匹配，<strong>注意通配符位置</strong></p></div></div><h2 id="for循环语句"><a href="#for循环语句" class="headerlink" title="for循环语句"></a>for循环语句</h2><div class="story post-story"><p>for循环语句两种写法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for （(初始值；限制值；执行步阶)）    #注意两个小括号，少一个都不行</span><br><span class="line">do</span><br><span class="line">    程序段</span><br><span class="line">done</span><br><span class="line">或</span><br><span class="line">for 变量 in 1 2 3 4 5 6 7 8 9 10    #等价于`seq 1 10`</span><br><span class="line">do</span><br><span class="line">    程序段</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>vim建立脚本文件for_example.sh：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">declare -i sum=0        # 强制定义sum为整数型变量（不定义会变成一串字符串）</span><br><span class="line">read -p &quot;请输入整数&quot; n      # 标准输入定义变量n</span><br><span class="line">for (( i=0; i&lt;=$n; i++ ))   # 等同于for i in `seq 0 $n`，不赘述</span><br><span class="line">do</span><br><span class="line">    sum=$sum+$i     # 计算0到n之和</span><br><span class="line">done</span><br><span class="line">echo &quot;0到这个数的整数之和=$sum&quot;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220420022902.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220420022902.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div><h2 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h2><div class="story post-story"><p>vim建立脚本文件12345.sh：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">function formax()</span><br><span class="line">&#123;</span><br><span class="line">    if [ $n -gt $m ]; then</span><br><span class="line">        return $n</span><br><span class="line">    else</span><br><span class="line">        return $m</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line">read -p &quot;输入数值1：&quot; n</span><br><span class="line">read -p &quot;输入数值2：&quot; m</span><br><span class="line">formax $n $m</span><br><span class="line">echo &quot;输入的最大值为$?&quot; # $?表示上个指令的返回值</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220420034507.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220420034507.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>自定义了一个formax函数判断输入的两个数值大小，可以看出shell脚本中是一行一行读取指令的。自定义函数可以被引用，保存上述{}内的指令至原文件名12345.sh，在下一个脚本文件中，将函数放在脚本开始处， shell解释器发现它才可以进行调用（如下所示）</p><p>vim建立脚本文件test.sh：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">source 12345.sh</span><br><span class="line">read -p &quot;输入数值1：&quot; n</span><br><span class="line">read -p &quot;输入数值2：&quot; m</span><br><span class="line">formax $n $m</span><br><span class="line">echo &quot;输入的最大值为$?&quot;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220420035345.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220420035345.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>自定义函数被成功调用</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;简单记录下shell脚本语言的学习&lt;/p&gt;
&lt;h2 id=&quot;shell脚本运行方式&quot;&gt;&lt;a href=&quot;#shell脚本运行方式&quot; class=&quot;headerlink&quot; title=&quot;shell脚本运行方式&quot;&gt;&lt;/a&gt;shell脚本运行方式&lt;/h2&gt;&lt;div class=&quot;</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="shell脚本" scheme="http://www.shelven.com/tags/shell%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>转录组数据分析笔记（7）——DESeq2差异分析</title>
    <link href="http://www.shelven.com/2022/04/18/a.html"/>
    <id>http://www.shelven.com/2022/04/18/a.html</id>
    <published>2022-04-18T07:49:20.000Z</published>
    <updated>2022-04-18T15:32:11.286Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-代码示范"><a href="#1-代码示范" class="headerlink" title="1. 代码示范"></a>1. 代码示范</h2><div class="story post-story"><p>前面处理好raw count定量表达矩阵，建立样本列表矩阵后，我们就可以在rstudio里运行DESeq2包进行差异基因筛选了。代码如下。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">library<span class="punctuation">(</span><span class="string">&quot;DESeq2&quot;</span><span class="punctuation">)</span></span><br><span class="line">mycounts <span class="operator">&lt;-</span> read.csv<span class="punctuation">(</span><span class="string">&quot;transcript_count_matrix.csv&quot;</span><span class="punctuation">,</span>row.names <span class="operator">=</span> <span class="number">1</span><span class="punctuation">)</span></span><br><span class="line">mycounts_1 <span class="operator">&lt;-</span> mycounts<span class="punctuation">[</span>rowSums<span class="punctuation">(</span>mycounts<span class="punctuation">)</span> <span class="operator">!=</span> <span class="number">0</span><span class="punctuation">,</span><span class="punctuation">]</span> <span class="comment"># 重新定义数据集，过滤mapping数为0的基因</span></span><br><span class="line">mymeta <span class="operator">&lt;-</span> read.csv<span class="punctuation">(</span><span class="string">&quot;sample_list.csv&quot;</span><span class="punctuation">,</span>stringsAsFactors <span class="operator">=</span> <span class="built_in">T</span><span class="punctuation">)</span>  <span class="comment"># 载入样本分组文件，遇到字符串将其转化为因子</span></span><br><span class="line">colnames<span class="punctuation">(</span>mycounts_1<span class="punctuation">)</span> <span class="operator">==</span> mymeta<span class="operator">$</span>id   <span class="comment"># 检查导入的两个数据集是否匹配，返回值为F需要重新匹配</span></span><br><span class="line">mymeta<span class="operator">$</span>index <span class="operator">&lt;-</span> factor<span class="punctuation">(</span>mymeta<span class="operator">$</span>index<span class="punctuation">,</span>levels <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;0&quot;</span><span class="punctuation">,</span><span class="string">&quot;1&quot;</span><span class="punctuation">,</span><span class="string">&quot;2&quot;</span><span class="punctuation">,</span><span class="string">&quot;3&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span>    <span class="comment"># 把样本分组文件的分组列转换到因子，不然会报错</span></span><br><span class="line">dds <span class="operator">&lt;-</span> DESeqDataSetFromMatrix<span class="punctuation">(</span>countData <span class="operator">=</span> mycounts_1<span class="punctuation">,</span></span><br><span class="line">                              colData <span class="operator">=</span> mymeta<span class="punctuation">,</span></span><br><span class="line">                              design <span class="operator">=</span> <span class="operator">~</span>index<span class="punctuation">)</span>  <span class="comment">#构造用于差异表达分析的数据集</span></span><br><span class="line">dds <span class="operator">&lt;-</span> DESeq<span class="punctuation">(</span>dds<span class="punctuation">)</span></span><br><span class="line">res <span class="operator">&lt;-</span> results<span class="punctuation">(</span>dds<span class="punctuation">)</span></span><br><span class="line">res_1 <span class="operator">&lt;-</span> data.frame<span class="punctuation">(</span>res<span class="punctuation">)</span>    <span class="comment"># 结果res不是常规的数据，需要转化成数据框</span></span><br><span class="line">library<span class="punctuation">(</span><span class="string">&quot;dplyr&quot;</span><span class="punctuation">)</span></span><br><span class="line">res_1 <span class="operator">%&gt;%</span>   <span class="comment"># dplyr给数据集增加新列</span></span><br><span class="line">  mutate<span class="punctuation">(</span>group <span class="operator">=</span> case_when<span class="punctuation">(</span></span><br><span class="line">    log2FoldChange <span class="operator">&gt;=</span><span class="number">1</span> <span class="operator">&amp;</span> padj <span class="operator">&lt;=</span><span class="number">0.05</span> <span class="operator">~</span> <span class="string">&quot;UP&quot;</span><span class="punctuation">,</span></span><br><span class="line">    log2FoldChange <span class="operator">&lt;=</span><span class="operator">-</span><span class="number">1</span> <span class="operator">&amp;</span> padj <span class="operator">&lt;=</span><span class="number">0.05</span> <span class="operator">~</span> <span class="string">&quot;DOWN&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="literal">TRUE</span> <span class="operator">~</span> <span class="string">&quot;NOT_CHANGE&quot;</span></span><br><span class="line">  <span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">-&gt;</span> res_2</span><br><span class="line">table<span class="punctuation">(</span>res_2<span class="operator">$</span>group<span class="punctuation">)</span></span><br><span class="line">write.csv<span class="punctuation">(</span>res_2<span class="punctuation">,</span>file <span class="operator">=</span> <span class="string">&quot;all.csv&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="built_in">quote</span> <span class="operator">=</span> <span class="built_in">F</span><span class="punctuation">)</span>    <span class="comment"># 输出文件</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h2 id="2-代码详解"><a href="#2-代码详解" class="headerlink" title="2. 代码详解"></a>2. 代码详解</h2><div class="story post-story"><p>详细解释一下过程：</p><p>在R里运行程序或者写代码，首先要确定好工作目录在哪里，将之前Stringtie转化的定量表达矩阵和样本列表矩阵全都放在工作目录下，这里我的表达量矩阵是transcript_count_matrix.csv，分组列表矩阵是sample_list.csv。<code>getwd()</code>可以查看当前工作目录，在全局设置里可以更改工作目录。</p><p><code>library(&quot;DESeq2&quot;)</code>  # 加载DESeq2这个R包</p><p><code>mycounts &lt;- read.csv(&quot;transcript_count_matrix.csv&quot;,row.names = 1)</code> # 载入raw count矩阵，以第一行数据作为行名，读取的矩阵命名为mycounts</p><p><code>mycounts_1 &lt;- mycounts[rowSums(mycounts) != 0,]</code> # 过滤每一行mapping总数为0的基因，将数据集整理命名为mycounts_1</p><p><code>mymeta &lt;- read.csv(&quot;sample_list.csv&quot;,stringsAsFactors = T)</code> # 载入样品列表，遇到字符串将其转化为一个因子</p><p><code>colnames(mycounts_1) == mymeta$id</code> # 检查raw count矩阵第一行是否与样品列表的id列是否一致（如下）。<strong>这个很重要，不一致跑DESeq2会报错</strong>。如果显示false就要调整</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220418154725.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220418154725.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><code>mymeta$index &lt;- factor(mymeta$index,levels = c(&quot;0&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;))</code> # 这一步同样重要，把样本分组文件的分组列转换到因子，不然会报错。我这里的分组是第0天，第1天，第2天和第3天</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dds <span class="operator">&lt;-</span> DESeqDataSetFromMatrix<span class="punctuation">(</span>countData <span class="operator">=</span> mycounts_1<span class="punctuation">,</span></span><br><span class="line">                              colData <span class="operator">=</span> mymeta<span class="punctuation">,</span></span><br><span class="line">                              design <span class="operator">=</span> <span class="operator">~</span>index<span class="punctuation">)</span> </span><br></pre></td></tr></table></figure><p># 中间那一长串是DESeq2包里的函数，countData是raw count定量矩阵，colData是样品列表，design是分组信息，这步是为了<strong>构造</strong>用于差异表达分析的数据集，并将数据集命名为dds</p><p><code>dds &lt;- DESeq(dds)</code>  # <strong>分析的核心DESeq程序</strong></p><p><code>res &lt;- results(dds)</code> # 将结果输出至res数据集</p><p><code>res_1 &lt;- data.frame(res)</code>  # res不是常规的数据，我们可以用head和class命令查看一下（如下图），需要转化成常规的数据框格式才可以对其进行加减列等操作，转换格式后的数据集名字为res_1</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220418153006.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220418153006.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><code>library(&quot;dplyr&quot;)</code>  # 加载这个包是为了对数据框进行操作，我是要增加新的一列统计差异表达情况</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">res_1 <span class="operator">%&gt;%</span>   </span><br><span class="line">  mutate<span class="punctuation">(</span>group <span class="operator">=</span> case_when<span class="punctuation">(</span></span><br><span class="line">    log2FoldChange <span class="operator">&gt;=</span><span class="number">1</span> <span class="operator">&amp;</span> padj <span class="operator">&lt;=</span><span class="number">0.05</span> <span class="operator">~</span> <span class="string">&quot;UP&quot;</span><span class="punctuation">,</span></span><br><span class="line">    log2FoldChange <span class="operator">&lt;=</span><span class="operator">-</span><span class="number">1</span> <span class="operator">&amp;</span> padj <span class="operator">&lt;=</span><span class="number">0.05</span> <span class="operator">~</span> <span class="string">&quot;DOWN&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="literal">TRUE</span> <span class="operator">~</span> <span class="string">&quot;NOT_CHANGE&quot;</span></span><br><span class="line">  <span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">-&gt;</span> res_2</span><br></pre></td></tr></table></figure><p># 调用dplyr包给数据集增加新的一列group，<strong>log2FoldChange &gt;&#x3D;1，padj &lt;&#x3D;0.05，判断这个基因表达为上调，在log2FoldChange &lt;&#x3D;-1，padj &lt;&#x3D;0.05时判断这个基因表达为下调，其余情况为该基因表达情况不变。</strong>将结果输出到res_2数据集。</p><p>FoldChange表示两样品间表达量比值，是倍数变化，差异表达基因分析里，log2 fold change绝对值大于1为差异基因筛选标准。padj是调整后的p值，在p检验里，p值小于0.05是有显著差异的标志。</p><p><code>table(res_2$group)</code> # 查看差异基因表达的结果，上调基因多少，下调基因有多少，不变的有多少</p><p><code>write.csv(res_2,file = &quot;all.csv&quot;, quote = F)</code> # 输出和生成all.csv文件，即为结果文件</p><p>我分别对转录本和基因都运行了DESeq2包做差异分析，</p><p>转录本差异分析如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220418153406.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220418153406.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>基因差异分析如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220418154154.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220418154154.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>基因差异表达情况可以看到，有173个基因表达下调，259个基因表达上调；转录本差异表达情况可以看到，336个上调表达，458个下调表达，数量不一致的情况是因为一个基因中存在多个转录本。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-代码示范&quot;&gt;&lt;a href=&quot;#1-代码示范&quot; class=&quot;headerlink&quot; title=&quot;1. 代码示范&quot;&gt;&lt;/a&gt;1. 代码示范&lt;/h2&gt;&lt;div class=&quot;story post-story&quot;&gt;&lt;p&gt;前面处理好raw count定量表达矩阵，建</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="转录组数据分析" scheme="http://www.shelven.com/categories/%E8%BD%AC%E5%BD%95%E7%BB%84%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
    <category term="DESeq2" scheme="http://www.shelven.com/tags/DESeq2/"/>
    
  </entry>
  
  <entry>
    <title>转录组数据分析笔记（6）——HTseq计数定量</title>
    <link href="http://www.shelven.com/2022/04/17/b.html"/>
    <id>http://www.shelven.com/2022/04/17/b.html</id>
    <published>2022-04-17T15:49:37.000Z</published>
    <updated>2022-04-19T17:06:13.683Z</updated>
    
    <content type="html"><![CDATA[<p>HTseq也是对有参考基因组转录数据进行表达量分析的，主要用于reads计数。这个软件功能就比较专一，不像stringtie还需要运行prepDE.py脚本进行数据转化，直接一步到位。那为什么我一开始不用HTseq呢？<del>因为我遇到一个bug</del> 主要还是运算速度的问题，我比较了两种定量方式，HTseq定量虽然只有一步，但是速度远不如stringtie，也可能是我的问题，下面会说到。</p><h2 id="1-HTseq定量获得raw-count"><a href="#1-HTseq定量获得raw-count" class="headerlink" title="1. HTseq定量获得raw count"></a>1. HTseq定量获得raw count</h2><div class="story post-story"><p>vim一个新脚本，输入如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">for i in `seq 194 209`</span><br><span class="line">do </span><br><span class="line">    htseq-count -f bam -s no \</span><br><span class="line">    /media/sf_/data/fastq/bam/ERR1698&quot;$i&quot;.bam \     # 输入bam文件</span><br><span class="line">    /media/sf_/data/ref/Arabidopis_thaliana.gtf     # 参考基因组注释文件</span><br><span class="line">    &gt; /media/sf_/data/fastq/count/ERR1698&quot;$i&quot;.count     # 自定义输出文件</span><br><span class="line">done</span><br></pre></td></tr></table></figure><div class="note "><p><strong>参数详解</strong></p><p>-f  # 设置输入文件格式，可以是bam或者sam<br>-s  # 设置是否是链特异性测序，设置no每一条reads都会和正义链和反义链进行比较</p></div><p>保存运行以后发现这个程序只能分配一个线程（也可能是我没找到分线程的方法），所以可以根据电脑内核数分几个批处理一起运行会快很多（不然就等着干瞪眼&#x3D; &#x3D;）。</p><p>还有一点非常重要！<strong>bam文件需要提前按照名称排序</strong>，不然会出现绝大部分reads mapping不到参考基因组，这种情况会在屏幕上输出提示信息，但是程序还是会继续跑……这时候就别犹豫了赶紧kill这个程序，就算跑完了数据都不能用。可以用<strong>samtools sort -n</strong>对bam文件进行名称排序，但是排序之后<strong>无法再用samtools index建立索引文件</strong>，这会导致HTseq运行速度比蜗牛还慢。暂时没找到更好的办法 <del>摊手</del>。</p><p>经过漫长长长长长的时间等待，我们可以看看结果文件的head和tail（这里就放一张图吧）：</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220417235405.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220417235405.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>前面记录了基因名称和mapping上的reads数，最后5行对应不同的mapping情况，在不同的模式下意义不同，官网给出的区别如下图，默认是union模式：</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220417235652.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220417235652.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>计数结果也可以用multiqc合并，生成在线报告，这里可以直观地看到每个样品比对上的reads数百分比，这里16个样品的比对率都超过<emp>80%</emp>，说明计数结果都还不错。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220418005645.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220418005645.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div><h2 id="2-HTseq结果文件处理"><a href="#2-HTseq结果文件处理" class="headerlink" title="2. HTseq结果文件处理"></a>2. HTseq结果文件处理</h2><div class="story post-story"><p>HTseq计数定量后得到的是每一个样品的每个基因reads数，我们需要合并每个样品定量数据，<strong>手动修改成DESeq2能识别的raw count表达矩阵，还需要再准备一个样本列表矩阵</strong>，才能进行后续的DESeq分析。参考一下stringtie最后生成的表达量矩阵文件，我们也需要将HTseq定量结果整理成csv格式（逗号作为分隔符），第一列是基因名，后面是按照样品序列的排序，中间是表达矩阵。</p><p>再来看一看HTseq定量生成的文件详情，同样第一列是基因名，后面是raw count数量，^I 表示两列数据是以制表符tab键分隔的，$为换行符。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220418013441.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220418013441.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>我的方法比较笨比，除第一个ERR1698194.count文件保留外，其他所有count文件第一列删去并命名为cut.count，然后合并ERR1698194.count和其他所有cut.count文件，再将所有的制表符替换为逗号，最后加上第一行行名和改文件名。</p><p>用awk命令删除第一列，写入到新的cut.count文件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for i in `seq 195 209`</span><br><span class="line">do </span><br><span class="line">    cat ERR1698&quot;$i&quot;.count | awk &#x27;&#123;$1 = &quot;&quot;; print $0&#125;&#x27; &gt; ERR1698&quot;$i&quot;cut.count</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>paste组合ERR1698194样品和其他cut.count文件到alldata.count:</p><p><code>$ paste ERR1698194.count *cut.count &gt; alldata.count</code></p><p>看看alldata.count的数据格式，列数没有问题，但是awk删除列产生了空格：</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220418014618.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220418014618.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>用sed命令删除所有空格，替换所有制表符为逗号（两步可以合一步）：</p><p><code>$ sed &#39;s/ //g&#39; alldata.count &gt; alldata1.count</code></p><p><code>$ sed &#39;s/\t/,/g&#39; alldata1.count &gt; alldata2.count</code></p><p>这样就手动生成符合csv格式的文件了，只需加上第一行：</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220418014916.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220418014916.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>这里样本量比较少，我直接vim复制粘贴的方法加了第一行，重命名一下文件就完成了表达矩阵的制作，可以用于DESeq2分析了！</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220418014948.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220418014948.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>因为本人比较小白，上面处理过程就有些啰嗦了，总的思路就是改成csv格式文件的样式就可以。</p><p>样本列表矩阵的制作过程和stringtie一模一样，<a href="https://www.shelven.com/2022/04/17/a.html">点击这里查看</a>，本篇不再赘述。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;HTseq也是对有参考基因组转录数据进行表达量分析的，主要用于reads计数。这个软件功能就比较专一，不像stringtie还需要运行prepDE.py脚本进行数据转化，直接一步到位。那为什么我一开始不用HTseq呢？&lt;del&gt;因为我遇到一个bug&lt;/del&gt; 主要还是运算</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="转录组数据分析" scheme="http://www.shelven.com/categories/%E8%BD%AC%E5%BD%95%E7%BB%84%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
    <category term="HTseq" scheme="http://www.shelven.com/tags/HTseq/"/>
    
  </entry>
  
  <entry>
    <title>转录组数据分析笔记（5）——stringtie转录本组装和定量</title>
    <link href="http://www.shelven.com/2022/04/17/a.html"/>
    <id>http://www.shelven.com/2022/04/17/a.html</id>
    <published>2022-04-17T15:14:21.000Z</published>
    <updated>2022-04-19T17:05:56.688Z</updated>
    
    <content type="html"><![CDATA[<h2 id="stringtie转录本组装和定量"><a href="#stringtie转录本组装和定量" class="headerlink" title="stringtie转录本组装和定量"></a>stringtie转录本组装和定量</h2><div class="story post-story"><h3 id="1-转录本组装"><a href="#1-转录本组装" class="headerlink" title="1 转录本组装"></a>1 转录本组装</h3><p>Stringtie是一个基因和转录本组装定量的软件，stringtie的输入文件有两个，一个是经过<strong>排序</strong>的bam文件，排序可以用前面说到的samtools sort命令完成，还有一个是参考基因组的注释文件（gff或gtf格式）。</p><p>在使用Stringtie进行基因或者转录本组装定量的过程中，有一个非常重要的参数 <strong>- e</strong>，我之前跑了一遍流程没有加参数-e，结果组装的结果非常差，还有大量的未注释的基因。我请教了度娘，网上的教程攻略也都是抄来抄去的没解决什么问题，官网只有这么一句解释：</p><blockquote><p>-e    this option directs StringTie to operate in expression estimation mode; this limits the processing of read alignments to estimating the coverage of the transcripts given with the <code>-G</code> option (hence this option requires <code>-G</code>).</p></blockquote><p>对于加了参数-e之后如何做的比对和组装处理还是不明了，不知道表达评估模式的原理是什么，只能自己做个大概的总结（不知正确与否）：</p><div class="note "><p><strong></strong></p><ol><li>如果我们研究的样本没有很好的注释信息，研究的人少，现有的注释信息都不完善，那么我们就需要重建转录本进行注释，这个时候就不需要加参数-e。</li><li>如果样品的注释信息非常完整，比如拟南芥这种模式生物，我们不需要重建新的转录本进行注释，只对现有的参考基因组注释文件就足够了，那就要用-e参数，不需要预测新的转录本。</div></li></ol><p>-e参数还有个比较重要的地方，<strong>只有用了-e参数后，才可以运行prepDE.py3脚本得到read count矩阵</strong>（也就是进行定量），这个脚本后面会说。</p><hr><p>我们首先创建一个shell脚本进行转录本组装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">for i in `seq 194 209`</span><br><span class="line">do</span><br><span class="line">    stringtie -p 4 -e \</span><br><span class="line">    -G /media/sf_/data/ref/Arabidopis_thaliana.gtf \    # 参考基因组注释文件</span><br><span class="line">    -o /media/sf_/data/fastq/gtf/ERR1698&quot;$i&quot;.gtf \      # 自定义输出文件</span><br><span class="line">    /media/sf_/data/fastq/bam/ERR1698&quot;$i&quot;.bam   # 输入的bam文件</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>保存，运行，我们可以得到.gtf格式文件，less一下查看里面的内容：</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/QQ%E6%88%AA%E5%9B%BE20220417215153.jpg" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/QQ%E6%88%AA%E5%9B%BE20220417215153.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>我们这里因为加了参数-e，不会有新的基因和转录本，可以看到每个read比对上的基因的信息。（不加参数-e会组装<strong>新基因和转录本</strong>，默认采用STRG加数字编号进行区分）。每行数据会给出<strong>coverage</strong>，<strong>FPKM</strong>和<strong>TPM</strong>三个信息，后两者都可以用来定量。FPKM和TPM都是对read counts数目进行的标准化，如果是单端测序数据可以用RPKM进行标准化，不进行数据标准化的比较是没有意义的。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/ethwtjyj.jpg" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/ethwtjyj.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/%E6%96%87gnwn%E5%8C%96%E4%B8%BA.jpg" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/%E6%96%87gnwn%E5%8C%96%E4%B8%BA.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/%E6%B8%B8%E5%AE%A2%E4%BD%93sfns%E9%AA%8C%E7%9C%8B%E5%9B%BE.jpg" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/%E6%B8%B8%E5%AE%A2%E4%BD%93sfns%E9%AA%8C%E7%9C%8B%E5%9B%BE.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><hr><h3 id="2-合并转录本-重构转录本才需要"><a href="#2-合并转录本-重构转录本才需要" class="headerlink" title="2 合并转录本(重构转录本才需要)"></a>2 合并转录本(重构转录本才需要)</h3><p>这一步要注意下，如果需要重构转录本才需要<strong>合并</strong>所有的转录本的组装结果，得到一个非冗余的转录本合集，也就是获得跨多个RNA-seq样品的全局的转录本。这里需要分两步：</p><p><code>$ ls *.gtf &gt; mergelist.txt     # 将所有组装的转录本文件名合并到一个文件</code></p><p><code>$ stringtie --merge -p 4 -G /media/sf_/data/ref/Arabidopis_thaliana.gtf -o merge.gtf ./mergelist.txt   #这一步是用--merge指令将所有转录本合并输出到merge.gtf文件中</code></p><p>我们最后得到的merge.gtf就是全局的转录本。这里只是记录一下这步操作，我们只关注参考基因组的注释结果就不需要merge。</p><hr><h3 id="3-获得定量表达矩阵"><a href="#3-获得定量表达矩阵" class="headerlink" title="3 获得定量表达矩阵"></a>3 获得定量表达矩阵</h3><p>DESeq2要求输入的定量结果为raw count形式，raw count是根据mapping到基因或转录本的reads数计算得到，而stringtie只提供了转录本水平的表达量，定量方式包括TPM和FPKM值两种。为了进行raw count定量，stringtie官方提供了prepDE.py脚本（两个版本，我选择的python 3版本，在我base环境下不会冲突），可以计算出raw count的表达量。</p><p>下载这个python脚本，如果你用的是windows浏览器，在官网找到脚本直接右键复制链接，用wget直接下到linux系统里，<strong>千万不要在windows上直接复制粘贴代码过去</strong>。因为windows的换行符和linux的不一样，两个系统间直接粘贴代码会出现错行和莫名其妙的缩进导致程序报错（可以用cat -A看两个系统换行符的区别，血的教训，排查了老半天才发现）推荐用prepDE.py3，不用再切python 2 的环境了。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/stjssjrsjjjjs.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/stjssjrsjjjjs.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>官方给出的prepDE.py脚本有两种运行方式（如下图所示），一种是建立Ballgown能识别的目录结构，一种是建立sample_lst文件并指定所有样品数据的路径。两种方法都可行，Ballgown现在用的比较少，比较主流的还是Stringtie+DESeq2的分析方法。演示一下如何创建sample_lst和解释一下这个文件要求的格式。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/46uij.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/46uij.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="3-1-sample-lst文件准备"><a href="#3-1-sample-lst文件准备" class="headerlink" title="3.1 sample_lst文件准备"></a>3.1 sample_lst文件准备</h4><p>简单来说，sample_lst.txt要求第一列为样品编号，第二列为对应编号的样品gtf文件所在路径，中间用<strong>制表符tab</strong>隔开，如下图（命名不一定要完全一样，注意格式，后面要导入prepDE脚本，能找到就行）：</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220418211607.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220418211607.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>这个文件准备工作比较简单，不再赘述</p><h4 id="3-2-运行prepDE-py3"><a href="#3-2-运行prepDE-py3" class="headerlink" title="3.2 运行prepDE.py3"></a>3.2 运行prepDE.py3</h4><p>将prepDE.py3脚本放在上面gtf文件的目录下，运行以下命令：</p><p><code>$ python prepDE.py3 -i sample_lst.txt -g gene_count_matrix.csv -t transcript_count_matrix.csv</code></p><p>解释一下：</p><div class="note "><p><strong>参数含义</strong></p><p>-i  # 输入文件，就是前面做的sample_lst.txt<br>-g  # 自定义基因组表达矩阵名字，默认也是gene_count_matrix.csv<br>-t  # 自定义转录本表达矩阵名字，默认也是transcript_count_matrix.csv</p></div><p>得到的这两个文件就是基因和转录水平的raw count表达量矩阵，我们都可以用于后面的DESeq2分析。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220417225037.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220417225037.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><hr></div><h2 id="4-制作样本列表矩阵"><a href="#4-制作样本列表矩阵" class="headerlink" title="4. 制作样本列表矩阵"></a>4. 制作样本列表矩阵</h2><div class="story post-story"><p>这里需要和前面为了运行prepDE.py脚本而制作的sample_lst文件区分开，要做下一步DESeq2差异基因分析，我们需要自己手动创建一个DESeq2能识别的样本列表矩阵，包含两列信息：一列是样本名称，一列是样本分组。样本分组信息我们可以直接从下载样本数据的地方（EBI官网）得到，只需要自己改一下格式。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220417225800.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220417225800.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>下载之后发现第一行标题特别长，稍微处理下制表符替换成换行符，将第一行标题拆分成每个字段一行的格式，找一下不同天数处理的分组信息关键字“time”，发现我们要的分组信息在第36行（也就是原来文件的第36列）：</p><p><code>$ head -n1 E-MTAB-5130.sdrf.txt | tr &#39;\t&#39; &#39;\n&#39; | nl | grep &quot;time&quot;</code></p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220417225856.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220417225856.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>同样的方法找样本信息所在列是32列：</p><p><code>$ head -n1 E-MTAB-5130.sdrf.txt | tr &#39;\t&#39; &#39;\n&#39; | nl | grep &quot;ENA&quot;</code></p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220417225952.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220417225952.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>所以我们需要提取第32列和第36列，用cut命令切割并重定向到新的文件sample_list:</p><p><code>$ cut -f 32,36 E-MTAB-5130.sdrf.txt &gt; sample_list.csv</code></p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220417230231.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220417230231.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>发现相邻数据有重复，uniq删除重复行，再用sed替换制表符为逗号（因为csv文件就是以逗号作为分隔符），将原来的sample_list.csv覆盖，vim手动修改一下第一行名字，完成后就可以用于DESeq2分析了！</p><p><code>$ uniq sample_list.csv &gt; sample_list1.csv  # uniq删除重复行</code></p><p><code>$ sed &#39;s/\t/,/g&#39; sample_list1.csv &gt; sample_list .csv   # 替换制表符为逗号</code></p><p>手动修改sample_list .csv第一行内容，修改之后如下即可</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220417231146.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220417231146.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;stringtie转录本组装和定量&quot;&gt;&lt;a href=&quot;#stringtie转录本组装和定量&quot; class=&quot;headerlink&quot; title=&quot;stringtie转录本组装和定量&quot;&gt;&lt;/a&gt;stringtie转录本组装和定量&lt;/h2&gt;&lt;div class=&quot;s</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="转录组数据分析" scheme="http://www.shelven.com/categories/%E8%BD%AC%E5%BD%95%E7%BB%84%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
    <category term="stringtie" scheme="http://www.shelven.com/tags/stringtie/"/>
    
    <category term="prepDE.py3" scheme="http://www.shelven.com/tags/prepDE-py3/"/>
    
  </entry>
  
  <entry>
    <title>转录组数据分析笔记（4）——IGV基因组浏览器安装和解读</title>
    <link href="http://www.shelven.com/2022/04/16/b.html"/>
    <id>http://www.shelven.com/2022/04/16/b.html</id>
    <published>2022-04-16T11:32:50.000Z</published>
    <updated>2022-04-16T11:37:33.011Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-IGV软件下载"><a href="#1-IGV软件下载" class="headerlink" title="1. IGV软件下载"></a>1. IGV软件下载</h2><div class="story post-story"><p>IGV（Integrative Genomics Viewer）是一个非常方便的比对软件，在使用前只需要将参考基因组和bam文件分别建立索引（即建立fai和bai文件）并载入，就可以对转录组测序数据进行可视化浏览。对比samtools tview功能，这个软件有交互式操作界面，对萌新非常友好。</p><p>直接上百度搜就能找到IGV官网，选择linux版本或者windows版本都行，这里用linux版本为例，IGV只支持JAVA11版本，不用担心这个问题，下载的安装包里直接有JAVA11，解压就可以用，就是国外网站下载有点慢<del>（科学上网）</del>。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/%E7%87%83%E7%83%A7%E5%86%9B%E5%9B%A2%E6%98%AF.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/%E7%87%83%E7%83%A7%E5%86%9B%E5%9B%A2%E6%98%AF.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>直接在虚拟机里解压打开，运行igv.sh，会自动准备好JAVA11的运行环境，成功弹出交互式界面（终于告别了黑漆漆的命令行 <span><img src='https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/tieba/%E6%BB%91%E7%A8%BD.png' style='height:24px'></span>）。</p></div><h2 id="2-导入文件"><a href="#2-导入文件" class="headerlink" title="2. 导入文件"></a>2. 导入文件</h2><div class="story post-story"><p>Genomes菜单栏上传<strong>建立索引</strong>的参考基因组.fa和.fai文件：</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/%E6%96%87%E5%8C%96%E4%B8%BA.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/%E6%96%87%E5%8C%96%E4%B8%BA.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><hr><p>File菜单栏上传<strong>排序并建立索引</strong>的.bam和.bai文件：</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/45645%E5%92%8C.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/45645%E5%92%8C.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><hr><p>如果有参考基因组注释文件，同样可以导入进去，同样导入前需要sort排序和建立index，可以用菜单栏里的igvtools直接sort和index：</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/%E4%BA%BA%E5%BE%88%E5%B0%91.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/%E4%BA%BA%E5%BE%88%E5%B0%91.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div><h2 id="3-界面解读"><a href="#3-界面解读" class="headerlink" title="3. 界面解读"></a>3. 界面解读</h2><div class="story post-story"><p>我导入了5组bam数据，所有文件导入后可以看到如下界面，简单介绍一下各个区域和功能：</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/%E4%BA%8C%E7%BA%A7%E5%90%88%E5%90%8C%E9%87%91%E9%A2%9D%E5%95%8A.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/%E4%BA%8C%E7%BA%A7%E5%90%88%E5%90%8C%E9%87%91%E9%A2%9D%E5%95%8A.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><hr><p>主页面获得的信息有限，我们选取第3条染色体为例，将其放大：</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/35724575.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/35724575.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><hr><p>中间的界面可以通过左右拖动鼠标，或者按左右方向键来浏览染色体上的比对情况。我们在搜索框中直接搜基因名字进行染色体定位，比如CIPK家族中的CIPK7基因，回车后双击最后一栏基因注释文件中的基因名称CIPK7，可以得到详细的CIPK7基因信息<strong>（这里注意下，如果双击弹出来多个可供选择的片段的话，代表这个基因存在可变剪切）</strong>:</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/4362436%E5%85%B67.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/4362436%E5%85%B67.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><hr><p>在基因注释区右键，选择expanded，可以将CIPK7基因的所有转录本显示出来。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/3472572.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/3472572.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><hr><p>放大到一定程度后，我们可以看到基因注释区上方出现了核苷酸序列和氨基酸序列，我们可以点击sequence旁边的箭头，切换到另一条链的序列。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/%E5%91%B5%E5%91%B5%E5%95%8A.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/%E5%91%B5%E5%91%B5%E5%95%8A.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><hr><p>点击核苷酸，会出现三行，分别表示不同起始位点的核苷酸翻译结果，绿色为起始密码子，红色的星号表示终止密码子。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/4365486795.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/4365486795.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><hr><p>再来看看放大后的tracks区域，bam文件在载入后会默认生成两个tracks，一个显示测序深度（<strong>Coverage track</strong>，可以对比下<u>samtools depth</u>），一个显示比对情况（<strong>Alignment track</strong>），我们放大其中一个样本的数据信息。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/11122333.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/11122333.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>Coverage track区域灰色代表质量好，如果reads中某核苷酸与参考序列超过20%不一致的时候，IGV会根据四个碱基的计数对coverage的条形图进行着色。这里可以看到该位点处有20个reads覆盖到，8条reads测的是C核苷酸，12条reads测的是T核苷酸。如果某个位置coverage条形图只有一种颜色，即该位点测的核苷酸和参考序列完全不一样，那说明该位点是<span class='p red'>SNP位点</span>。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/%E7%81%AF%E5%85%89%E8%BE%83%E6%9A%97%E7%9A%84%E6%84%9F%E8%A7%89%E5%95%8A.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/%E7%81%AF%E5%85%89%E8%BE%83%E6%9A%97%E7%9A%84%E6%84%9F%E8%A7%89%E5%95%8A.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><hr><p>Alignment tracks柱形图是和bam文件中的数据一一对应的，举个例子，我在IGV软件的ERR1698206.bam可以看到在第3条染色体位置8173028有3条reads。虚拟机中找到这个bam文件，直接samtools view查看并grep这个位置，可以找到3条定位的reads（还有三条是配对的另一条链）。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/QQ%E6%88%AA%E5%9B%BE20220416192308.jpg" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/QQ%E6%88%AA%E5%9B%BE20220416192308.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><hr><p>如果一条reads中间有缺失，IGV会用黑色横杠表示，中间数字表示缺失几个核苷酸。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/%E5%95%8A%E5%95%8A%E5%95%8A%E5%95%8A%E5%95%8A%E5%95%8A%E5%95%8A%E9%98%BF%E4%B8%89%E5%A3%AB%E5%A4%A7%E5%A4%AB%E5%B1%B1%E8%B1%86%E6%A0%B9.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/%E5%95%8A%E5%95%8A%E5%95%8A%E5%95%8A%E5%95%8A%E5%95%8A%E5%95%8A%E9%98%BF%E4%B8%89%E5%A3%AB%E5%A4%A7%E5%A4%AB%E5%B1%B1%E8%B1%86%E6%A0%B9.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><hr><p>IGV还用不同颜色标记异常的插入片段大小的reads，这里做的是RNA-seq数据比对，不用看reads颜色，有些reads还在质控的时候被裁短了，变成蓝色很正常（<u>因为比预期短，个人理解是这样，有待考证？</u>）。以下是官网的默认着色方案：</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/a1029731a0e61326140cb74b369fc3fb.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/a1029731a0e61326140cb74b369fc3fb.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-IGV软件下载&quot;&gt;&lt;a href=&quot;#1-IGV软件下载&quot; class=&quot;headerlink&quot; title=&quot;1. IGV软件下载&quot;&gt;&lt;/a&gt;1. IGV软件下载&lt;/h2&gt;&lt;div class=&quot;story post-story&quot;&gt;&lt;p&gt;IGV（Integr</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="转录组数据分析" scheme="http://www.shelven.com/categories/%E8%BD%AC%E5%BD%95%E7%BB%84%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
    <category term="IGV" scheme="http://www.shelven.com/tags/IGV/"/>
    
  </entry>
  
  <entry>
    <title>转录组数据分析笔记（3）——samtools用法小结</title>
    <link href="http://www.shelven.com/2022/04/16/a.html"/>
    <id>http://www.shelven.com/2022/04/16/a.html</id>
    <published>2022-04-16T10:41:24.000Z</published>
    <updated>2022-04-20T04:54:51.829Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-sam文件转化bam"><a href="#1-sam文件转化bam" class="headerlink" title="1. sam文件转化bam"></a>1. sam文件转化bam</h2><div class="story post-story"><p>bam文件是二进制文件，占用磁盘空间小，运算速度快，samtools操作是针对bam文件的，所以我们要进行数据转化。samtools sort指令可以将bam文件进行排序，这个指令同时也可以将sam文件转化成bam文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">ls *.sam | while read id</span><br><span class="line">do</span><br><span class="line">    samtools sort -l 0 -@ 5 -o $(basename $id &quot;.sam&quot;).bam $id     # 指定输出文件，改后缀.bam</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>运行脚本，将当前目录的sam文件全转换成bam文件并排序（<strong>这里的排序不是按名称，用HTseq还要再按照read名称排序，使用参数-n）</strong>。</p><div class="note "><p><strong>samtools sort参数</strong></p><p>samtools sort   # 对bam文件进行排序（sam文件排序不会变）<br>-l  # 设置输出文件压缩等级，0-9，0是不压缩,9是最高等级压缩<br>-@  # 设置线程数<br>-o  # 设置排序后输出的文件名<br>最后接输入的bam或者sam格式文件</p></div></div><h2 id="2-构建索引文件"><a href="#2-构建索引文件" class="headerlink" title="2. 构建索引文件"></a>2. 构建索引文件</h2><div class="story post-story"><h3 id="2-1-构建bam文件索引"><a href="#2-1-构建bam文件索引" class="headerlink" title="2.1 构建bam文件索引"></a>2.1 构建bam文件索引</h3><p>在bam文件目录下，<strong>排序后</strong>的bam文件可以建立索引：</p><p><code>$ ls *.bam | xargs -i samtools index &#123;&#125;</code></p><p>注意下xargs -i的用法，和管道不一样，是传递参数给后一个命令的花括号中，后一个命令中不存在歧义的时候可省略参数-i和花括号。</p><p>如图生成的bai文件就是索引文件。其实到了这一步，前面的sam文件就可以删除（节省电脑空间），只留下bam文件就行，bam文件无法直接查看，可以通过samtools view命令查看bam文件。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/QQ%E6%88%AA%E5%9B%BE20220416174957.jpg" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/QQ%E6%88%AA%E5%9B%BE20220416174957.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="2-2-构建参考基因组fa文件索引"><a href="#2-2-构建参考基因组fa文件索引" class="headerlink" title="2.2 构建参考基因组fa文件索引"></a>2.2 构建参考基因组fa文件索引</h3><p>在参考基因组文件目录下，对参考基因组的fa文件建立索引：</p><p><code>$ samtools faidx Arabidopsis_thaliana.dna.genome.fa</code></p><p>参考基因组文件名注意改成自己的，生成的索引文件是.fai结尾的</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/QQ%E6%88%AA%E5%9B%BE20220416180041.jpg" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/QQ%E6%88%AA%E5%9B%BE20220416180041.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div><h2 id="3-bam文件qc质控"><a href="#3-bam文件qc质控" class="headerlink" title="3. bam文件qc质控"></a>3. bam文件qc质控</h2><div class="story post-story"><p>samtools转化生成的bam文件需要进行质控，看看比对情况如何。在bam文件目录下，我们创建一个samtools自带qc质控指令samtools flagstat运行脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">ls *.bam | while read id</span><br><span class="line">do</span><br><span class="line">    samtools flastat -@ 4 $id &gt; $(basename $id &quot;.bam&quot;).flagstat     # 自定义输出文件</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p><code>$ samtools flagstat bam文件 &gt; 输出文件     # 这种格式，其他参数都一样</code> </p><p>运行脚本文件可以获得16个.flagstat质控文件，和fastqc一样，我们还可以做完后用multiqc命令集合成一个html格式的总的qc报告网页。和fastqc不同之处是，fastqc是做下机数据质控，samtools是做比对参考基因组的质控。如下图所示，可以比较直观地看出大部分reads都是map上的。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/%E5%B7%A5%E5%95%86%E9%87%91%E8%9E%8D%E7%95%8C.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/%E5%B7%A5%E5%95%86%E9%87%91%E8%9E%8D%E7%95%8C.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>生成的每一个flagstat文件我们也可以直接点开。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/QQ%E6%88%AA%E5%9B%BE20220416181848.jpg" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/QQ%E6%88%AA%E5%9B%BE20220416181848.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>每一行统计数据都是以通过QC的reads数量和未通过QC的reads数量组成，以我点开的这个文件为例，主要信息有以下几个：</p><div class="note "><p><strong></strong></p><p>13992629个reads都是合格的<br>12328290个reads只比对到参考基因组一个位置上<br>13988737个reads比对到参考基因组（99.97%）<br>12332182个reads是成对的<br>12201338个reads可以正确配对（98.94%）<br>2846条reads成对但只有一条能比对上参考基因组<br>12398个配对的reads可以比对到别的染色体上</p></div><p>可以自己将所有的flagstat运行结束后的文件放在一个目录下，运用paste命令全部按列粘贴在一起，用cut或者awk提取所需的列数据自己做比对情况表格，这里不再赘述。</p></div><h2 id="4-samtools其他指令"><a href="#4-samtools其他指令" class="headerlink" title="4. samtools其他指令"></a>4. samtools其他指令</h2><div class="story post-story"><p>简单介绍一下：</p><p><code>$ samtools view ERR1698194.bam     #查看bam文件（不能直接cat查看二进制文件）</code></p><p><code>$ samtools tview ERR1698194.bam    #类似于IGV这种基因组浏览器，但是非交互式界面（下图）不直观，我们一般都是用IGV查看基因组</code></p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/QQ%E6%88%AA%E5%9B%BE20220416182944.jpg" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/QQ%E6%88%AA%E5%9B%BE20220416182944.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>其他还有samtools merge（合并所有bam文件到一个文件），samtools depth（得到每个碱基位点或者区域的测序深度,并输出到标准输出）等等，不是特别常用，这里就不介绍了。</p><p>在步骤2中构建的索引文件可以导入IGV中，对转录组每个read mapping情况进行可视化浏览，下个笔记将介绍IGV的用法。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-sam文件转化bam&quot;&gt;&lt;a href=&quot;#1-sam文件转化bam&quot; class=&quot;headerlink&quot; title=&quot;1. sam文件转化bam&quot;&gt;&lt;/a&gt;1. sam文件转化bam&lt;/h2&gt;&lt;div class=&quot;story post-story&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="转录组数据分析" scheme="http://www.shelven.com/categories/%E8%BD%AC%E5%BD%95%E7%BB%84%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
    <category term="samtools" scheme="http://www.shelven.com/tags/samtools/"/>
    
  </entry>
  
  <entry>
    <title>转录组数据分析笔记（2）——使用Hisat2比对参考基因组</title>
    <link href="http://www.shelven.com/2022/04/15/a.html"/>
    <id>http://www.shelven.com/2022/04/15/a.html</id>
    <published>2022-04-15T08:53:41.000Z</published>
    <updated>2022-04-19T17:04:40.287Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-建立参考基因组索引"><a href="#1-建立参考基因组索引" class="headerlink" title="1. 建立参考基因组索引"></a>1. 建立参考基因组索引</h2><div class="story post-story"><p>在进行clean data与参考基因组比对之前，我们需要先建立参考基因组索引。进入下载好参考基因组的文件目录下，运行命令：</p><p><code>$ hisat2-build Arabidopsis_thaliana.dna.genome.fa genome</code></p><div class="note info"><p>-p # 以几个线程运行，与电脑核数或者分配虚拟机的核数有关<br >genome # 命名的索引文件名，可以改成自己能找到的</p></div><p>就可以在当前目录建立参考基因组索引文件，hisat2固定会生成8个以.ht2做后缀名的索引文件，如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/QQ%E6%88%AA%E5%9B%BE2022dhkdk041tweaaeheqhh.jpg" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/QQ%E6%88%AA%E5%9B%BE2022dhkdk041tweaaeheqhh.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>需要注意的一点，比对软件除了hiasat2以外，还有subjunk、bwa、bowtie2等等，<strong>各个比对软件生成的索引文件是不同的</strong>，不能相互混用，命名的时候注意区分各种比对工具。</p></div><h2 id="2-clean-data与参考基因组比对"><a href="#2-clean-data与参考基因组比对" class="headerlink" title="2. clean data与参考基因组比对"></a>2. clean data与参考基因组比对</h2><div class="story post-story"><p>比对的意思是将每一个read与参考基因组序列进行对比，目的是得到每一个read在参考基因组上的位置信息，有了这个基础的位置信息才可以进行后续基因或者转录本的定量，最终由定量结果做差异表达矩阵，分析上调或者下调的基因数量。</p><p>新建一个shell脚本输入下面的代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">for i in `seq 194 209`</span><br><span class="line">do</span><br><span class="line">    hisat2 -p 4 -x /media/sf_example/data/ref/genome \  #索引文件绝对路径</span><br><span class="line">    -1 /media/sf_example/data/clean_data/ERR1698&quot;$i&quot;_1.fq.gz \</span><br><span class="line">    -2 /media/sf_example/data/clean_data/ERR1698&quot;$i&quot;_2.fq.gz \</span><br><span class="line">    -S /media/sf_example/data/hisat2_sam/ERR1698&quot;$i&quot;.sam    #注意大写的S</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>参数解释：</p><div class="note info"><p>-p # 同样是配置线程数<br >-x # 指定索引文件，需要定义索引文件名称，不能加后缀，不能只定义到索引文件所在目录<br >-1 # 第一端测序数据文件<br >-2 # 第二端测序数据文件<br >-S # 指定输出目录和文件，不指定会刷屏，<strong>注意是大写的S</strong></p></div><p>输出到屏幕的结果如下，我们选取其中一个进行解读：</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/QQ%E6%88%AA%E5%9B%BE20220415150423.jpg" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/QQ%E6%88%AA%E5%9B%BE20220415150423.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>共有6166091对测序数据，都是双侧测序数据，其中：</p><div class='checkbox'><input type="checkbox" />            <p>read1 和 read2 没有合理比对上参考基因组序列的有65259对，占1.06%</p>            </div><div class='checkbox'><input type="checkbox" />            <p>read1 和 read2 只有一条比对上参考基因组序列的有5698903对，占92.42%，<strong>这部分reads数需要占测序reads的绝大多数才正常</strong></p>            </div><div class='checkbox'><input type="checkbox" />            <p>read1 和 read2 可以同时比对到多个地方的有401929对，占6.52%</p>            </div><div class='checkbox'><input type="checkbox" />            <p>65259对没有合理比对上的序列中，55871对可以不合理地比对上一次</p>            </div><p>最后一块是对两条链拆开比对的结果，这个一般用不到，本来测序的两条reads就应该比对到同一个染色体同一个基因附近，拆开比对到不同染色体没有意义。我们要看的是最后一句话，总比对率为99.97%，通常比对率大于90%说明比对情况较好，与参考基因组基本吻合。</p></div><h2 id="3-sam文件解读"><a href="#3-sam文件解读" class="headerlink" title="3. sam文件解读"></a>3. sam文件解读</h2><div class="story post-story"><p>比对结果除了有屏幕上输出的总体报告外，还有记录详细比对结果的sam文件。双端测序的比对会将两个测序文件进行整合和比较，最后只生成一个sam文件，因此这个sam文件非常大，hisat2比对生成的sam文件可以直接打开。我们可以选取一部分进行解读。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/QQ%E6%88%AA%E5%9B%BE20220415153505.jpg" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/QQ%E6%88%AA%E5%9B%BE20220415153505.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><div class='checkbox checked'><input type="radio" checked="checked"/>            <p><strong>@HD VN:1.0 SO:unsorted （排序类型）</strong></p>            </div><p>VN是格式版本；SO表示比对排序的类型，有unknown，unsorted，queryname和coordinate几种。samtools软件在进行行排序后不能自动更新sam文件的SO值。</p><div class='checkbox checked'><input type="radio" checked="checked"/>            <p><strong>@SQ SN:1 LN:30427671 （序列ID及长度）</strong></p>            </div><p>参考序列名，这些参考序列决定了比对结果sort的顺序，SN是参考序列名；LN是参考序列长度；每个参考序列为一行。这里表示拟南芥有5条染色体，对应长度都在后面，Mt是线粒体基因，Pt是叶绿体基因。</p><div class='checkbox checked'><input type="radio" checked="checked"/>            <p><strong>@PG ID:hisat2 PN:hisat2 VN:2.2.1 （比对所使用的软件及版本</strong>）</p>            </div><p>这里包括了路径，方法，以及我质控后的序列长度（50-100）等详细信息。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/QQ%E6%88%AA%E5%9B%BE20220415154521.jpg" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/QQ%E6%88%AA%E5%9B%BE20220415154521.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><div class='checkbox checked'><input type="radio" checked="checked"/>            <p><strong>接下来每行都是一长串，显示的是比对结果部分，11个字段（列）</strong></p>            </div><div class='checkbox'><input type="checkbox" />            <p>第一列：QNAME：测序出来的reads序列数据名，ERR1698194.2</p>            </div><div class='checkbox'><input type="checkbox" />            <p>第二列：FLAG：表明比对类型：paring，strand，mate strand等</p>            </div><div class='checkbox'><input type="checkbox" />            <p>第三列：RNAME：参考基因组的染色体名，我这里是第1条染色体</p>            </div><div class='checkbox'><input type="checkbox" />            <p>第四列：POS：比对到这个染色的具体位置，4969</p>            </div><div class='checkbox'><input type="checkbox" />            <p>第五列：MAPQ：比对质量，是一个衡量比对好坏的打分结果，60最好</p>            </div><div class='checkbox'><input type="checkbox" />            <p>第六列：CIGAR：简要比对信息表达式，1S100M是第1个碱基切除，100个匹配</p>            </div><div class='checkbox'><input type="checkbox" />            <p>第七列：RNEXT：另一个序列比对上的参考序列编号，没有另外的片段是*，同一个片段&#x3D;</p>            </div><div class='checkbox'><input type="checkbox" />            <p>第八列：MPOS：另一个序列匹配的染色体具体位置，这里一样也是4969</p>            </div><div class='checkbox'><input type="checkbox" />            <p>第九列：TLEN：配对片段长度，最左边的为正，最右边的为负</p>            </div><div class='checkbox'><input type="checkbox" />            <p>第十列：SEQ：和参考序列在同一个链上比对的序列</p>            </div><div class='checkbox'><input type="checkbox" />            <p>第十一列：QUAL：比对序列的质量和reads碱基质量值</p>            </div><p>后面提供额外的信息，一般不重要，了解一下就行。因为sam文件太大（往往有10G以上），也不适合电脑进行后续处理，所以我们会用到samtools，将sam文件转化为更适合电脑处理的二进制bam文件。这个后面会讲。</p></div><h2 id="4-其他比对软件"><a href="#4-其他比对软件" class="headerlink" title="4. 其他比对软件"></a>4. 其他比对软件</h2><div class="story post-story"><p>以下4种软件均用于序列比对，用法稍有不同，做个记录</p><p><code>$ hisat2 -p 4 -x 索引目录 -1 单端测序数据文件 -2 另一端测序数据文件 -S 输出文件</code></p><p><code>$ subjunk -T 4 -i 索引目录 -r 单端测序数据文件 -R 另一端测序数据文件 -o 输出文件</code></p><p><code>$ bowtie2 -p 4 -x 索引目录 -1 单端测序数据文件 -2 另一端测序数据文件 -S 输出文件</code></p><p><code>$ bwa mem -t 4 -M 索引目录 单端测序数据文件 另一端测序数据文件 &gt; 输出文件</code></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-建立参考基因组索引&quot;&gt;&lt;a href=&quot;#1-建立参考基因组索引&quot; class=&quot;headerlink&quot; title=&quot;1. 建立参考基因组索引&quot;&gt;&lt;/a&gt;1. 建立参考基因组索引&lt;/h2&gt;&lt;div class=&quot;story post-story&quot;&gt;&lt;p&gt;在进</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="转录组数据分析" scheme="http://www.shelven.com/categories/%E8%BD%AC%E5%BD%95%E7%BB%84%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
    <category term="hisat2" scheme="http://www.shelven.com/tags/hisat2/"/>
    
  </entry>
  
  <entry>
    <title>转录组数据分析笔记（1）——如何用fastqc和trim-galore做测序数据质控</title>
    <link href="http://www.shelven.com/2022/04/14/a.html"/>
    <id>http://www.shelven.com/2022/04/14/a.html</id>
    <published>2022-04-14T13:13:35.000Z</published>
    <updated>2022-04-19T17:04:50.761Z</updated>
    
    <content type="html"><![CDATA[<p>本系列学习笔记数据均来自”<strong>Temporal dynamics of gene expression and histone marks at the Arabidopsis shoot meristem during flowering</strong>“，原文用RNA-Seq的方式研究开花阶段，芽分生组织不同时期的基因表达量变化，4个时间段（0, 1, 2, 3），4个重复，共有16个样品。<a href="https://pubmed.ncbi.nlm.nih.gov/28513600/">点击这里获取文献</a></p><hr><h2 id="1-读文章获得RNA-Seq数据"><a href="#1-读文章获得RNA-Seq数据" class="headerlink" title="1. 读文章获得RNA-Seq数据"></a>1. 读文章获得RNA-Seq数据</h2><div class="story post-story"><p>从文章末尾我们可以获得一些测序数据信息：</p><blockquote><p>Data availability. ChIP-seq and RNA-seq data have been deposited with ArrayExpress database (<a href="http://www.ebi.ac.uk/arrayexpress">www.ebi.ac.uk/arrayexpress</a>), accession numbers E-MTAB-4680, E-MTAB-4684 and E-MTAB-5130. </p></blockquote><p>可以看到作者将CHIP-seq和RNA-seq数据上传到<strong>ArrayExpress</strong>这个数据库中，这个数据库是欧洲生物信息研究所（European Bioinformatics Institute, <strong>EBI</strong>）旗下的公共数据库，主要用于存放芯片和高通量测序数据，我们可以直接从该数据库中下载我们需要的RNA-seq数据，自己动手分析。</p><div class="note info"><p>顺便介绍一下，欧洲<a href="https://www.ebi.ac.uk/">EBI</a>旗下的<a href="https://www.ebi.ac.uk/ena/browser/home">ENA</a>数据库，美国<a href="https://www.ncbi.nlm.nih.gov/">NCBI</a>旗下的<a href="https://www.ncbi.nlm.nih.gov/genbank/">GenBank</a>，以及日本的<a href="https://www.ddbj.nig.ac.jp/index-e.html">DDBJ</a>三大巨头组成了国际核酸序列数据库合作联盟（INSDC），这三大数据库收录了世界上报道的所有序列数据。</p></div><p>EBI数据库可以直接下载fastq数据，不需要做SRA数据转换（NCBI数据库中下载sra数据则需要转换，需要用工具fastq-dump），这是EBI数据库下载高通量测序数据的优点，但是这个数据库经常网络连接不稳定，用aspera或者prefetch这种高速下载软件也不一定能稳定下载 <del>最好的方法是科学上网</del>。我们可以从ArrayExpress数据库中输入索引号E-MTAB-5130，直接获得样本信息和测序信息。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/1234.jpg" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/1234.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><hr></div><h2 id="2-测序数据质控"><a href="#2-测序数据质控" class="headerlink" title="2. 测序数据质控"></a>2. 测序数据质控</h2><div class="story post-story"><p>我们可以看到，下载的数据是双端测序产生的。我们不能直接用下载的raw data做后续分析，必须要进行质控查看测序质量如何。</p><hr><h3 id="2-1-使用fastqc对测序数据生成质控报告"><a href="#2-1-使用fastqc对测序数据生成质控报告" class="headerlink" title="2.1 使用fastqc对测序数据生成质控报告"></a>2.1 使用fastqc对测序数据生成质控报告</h3><p>下载好的fastq文件可以直接用fastqc工具做测序数据质控，输入以下命令一次生成所有qc报告：</p><p><code>$ fastqc *.fastq.gz -o ./  #在当前目录下对所有.fastq.gz文件生成qc报告，-o参数定义输出目录</code></p><p>运行结束后我们可以得到.html文件和.zip压缩包，这个就是质控报告。在虚拟机里，我们可以直接点开.html后缀的网页文件查看质控报告（和压缩包的内容是一致的）。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/QQ%E6%88%AA%E5%9B%BE20220414195329.jpg" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/QQ%E6%88%AA%E5%9B%BE20220414195329.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>顺便介绍一个非常好用的工具multiqc，可以通过conda install直接安装，这个工具可以将批量生成的qc报告合并为一个，看起来更加直观。在生成qc报告的当前目录下，运行代码：</p><p><code>$ multiqc ./</code></p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/zfd.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/zfd.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><hr><h3 id="2-2-质控报告解读"><a href="#2-2-质控报告解读" class="headerlink" title="2.2 质控报告解读"></a>2.2 质控报告解读</h3><h4 id="2-2-1-基本信息"><a href="#2-2-1-基本信息" class="headerlink" title="2.2.1 基本信息"></a>2.2.1 基本信息</h4><p>绿色表示通过，黄色表示不太好，红色表示不通过。RNA-seq一般在Sequence Duplication Levels上结果会不好，一个基因可能会大量表达，测到好多遍。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/afhfh.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/afhfh.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="2-2-2-核苷酸测序质量箱式图"><a href="#2-2-2-核苷酸测序质量箱式图" class="headerlink" title="2.2.2 核苷酸测序质量箱式图"></a>2.2.2 核苷酸测序质量箱式图</h4><p>这里测序质量（纵坐标）用Q值表示，p为出错率，Q值计算式为Q&#x3D;-10*lg（p）。每一个核苷酸的测序质量可以从fastq文件第四行一一对应上，这里只是做了统计和可视化。我们可以看到每个位点的核苷酸测序质量Q值都在30以上，意味着每个位点的测序正确率都在99.9%以上，可以认为测序质量比较好。</p><p>箱式图解读：黄色箱子(25%和75%的分数线)，红色线(中位数)，蓝线是平均数，下面和上面的触须分别表示10%和90%的点。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/fagasdga.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/fagasdga.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="2-2-3-测序泳道质量图"><a href="#2-2-3-测序泳道质量图" class="headerlink" title="2.2.3 测序泳道质量图"></a>2.2.3 测序泳道质量图</h4><p>纵坐标为tile编号，这张图代表每次荧光扫描的质量。蓝色背景表明测序质量良好，白色和红色的背景表示测序过程中可能有小气泡或者测序泳道上有污染。直接的体现就是部分测序数据中出现连续的N，也就是不能读取，可能是任何一个核苷酸。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/faheah.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/faheah.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="2-2-4-reads质量得分"><a href="#2-2-4-reads质量得分" class="headerlink" title="2.2.4 reads质量得分"></a>2.2.4 reads质量得分</h4><p>可以看到平均质量在38，质量比较高。如果最高峰所对应的横坐标质量值小于27（错误率0.2%） 则会显示“警告”，如果最高峰的质量值小于20（错误率1%）则会显示“不合格”。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/rtjyrklyl.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/rtjyrklyl.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="2-2-5-每条reads各个测序位点上各碱基出现概率"><a href="#2-2-5-每条reads各个测序位点上各碱基出现概率" class="headerlink" title="2.2.5 每条reads各个测序位点上各碱基出现概率"></a>2.2.5 每条reads各个测序位点上各碱基出现概率</h4><p>图上看得出比较稳定，测序刚开始的时候波动会大一点，这里的GC含量和AT含量不一致。如果任何一个位置上的A和T之间或者G和C之间的比例相差10%以上则报“警告”，任何一个位置上的A和T之间或者G和C之间的比例相差20%以上则报“不合格”。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/srgsrjsryjy.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/srgsrjsryjy.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="2-2-6-GC含量和理论分布"><a href="#2-2-6-GC含量和理论分布" class="headerlink" title="2.2.6 GC含量和理论分布"></a>2.2.6 GC含量和理论分布</h4><p>可以看出GC含量在43%左右，与理论分布（也就是正态分布）比较吻合，中心峰值与所测转录组的GC含量一致。如果有不正常的尖峰，可能是测序文库有污染，接头的污染还会在过表达序列中体现。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/asgarjry67fb.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/asgarjry67fb.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="2-2-7-每条reads的含N碱基数"><a href="#2-2-7-每条reads的含N碱基数" class="headerlink" title="2.2.7 每条reads的含N碱基数"></a>2.2.7 每条reads的含N碱基数</h4><p>不能识别的碱基会被读成N，这里没有N，测序质量非常好。横坐标表示reads的位置，纵坐标表示N的比例。如果任何一个位置N的比例大于5%则报“警告”，大于20%则报“失败”。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/fhdfdzjnf.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/fhdfdzjnf.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="2-2-8-测序长度分布"><a href="#2-2-8-测序长度分布" class="headerlink" title="2.2.8 测序长度分布"></a>2.2.8 测序长度分布</h4><p>这个测序仪一次测量长度是101bp。测序仪出来的原始reads通常是均一长度的，经过质控软件处理过的reads长度则不一样，这里说明测序结果较好。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/dsgnsfgmsfgmdfhms.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/dsgnsfgmsfgmdfhms.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="2-2-9-重复序列水平"><a href="#2-2-9-重复序列水平" class="headerlink" title="2.2.9 重复序列水平"></a>2.2.9 重复序列水平</h4><p>可以看到重复水平较低。图中横轴代表reads的重复次数，大于10次重复后则按不同的重复次数合并显示。纵坐标表示各重复次数下的reads数占总reads的百分比；蓝线展示所有reads的重复情况，红线表示在去掉重复以后，原重复水平下的reads占去重后reads总数的百分比；如果非unique的reads占总reads数的20%以上则报 ”警告“，占总read数的50%以上则报 ”不合格“。<strong>这项变黄是正常的</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/gdmshmdttu.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/gdmshmdttu.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="2-2-10-过表达序列和接头序列"><a href="#2-2-10-过表达序列和接头序列" class="headerlink" title="2.2.10 过表达序列和接头序列"></a>2.2.10 过表达序列和接头序列</h4><p>过表达的序列很可能是一些测序的接头序列，这里两种序列都看不到，说明质量良好。过表达序列是显示同一条reads出现次数超过总测序reads数的0.1%的统计情况，超过0.1%则报“警告”，超过1%则报“不合格”，会列出可能的接头序列。接头序列正常情况下含量接近于0。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/gsgggnsjtttjbbb.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/gsgggnsjtttjbbb.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><hr><h3 id="2-3-trim-galore测序数据质控过滤"><a href="#2-3-trim-galore测序数据质控过滤" class="headerlink" title="2.3 trim-galore测序数据质控过滤"></a>2.3 trim-galore测序数据质控过滤</h3><p>质控的目的使为了除去下机数据raw data中的接头序列和质量比较差的测序数据，Q&lt;20，正确率小于99%，如果这样的核苷酸超过read长度的20%，则考虑将该read丢弃（只是建议，不是强制，根据需要可以自定义过滤条件）。</p><p>trim-galore也可以用conda install安装，非常方便，这是一个自动检测adaptor的软件，可以一个命令自动找出主流的测序接头并去除，还可以设置参数对测序数据质控。简单介绍一下trim-galore的一些参数：</p><div class="note info"><p>-q # 设定Phred quality score阈值，默认为20；<br />-phred33 # 测序平台衡量测序质量的方法，有33和64，不影响；<br />-length # 设定输出reads长度阈值，小于设定值会被抛弃，根据需要设计;<br >-stringency # 设定可以忍受的前后adapter重叠的碱基数，默认为1（非常苛刻）;<br >-paired # 用于分析双端测序数据结果；<br >-o # 输出目录</p></div><p>因为是双端测序，16个样本每个都有_1和_2两个文件，可以写个脚本批量运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">for i in `seq 194 209`</span><br><span class="line">    do </span><br><span class="line">    trim_galore -q 25 -phred33 -length 50 -stringency 3 -paired \</span><br><span class="line">    -0 /media/sf_/example/data/clean_data \</span><br><span class="line">    /media/sf_/example/data/raw_data/ERR1698&quot;$i&quot;_1.fastq.gz \   #一端测序数据</span><br><span class="line">    /media/sf_/example/data/raw_data/ERR1698&quot;$i&quot;_2.fastq.gz     #另一端测序数据</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>保存退出，运行，最后生成的_triming_report.txt文件就是生成的质控报告，_val_1.fq.gz就是过滤后瘦身的<strong>clean data</strong>，我们可以看到大小比原来小了10M左右，这个<strong>clean data才可以用于后续的分析流程</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/dagjsgjsrjsr.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/dagjsgjsrjsr.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>我截取了其中一个数据的质控结果，拉到最底下，可以看到两端测序数据中都有AGATCGGAAGAGC这个序列，在一个样本测序数据中出现240027次经过网上查找，AGATCGGAAGAGC这个序列确实是Illumina公司测序时的接头序列<a href="https://support.illumina.com/content/dam/illumina-support/help/Illumina_DRAGEN_Bio_IT_Platform_v3_7_1000000141465/Content/SW/Informatics/Dragen/FastQC_Adapter_Kmer_files_fDG.htm">（点击这里查看）</a>，可以和上面fastqc质控报告中的测序平台Illumina相互验证。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/wagrwrhe.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/wagrwrhe.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本系列学习笔记数据均来自”&lt;strong&gt;Temporal dynamics of gene expression and histone marks at the Arabidopsis shoot meristem during flowering&lt;/strong&gt;“，</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="转录组数据分析" scheme="http://www.shelven.com/categories/%E8%BD%AC%E5%BD%95%E7%BB%84%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
    <category term="fastqc" scheme="http://www.shelven.com/tags/fastqc/"/>
    
    <category term="multiqc" scheme="http://www.shelven.com/tags/multiqc/"/>
    
    <category term="trim-galore" scheme="http://www.shelven.com/tags/trim-galore/"/>
    
  </entry>
  
  <entry>
    <title>小破站正式对外开放啦！</title>
    <link href="http://www.shelven.com/2022/04/13/a.html"/>
    <id>http://www.shelven.com/2022/04/13/a.html</id>
    <published>2022-04-13T14:29:14.000Z</published>
    <updated>2022-04-18T15:17:02.573Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><div class="story post-story"><p>咳咳，经过10天左右紧张地准备，小站今天正式对外开放啦！作为第一次运行个人网站的小白，看着网站从零开始在自己手上慢慢展现一个个页面，实现一个个功能，这种成就感和激动感，让我感觉这几天的熬夜狂肝还是值得的<del>呜呜呜我的头发</del>。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/QQ%E5%9B%BE%E7%89%8720220414020811.jpg" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/QQ%E5%9B%BE%E7%89%8720220414020811.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div><h2 id="建站过程"><a href="#建站过程" class="headerlink" title="建站过程"></a>建站过程</h2><div class="story post-story"><h4 id="为什么建站"><a href="#为什么建站" class="headerlink" title="为什么建站"></a>为什么建站</h4><p>说是从零开始，其实也是站在前人搭建好的框架上才能顺利进行的。我很早之前就萌发了搭建个人网站的想法，自从这个学期开始学习生物信息学，我也慢慢对linux系统有了更深入的理解。一开始只是在虚拟机上跑跑程序，后来就想着不如买一个云服务器装linux玩玩，既然买了服务器了，那就再绑个域名吧，既然两个都有了，不如就再建个网站吧<del>（滑稽）</del>。于是趁着腾讯云的轻量级应用服务器打折的机会，一次性买了3年…然后又在阿里云买了个域名，了解到需要备案后才能解析域名，行，又办理各种手续在工信部备了案。不得不说，在各大云服务器商内卷搞活动的时候，有个学生认证还是相当香的。至于怎么用服务器，那就是后面考虑的事了。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/QQ%E6%88%AA%E5%9B%BE20220414022126.jpg" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/QQ%E6%88%AA%E5%9B%BE20220414022126.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="我买的服务器"></p><h4 id="备案和备案期间的学习"><a href="#备案和备案期间的学习" class="headerlink" title="备案和备案期间的学习"></a>备案和备案期间的学习</h4><p>我在腾讯云买的服务器，通过接入商腾讯云协助，腾讯云先审核我的材料，通过以后再提交工信部备案，备案还是相当快的，3天时间就办下来了。备案期间也没闲着，作为一个前端小白的我，又去恶补了一些前端知识，比如什么是css、js、ejs、html文件，这些文件的格式是怎么样的，java的一些基本语法等等。学习的折磨程度不亚于刚开始学R语言和linux操作系统，不过有了一些shell脚本的语法知识以后，还是能感觉到这些语言之间还是有共同的判断方式和逻辑在里面的<u>（纯小白发言，不知道对不对）</u>。在慢慢摸索的过程中痛并快乐着，先是照着别人给的js文件魔改，再是自己调试遇到的问题和bug，尤其在发现bug最后解决bug的时候，那种成就感能给我带来莫大的快乐。</p><h4 id="建站历程"><a href="#建站历程" class="headerlink" title="建站历程"></a>建站历程</h4><p>建站的过程是痛苦的，踩了非常多的坑，我觉得我甚至可以写好几篇攻略出来。我一开始的想法是在github建库搭建个人网站，从安装nodejs和npm这种最基础的开始，配置环境，用hexo框架搭建一个本地静态博客，然后部署到github空间，这样就可以用github仓库名访问我的网站。但是<strong>有一个非常大的问题</strong>，github从国内访问会有DNS污染，连接速度那叫一个绝望。我自己是可以科学上网，但是总不能让别人浏览我网页的时候也科学上网吧？我也不太相信有很多人会用<strong>改host</strong>的办法来访问github，于是我就萌生了将买的云服务器用来搭建网站的想法（我知道这是一种资源浪费），github就可以当做网站的备份，以后即使我的云服务器过期了，我也可以依旧正常访问搭建在github里的静态博客。所以我的部署过程有点绕，就是本地生成静态博客，先部署到github仓库，再同步部署到我的云服务器。这样我就可以用备案后的二级域名解析到云服务器，在通过安装httpd服务来开启外部的访问了。</p><p>可以访问我的网站还是第一步，还要做好安全防护，申请<strong>SSL安全证书</strong>才能开启https连接。免费申请方式也很多，我申请了一年的apache上的SSL安全证书，然后安装到自己服务器上。还想吐槽一下，腾讯云有一键部署SSL安全证书通道，要90块钱，只要有点linux文本操作基础，自己按照教程部署一下半小时左右就能完成，<del>这钱真好赚</del>。SSL证书安装做好以后，就可以上别的云服务商找找免费的<strong>CDN加速</strong>了，有CDN加速一是可以加快网站的加载速度，二是隐藏自己服务器的ip地址，能起到一定的网站安全防护作用。吹一波又拍云，只要在网站底下加上他们的标志，启用他们的CDN加速，就能申请加入又拍云联盟，有免费一年的CDN加速和云储存服务，还可以查看访问记录等等 <del>学生党薅羊毛的利器23333</del> 。因为我的网页图片比较多，所以就应用了网页图片加速。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/QQ%E6%88%AA%E5%9B%BE20220414023552.jpg" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/QQ%E6%88%AA%E5%9B%BE20220414023552.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><div class="story post-story"><p>具体过程比如怎么接入第三方各种网站，用什么主题，怎么美化页面等等，就不详细说了，说多了肝疼，以后有想法再更新如何<strong>从零开始搭建自己的博客</strong>吧！<strong>至少没有服务器和域名也是完全可以实现的</strong>。建立这个小破站也主要是为了上传自己的学习笔记，整理生信网站和工具合集（相应的栏目还在建设中 <del>新建文件夹了</del> ），督促自己学习hhhhh</p><p>本人技术实力有限，也不想搞地太花里胡哨，之后可能会有一些简单的小功能接入，还有移动端浏览小破站的优化（现在移动端浏览这个小破站简直是灾难，我都看不下去了），太费心思的东西就暂时放放了，主要专注于内容的创作，这几天会把一些学习笔记陆续上传。本人也是第一次用markdown语法写东西，排版一直搞不定段首的两个空格，先这样吧。 <psw>开摆</psw></p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/u=2001056350,755226689&fm=26&gp=0.jpg" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/u=2001056350,755226689&fm=26&gp=0.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;div class=&quot;story post-story&quot;&gt;&lt;p&gt;咳咳，经过10天左右紧张地准备，小站今天正式对外开放啦！作为第一次运行个人网站的</summary>
      
    
    
    
    <category term="个人主页" scheme="http://www.shelven.com/categories/%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5/"/>
    
    
    <category term="建站" scheme="http://www.shelven.com/tags/%E5%BB%BA%E7%AB%99/"/>
    
  </entry>
  
</feed>
