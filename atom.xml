<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>我的小破站</title>
  
  
  <link href="http://www.shelven.com/atom.xml" rel="self"/>
  
  <link href="http://www.shelven.com/"/>
  <updated>2023-03-02T15:26:26.000Z</updated>
  <id>http://www.shelven.com/</id>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>0基础学习基因组三代测序组装（8）——基因组组装质量评估（QUAST）</title>
    <link href="http://www.shelven.com/2023/03/02/a.html"/>
    <id>http://www.shelven.com/2023/03/02/a.html</id>
    <published>2023-03-02T15:24:41.000Z</published>
    <updated>2023-03-02T15:26:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>接上一篇博客，这一篇博客继续介绍一个常用的评估基因组组装质量的软件——<strong>QUAST</strong></p><span id="more"></span><h2 id="1-QUAST介绍"><a href="#1-QUAST介绍" class="headerlink" title="1. QUAST介绍"></a>1. QUAST介绍</h2><div class="story post-story"><p>QUAST（Quality Assessment Tool for Genome Assemblies）是一个比较综合的评估基因组组装质量的软件，主要包括四种分析工具：</p><ul><li>QUAST：常规基因组组装质量评估</li><li>MetaQUAST：宏基因组（元基因组）组装质量评估</li><li>QUAST-LG：大型基因组组装质量评估</li><li>Icarus：Contig比对可视化工具（类似IGV浏览器的感觉）</li></ul><p>QUAST用到的软件如下（参考自<a href="https://nmdc.cn/static/pdf/web/viewer.html?file=/static/file/analysis/QUAST.pdf">国家微生物科学数据中心</a>）：</p><blockquote><p>序列比对：Minimap2</p><p>基因和功能：GeneMarkS、GeneMark-ES、GlimmerHMM、Barrnap和BUSCO</p><p>查找结构变异：BWA、Sambamba</p><p>覆盖度计算：bedtools</p><p>MetaQUAST：MetaGeneMark、Krona tools、BLAST和SILVA数据库</p><p>QUAST-LG：KMC和Red</p></blockquote><p>这个软件优点是可以使用参考基因组或者<strong>无参考基因组</strong>情况对组装的基因组进行评估，可以快速进行<strong>大批量的基因组组装质量比较</strong>，最终的结果有图表、excel和latex等多种表现形式，也有个可以<strong>交互的网页结果</strong>，非常直观和方便。</p></div><h2 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h2><div class="story post-story"><p>如果从官网下载的话，需要安装非常多的依赖软件，好消息是：<strong>可以conda安装</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">conda install -c bioconda quast</span><br><span class="line"></span><br><span class="line">quast-download-busco</span><br><span class="line">quast-download-gridss# 检测基因组重排的软件</span><br><span class="line">quast-download-silva# 著名的16s数据库，提供最新的核糖体大小亚基rRNA注释信息</span><br></pre></td></tr></table></figure><p>截至2023年3月2日，最新版本为5.2.0</p><p>后续需要安装什么软件都可以<code>conda search</code>一下，能省好多功夫。注意一下conda安装之后会提醒缺两个工具和一个数据库，直接运行命令下载即可。</p></div><h2 id="3-运行实例"><a href="#3-运行实例" class="headerlink" title="3. 运行实例"></a>3. 运行实例</h2><div class="story post-story"><p>以我的植物基因组跑一个常规基因组组装质量评估的例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -n 50</span></span><br><span class="line"></span><br><span class="line">quast -t 50 -o quast_baima -1 /public/home/wlxie/clean_data/1.fq -2 /public/home/wlxie/2.fq /public/home/wlxie/NextPolish/baima_rundir/genome.nextpolish.fasta</span><br></pre></td></tr></table></figure><p>QUAST输入文件只有组装的基因组是必须的，同时也支持三代测序<code>--pacbio</code>、<code>--nanopore</code>数据，也支持二代数据输入。我这里同时输入了二代数据，因此结果文件中有组装基因组的质量评估，也有二代数据回贴组装基因组的分析数据。</p></div><h2 id="4-结果展示"><a href="#4-结果展示" class="headerlink" title="4. 结果展示"></a>4. 结果展示</h2><div class="story post-story"><p>运行结束后的输出日志如下：</p><p><img src="https://www.shelven.com/tuchuang/20230303/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230303/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>最终生成图表结果可以在report.pdf中找到，也可以看report.html：</p><p><img src="https://www.shelven.com/tuchuang/20230303/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230303/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>左边红框框起来的部分就是二代数据回比基因组的结果，mapping率高于100%说明有多比对，<strong>完美比对率</strong>（配对reads中两条序列比对上同一个参考基因组序列的比例，Properly Paired）<strong>93.45%<strong>，</strong>覆盖度（coverage）98.63%<strong>。</strong>这个比对率说明二代测序reads与组装的基因组有较高的一致性（Properly paired 90%以上，coverage 95%以上）</strong>，可以进行后续的分析。</p><p>右边是contig长度累积图，横坐标从左到右contig长度依次减小，曲线越陡表明大片段越长、数量越多，也可以看到基因组组装的连续性良好。</p><p>左上角contig的具体数据，以及N50、GC含量可以在<code>transposed_report.txt</code>中查看，同时也提供了latex和excel格式的结果文件，非常贴心~或者可以在<code>basic_stats</code>文件夹中查看相应的pdf图表：</p><p><img src="https://www.shelven.com/tuchuang/20230303/3.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230303/3.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><img src="https://www.shelven.com/tuchuang/20230303/4.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230303/4.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>Nx图横轴是Nx百分比，比如50就是N50；纵轴是contig长度。这张图也可以反映组装结果的连续性。</p><p><img src="https://www.shelven.com/tuchuang/20230303/5.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230303/5.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>最后是icarus网页结果，前面说这个界面有点像IGV。。。总之就是将各个contig从长到短组装情况可视化的工具，可以拖动底下的黄色框左右移动来查看对应的contig情况。</p><p>在基因组组装质量评估方面，<strong>这个软件就可以一次给出序列一致性、组装完整性和测序覆盖均匀性评估</strong>，还是非常方便的~当然，如果你有参考基因组的话，就可以得到更多有效的评估信息。</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;接上一篇博客，这一篇博客继续介绍一个常用的评估基因组组装质量的软件——&lt;strong&gt;QUAST&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="基因组三代测序分析" scheme="http://www.shelven.com/categories/%E5%9F%BA%E5%9B%A0%E7%BB%84%E4%B8%89%E4%BB%A3%E6%B5%8B%E5%BA%8F%E5%88%86%E6%9E%90/"/>
    
    
    <category term="QUAST" scheme="http://www.shelven.com/tags/QUAST/"/>
    
  </entry>
  
  <entry>
    <title>0基础学习基因组三代测序组装（7）——基因组组装质量评估（BUSCO、LAI指数）</title>
    <link href="http://www.shelven.com/2023/03/01/a.html"/>
    <id>http://www.shelven.com/2023/03/01/a.html</id>
    <published>2023-03-01T12:39:05.000Z</published>
    <updated>2023-03-03T06:15:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>通过前面的纠错和校正步骤，我们得到了组装完成的基因组序列，接下来就是进行基因组的组装质量评估。质量评估的软件和方法比较多，这里分两篇博客记录，本篇主要演示如何用BUSCO和LAI指数评价基因组组装质量。</p><span id="more"></span><p>复习一下前面说到的contig N50，按照contig从短到长的顺序依次相加，当相加的长度达到Contig总长度的一半，最后一个Contig长度即为<strong>contig N50</strong>.</p><p>contig N50是基因组组装质量的第一指标，一般来说越高越好，但是contig N50不能完全代表一个基因组组装质量的高低，比如reads的错误连接也会使contig N50变高。接下来介绍几个现在常用的评估基因组组装质量的软件和方法。</p><h2 id="1-保守型基因评估"><a href="#1-保守型基因评估" class="headerlink" title="1. 保守型基因评估"></a>1. 保守型基因评估</h2><div class="story post-story"><p>BUSCO（Benchmarking Universal Single-Copy Orthologs）评估是在基因含量层面上评估基因组完整性。简单来说，通过已有的直系同源数据库进行基因组比对，同源的生物之间有保守基因序列，能比对上的基因数越多说明组装的结果越靠谱。</p><p>安装过程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1. 源码安装（需要安装前置软件）</span></span><br><span class="line">git clone https://gitlab.com/ezlab/busco.git</span><br><span class="line">cd busco/</span><br><span class="line">python setup.py install</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">前置软件：</span></span><br><span class="line">https://biopython.org/</span><br><span class="line">https://pandas.pydata.org/</span><br><span class="line">https://jgi.doe.gov/data-and-tools/software-tools/bbtools/</span><br><span class="line">https://ftp.ncbi.nlm.nih.gov/blast/executables/blast+/LATEST</span><br><span class="line">http://bioinf.uni-greifswald.de/augustus/</span><br><span class="line">https://github.com/soedinglab/metaeuk</span><br><span class="line">https://github.com/hyattpd/Prodigal</span><br><span class="line">http://hmmer.org/</span><br><span class="line">https://github.com/smirarab/sepp/</span><br><span class="line">https://www.r-project.org/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2. conda安装（推荐）</span></span><br><span class="line">conda install -c conda-forge -c bioconda busco=5.3.2</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>conda安装可能会比较慢，需要多试几次。实在不行就源码下载编译，不过需要下载非常多的前置软件，不同软件可能会有环境冲突问题、gcc版本问题等等<del>（我花了大半天时间在折腾环境）</del>。安装之后通过<code>busco -h</code>查看是否安装成功，如果提示缺什么软件就用conda补上（我当前环境中没有安装pandas就会有提示）。</p><p>通过<code>busco --list-datasets</code>可以查看当前有哪些物种的数据库，我的植物是双子叶龙胆目，这里的数据库只有<strong>真双子叶植物（eudicots）</strong>分支离的最近，因此选择这个数据库，v5版本所有单拷贝直系同源数据库网址<a href="https://busco-data.ezlab.org/v5/data/lineages/">https://busco-data.ezlab.org/v5/data/lineages/</a></p><p><img src="https://www.shelven.com/tuchuang/20230228/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230228/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>下载的数据库放在<code>busco_downloads</code>文件夹中，解压即可使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nohup wget https://busco-data.ezlab.org/v5/data/lineages/eudicots_odb10.2020-09-10.tar.gz &amp;</span><br><span class="line">tar -zxvf eudicots_odb10.2020-09-10.tar.gz</span><br></pre></td></tr></table></figure><p>busco的详细参数可以看官网的user guide <a href="https://busco.ezlab.org/busco_userguide.html">User guide BUSCO v5.4.4 (ezlab.org)</a></p><p>简单讲一讲格式和能用到的参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">busco -i [SEQUENCE_FILE] -l [LINEAGE] -o [OUTPUT_NAME] -m [MODE] [OTHER OPTIONS]</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">主要参数：</span><br><span class="line"> -i序列文件位置</span><br><span class="line"> -l下载的同源物种保守基因数据库位置</span><br><span class="line"> -o输出文件名</span><br><span class="line"> -m模式，分为genome,proteins,transcriptome三种</span><br><span class="line"> 其他参数：</span><br><span class="line"> --cpu设置cpu数量</span><br><span class="line"> --download在线下载数据库，根据分类有&quot;all&quot;、&quot;prokaryota&quot;、&quot;eukaryota&quot;和&quot;virus&quot; （不推荐，速度慢）</span><br><span class="line"> --offline离线模式，不会更新数据库</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><p>以下是我跑的程序，大约用了1个小时：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">busco -i /public/home/wlxie/NextPolish/01_rundir/genome.nextpolish.fasta -l /public/home/wlxie/busco_soft/busco/test_data/eukaryota/busco_downloads/lineages/eudicots_odb10 -o baima -m genome --cpu 8 --offline</span><br></pre></td></tr></table></figure><p>截至2023&#x2F;02&#x2F;28，<strong>真双子叶植物库有2326个保守BUSCO基因序列</strong>，比对结果文件在short_summary.specific.xxx.xxx.txt中，如下：</p><p><img src="https://www.shelven.com/tuchuang/20230228/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230228/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><ul><li>Complete BUSCOs (C)    多少个基因完全比对上BUSCOs</li><li>Complete and single-copy BUSCOs (S)    多少个基因比对上单拷贝的BUSCOs</li><li>Complete and duplicated BUSCOs (D)    多少个基因比对上多拷贝的BUSCOs</li><li>Fragmented BUSCOs (F)    多少个基因部分比对上BUSCOs，可能基因只是部分存在</li><li>Missing BUSCOs (M)    多少个基因没有比对上BUSCOs，可能这些直系同源基因是缺失的</li></ul><p>从上面的数据看，组装结果还是不错的。从中也可以看到BUSCO运行的<strong>两个步骤</strong>：<strong>用metaeuk进行基因预测</strong>（真核生物可以用tBLASTn与对应的BUSCO数据库序列进行比对从而确定候选区域，然后使用 Augustus 软件进行基因结构预测，两个软件可以替代metaeuk，详细参数见官网），以及<strong>HMMER进行同源基因的比对</strong>，从而评估基因组组装的完整性。</p><p>官方还提供了相应的python程序绘制结果图（调用了R包ggplot2），先将BUSCO结果文件放到新建的文件夹，运行相应的py程序，指定工作目录即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir summaries</span><br><span class="line"></span><br><span class="line">cp baima/short_summary.specific.eudicots_odb10.baima.txt summaries</span><br><span class="line"></span><br><span class="line">generate_plot.py -wd summaries</span><br></pre></td></tr></table></figure><p>结果图如下：</p><p><img src="https://www.shelven.com/tuchuang/20230228/3.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230228/3.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>当然，有结果数据就可以自己做更好看的图了，不一定要用官方的。</p></div><h2 id="2-长末端重复序列评估"><a href="#2-长末端重复序列评估" class="headerlink" title="2. 长末端重复序列评估"></a>2. 长末端重复序列评估</h2><div class="story post-story"><p>2018年发表在Nucleic Acids Research上的一篇文章<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6265445/">Assessing genome assembly quality using the LTR Assembly Index (LAI)</a>，研究者提出了一种对长末端重复序列（long terminal repeats,LTRs）评估从而评价基因组完整度的方法，并且开发了对应的分析工具<code>LTR_retriever</code></p><p>具体的LTR注释我会在后续的基因组注释笔记中更新，这里暂时跳过原理和背景部分，介绍下文章中提出的评估核心——LAI指数（LTR Assembly Index，LAI），也就是长末端重复序列组装指数。<code>raw LAI = (完整LTR-RTs长度/总LTR长度)*100</code>，修正后，<code>LAI = raw LAI + 2.8138 × (94 – 整个基因组LTR identity)</code>。</p><p>以下是一个完整的LTR-RTs的结构示意图：</p><p><img src="https://www.shelven.com/tuchuang/20230228/4.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230228/4.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>文章还阐明LAI独立于基因组大小、LTR-RT含量以及基因空间评估指标（如BUSCO和CEGMA）等参数，可以用于鉴定低质量的基因组区域。使用这个指标要求**基因组中完整的LTR-RTs应至少占基因组0.1%且总LTR-RTs长度至少占5%**。</p><p>文章最后给出了LAI评价基因组完整度的三个指标：</p><table><thead><tr><th>分类</th><th>LAI</th><th>举例</th></tr></thead><tbody><tr><td>Draft</td><td>0 ≤ LAI &lt; 10</td><td>Apple (v1.0), Cacao (v1.0)</td></tr><tr><td>Reference</td><td>10 ≤ LAI &lt; 20</td><td>Arabidopsis (TAIR10), Grape (12X)</td></tr><tr><td>Gold</td><td>20 ≤ LAI</td><td>Rice (MSUv7), Maize (B73 v4)</td></tr></tbody></table><h3 id="2-1-LTR序列预测"><a href="#2-1-LTR序列预测" class="headerlink" title="2.1 LTR序列预测"></a>2.1 LTR序列预测</h3><p><code>LTR_retriever</code>需要以<code>LTR_finder</code>和&#x2F;或<code>ltrharvest</code>的LTR预测结果文件为输入，也可以整合两个软件的预测结果作为输入（或者其他符合格式的LTR结果文件），因此需要先安装并运行以上软件，我这里以文章中提到的软件和参数运行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">LTR_finder、ltrharvest和LTR_retriever安装（ltrharvest是genometools软件的一部分）</span></span><br><span class="line"></span><br><span class="line">conda install -c bioconda ltr_finder</span><br><span class="line">conda install -c bioconda genometools-genometools</span><br><span class="line">conda install -c bioconda ltr_retriever</span><br></pre></td></tr></table></figure><p><strong>LTR_finder</strong>预测LTR序列（参数均由作者给出，只有文件是自己的）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -n 10</span></span><br><span class="line"></span><br><span class="line">ltr_finder -D 15000 -d 1000 -L 7000 -l 100 -p 20 -C -M 0.85 /public/home/wlxie/NextPolish/01_rundir/genome.nextpolish.fasta &gt; baima_ltrfinder.scn</span><br></pre></td></tr></table></figure><blockquote><p>参数解释：</p><p>-D NUM     Max distance between 5’&amp;3’LTR, default is 20000# 5’和3’LTR之间的最大距离</p><p>-d NUM     Min distance between 5’&amp;3’LTR, default is 1000</p><p>-L NUM     Max length of 5’&amp;3’LTR, default is 3500# 5’和3’LTR最大长度</p><p>-l NUM     Min length of 5’&amp;3’LTR, default is 100</p><p>-p NUM     min length of exact match pair, default is 20# 完全匹配最小长度</p><p>-C         detect Centriole, delete highly repeat regions# 检测中心粒，删除高度重复区域</p><p>-M NUM     min LTR similarity threshold, default is 0.00, [0,1]#最小LTR相似度</p></blockquote><p><strong>ltrharvest</strong>预测LTR序列（ltrharvest参数均由作者给出，只有文件是自己的）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -n 10</span></span><br><span class="line"></span><br><span class="line">mkdir index</span><br><span class="line"></span><br><span class="line">gt suffixerator -db /public/home/wlxie/NextPolish/01_rundir/genome.nextpolish.fasta -indexname index_baima -tis -suf -lcp -des -ssp -sds -dna</span><br><span class="line"></span><br><span class="line">gt ltrharvest -index index/baima -minlenltr 100 -maxlenltr 7000 -mintsd 4 -maxtsd 6 -motif TGCA -motifmis 1 -similar 85 -vic 10 -seed 20 -seqids yes &gt; baima_ltrharvest.scn</span><br></pre></td></tr></table></figure><p>这里要注意下要先使用genome tools里的suffixerator<strong>创建基因组索引文件</strong>，然后才可以使用ltrharvest进行LTR预测。</p><blockquote><p>创建基因组索引的参数不做解释了，可以 gt suffixerator -help 查看。稍微记录下ltrharvest参数：</p><p>-minlenltr  specify minimum length for each LTR，default: 100</p><p>-mintsd     specify minimum length for each TSD，default: 4</p><p>-motif      specify 2 nucleotides startmotif + 2 nucleotides endmotif: ****</p><p>-motifmis   specify maximum number of mismatches in motif [0,3]，default: 4</p><p>-similar    specify similaritythreshold in range [1..100%]，default: 85.00</p><p>-vic        specify the number of nucleotides (to the left and to the right) that will be searched for TSDs and&#x2F;or motifs around 5’ and 3’boundary of predicted LTR retrotransposons, default: 60</p><p>-seed       specify minimum seed length for exact repeats，default: 30</p><p>-seqids     use sequence descriptions instead of sequence numbers in GFF3 output，default: no</p></blockquote><p>以上两个软件以同样的LTR最小相似度0.85预测LTR，得到两个结果文件<code>baima_ltrfinder.scn</code>和<code>baima_ltrharvest.scn</code>。</p><h3 id="2-2-LAI指数计算"><a href="#2-2-LAI指数计算" class="headerlink" title="2.2 LAI指数计算"></a>2.2 LAI指数计算</h3><p>用上一步的输出的两个结果文件，运行<code>LTR_retriever</code>鉴定LTR和计算LAI指数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -n 20</span></span><br><span class="line"></span><br><span class="line">LTR_retriever -genome /public/home/wlxie/NextPolish/01_rundir/genome.nextpolish.fasta -inharvest baima_ltrharvest.scn -infinder baima_ltrfinder.scn -threads 20</span><br></pre></td></tr></table></figure><p>这一步运行结果如下：</p><p><img src="https://www.shelven.com/tuchuang/20230228/5.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230228/5.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><strong>其他文件可以后续做LTR分析用到</strong>，这里我们只要看最后一个LAI的计算结果文件：</p><p><img src="https://www.shelven.com/tuchuang/20230228/6.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230228/6.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>可以看到这个结果文件中包含了整个genome和各个contig的raw LAI和LAI指数，这里就只看整个genome的LAI指数15.37，根据上面文章作者提到的分类，属于Reference级别，也就是说可以认为达到参考基因组级别。</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;通过前面的纠错和校正步骤，我们得到了组装完成的基因组序列，接下来就是进行基因组的组装质量评估。质量评估的软件和方法比较多，这里分两篇博客记录，本篇主要演示如何用BUSCO和LAI指数评价基因组组装质量。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="基因组三代测序分析" scheme="http://www.shelven.com/categories/%E5%9F%BA%E5%9B%A0%E7%BB%84%E4%B8%89%E4%BB%A3%E6%B5%8B%E5%BA%8F%E5%88%86%E6%9E%90/"/>
    
    
    <category term="BUSCO" scheme="http://www.shelven.com/tags/BUSCO/"/>
    
    <category term="LAI" scheme="http://www.shelven.com/tags/LAI/"/>
    
  </entry>
  
  <entry>
    <title>0基础学习基因组三代测序组装（6）——基因组polish</title>
    <link href="http://www.shelven.com/2023/02/27/a.html"/>
    <id>http://www.shelven.com/2023/02/27/a.html</id>
    <published>2023-02-27T03:02:16.000Z</published>
    <updated>2023-02-27T03:05:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>三代基因组de novo组装后得到一系列contig，由于三代测序的错误率较高，我们需要对组装结果进行打磨（以下均用polish表示）以提高基因组的拼接指标如Contig N50，Scaffold N50。</p><span id="more"></span><p>常用软件主要有Pilon、Racon，针对PacBio的有Quiver &amp; Arrow，针对Nanopore的有NanoPolish，以及武汉希望组为NextDenovo配套开发的NextPolish等等。<strong>要注意下先进行三代测序数据矫正，再进行二代测序数据矫正，顺序不能反</strong>，因为三代数据读长长准确率低，二代读长短准确率高，利用二代测序测序数据对三代测序数据进行纠错可以将三代测序错误率降低到二代测序的水平。如果不先进行三代序列纠错，由于基因组上存在过高错误率，导致二代序列的错误比对，影响最终polish效果。</p><p>这里以前面用NextDenovo组装的植物三代基因组为例，介绍下Racon和NextPolish用法。</p><h2 id="1-Racon"><a href="#1-Racon" class="headerlink" title="1. Racon"></a>1. Racon</h2><div class="story post-story"><p>racon的基本用法如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">racon [options ...] &lt;sequences&gt; &lt;overlaps&gt; &lt;target sequences&gt;</span><br></pre></td></tr></table></figure><p>需要用到三种输入文件：sequences是指用来纠错的三代基因组测序数据（后面以原始数据称呼）；target sequences指<strong>需要校正的组装后的基因组数据</strong>（后面以组装基因组称呼）；overlaps指回比到组装基因组的原始数据文件，其中包含了所有的overlaps，其文件格式为MHAP&#x2F;PAF&#x2F;SAM三种之一。</p><p>因此在使用Racon之前需要使用其他比对工具将三代数据回贴到组装基因组上，在<a href="https://www.shelven.com/2022/04/15/a.html">转录组分析笔记</a>中有介绍过相关软件，我这里用minimap2进行比对，这是专门针对三代测序数据开发的比对工具，运行速度较快。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minimap2 -a -t 20 &lt;target sequences&gt; &lt;sequences&gt; &gt; minimap_1.sam</span><br></pre></td></tr></table></figure><p><code>-a</code>表示结果为sam格式，<code>&lt;target sequences&gt;</code>处传入组装基因组的绝对路径，<code>&lt;sequences&gt;</code>处传入原始数据的绝对路径，比对结果的sam文件命名为minimap_1.sam</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">racon -t 50 &lt;sequences&gt; minimap_1.sam &lt;target sequences&gt; &gt; racon_minimap_1.fasta</span><br></pre></td></tr></table></figure><p>如上一次循环下来（大约3小时），得到的racon_minimap_1.fasta就是经过一次三代数据校正的组装基因组。</p><p>一般要用三代数据polish 2-4次，之后用二代数据继续校正4次左右，可以写脚本循环，需要注意<strong>racon因为要一次读入三代原始数据和回比的sam数据，内存需求量非常大</strong>，申请的内核数需要自己计算一下，否则会报内存溢出的错误（220Mb的基因组，100X测序深度，申请50个核才能跑动）。</p><p>脚本文件racon.sh如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">minimap2 -a -t 50 $1 $2 &gt; minimap_1.sam</span><br><span class="line">racon -t 50 $2 minimap_1.sam $1 &gt; racon_minimap_1.fasta</span><br><span class="line"></span><br><span class="line">minimap2 -a -t 50 racon_minimap_1.fasta $2 &gt; minimap_2.sam</span><br><span class="line">racon -t 50 $2 minimap_2.sam racon_minimap_1.fasta &gt; racon_minimap_2.fasta</span><br></pre></td></tr></table></figure><p>recon.slurm：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -J recon</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -N 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -n 50</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -t 7200</span></span><br><span class="line"></span><br><span class="line">date</span><br><span class="line">bash racon.sh /public/home/wlxie/NextDenovo/03_rundir/03.ctg_graph/nd.asm.fasta /public/home/wlxie/luobuma/luobuma/baima_rawdata/Third_generation_sequencing/clean_filter.fq</span><br><span class="line">date</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sbatch recon.slurm</span><br></pre></td></tr></table></figure><p>可以从输出日志中看到，racon运行主要分两步，分别是校准overlap和生成共有序列（也就是去重），<strong>在生成共有序列（consensus sequence）之后再进行二代数据的纠错</strong>。</p><p>这一步的Racon检测出两个contig可能是嵌合体（chimeric），所谓嵌合contig，该contig的某段区域可能可以比对上不同的染色体，或者头尾部分可能分别属于不同的染色体。第一遍racon的时候没有检测到，第二遍racon才出现这个提示，我不确定这两个contig是否真的是嵌合体，最终还是需要Hi-C数据来验证。</p><p><img src="https://www.shelven.com/tuchuang/20230227/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230227/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>我这里两次循环得到polish的结果文件<code>racon_minimap_2.fasta</code>，接下来用NextPolish软件继续用二代数据polish。</p></div><h2 id="2-NextPolish"><a href="#2-NextPolish" class="headerlink" title="2. NextPolish"></a>2. NextPolish</h2><div class="story post-story"><p>NextPolish是武汉那希望组开发的与NextDenovo配套的基因组polish软件，支持二代短读长、三代长读长和HiFi数据进行纠错。</p><p>和之前的NextDenovo操作方法类似，首先需要准备一个input文件，写入二代数据的绝对路径到sgs.fofn：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">realpath ./1.fq ./2.fq &gt; sgs.fofn</span><br></pre></td></tr></table></figure><p>从doc文件夹中copy一份配置文件run.cfg，修改参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[General]</span><br><span class="line">job_type = slurm# local, slurm, sge, pbs, lsf塔大学校集群选择slurm</span><br><span class="line">job_prefix = nextPolish</span><br><span class="line">task = best# all, default, best, 1, 2, 5, 12, 1212…  1，2是两个不同的短读长算法模块，5是长读长算法模块，默认best</span><br><span class="line">rewrite = yes</span><br><span class="line">deltmp = yes# 删除临时结果文件</span><br><span class="line">rerun = 3# 重复执行polish次数</span><br><span class="line">parallel_jobs = 20# 每个job线程数</span><br><span class="line">multithread_jobs = 5# job数</span><br><span class="line">genome = /public/home/wlxie/baima_polish/racon_minimap_2.fasta</span><br><span class="line">genome_size = auto</span><br><span class="line">workdir = ./01_rundir</span><br><span class="line">polish_options = -p &#123;multithread_jobs&#125;</span><br><span class="line"></span><br><span class="line">[sgs_option] #optional</span><br><span class="line">sgs_fofn = ./sgs.fofn# 输入文件位置（一行一条）</span><br><span class="line">sgs_options = -max_depth 100 -bwa# 使用bwa进行比对</span><br></pre></td></tr></table></figure><p>长reads和HiFi的两段配置信息删除，<strong>只留下短读长sgs_options</strong>。</p><p>这个软件的优点是速度快（<strong>100线程，4次polish，220Mb的基因组，72G的二代数据量仅仅用了8小时</strong>），而且只需要提供配置和输入文件就可以到polish结束出结果，经过4次Polish结果的迭代，最终结果如下:</p><p><img src="https://www.shelven.com/tuchuang/20230227/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230227/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>Contig N50比一开始NextDenovo组装结果大，也就是组装效果更好。</p><p><img src="https://www.shelven.com/tuchuang/20230227/3.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230227/3.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;三代基因组de novo组装后得到一系列contig，由于三代测序的错误率较高，我们需要对组装结果进行打磨（以下均用polish表示）以提高基因组的拼接指标如Contig N50，Scaffold N50。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="基因组三代测序分析" scheme="http://www.shelven.com/categories/%E5%9F%BA%E5%9B%A0%E7%BB%84%E4%B8%89%E4%BB%A3%E6%B5%8B%E5%BA%8F%E5%88%86%E6%9E%90/"/>
    
    
    <category term="NextPolish" scheme="http://www.shelven.com/tags/NextPolish/"/>
    
    <category term="Racon" scheme="http://www.shelven.com/tags/Racon/"/>
    
  </entry>
  
  <entry>
    <title>0基础学习基因组三代测序组装（5）——三代数据组装</title>
    <link href="http://www.shelven.com/2023/02/23/a.html"/>
    <id>http://www.shelven.com/2023/02/23/a.html</id>
    <published>2023-02-23T14:22:00.000Z</published>
    <updated>2023-02-28T13:07:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间比较忙，现在继续整理基因组测序组装系列的学习笔记。<a href="https://www.shelven.com/2022/07/03/a.html">第四篇笔记</a>写的二代测序基因组组装，主要是演示二代测序数据组装的主流工具SOAPdenovo 2.0是如何应用的。我这里有了二代和三代的测序数据，后续组装还是以<strong>三代数据为主</strong>，这里就继续记录下几款三代测序数据组装的主流工具和用法。</p><span id="more"></span><p>现在主流的三代测序公司是Pacbio和Nanopore，两家测序公司测序原理不同，产生的数据类型也有区别。</p><h2 id="1-主流三代测序平台"><a href="#1-主流三代测序平台" class="headerlink" title="1. 主流三代测序平台"></a>1. 主流三代测序平台</h2><div class="story post-story"><h3 id="1-1-Pacbio测序平台"><a href="#1-1-Pacbio测序平台" class="headerlink" title="1.1 Pacbio测序平台"></a>1.1 Pacbio测序平台</h3><p>Pacbio测序平台是单分子实时测序（single molecule real time sequencing，SMRT），原理是当DNA与聚合酶形成的复合物被ZMW（零模波导孔）捕获后，4种不同荧光标记的dNTP随机进入检测区域并与聚合酶结合，与模板匹配的碱基生成化学键并激发荧光，生成化学键激发的荧光存在的时间远远长于其他碱基被激发荧光的时间，从而实现单碱基的实时检测。</p><p><img src="https://www.shelven.com/tuchuang/20230223/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230223/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>现在Pacbio有两种测序模式，一种是<strong>CLR测序模式</strong>（超长测序模式），产生数据基于单循环测序结果；一种是<strong>HiFi测序模式</strong>，也就是高保真测序模式，产生数据基于滚环一致序列（Circular Consensus Sequencing ，CCS）。具体原理就不说了，两种测序模式中HiFi数据相对来说准确率会高一些，所以不同软件对两种测序模式的数据也会有不同的处理。 </p><h3 id="1-2-Nanopore测序平台"><a href="#1-2-Nanopore测序平台" class="headerlink" title="1.2 Nanopore测序平台"></a>1.2 Nanopore测序平台</h3><p>Nanopore测序平台前面第一篇博客介绍过了，可以<a href="https://www.shelven.com/2022/06/17/b.html">点击这里</a>。需要了解ONT测序平台测序产生的原始数据是<strong>电信号</strong>，经过basecalling之后才可以转化成我们要的测序数据。</p></div><h2 id="2-三代基因组测序组装软件"><a href="#2-三代基因组测序组装软件" class="headerlink" title="2. 三代基因组测序组装软件"></a>2. 三代基因组测序组装软件</h2><div class="story post-story"><h3 id="2-1-NextDenovo"><a href="#2-1-NextDenovo" class="headerlink" title="2.1 NextDenovo"></a>2.1 NextDenovo</h3><p>NextDenovo是武汉希望组开发的集校正、比对和组装一体的，基于字符串图（string graph-based）的三代测序基因组组装软件。它的实现过程和另一款经典的三代基因组组装软件Canu类似，经过长读长数据的纠错校正后再进行组装。</p><p>官网上介绍原来可以对CLR、HiFi和ONT数据都可以组装，HiFi数据可以跳过数据的自我纠错过程，如今HiFi数据被划掉了，也许已经不再适用，但是对Pabio的CLR和Nanopore的ONT测序数据仍有较好的组装效果，其介绍是组装的准确率有98%-99.8%。</p><p>NextDenovo主要有两个核心模块 <strong>NextCorrect</strong>和<strong>NextGraph</strong>。NextCorrect用于原始数据纠错，NextGraph用于纠错后数据的组装。据作者介绍，与其他工具相比，NextDenovo在装配一致性和单碱基装配精度方面表现出较高的水平。我个人用起来是觉得这个软件<strong>运行时间相对Canu较短</strong>，需要的算力资源较小，可以很快地组装出结果（后面可以进行比较）。</p><p>安装并测试通过后，我们就可以开始使用这个工具了。</p><p>首先准备input文件，将前面质控后的三代测序数据的绝对路径写在<strong>input.fofn</strong>文件里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/public/home/wlxie/luobuma/luobuma/baima_rawdata/Third_generation_sequencing/clean_filter.fq</span><br></pre></td></tr></table></figure><p>接下来也是最重要的，修改配置文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[General]</span><br><span class="line">job_type = slurm # local, slurm, sge, pbs, lsf塔大学校集群选择slurm</span><br><span class="line">job_prefix = nextDenovo</span><br><span class="line">task = all # all, correct, assemble选择只进行correct还是只进行assemble，或者两者都进行，基因组小的话可以直接all</span><br><span class="line">rewrite = yes # yes/no覆写</span><br><span class="line">deltmp = yes </span><br><span class="line">parallel_jobs = 20 # number of tasks used to run in parallel线程数，咱学校的集群20勉强够</span><br><span class="line">input_type = raw # raw, corrected输入的数据情况</span><br><span class="line">read_type = ont # clr, ont, hifi数据类型</span><br><span class="line">input_fofn = input.fofn# 输入数据的位置信息</span><br><span class="line">workdir = 03_rundir# 输出的文件夹名字</span><br><span class="line"></span><br><span class="line">[correct_option]</span><br><span class="line">read_cutoff = 1k# 进行correct的时候截取的最小read</span><br><span class="line">genome_size = 230m # estimated genome size预估的基因组大小</span><br><span class="line">sort_options = -m 20g -t 15</span><br><span class="line">minimap2_options_raw = -t 8</span><br><span class="line">pa_correction = 3 # number of corrected tasks used to run in parallel, each corrected task requires ~TOTAL_INPUT_BASES/4 bytes of memory usage.</span><br><span class="line">correction_options = -p 15 -dbuf# 非常重要！-dbuf让每一步作业释放内存，防止节点卡死！</span><br><span class="line"></span><br><span class="line">[assemble_option]</span><br><span class="line">minimap2_options_cns = -t 8 </span><br><span class="line">nextgraph_options = -a 1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上是我的配置文件信息，<strong>中文标注的地方都很重要</strong>，根据情况修改。其他参数可以用默认。其中预估的基因大小也是很有必要的，前面在做基因组Survey的时候预测过，这里就直接写预测的基因组大小。</p><p>其他参数的设定和使用可以参考这篇博客<a href="https://blog.csdn.net/u012110870/article/details/102660023">使用NextDenovo组装Nanopore数据</a>，以及官方的参数说明手册<a href="https://nextdenovo.readthedocs.io/en/latest/OPTION.html">NextDenovo Parameter Reference — NextDenovo latest documentation</a></p><p>需要强调一点，<code>correction_options = -p 15 -dbuf</code>这项参数是我在华农的集群平台手册上看到的，之前确实一直会<strong>卡死</strong>在某一步直到24h后台强杀这个进程，目前未知原因，加上之后运行正常。以我的数据来看，一个200多Mb的植物基因组，测序深度100X左右，一次组装运行结束需要12小时左右，<strong>已经非常快了</strong>。</p><p>最后是运行程序，我写了一个run.slurm文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -n 40</span></span><br><span class="line"></span><br><span class="line">./nextDenovo run.cfg</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sbatch run.slurm</span><br></pre></td></tr></table></figure><p><strong>基因组比较大的话，建议分步运行，先correct，再assemble。</strong></p><p>因为是在集群中运行，所有输出都会在slurm-xxxx.out的文件夹中显示，打开以后可以看到每个时间节点完成了什么任务，当有任务卡住几个小时都没动的时候，就要检查是否是配置文件是否正确。</p><p><img src="https://www.shelven.com/tuchuang/20230223/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230223/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>最后组装的基因组在03.ctg_graph目录下，文件名称nd.asm.fasta。最底下输出了组装结果概况，contig N50为9Mb，总共组装出225Mb的基因组序列，contig总数为59，组装结果还算不错。</p><h3 id="2-2-Canu"><a href="#2-2-Canu" class="headerlink" title="2.2 Canu"></a>2.2 Canu</h3><p>Canu是三代测序数据组装的经典工具，也是主要用于Pacbio和Nanopore公司的测序结果组装。</p><p>这个软件在安装过程中有点曲折，从官网下数据包，最后一步编译的过程会报错。目前我暂时没办法解决，但是可以用conda安装（虽然官网不建议这么做）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install -c conda-forge -c bioconda -c defaults canu</span><br></pre></td></tr></table></figure><p>如果报错动态库出问题，可以参考<a href="https://www.shelven.com/2022/07/02/a.html">第三篇博客</a>中的方法，寻找根目录下的动态库中是否有对应的版本文件，如果有，<strong>直接修改软链接到对应的动态库下</strong>。</p><p>Canu运行分为三个步骤：<strong>纠错（Correct）、修剪（Trim）和组装（Assemble）</strong>。可以每一个步骤分开跑，比如纠错修剪之后的数据可以放到别的软件中组装，或者用别的软件纠错之后作为输入到Canu中组装。考虑到塔大集群24小时自动杀程序，保险起见还是三个步骤分开跑比较安全。</p><p>下面是官方的帮助文档，写的非常详细：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">usage:   canu [-version] [-citation] \</span><br><span class="line">              [-haplotype | -correct | -trim | -assemble | -trim-assemble] \</span><br><span class="line">              [-s &lt;assembly-specifications-file&gt;] \</span><br><span class="line">               -p &lt;assembly-prefix&gt; \# 输出文件前缀</span><br><span class="line">               -d &lt;assembly-directory&gt; \# 输出目录</span><br><span class="line">               genomeSize=&lt;number&gt;[g|m|k] \# 预测基因组大小</span><br><span class="line">              [other-options] \</span><br><span class="line">              [-haplotype&#123;NAME&#125; illumina.fastq.gz] \</span><br><span class="line">              [-corrected] \</span><br><span class="line">              [-trimmed] \</span><br><span class="line">              [-pacbio |</span><br><span class="line">               -nanopore |</span><br><span class="line">               -pacbio-hifi] file1 file2 ...</span><br><span class="line"></span><br><span class="line">example: canu -d run1 -p godzilla genomeSize=1g -nanopore-raw reads/*.fasta.gz </span><br><span class="line"></span><br><span class="line">  To restrict canu to only a specific stage, use:# 描述canu要执行的主程序</span><br><span class="line">    -haplotype     - generate haplotype-specific reads</span><br><span class="line">    -correct       - generate corrected reads</span><br><span class="line">    -trim          - generate trimmed reads</span><br><span class="line">    -assemble      - generate an assembly</span><br><span class="line">    -trim-assemble - generate trimmed reads and then assemble them</span><br><span class="line"></span><br><span class="line">  Reads can be either FASTA or FASTQ format, uncompressed, or compressed with gz, bz2 or xz.</span><br><span class="line"></span><br><span class="line">  Reads are specified by the technology they were generated with, and any processing performed.</span><br><span class="line"></span><br><span class="line">  [processing]# 描述reads状态</span><br><span class="line">    -corrected</span><br><span class="line">    -trimmed</span><br><span class="line"></span><br><span class="line">  [technology]# 描述测序平台（数据类型）</span><br><span class="line">    -pacbio      &lt;files&gt;</span><br><span class="line">    -nanopore    &lt;files&gt;</span><br><span class="line">    -pacbio-hifi &lt;files&gt;</span><br><span class="line">    </span><br><span class="line">  Some common options:</span><br><span class="line">    useGrid=string</span><br><span class="line">      - Run under grid control (true), locally (false), or set up for grid control</span><br><span class="line">        but don&#x27;t submit any jobs (remote)</span><br><span class="line">    rawErrorRate=fraction-error# 降低这个参数会提高第一步的速度</span><br><span class="line">      - The allowed difference in an overlap between two raw uncorrected reads.  For lower</span><br><span class="line">        quality reads, use a higher number.  The defaults are 0.300 for PacBio reads and</span><br><span class="line">        0.500 for Nanopore reads.  </span><br><span class="line">    correctedErrorRate=fraction-error# 降低这个参数可以提高组装效率</span><br><span class="line">      - The allowed difference in an overlap between two corrected reads.  Assemblies of</span><br><span class="line">        low coverage or data with biological differences will benefit from a slight increase</span><br><span class="line">        in this.  Defaults are 0.045 for PacBio reads and 0.144 for Nanopore reads.</span><br><span class="line">    gridOptions=string</span><br><span class="line">      - Pass string to the command used to submit jobs to the grid.  Can be used to set</span><br><span class="line">        maximum run time limits.  Should NOT be used to set memory limits; Canu will do</span><br><span class="line">        that for you.</span><br><span class="line">    minReadLength=number</span><br><span class="line">      - Ignore reads shorter than &#x27;number&#x27; bases long.  Default: 1000.</span><br><span class="line">    minOverlapLength=number</span><br><span class="line">      - Ignore read-to-read overlaps shorter than &#x27;number&#x27; bases long.  Default: 500.</span><br><span class="line">  A full list of options can be printed with &#x27;-options&#x27;.  All options can be supplied in</span><br><span class="line">  an optional sepc file with the -s option.# 可以用-s来提供自己修改的参数文件</span><br><span class="line"></span><br><span class="line">Complete documentation at http://canu.readthedocs.org/en/latest/</span><br></pre></td></tr></table></figure><p>也可以<a href="https://canu.readthedocs.io/en/latest/quick-start.html#">点击这里</a>，进官方手册看原文。下面用我自己的三代数据跑一个案例。</p><h4 id="2-2-1-纠错（Correct）"><a href="#2-2-1-纠错（Correct）" class="headerlink" title="2.2.1 纠错（Correct）"></a>2.2.1 纠错（Correct）</h4><p>因为三代测序数据错误率较高，纠错的步骤是通过序列之间的一致性比较获得高可信的碱基。</p><p>创建一个canu的空文件夹，写入以下内容到correct.slurm:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -N 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -n 40</span></span><br><span class="line"></span><br><span class="line">canu -correct -p baima -d baima_nanopore genomeSize=230m -nanopore-raw /public/home/wlxie/luobuma/luobuma/baima_rawdata/Third_generation_sequencing/pass.fq</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sbatch correct.slurm</span><br></pre></td></tr></table></figure><p>主要就是注意下参数，<code>-p</code>是输出文件的前缀，<code>-d</code>是输出文件的目录名，需要声明这个数据是什么平台测的，以及数据是什么状态。虽然我这里只申请了40个核，但是<strong>canu会自动提交作业直到你能申请的核数上限</strong>……在塔大集群我的权限是200个核，通过scontrol show job 可以查到，我这边一次性提交了136个作业，排队100多个任务，占用192个核…..</p><p><strong>纠错、修整和组装每一个步骤会依次进行以下各个阶段</strong>，需要的内存和核数挺高的，所以推荐在集群中运行。</p><p><img src="https://www.shelven.com/tuchuang/20230223/3.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230223/3.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>如果运行时间很长，<strong>建议到设置的输出文件夹目录下查看canu.out文件</strong>，详细记载了正在执行哪一步以及花了多少时间。如果不确定程序是否卡死，直接通过<code>scontrol show job</code>命令查看状态为RUNNING的作业，进入作业的输出目录，如果文件夹中的内容一直到最近的时间点都有更新，则可以放心地继续运行。</p><p><strong>仅仅这一个步骤花了30个小时。</strong>并且这一步会将<strong>100X的测序数据量降到40X（默认，可以调整，见官方<a href="https://canu.readthedocs.io/en/latest/parameter-reference.html#readsamplingcoverage">readSampleingCoverage</a>参数介绍）</strong>。最后生成文件<code>baima.correctedReads.fasta.gz</code>，我为了方便复制到了前一个文件夹，修改文件权限为0755。</p><h4 id="2-2-2-修整（trim）"><a href="#2-2-2-修整（trim）" class="headerlink" title="2.2.2 修整（trim）"></a>2.2.2 修整（trim）</h4><p>修整是在上一步纠错的基础上，再对reads进行修剪，删去可疑区域。</p><p>这一步经历的步骤与上一步是一样的，虽然上一步纠错已经将数据量降了一大半，对于我的基因组，<strong>这一步依然要跑32小时.</strong></p><p>同样在canu文件夹写入如下内容到trim.slurm：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -n 50</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -t 7200</span></span><br><span class="line"></span><br><span class="line">canu -trim -p baima -d baima_trim genomeSize=230m -corrected -nanopore /public/home/wlxie/canu/baima.correctedReads.fasta.gz</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sbatch trim.slurm</span><br></pre></td></tr></table></figure><p>注意修改参数以及reads所处的状态。</p><p>在canu.out输出文件中，可以找到trim步骤用了什么参数，处理了哪些类型的reads：</p><p><img src="https://www.shelven.com/tuchuang/20230223/4.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230223/4.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>生成的结果文件在baima_trim文件夹中，名称为<code>baima.trimmedReads.fasta.gz</code>，同样修改文件权限，移到前一个文件夹方便操作。</p><h4 id="2-2-3-组装（Assemble）"><a href="#2-2-3-组装（Assemble）" class="headerlink" title="2.2.3 组装（Assemble）"></a>2.2.3 组装（Assemble）</h4><p>经过前两步的数据纠错和修整，这一步才是正式组装基因组。</p><p>在canu文件夹写入如下内容到assemble.slurm：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -n 50</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -t 10800</span></span><br><span class="line"></span><br><span class="line">canu -assemble -p baima -d baima_assemble genomeSize=230m correctedErrorRate=0.144 -trimmed -corrected -nanopore /public/home/wlxie/canu/baima.trimmedReads.fasta.gz</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sbatch assemble.slurm</span><br></pre></td></tr></table></figure><p>在官方的介绍中，correctedErrorRate这个参数可以根据前面纠错和修整的reads质量做修改的，<strong>默认是Pacbio数据0.045，Nanopore数据0.144</strong>，降低这个参数值可以加快组装的效率，但是存在遗漏overlap和组装片段断裂的风险。低于30X测序深度以下的数据，官方建议可以略微提高这个值，对于60X测序深度以上的数据可以略微降低这个值，<strong>每次改变1%左右比较合适</strong>。</p><p>我这里就用默认参数了，组装时间可能会比较长，就将作业的时间调整为7天。</p><p>实际运行时间为30小时，最终组装结果如下：</p><p><img src="https://www.shelven.com/tuchuang/20230223/5.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230223/5.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>这个工具组装出的结果比预期大很多，<strong>前面基因组survey预测的基因组大小为230Mbp，实际通过canu组装出有276Mbp</strong>，且contig数明显比NextDenovo多，导致contig N50指标低。我觉得可能是<code>correctedErrorRate</code>这个值比较高，可以适当调低一些，过于严格的纠错标准可能导致组装的contig比较碎。</p><p>因为前面的NextDenovo组装的效果已经比较理想，因此这一步我也就不再细调参数了。以NextDenovo组装出的基因组继续后面的分析。以目前我的植物基因组来看，用NextDenovo组装三代基因组的效率和质量都比Canu高。</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;前段时间比较忙，现在继续整理基因组测序组装系列的学习笔记。&lt;a href=&quot;https://www.shelven.com/2022/07/03/a.html&quot;&gt;第四篇笔记&lt;/a&gt;写的二代测序基因组组装，主要是演示二代测序数据组装的主流工具SOAPdenovo 2.0是如何应用的。我这里有了二代和三代的测序数据，后续组装还是以&lt;strong&gt;三代数据为主&lt;/strong&gt;，这里就继续记录下几款三代测序数据组装的主流工具和用法。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="基因组三代测序分析" scheme="http://www.shelven.com/categories/%E5%9F%BA%E5%9B%A0%E7%BB%84%E4%B8%89%E4%BB%A3%E6%B5%8B%E5%BA%8F%E5%88%86%E6%9E%90/"/>
    
    
    <category term="NextDenovo" scheme="http://www.shelven.com/tags/NextDenovo/"/>
    
    <category term="Canu" scheme="http://www.shelven.com/tags/Canu/"/>
    
  </entry>
  
  <entry>
    <title>解决github DNS污染的三种方法</title>
    <link href="http://www.shelven.com/2023/02/21/a.html"/>
    <id>http://www.shelven.com/2023/02/21/a.html</id>
    <published>2023-02-21T13:47:13.000Z</published>
    <updated>2023-02-21T13:49:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近因为需要安装各种生信软件，用github比较多，每次登github都要翻墙很是麻烦。索性花了点时间研究了一下，下面分别列举三种情况下的解决github网站登录的问题。</p><span id="more"></span><p>知其然知其所以然，首先我们需要明白为什么github在国内经常无法登录。我们在浏览器地址栏输入网址以后，域名服务器会对输入的域名进行解析（DNS解析），解析成为计算机之间可以识别的ip地址。然而因为一些众所周知的因素，很多国外的网站在国内是无法直接访问的，其中一个限制方法就是<strong>DNS污染</strong>，将域名服务器中缓存的域名指向不正确的ip地址。<strong>这种限制手段就和你公司电脑会限制你浏览一些网站是一样的。</strong></p><p>因此要浏览这些被DNS污染的网站，我们需要跳过受污染的局域域名服务器，常用的方法就是<strong>代理服务器和VPN</strong>（VPN就是一个典型的正向代理），通过更远的服务器转发我们的http请求，在经过未污染的域名服务器解析之后，返回我们想要的网页内容。当然，如果仅仅只是用翻墙的方法的话，本篇博客这里可以结束了，下面通过三种情况分别讲一下如何通过修改host等其他方法访问github。</p><h2 id="1-Windows系统修改host"><a href="#1-Windows系统修改host" class="headerlink" title="1. Windows系统修改host"></a>1. Windows系统修改host</h2><div class="story post-story"><p><strong>首先注意一点，如果你正在用翻墙软件或者VPN等，需要先将所有代理都关闭（防止全局代理导致设置的host失效）。</strong></p><p>host文件是一个没有扩展名的系统文件，可以用notepad++打开编辑，其本质就是就是将访问的域名和ip地址建立关联。当浏览器中输入网址时，系统会首先从host文件中找到域名对应的ip地址，如果没有找到才会发送给域名解析器。所以我们只需要找到github相关域名对应的正确的ip地址，即可正常访问github（其他受DNS污染的网址同理）。</p><p>打开网址 <a href="https://www.ipaddress.com/">https://www.ipaddress.com/</a></p><p>主要查找以下github相关域名的ip地址，有多少个记录多少个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">github.com# 主站</span><br><span class="line">nodeload.github.com</span><br><span class="line">api.github.com# API</span><br><span class="line">codeload.github.com</span><br><span class="line">github.global.ssl.Fastly.net# git clone速度相关</span><br><span class="line">assets-cdn.github.com# 静态资源相关</span><br></pre></td></tr></table></figure><p><img src="https://www.shelven.com/tuchuang/20230221/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230221/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>windows系统中host文件位置</p><p><code>C:\WINDOWS\System32\drivers\etc\hosts</code></p><p>notepad++打开host文件，最后加入如下查到的ip地址，保存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># domain: github.com</span><br><span class="line"># 更新时间 2023年2月21日</span><br><span class="line"></span><br><span class="line">140.82.113.3 github.com</span><br><span class="line">140.82.114.10 nodeload.github.com</span><br><span class="line">140.82.112.6 api.github.com</span><br><span class="line">140.82.114.10 codeload.github.com</span><br><span class="line"></span><br><span class="line">151.101.1.194 github.global.ssl.Fastly.net</span><br><span class="line">151.101.65.194 github.global.ssl.Fastly.net</span><br><span class="line">151.101.129.194 github.global.ssl.Fastly.net</span><br><span class="line">151.101.193.194 github.global.ssl.Fastly.net</span><br><span class="line"></span><br><span class="line">185.199.108.153 assets-cdn.github.com</span><br><span class="line">185.199.110.153 assets-cdn.github.com</span><br><span class="line">185.199.111.153 assets-cdn.github.com</span><br></pre></td></tr></table></figure><p>最后一步打开cmd命令行，刷新缓存就可以正常登录github了</p><p><code>ipconfig /flushdns</code></p><p><img src="https://www.shelven.com/tuchuang/20230221/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230221/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div><h2 id="2-Linux系统修改host"><a href="#2-Linux系统修改host" class="headerlink" title="2. Linux系统修改host"></a>2. Linux系统修改host</h2><div class="story post-story"><p><strong>方法步骤同上，需要注意linux系统修改host需要root权限!</strong></p><p>linux系统host文件路径</p><p><code>/etc/hosts</code></p></div><h2 id="3-无root权限的linux系统访问github"><a href="#3-无root权限的linux系统访问github" class="headerlink" title="3. 无root权限的linux系统访问github"></a>3. 无root权限的linux系统访问github</h2><div class="story post-story"><p>有些时候我们会在集群中安装软件，这个时候是没有root权限的，无法通过修改host的方法直接访问，因此也无法用git clone的方法克隆仓库（<strong>会报错，错误代码443</strong>）。</p><p><img src="https://www.shelven.com/tuchuang/20230221/3.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230221/3.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>今天碰到这个问题，找贺师兄聊了聊才发现可以找镜像资源曲线救国……突然打开了新世界的大门hhhh</p><p>真的解决了困扰我很久的疑惑，按照往常我只能翻墙下载源代码，再解压后传回服务器，一来一回校园网的速度要传很久很久……</p><p>具体做法是先下载<strong>油猴（Tampermonkey）插件</strong>，这是个非常有名的脚本管理器，下载安装方式就不说了，网上一大把，自己搜下github官方也非常简单。<a href="https://github.com/Tampermonkey/tampermonkey">Tampermonkey&#x2F;tampermonkey</a></p><p>然后是安装github增强加速插件，插件地址 <a href="https://greasyfork.org/zh-CN/scripts/412245-github-%E5%A2%9E%E5%BC%BA-%E9%AB%98%E9%80%9F%E4%B8%8B%E8%BD%BD">https://greasyfork.org/zh-CN/scripts/412245-github-%E5%A2%9E%E5%BC%BA-%E9%AB%98%E9%80%9F%E4%B8%8B%E8%BD%BD</a></p><p>我因为安装过了，这里就只演示一下：</p><p><img src="https://www.shelven.com/tuchuang/20230221/4.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230221/4.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>安装之后再回到原来github页面，点击code按钮，就可以看到原来只有一个git clone地址，现在有好几个地址给出来了，在集群里随便git clone选择其他地址，就可以在成功下载啦。</p><p><img src="https://www.shelven.com/tuchuang/20230221/5.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230221/5.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>这个javascript脚本感兴趣的话可以在油猴中看看，本质上也是个CDN加速和代理，只不过用的都是公益资源，速度也相当不错了。</p></div><h2 id="4-写在最后"><a href="#4-写在最后" class="headerlink" title="4. 写在最后"></a>4. 写在最后</h2><div class="story post-story"><p>前面两个方法改host并不是一劳永逸的，<strong>隔一段时间github的ip地址就会更新（不定，可能几天，可能几周）。</strong>这种纯手动更新的方法仍然是不够智能不够优雅的，<strong>有能力的话以后写一个自动更新的脚本</strong>（间隔一段时间自动查找相关github域名的ip地址，自动更新到host文件中）。</p><p>目前为止，还是代理最为省心。</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近因为需要安装各种生信软件，用github比较多，每次登github都要翻墙很是麻烦。索性花了点时间研究了一下，下面分别列举三种情况下的解决github网站登录的问题。&lt;/p&gt;</summary>
    
    
    
    <category term="网络相关" scheme="http://www.shelven.com/categories/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="github" scheme="http://www.shelven.com/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>校园网代理服务器的搭建</title>
    <link href="http://www.shelven.com/2023/02/09/a.html"/>
    <id>http://www.shelven.com/2023/02/09/a.html</id>
    <published>2023-02-09T08:55:45.000Z</published>
    <updated>2023-02-09T08:58:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>以前的一篇博客讲过如何搭建反向代理服务器，从而实现在校外登录校内集群，<a href="https://www.shelven.com/2022/07/13/a.html">详情点击这里</a>。本篇博客主要记录下如果想要在校外登录学校教务平台、登录学校购买的数字资源库应该如何实现。</p><span id="more"></span><h2 id="1-实现思路"><a href="#1-实现思路" class="headerlink" title="1. 实现思路"></a>1. 实现思路</h2><div class="story post-story"><p>首先要更正一下前一篇博客的错误之处，<strong>学校集群是有公网ip的，只是限制了ip访问</strong>。</p><p>使用的工具仍然是frp，需要的设备是一台在校内24h不断电的服务器（本篇博客中的校内集群），以及一台有公网ip的校外服务器（本篇博客中是我的轻量云服务器）。</p><p>上篇内网穿透博客记录的是典型的<strong>反向代理过程</strong>，将校内集群ssh登录的端口映射到校外服务器的其他端口，通过访问该端口登录校内集群，整个代理过程客户端无法得知服务端的真实ip和端口，可以做到隐藏服务端真实信息、确保服务端安全。</p><p>而我们这里想要登录校园内的其他网站、使用校园网ip登录知网万方等数据库的话，就需要<strong>用校内集群转发我们的http请求，将请求返回的结果通过校外服务器中转后返回给我们</strong>，按照我的理解，这是一个正向代理+反向代理结合的过程。</p><p>反向代理：隐藏了服务端，我并不知道我访问的实际是校内集群（输入的是校外服务器的ip地址和端口）。</p><p>正向代理：隐藏了客户端，集群将http请求转发到校内网站和学校买的数据库网站（后者并不知道发出请求的实际是校外服务器）。</p><p><strong>校内集群在整个过程中信息完全被隐藏，校外服务器起到中转的作用，最后将http请求返回的结果传递给我们</strong>。</p></div><h2 id="2-frp配置"><a href="#2-frp配置" class="headerlink" title="2. frp配置"></a>2. frp配置</h2><div class="story post-story"><h3 id="2-1-service端配置"><a href="#2-1-service端配置" class="headerlink" title="2.1 service端配置"></a>2.1 service端配置</h3><p>frps安装在校外服务器上，frps.ini配置文件完全不用修改，这里就顺便展示一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_port = 7000# frp监听的端口，默认7000，可改</span><br><span class="line">bind_udp_port = 7400# UDP通讯端口，可不设置，用于点对点穿透</span><br><span class="line">token = xxxxxxxx# 安全考虑需要设置口令，client端需要用到</span><br><span class="line"></span><br><span class="line">dashboard_port = 7500# frp管理端口，可改</span><br><span class="line">dashboard_user = xxxx# 管理端口认证的用户名，用于身份识别，自己设置</span><br><span class="line">dashboard_pwd = xxxx# 管理端口认证的密码，用于身份识别，自己设置</span><br><span class="line">enable_prometheus = true</span><br><span class="line"></span><br><span class="line">subdomain_host = xxx.xxx.xxx# 设置子域名，主要方便登录管理界面。不用ip地址，用域名+端口的方式直接访问</span><br><span class="line"></span><br><span class="line">log_file = /usr/local/frp/frps.log# frp日志配置，这里是记录3天的日志信息</span><br><span class="line">log_level = info</span><br><span class="line">log_max_days = 3</span><br></pre></td></tr></table></figure><h3 id="2-2-client端配置"><a href="#2-2-client端配置" class="headerlink" title="2.2 client端配置"></a>2.2 client端配置</h3><p>frpc安装在校内集群，frpc.ini配置文件修改如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = xxx.xxx.xxx.xxx# 填写你的service端服务器公网ip，这里我写我的云服务器ip</span><br><span class="line">server_port = 7000# 前面设置的frp监听端口，需要保持一致</span><br><span class="line">token = xxxxxxxxx # 前面设置的口令</span><br><span class="line"></span><br><span class="line">[http_proxy]# 这里只演示http代理，有ssh需求的自行加入，其他参考frpc_full.ini</span><br><span class="line">type = tcp</span><br><span class="line">remote_port = xxxx# 映射的service端服务器的端口，自己定义</span><br><span class="line">plugin = http_proxy# http代理插件（frpc自带）</span><br></pre></td></tr></table></figure><h3 id="2-3-开放端口，开启frp服务"><a href="#2-3-开放端口，开启frp服务" class="headerlink" title="2.3 开放端口，开启frp服务"></a>2.3 开放端口，开启frp服务</h3><p>service端（也就是校外服务器）开放上一步client端设置的服务器端口，<strong>重载防火墙</strong>。</p><p>分别在service端和client端后台不挂起运行frps和frpc（对应文件夹中运行）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nohup ./frps -c frps.ini &amp;</span><br><span class="line">nohup ./frpc -c frpc.ini &amp;</span><br></pre></td></tr></table></figure><p>service端可以查看运行日志frps.log文件，端口监听成功即可；client端可以查看nohup文件的运行结果（最好定时清一下，否则这个文件会很大）。</p><p>如果想要停止frp服务，查看任意service端或者client端的frp程序进程，结束即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | grep frp# 查看任务进程号</span><br><span class="line">kill -9 进程号# 结束任务进程</span><br></pre></td></tr></table></figure></div><h2 id="3-代理实现"><a href="#3-代理实现" class="headerlink" title="3. 代理实现"></a>3. 代理实现</h2><div class="story post-story"><p>按照上面步骤搭建好代理服务器，我们只需要在电脑上设置代理地址和端口，就可以在电脑上用外网访问校园内网和数据库网站了。</p><p><img src="https://www.shelven.com/tuchuang/20230209/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230209/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>上面的图片我就不放真实信息了，根据图片意思设置即可，一般来说教程到这里就可以结束了，<strong>但是仅仅如此还不够优雅</strong>。</p><p>如果不对地址进行限制，那么所有http访问都将通过代理进行，即<strong>全局代理</strong>，一般情况下我们是不希望如此的。举个例子，如果访问的是localhost，我们一般是用直连（Direct）；访问限制ip的特定的网站走代理服务器（Proxy）；访问不限制ip的网站仍然用直连，因为直连速度最快，只受你电脑带宽限制。</p><p><strong>如果访问所有网站都用代理的话，比如我的小破服务器就1M带宽，速度就很感人了……</strong></p><p>简单讲一讲三种方法优雅地实现校园网代理</p><h3 id="3-1-使用设置脚本"><a href="#3-1-使用设置脚本" class="headerlink" title="3.1 使用设置脚本"></a>3.1 使用设置脚本</h3><p>没错就是手动设置代理上面那个选项，这个脚本是以**.PAC<strong>为扩展名的</strong>JavaScript脚本**，决定http请求是通过直连目标还是通过代理的方式连接。</p><p>pac文件中使用的JavaScript 函数可以在官方查到用法，这里做个示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">FindProxyForURL</span>(<span class="params">url, host</span>) &#123;</span><br><span class="line">    <span class="comment">//设置代理池</span></span><br><span class="line"><span class="keyword">var</span> proxy1 = <span class="string">&quot;PROXY xxx.xxx.xxx.xxx:xxxx&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> proxy2 = <span class="string">&quot;PROXY xxx.xxx.xxx.xxx:xxxx&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//本地地址直连</span></span><br><span class="line"><span class="keyword">if</span> (<span class="title function_">isPlainHostName</span>(host)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;DIRECT&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 代理1</span></span><br><span class="line"><span class="keyword">if</span> (<span class="title function_">shExpMatch</span>(url, <span class="string">&quot;*.cnki.com/*&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> proxy1;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 代理2</span></span><br><span class="line"><span class="keyword">if</span> (<span class="title function_">shExpMatch</span>(url, <span class="string">&quot;*.wanfangdata.com.cn/*&quot;</span>)) &#123;</span><br><span class="line">   <span class="keyword">return</span> proxy2;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;DIRECT&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的文件保存为.pac格式文件，代理池部分填写前面做的代理服务器ip和端口（当然我只有一个代理服务器，根据需要自己改），需要代理的网址这里可以用<strong>shExpMatch</strong>函数进行<strong>正则匹配</strong>，完成后再设置自动设置代理部分。打开自动检测设置和使用设置脚本，将.pac文件的地址（可以是本地地址或者放在你自己的服务器上，能访问到就行）贴到脚本地址栏。</p><p><img src="https://www.shelven.com/tuchuang/20230209/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230209/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><strong>接下来就可以愉快地访问学校购买的数字资源啦<del>并且上其他网站因为是直连网速也不会变慢</del></strong></p><p><img src="https://www.shelven.com/tuchuang/20230209/3.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230209/3.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="3-2-使用其他代理软件"><a href="#3-2-使用其他代理软件" class="headerlink" title="3.2 使用其他代理软件"></a>3.2 使用其他代理软件</h3><p>代理软件种类繁多，相比直接设置脚本，代理软件往往还提供更多更直观的方式控制http代理方式，这里就简单介绍个软件<strong>Proxifier</strong></p><p>设置方法与手动设置大同小异<del>（手动设置的代理规则比较反人类）</del>，同样是设置代理服务器ip，端口，可以设置不同的协议，还可以启用验证保证安全。</p><p><img src="https://www.shelven.com/tuchuang/20230209/4.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230209/4.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>设置代理规则</p><p><img src="https://www.shelven.com/tuchuang/20230209/5.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230209/5.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>代理规则就不一一细说了，这个软件就是比较直观，而且还可以记录代理产生的流量等等。</p><h3 id="3-3-做个切换全局代理工具"><a href="#3-3-做个切换全局代理工具" class="headerlink" title="3.3 做个切换全局代理工具"></a>3.3 做个切换全局代理工具</h3><p>如果是自己用的话，使用代理脚本是最简单最优雅又不费事的方法。</p><p>如果要给同一个实验室其他人分享，又怕别人电脑不安全（直接分享脚本会导致源码泄露，万一别人电脑被黑了自己服务器的信息就被暴露了），就可以做一个代理工具，别人用得着的时候开启，用不着的时候就关闭（<strong>全局代理的重要性，就算忘记关闭代理，看到别的网页速度变慢了，也就会想起来去关闭代理了</strong>），可以一定程度上保护自己服务器的安全，又简化别人设置代理的步骤，一举两得哈哈~</p><p><strong>实现方式就是做一个批处理，然后将bat转化为exe即可</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">for /f &quot;tokens=1,2,* &quot; %%i in (&#x27;REG QUERY &quot;HKCU\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot; /v ProxyEnable ^| find /i &quot;ProxyEnable&quot;&#x27;) do (set /A ProxyEnableValue=%%k)</span><br><span class="line"></span><br><span class="line">if %ProxyEnableValue% equ 0 (</span><br><span class="line">    echo 正在开启知网代理，请稍候...</span><br><span class="line">    ping -n 2 127.0.0.1&gt;nul</span><br><span class="line">    echo=</span><br><span class="line">    echo 获取注册表中代理启用状态......</span><br><span class="line">    reg add &quot;HKCU\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot; /v ProxyEnable /t REG_DWORD /d 1 /f</span><br><span class="line">    ping -n 2 127.0.0.1&gt;nul</span><br><span class="line">    echo=</span><br><span class="line">    echo 设置代理服务器......</span><br><span class="line">    reg add &quot;HKCU\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot; /v ProxyServer /d &quot;xxx.xxx.xxx.xxx:xxxx&quot; /f</span><br><span class="line">    ping -n 2 127.0.0.1&gt;nul</span><br><span class="line">    echo=</span><br><span class="line">    echo 代理已开启，请阅读弹窗内容并按确认键关闭本窗口...</span><br><span class="line">    echo=</span><br><span class="line">    echo 知网一键代理工具 Version 1.0</span><br><span class="line">    echo 版权所有 塔里木大学研发中心405. 保留所有权利。</span><br><span class="line">    echo 该工具由405实验室内部开发，仅供本实验室人员使用，切勿外传。</span><br><span class="line">    echo msgbox&quot;代理开启期间网速会变慢，使用完毕后请再次点击该工具结束代理！&quot;,0,&quot;提示&quot;&gt; %tmp%\\tmp.vbs</span><br><span class="line">    cscript /nologo %tmp%\\tmp.vbs</span><br><span class="line">    del %tmp%\\tmp.vbs</span><br><span class="line">) else if %ProxyEnableValue% equ 1 (</span><br><span class="line">    echo 正在关闭知网代理，请稍候...</span><br><span class="line">    ping -n 2 127.0.0.1&gt;nul</span><br><span class="line">    echo=</span><br><span class="line">    echo 获取注册表中代理启用状态......</span><br><span class="line">    reg add &quot;HKCU\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot; /v ProxyEnable /t REG_DWORD /d 0 /f </span><br><span class="line">    ping -n 2 127.0.0.1&gt;nul</span><br><span class="line">    echo=</span><br><span class="line">    echo 清除代理服务器设置......</span><br><span class="line">    reg add &quot;HKCU\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot; /v ProxyServer /d &quot;&quot; /f </span><br><span class="line">    ping -n 2 127.0.0.1&gt;nul</span><br><span class="line">    echo=</span><br><span class="line">    echo 代理已关闭，请按确认键退出本窗口...</span><br><span class="line">    echo=</span><br><span class="line">    echo 知网一键代理工具 Version 1.0</span><br><span class="line">    echo 版权所有 塔里木大学研发中心405. 保留所有权利。</span><br><span class="line">    echo 该工具由405实验室内部开发，仅供本实验室人员使用，切勿外传。</span><br><span class="line">    echo msgbox&quot;再见。&quot;,0,&quot;提示&quot;&gt; %tmp%\\tmp.vbs</span><br><span class="line">    cscript /nologo %tmp%\\tmp.vbs</span><br><span class="line">    del %tmp%\\tmp.vbs</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>上面的内容文件保存为.bat后缀文件（<strong>有中文的话，保存时编码格式要改为ANSI</strong>），只需修改xxx.xxx.xxx.xxx:xxxx部分为你前面设置的代理服务器ip和端口即可。</p><p>原理就是获取注册表中代理服务的开启状态，转化为另一种状态， <code>ping -n 2 127.0.0.1</code>这个只是为了使用者有<strong>参与感</strong>……延迟两秒进行下一步处理hhhhhh</p><p>最后网上找个图，转成icon格式作为图标，然后将bat批处理格式文件转化成exe可执行程序文件即可，我这里用的Bat_To_Exe_Converter这个软件，转成exe源码不容易被泄露，而且怎么说呢看上去给人感觉也稍微正式一点<del>（bushi）</del>。</p><p><img src="https://www.shelven.com/tuchuang/20230209/6.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20230209/6.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>大概就是这样，<strong>每双击一次应用程序，切换全局代理的状态为开或者关</strong></p></div><h2 id="4-注意"><a href="#4-注意" class="headerlink" title="4. 注意"></a>4. 注意</h2><div class="story post-story"><p><strong>浏览器是会缓存ip信息的，无论使用何种方式开启代理，最好都先关闭浏览器之后重新打开。</strong></p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;以前的一篇博客讲过如何搭建反向代理服务器，从而实现在校外登录校内集群，&lt;a href=&quot;https://www.shelven.com/2022/07/13/a.html&quot;&gt;详情点击这里&lt;/a&gt;。本篇博客主要记录下如果想要在校外登录学校教务平台、登录学校购买的数字资源库应该如何实现。&lt;/p&gt;</summary>
    
    
    
    <category term="网络相关" scheme="http://www.shelven.com/categories/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="内网穿透" scheme="http://www.shelven.com/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    
    <category term="代理服务器" scheme="http://www.shelven.com/tags/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>基于requests和Xpath改进微信公众号爬虫</title>
    <link href="http://www.shelven.com/2022/12/18/a.html"/>
    <id>http://www.shelven.com/2022/12/18/a.html</id>
    <published>2022-12-18T15:00:18.000Z</published>
    <updated>2022-12-18T15:03:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>前面一篇博客讲了requests、Xpath和selenium的用法，最后用selenium模拟浏览器对搜狗微信文章做了自动化爬取。从搜狗微信网页爬取的公众号文章其实是不全的，不能保证公众号的所有文章都被搜狗收录，且selenium爬取速度相对较慢（但是对动态页面爬取很有用），因此可以选择另一种方式——直接从微信公众号后台进行爬取。</p><span id="more"></span><p>这两天改了下代码，就讲一讲从微信公众号后台爬文章的思路。</p><h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h2><div class="story post-story"><p>首先是申请微信公众号，自从2018年微信公众号加强用户管理以后，<strong>一个身份证只可以注册一个订阅号</strong>了，除非你有营业执照，以公司为主体注册名额还能加两个。比较建议多弄几个微信公众号，只要绑定自己是运营者就行，可以让朋友帮忙注册一下，<strong>从微信公众号后台直接爬是有可能被ban接口的</strong>，被反爬机制检测到第一次ban一小时，第二次可能ban一天，看情况而定。</p><p>我这里是准备了三个微信公众号，保证爬取过程不中断~</p><p>首先进入微信公众号后台，点击<strong>图文消息</strong>，在跳转的编辑页面上方点击<strong>超链接</strong>。</p><p><img src="https://www.shelven.com/tuchuang/20221218/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221218/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><img src="https://www.shelven.com/tuchuang/20221218/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221218/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>在这个页面按F12进入开发者工具，链接内容选择其他公众号，输入你想要爬的公众号名字，点击右边放大镜搜索后对返回数据抓包。</p><p>这里第一个返回的数据包是显示公众号搜索内容的，一个重要的参数<strong>fakeid</strong>就是公众号名字的内部编号。然后<strong>返回前面的标头，获取cookie</strong>，这是我们登录微信公众号的凭证，后面爬取网页必须带上cookie内容。</p><p><img src="https://www.shelven.com/tuchuang/20221218/3.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221218/3.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>点击我们要找的公众号（你名字输对的话肯定是第一个），又返回一个数据包，在负载里我们可以看到begin和count两个重要的参数。在试验过后可以发现，begin表示从哪一页开始，count表示一页显示多少天的推送，这里count值在我多次试验之后，发现最大值为5，<strong>传入超过5的数都会变成默认值5</strong>（<strong>也就是说不能通过一页获取所有文章的url</strong>）！</p><p><img src="https://www.shelven.com/tuchuang/20221218/4.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221218/4.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>而在响应体中，我们可以看到所有返回文章的title、link、update_time、digest等重要的信息都在app_msg_list中，上面的app_msg_count值我测试后发现是记录一共发布文章<strong>天数</strong>的。</p><p><img src="https://www.shelven.com/tuchuang/20221218/555.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221218/555.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>在这个公众号例子中，digest本来应该是摘要的，但在这里只是一段甚至半段内容，无法提取有用的信息，所以我直接忽略了这部分数据；而且一般公众号会把subtitle分离出来，这个公众号没有，因此需要写一段代码分离标题中的分类标题，以标题中的竖线来分割“副标题（分类）|标题”。</p><p>接下来可以随便点一个link，F12看看文章的html结构，记录文章内容的xpath地址（不记得xpath地址怎么找的话，<a href="https://www.shelven.com/2022/12/14/a.html">看前一篇xpath用法</a>）。这里文章的图片我就没有收集了，我只收集了文字部分内容。</p><p>每个公众号排版不一样，根据内容再写一个正则匹配一下不需要的内容，也就是对内容“去噪”。不详细讲，因公众号而异，我这里要去除的噪声是公众号底部的进群邀请内容。</p></div><h2 id="2-代码部分"><a href="#2-代码部分" class="headerlink" title="2. 代码部分"></a>2. 代码部分</h2><div class="story post-story"><p>截至目前为止（2022年12月28日），代码运行正常：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> requests, re</span><br><span class="line"><span class="keyword">from</span> requests.packages <span class="keyword">import</span> urllib3</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">import</span> xlwt</span><br><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> DataFrame</span><br><span class="line"></span><br><span class="line">key_word = <span class="string">&quot;植物生物技术Pbj&quot;</span></span><br><span class="line">xpath_string = <span class="string">&#x27;//*[@id=&quot;js_content&quot;]//text()&#x27;</span>    <span class="comment"># 文章内容的xpath路径</span></span><br><span class="line">last_date = <span class="number">2018</span>  <span class="comment"># 想要获得哪一年之后的文章</span></span><br><span class="line"><span class="comment"># 创建工作表格，存储爬取的临时数据</span></span><br><span class="line">book = xlwt.Workbook(encoding=<span class="string">&#x27;utf-8&#x27;</span>,style_compression=<span class="number">0</span>)</span><br><span class="line">sheet = book.add_sheet(key_word,cell_overwrite_ok=<span class="literal">True</span>)</span><br><span class="line">col = (<span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;author&#x27;</span>, <span class="string">&#x27;content&#x27;</span>,<span class="string">&#x27;category&#x27;</span>,<span class="string">&quot;link&quot;</span>,<span class="string">&quot;date&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">6</span>):</span><br><span class="line">    sheet.write(<span class="number">0</span>,i,col[i]) <span class="comment"># 第一行写入属性名称,write对应参数：行、列、值</span></span><br><span class="line"></span><br><span class="line">urllib3.disable_warnings()  <span class="comment"># 忽略警告</span></span><br><span class="line"><span class="comment"># 最终爬取数据存放列表</span></span><br><span class="line">title_list = []</span><br><span class="line">link_list = []</span><br><span class="line">cat_list = []</span><br><span class="line">date_list = []</span><br><span class="line">content_list = []</span><br><span class="line">author_list = []</span><br><span class="line"></span><br><span class="line">s = requests.Session()  <span class="comment"># 维持会话</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对微信公众号查找的headers</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:72.0) Gecko/20100101 Firefox/72.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Host&quot;</span>: <span class="string">&quot;mp.weixin.qq.com&quot;</span>,</span><br><span class="line">    <span class="string">&#x27;Referer&#x27;</span>: <span class="string">&#x27;https://mp.weixin.qq.com/&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">cookie_str = <span class="string">&quot;&quot;</span></span><br><span class="line">cookies = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载cookies，将字符串格式的cookies转化为字典形式</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_cookies</span>():</span><br><span class="line">    <span class="keyword">global</span> cookie_str, cookies</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> cookie_str.split(<span class="string">&#x27;;&#x27;</span>):</span><br><span class="line">        sep_index = item.find(<span class="string">&#x27;=&#x27;</span>)</span><br><span class="line">        cookies[item[:sep_index]] = item[sep_index + <span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 去噪函数，只适合该公众号</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quzao</span>(<span class="params">content</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(content) == <span class="built_in">str</span>:</span><br><span class="line">        i = re.sub(<span class="string">&#x27;植物生物技术Pbj交流群&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="built_in">str</span>(content))</span><br><span class="line">        i = re.sub(<span class="string">&#x27;为了能更有效地帮助广大的科研工作者获取相关信息.*&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="built_in">str</span>(i))</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 爬虫主函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spider</span>():</span><br><span class="line">    <span class="comment"># 加载cookies</span></span><br><span class="line">    load_cookies()</span><br><span class="line">    <span class="comment"># 访问官网主页</span></span><br><span class="line">    url = <span class="string">&#x27;https://mp.weixin.qq.com&#x27;</span></span><br><span class="line">    res = s.get(url = url, headers = headers, cookies = cookies, verify = <span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">if</span> res.status_code == <span class="number">200</span>:</span><br><span class="line">        <span class="comment"># 由于加载了cookies，相当于已经登陆了，系统作了重定义，response的url中含有我们需要的token</span></span><br><span class="line">        <span class="built_in">print</span>(res.url)</span><br><span class="line">        <span class="comment"># 获得token</span></span><br><span class="line">        token = re.findall(<span class="string">r&#x27;.*?token=(\d+)&#x27;</span>, res.url)</span><br><span class="line">        <span class="keyword">if</span> token:</span><br><span class="line">            token = token[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 没有token的话，说明cookies过时了，没有登陆成功，退出程序</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;登陆失败&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;token&#x27;</span>, token)</span><br><span class="line">        <span class="comment"># 检索公众号</span></span><br><span class="line">        url = <span class="string">&#x27;https://mp.weixin.qq.com/cgi-bin/searchbiz&#x27;</span></span><br><span class="line">        data = &#123;</span><br><span class="line">            <span class="string">&quot;action&quot;</span>: <span class="string">&quot;search_biz&quot;</span>,</span><br><span class="line">            <span class="string">&quot;begin&quot;</span>: <span class="string">&quot;0&quot;</span>,</span><br><span class="line">            <span class="string">&quot;count&quot;</span>: <span class="string">&quot;5&quot;</span>,</span><br><span class="line">            <span class="string">&quot;query&quot;</span>: key_word,</span><br><span class="line">            <span class="string">&quot;token&quot;</span>: token,</span><br><span class="line">            <span class="string">&quot;lang&quot;</span>: <span class="string">&quot;zh_CN&quot;</span>,</span><br><span class="line">            <span class="string">&quot;f&quot;</span>: <span class="string">&quot;json&quot;</span>,</span><br><span class="line">            <span class="string">&quot;ajax&quot;</span>: <span class="string">&quot;1&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># 继续使用会话发起请求</span></span><br><span class="line">        res = s.get(url = url, params = data, cookies = cookies, headers = headers, verify = <span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">if</span> res.status_code == <span class="number">200</span>:</span><br><span class="line">            <span class="comment"># 搜索结果的第一个提取它的fakeid</span></span><br><span class="line">            fakeid = res.json()[<span class="string">&#x27;list&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;fakeid&#x27;</span>]</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;微信公众号fakeid&#x27;</span>, fakeid)</span><br><span class="line">            page_size = <span class="number">5</span>  <span class="comment"># 默认是5天文章1页，这个参数似乎最大值只有5</span></span><br><span class="line">            page_count = <span class="number">278</span>  <span class="comment"># 公众号文章总页数（自己手动调整，爬取到第几页）</span></span><br><span class="line">            cur_page = <span class="number">1</span>    <span class="comment"># 爬取页数（从第几页开始爬取）</span></span><br><span class="line">            l = <span class="number">1</span> <span class="comment"># excel计数用</span></span><br><span class="line">            <span class="keyword">while</span> cur_page &lt;= page_count:</span><br><span class="line">                url = <span class="string">&#x27;https://mp.weixin.qq.com/cgi-bin/appmsg&#x27;</span></span><br><span class="line">                data = &#123;</span><br><span class="line">                    <span class="string">&quot;action&quot;</span>: <span class="string">&quot;list_ex&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;begin&quot;</span>: <span class="built_in">str</span>(page_size * (cur_page - <span class="number">1</span>)),</span><br><span class="line">                    <span class="string">&quot;count&quot;</span>: <span class="built_in">str</span>(page_size),</span><br><span class="line">                    <span class="string">&quot;fakeid&quot;</span>: fakeid,</span><br><span class="line">                    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;9&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;query&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;token&quot;</span>: token,</span><br><span class="line">                    <span class="string">&quot;lang&quot;</span>: <span class="string">&quot;zh_CN&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;f&quot;</span>: <span class="string">&quot;json&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;ajax&quot;</span>: <span class="string">&quot;1&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">                time.sleep(random.randint(<span class="number">1</span>, <span class="number">5</span>))</span><br><span class="line">                <span class="comment">#继续会话发起请求</span></span><br><span class="line">                res = s.get(url = url, params = data, cookies = cookies, headers = headers, verify  =<span class="literal">False</span>)</span><br><span class="line">                <span class="keyword">if</span> res.status_code == <span class="number">200</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&#x27;开始爬取页数：&#x27;</span>, cur_page)</span><br><span class="line">                    <span class="comment"># 文章列表位于app_msg_list字段中</span></span><br><span class="line">                    app_msg_list = res.json()[<span class="string">&#x27;app_msg_list&#x27;</span>]</span><br><span class="line">                    <span class="keyword">for</span> item <span class="keyword">in</span> app_msg_list:</span><br><span class="line">                        <span class="comment"># 通过更新时间戳获得文章的发布日期</span></span><br><span class="line">                        item[<span class="string">&#x27;post_date&#x27;</span>] = time.strftime(<span class="string">&quot;%Y-%m-%d&quot;</span>, time.localtime(<span class="built_in">int</span>(item[<span class="string">&#x27;update_time&#x27;</span>])))</span><br><span class="line">                        <span class="keyword">if</span> <span class="built_in">int</span>(item[<span class="string">&#x27;post_date&#x27;</span>].split(<span class="string">&#x27;-&#x27;</span>)[<span class="number">0</span>])&lt;last_date:</span><br><span class="line">                            <span class="keyword">continue</span></span><br><span class="line">                        <span class="comment"># 以下标题分离只适合该公众号</span></span><br><span class="line">                        <span class="keyword">if</span> item[<span class="string">&#x27;title&#x27;</span>].find(<span class="string">&quot;|&quot;</span>) != -<span class="number">1</span>:   <span class="comment"># 有竖线分离副标题</span></span><br><span class="line">                            title = item[<span class="string">&#x27;title&#x27;</span>].split(<span class="string">&quot;|&quot;</span>)[<span class="number">1</span>].strip()</span><br><span class="line">                            cat = item[<span class="string">&#x27;title&#x27;</span>].split(<span class="string">&quot;|&quot;</span>)[<span class="number">0</span>].strip()</span><br><span class="line">                        <span class="keyword">elif</span> item[<span class="string">&#x27;title&#x27;</span>].find(<span class="string">&quot;｜&quot;</span>) != -<span class="number">1</span>:</span><br><span class="line">                            title = item[<span class="string">&#x27;title&#x27;</span>].split(<span class="string">&quot;｜&quot;</span>)[<span class="number">1</span>].strip()    <span class="comment"># 分离中文竖线</span></span><br><span class="line">                            cat = item[<span class="string">&#x27;title&#x27;</span>].split(<span class="string">&quot;｜&quot;</span>)[<span class="number">0</span>].strip()</span><br><span class="line">                        <span class="keyword">elif</span> item[<span class="string">&#x27;title&#x27;</span>].find(<span class="string">&quot;│&quot;</span>) != -<span class="number">1</span>:</span><br><span class="line">                            title = item[<span class="string">&#x27;title&#x27;</span>].split(<span class="string">&quot;│&quot;</span>)[<span class="number">1</span>].strip()     <span class="comment"># 分离另一种很神奇的竖线</span></span><br><span class="line">                            cat = item[<span class="string">&#x27;title&#x27;</span>].split(<span class="string">&quot;│&quot;</span>)[<span class="number">0</span>].strip()</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            title = (item[<span class="string">&#x27;title&#x27;</span>])</span><br><span class="line">                            cat = <span class="string">&#x27;N/A&#x27;</span></span><br><span class="line">                        title_list.append(title)</span><br><span class="line">                        date_list.append(item[<span class="string">&#x27;post_date&#x27;</span>])</span><br><span class="line">                        link_list.append(item[<span class="string">&#x27;link&#x27;</span>])</span><br><span class="line">                        author_list.append(key_word)</span><br><span class="line">                        cat_list.append(cat)</span><br><span class="line">                        response = requests.get(url = item[<span class="string">&#x27;link&#x27;</span>], headers = headers)</span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">&quot;正在解析网页&quot;</span> + <span class="built_in">str</span>(item[<span class="string">&#x27;link&#x27;</span>]) + <span class="string">&#x27;......&#x27;</span>)</span><br><span class="line">                        time.sleep(random.randint(<span class="number">1</span>, <span class="number">5</span>))  <span class="comment"># 爬一个，休息1-5秒</span></span><br><span class="line">                        tree_content = etree.HTML(response.text)  <span class="comment"># 获取爬到的动态页面源码</span></span><br><span class="line">                        <span class="keyword">try</span>:    <span class="comment"># 解析xpath，去噪</span></span><br><span class="line">                            content = tree_content.xpath(xpath_string)</span><br><span class="line">                            content = re.sub(<span class="string">r&#x27;\s+&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>.join(content))  <span class="comment"># 获取到的文章内容（去空格）</span></span><br><span class="line">                            content = quzao(content)</span><br><span class="line">                        <span class="keyword">except</span>:</span><br><span class="line">                            content = <span class="string">&#x27;&#x27;</span>    <span class="comment"># 没有内容的可能是内容违规已撤销</span></span><br><span class="line">                        content_list.append(content)    </span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">&#x27;解析文章&quot;&#x27;</span>+title+<span class="string">&#x27;&quot;成功！&#x27;</span>)</span><br><span class="line">                        <span class="keyword">try</span>:</span><br><span class="line">                            <span class="comment"># 以下逐行写入，备份数据用，防止反爬造成数据丢失</span></span><br><span class="line">                            sheet.write(l , <span class="number">0</span>, title)</span><br><span class="line">                            sheet.write(l , <span class="number">1</span>, key_word)</span><br><span class="line">                            sheet.write(l , <span class="number">2</span>, content)</span><br><span class="line">                            sheet.write(l , <span class="number">3</span>, cat)</span><br><span class="line">                            sheet.write(l , <span class="number">4</span>, item[<span class="string">&#x27;link&#x27;</span>])</span><br><span class="line">                            sheet.write(l , <span class="number">5</span>, item[<span class="string">&#x27;post_date&#x27;</span>])</span><br><span class="line">                            savepath = <span class="string">&#x27;./微信公众号_&#x27;</span> + key_word + <span class="string">&#x27;_.xls&#x27;</span></span><br><span class="line">                            l += <span class="number">1</span></span><br><span class="line">                            <span class="keyword">if</span> l % <span class="number">20</span> == <span class="number">0</span>:     <span class="comment"># 每20行保存一次（适当调大一点，以免保存失败）</span></span><br><span class="line">                                book.save(savepath)</span><br><span class="line">                                <span class="built_in">print</span>(<span class="string">&quot;数据备份成功！已保存&quot;</span> + <span class="built_in">str</span>(l) + <span class="string">&quot;条！&quot;</span>)</span><br><span class="line">                        <span class="keyword">except</span>:</span><br><span class="line">                            <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 当前页面数+1</span></span><br><span class="line">                cur_page += <span class="number">1</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;over！开始保存&#x27;</span>)</span><br><span class="line">    <span class="comment"># 中途没有反爬的话，一次写入所有爬取数据</span></span><br><span class="line">    data = &#123;<span class="string">&#x27;title&#x27;</span>: title_list, <span class="string">&#x27;author&#x27;</span>: author_list, <span class="string">&#x27;content&#x27;</span>: content_list,<span class="string">&#x27;category&#x27;</span>: cat_list,<span class="string">&quot;link&quot;</span>:link_list,<span class="string">&quot;date&quot;</span>:date_list&#125;</span><br><span class="line">    df = DataFrame(data)</span><br><span class="line">    df.to_excel(<span class="string">&#x27;./微信公众号_&#x27;</span> + key_word + <span class="string">&#x27;_.xlsx&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;保存成功！&#x27;</span>)</span><br><span class="line">spider()</span><br></pre></td></tr></table></figure><p>代码只有cookie需要登录微信公众号后台手动获取，复制粘贴进去；page_count由刚才查文章的界面往下拉，找到一共有多少页，其他参数都不用修改。</p><p>为了防止半路被反爬，引入了xlwt库，作用是创建工作表，逐行写入保存爬到的临时数据，不然有可能爬到一半被检测到，最后所有数据都不会保存<del>（别问我为什么知道）</del>！最后一步是写入所有数据，名称和临时数据不一样，也是多一步保险措施。爬取过程显示的数据如下：</p><p><img src="https://www.shelven.com/tuchuang/20221218/111.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221218/111.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>如果中途被反爬机制检测到，换一个公众号cookie，然后从中断的cur_page处继续，excel另存。</p><p>通过以上代码，实现对公众号“植物生物技术Pbj”8447篇推送（从创建的第一天2019年3月1日至2022年12月18日）爬取：</p><p><img src="https://www.shelven.com/tuchuang/20221218/6.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221218/6.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><strong>上面的代码是根据“植物生物技术Pbj”这个公众号排版所特制的</strong>，一定要注意根据具体公众号决定制作怎么样的去噪函数，总页数其实也可以根据app_msg_count&#x2F;page_size值写一个函数自动计算出来，但是如果中途被反爬还是要手动改page值，这里就不多此一举了。还有，如果爬取的每页推送天数（也就是第二个data字典中的count值）可以突破5的话，就可以再写一个循环尽量一次拿到多的文章url，这样检测的机率就会大大降低（<strong>我每次被检测都是抓取app_msg_list的时候，而不是抓取文章内容的时候</strong>）。</p><p>经过半天的测试，有一点以下的经验之谈</p><ul><li>微信公众号反爬机制<strong>可能是检测你翻页的次数</strong>，一天翻页的次数在100-200次间比较保险，也就是一次爬500天-1000天内的推送数据</li><li>每次抓取数据sleep1-5秒比较靠谱，1-3秒也容易在爬100条左右的时候被抓……</li><li>有一个思路是通过保存所有文章url，再进行每个文章内容抓取，但是获取文章列表的data字典中count值最大只能是5，导致我们需要频繁翻页，这个地方如何突破是一个问题。</li><li>sheet.write方法有的时候会失效，在某一次打开excel之后可能没来得及写入数据就被保存，<strong>导致后续无法继续保存临时数据</strong>。解决方法之一是保存间隔大一点，这里我设置了每写入20行保存一次。</li><li>做好爬取数据的双保险！<strong>我这里做了临时数据保存，不要抱侥幸心，不然爬半天数据容易全部木大！</strong></li></ul></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;前面一篇博客讲了requests、Xpath和selenium的用法，最后用selenium模拟浏览器对搜狗微信文章做了自动化爬取。从搜狗微信网页爬取的公众号文章其实是不全的，不能保证公众号的所有文章都被搜狗收录，且selenium爬取速度相对较慢（但是对动态页面爬取很有用），因此可以选择另一种方式——直接从微信公众号后台进行爬取。&lt;/p&gt;</summary>
    
    
    
    <category term="网络相关" scheme="http://www.shelven.com/categories/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="python" scheme="http://www.shelven.com/tags/python/"/>
    
    <category term="爬虫" scheme="http://www.shelven.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>应用requests、Xpath和selenium编写爬虫脚本</title>
    <link href="http://www.shelven.com/2022/12/14/a.html"/>
    <id>http://www.shelven.com/2022/12/14/a.html</id>
    <published>2022-12-13T16:42:48.000Z</published>
    <updated>2022-12-13T16:47:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博客承接前面的HTTP基本原理，对requests、Xpath和selenium三个库&#x2F;工具做个简单介绍，并且用三个爬虫实例由浅到深理解爬虫的构思和实现过程，最后是用selenium+chromedriver模拟浏览器，实现对微信公众号文章的爬取。</p><span id="more"></span><h2 id="1-requests"><a href="#1-requests" class="headerlink" title="1. requests"></a>1. requests</h2><div class="story post-story"><p>requests是python最常见的HTTP客户端库，可以调用requests模块的API伪装成浏览器对网站发起请求。</p><p>前面一篇爬虫博客介绍了requests的六种方法，这里不多赘述，主要回顾下发送请求和获得响应的过程。</p><p>requests库有两个重要的对象，<strong>Request</strong>和<strong>Response</strong>，Request对象对应的是请求，向目标网址发送一个请求访问服务。而Response对象，是包含了爬虫返回的内容。</p><p>Request对象完整的发起get和post请求方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">requests.get(url, params=<span class="literal">None</span>, **kwargs)</span><br><span class="line">requests.post(url, data=<span class="literal">None</span>, **kwargs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># url：想要获取的网页链接</span></span><br><span class="line"><span class="comment"># params：显示在url中的参数，字典形式</span></span><br><span class="line"><span class="comment"># data：不显示在url中，通过提交表单的方式提交参数，也是字典形式</span></span><br><span class="line"><span class="comment"># **kwargs：控制访问的参数，字典形式</span></span><br></pre></td></tr></table></figure><p>当服务器正常响应时，返回<strong>状态码200</strong>，这个时候就可以用Response对象的属性来获取网页信息。</p><p>Response对象属性：</p><ul><li>.status_code：HTTP响应状态码，200表示成功，其他状态码详见上篇博客</li><li>.text：HTTP响应体内容的<strong>字符串格式</strong></li><li>.content：HTTP响应体内容的<strong>二进制格式</strong></li><li>.encoding：从HTTP header中猜测的响应内容编码方式</li><li>.apparent_encoding：从内容中分析出的响应内容编码方式（备选编码方式）</li></ul><p>这里需要注意，<strong>如果我们获得的响应内容是图片视频和音频的话，需要用二进制格式进行储存。</strong></p><p>有了以上基础知识，就可以用request写一个爬虫项目了，我们现在目的是爬取豆瓣电影古装排行榜前20的电影图片。</p><p>进入豆瓣电影排行榜网页，按F12进入浏览器开发者工具，点击网页页面分类中的“古装”，对网页数据进行抓包。当鼠标滚轮往下滚动的时候我们可以发现，每次滚动更新，有一个名字很长的数据包会不断更新，还伴随着一大堆jpg图片的出现，很明显这个数据包是我们要抓取的对象。</p><p><img src="https://www.shelven.com/tuchuang/20221213/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221213/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>点击表头选项的响应头，我们看到返回的数据是json格式，编码方式是utf-8。请求url栏中问号之前的部分是我们要的url，参数可以设置一个字典传入。</p><p><img src="https://www.shelven.com/tuchuang/20221213/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221213/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>在负载部分，多次抓包以后可以看到前三个参数是<strong>一直不变</strong>的，猜测这几个参数可能是和电影类型和页面布局相关，这个可以不用管。翻页刷新后总是固定显示20个电影，因此limit和数据包内抓取的电影数相关，start和这个数据库中起始的电影编号相关。</p><p>再看看响应的json数据中，有一个“cover_url”的键对应值是电影的图片地址，至此思路就很明确了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://movie.douban.com/j/chart/top_list&#x27;</span></span><br><span class="line"><span class="comment"># 传入的url参数设置</span></span><br><span class="line">param = &#123;</span><br><span class="line">    <span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;30&#x27;</span>,<span class="comment"># 影片类型代号</span></span><br><span class="line">    <span class="string">&#x27;interval_id&#x27;</span>: <span class="string">&#x27;100:90&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;action&#x27;</span>:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;start&#x27;</span>: <span class="string">&#x27;0&#x27;</span>,<span class="comment"># 从第一个影片开始</span></span><br><span class="line">    <span class="string">&#x27;limit&#x27;</span>: <span class="string">&#x27;10&#x27;</span>,<span class="comment"># 需要抓取的影片数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 伪装浏览器</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36 Edg/108.0.1462.46&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 抓取上面定义范围内所有影片信息</span></span><br><span class="line">response = requests.get(url = url, params = param, headers = headers)</span><br><span class="line"><span class="comment"># json字符串反序列化为list类型</span></span><br><span class="line">ls = response.json()</span><br><span class="line"><span class="comment"># 解析电影图片地址，并抓取和保存图片</span></span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> ls:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./&#x27;</span> + <span class="built_in">str</span>(p[<span class="string">&#x27;title&#x27;</span>]) + <span class="string">&#x27;.jpg&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> img:</span><br><span class="line">        response1 = requests.get(url = p[<span class="string">&quot;cover_url&quot;</span>], headers = headers)</span><br><span class="line">        img.write(response1.content)</span><br><span class="line">        </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;over!!!&#x27;</span>)</span><br></pre></td></tr></table></figure><p><code>.json()</code>这个requests库自带的函数还是挺有意思的，在这个例子中是将返回的字符串JSON数据反序列化为list数据，list中嵌套了字典数据，每个电影的信息都储存在字典中。因此这里也可以用<code>.json()[&#39;cover_url&#39;]</code>直接对图片网址进行抓取，注意下这里第二次抓取的是图片，返回的是二进制数据，所以用content而不是text。</p></div><h2 id="2-Xpath"><a href="#2-Xpath" class="headerlink" title="2. Xpath"></a>2. Xpath</h2><div class="story post-story"><p>前面例子抓包返回的是JSON字符串，所以可以直接提取我们要的信息。如果返回的是HTML源代码，就可以用<strong>正则或者Xpath</strong>来解析我们想要的数据。</p><p><strong>Xpath是一种解析XML文档信息的工具，我们可以通过lxml库（XML和HTML的解析库）中导入etree模块，实例化etree对象，使用xpath函数结合xpath表达式进行标签定位和指定数据的获取。</strong></p><p>Xpath常用规则：</p><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>nodename</td><td>选取此节点的所有子节点</td></tr><tr><td>&#x2F;</td><td>从当前节点选取直接子节点</td></tr><tr><td>&#x2F;&#x2F;</td><td>从当前节点选取所有子孙节点</td></tr><tr><td>.</td><td>选取当前节点</td></tr><tr><td>..</td><td>选取当前节点的父节点</td></tr><tr><td>@</td><td>选取属性</td></tr></tbody></table><p>Xpath常用表达式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">属性定位</span><br><span class="line">//div[@class=&quot;slist&quot;]# 找到所有class属性值为slist的div标签</span><br><span class="line">层级定位</span><br><span class="line">//div[@class=&quot;slist&quot;]/../li[2]# 找到class属性值为slist的div的父标签下的第二个直系子标签li</span><br><span class="line">多属性解析</span><br><span class="line">//div[@class=&quot;slist&quot; and @name=&quot;Id&quot;]# 找到class属性为slist以及name属性为Id的div标签</span><br><span class="line">模糊匹配</span><br><span class="line">//div[contains(@class, &quot;slist&quot;)]# 找到class属性中包含slist值得div标签</span><br><span class="line">文本获取</span><br><span class="line">//li[@class=&quot;item&quot;]//text()# 取出class属性值为item的所有li标签下的所有标签文本（包括子标签） </span><br><span class="line">获取属性</span><br><span class="line">//li/a/@href# 取出所有li标签下a标签下的href属性值</span><br></pre></td></tr></table></figure><p>etree对象实例化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">本地文件（解析保存在本地的HTML文件）：</span><br><span class="line">tree = etree.parse(文件名)</span><br><span class="line">tree.xpath(&quot;xpath表达式&quot;)</span><br><span class="line"></span><br><span class="line">网络数据（实例化一个html类）：</span><br><span class="line">tree = etree.HTML(网页内容字符串)</span><br><span class="line">tree.xpath(&quot;xpath表达式&quot;)</span><br></pre></td></tr></table></figure><p>注意下xpath解析出来的数据是以<strong>列表</strong>形式存储的，接下来示范一下requests结合Xpath写一个爬虫程序，目的是抓取<a href="https://pic.netbian.com/4kdongman/">彼岸图网</a>的4k动漫封面图。</p><p>进入页面以后同样F12审查元素，点击不同页抓取返回的数据包，发现翻到第x页能抓到index_x.html，但是第一页没有下划线和其他页稍有不同，为了方便起见就从第二页开始抓。</p><p><img src="https://www.shelven.com/tuchuang/20221213/3.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221213/3.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>仔细观察可以发现，所有封面图都在属性值为slist的div标签下的ul标签下的li标签中<del>（这么说着好绕&#x3D; &#x3D;）</del>，前面http原理的博客说过，这样的标签可以看出是是无序列表，我们要找的封面图片地址可以通过img标签的src属性获得，图片名称可以通过alt属性获得，因此可以写如下的爬虫代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># 举个例子，这里抓取的是第二页数据</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="number">3</span>):</span><br><span class="line">    url = <span class="string">&#x27;http://pic.netbian.com/4kdongman/index_&#x27;</span>+<span class="built_in">str</span>(i)+<span class="string">&#x27;.html&#x27;</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.3&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    response = requests.get(url = url, headers = headers)</span><br><span class="line">    <span class="comment"># 获取网页内容字符串</span></span><br><span class="line">    page_text = response.text</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化etree对象，获取所有图片li标签信息（列表格式）</span></span><br><span class="line">    tree = etree.HTML(page_text)</span><br><span class="line">    li_list = tree.xpath(<span class="string">&#x27;//div[@class=&quot;slist&quot;]/ul/li&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 创建文件夹</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">&#x27;./pic&#x27;</span>):</span><br><span class="line">            os.mkdir(<span class="string">&#x27;./pic&#x27;</span>)</span><br><span class="line">            </span><br><span class="line">    <span class="comment"># 解析li标签下孙子标签img的src属性和alt属性</span></span><br><span class="line">    <span class="keyword">for</span> li <span class="keyword">in</span> li_list:</span><br><span class="line">        img_src = <span class="string">&#x27;http://pic.netbian.com&#x27;</span> + li.xpath(<span class="string">&#x27;./a/img/@src&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">        img_name = li.xpath(<span class="string">&#x27;./a/img/@alt&#x27;</span>)[<span class="number">0</span>] + <span class="string">&#x27;.jpg&#x27;</span></span><br><span class="line">        <span class="comment"># 这里需要处理中文乱码问题，重新编码和解码，gbk是中文最常用的</span></span><br><span class="line">        img_name = img_name.encode(<span class="string">&#x27;iso-8859-1&#x27;</span>).decode(<span class="string">&#x27;gbk&#x27;</span>)</span><br><span class="line">        img_data = requests.get(url = img_src, headers = headers).content</span><br><span class="line">        img_path = <span class="string">&#x27;pic/&#x27;</span> + img_name</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(img_path,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">                fp.write(img_data)</span><br><span class="line">                <span class="built_in">print</span>(img_name,<span class="string">&#x27;下载成功！！！&#x27;</span>)</span><br></pre></td></tr></table></figure><p>当然，上面爬虫抓取的只是封面图片，并不是高清图片，因为高清图片是需要登录账号花钱下载的….我们只能合法地从我们能在浏览器中看到的图片爬取信息。而且如果你在短时间内发起大量请求的话，ip是很有可能被封的，以后再讲一些预防反爬的措施。</p></div><h2 id="3-selenium"><a href="#3-selenium" class="headerlink" title="3. selenium"></a>3. selenium</h2><div class="story post-story"><p>selenium是一个自动化测试工具，本质是通过驱动浏览器，<strong>完全模拟浏览器中的操作</strong>，比如拖动、点击下拉等等。为什么要模仿浏览器中的操作呢？因为很多网站是动态加载的，requests这一类的模块无法直接执行JavaScript代码，这个时候就可以通过测试工具selenium模仿人在浏览器中的操作，从而获得网页渲染之后的结果。</p><p>selenium官方网站：<a href="https://www.selenium.dev/">Selenium</a></p><p><del>（很暖心地有中文文档）</del>以最新的selenium指南为基础，简单介绍一下其用法。</p><p>强调两点：</p><ul><li>selenium在4.3版本做了代码重构，很多方法被改写，<strong>最重要的是find_element方法的改写</strong>，<a href="https://github.com/SeleniumHQ/selenium/blob/a4995e2c096239b42c373f26498a6c9bb4f2b3e7/py/CHANGES">具体点击这里查看官方消息</a>。本篇博客所有写法将按照最新的语法规则</li><li><strong>一定要注意自己的浏览器与驱动版本是否匹配</strong>，本篇博客以chrome浏览器为例，chrome浏览器驱动程序官方下载地址请点击<a href="http://chromedriver.storage.googleapis.com/index.html">http://chromedriver.storage.googleapis.com/index.html</a></li></ul><p>简单地以淘宝首页作为例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.chrome.service <span class="keyword">import</span> Service</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="comment"># 启动前先将驱动程序放在当前页面</span></span><br><span class="line">bro = Service(executable_path = <span class="string">&#x27;./chromedriver.exe&#x27;</span>)</span><br><span class="line"><span class="comment"># 启动谷歌浏览器</span></span><br><span class="line">driver = webdriver.Chrome(service = bro)</span><br><span class="line"><span class="comment"># 进入淘宝网页页面</span></span><br><span class="line">driver.get(<span class="string">&#x27;https://www.taobao.com/&#x27;</span>)</span><br><span class="line"><span class="comment"># 标签定位，输入栏id属性值为&#x27;q&#x27;，id属性是整个html中唯一的，不会重复</span></span><br><span class="line">search_input = driver.find_element(By.ID, <span class="string">&#x27;q&#x27;</span>)</span><br><span class="line"><span class="comment"># 节点交互，向输入栏中输入数据&#x27;Iphone&#x27;</span></span><br><span class="line">search_input.send_keys(<span class="string">&#x27;Iphone&#x27;</span>)</span><br><span class="line"><span class="comment"># 标签定位，找到搜索按钮（可以用css选择器、id值或者Xpath等定位，这里用css选择器）</span></span><br><span class="line">btn = driver.find_element(By.CSS_SELECTOR, <span class="string">&#x27;.btn-search&#x27;</span>)</span><br><span class="line"><span class="comment"># 节点交互，点击搜索按钮</span></span><br><span class="line">btn.click()</span><br><span class="line">driver.get(<span class="string">&#x27;https://www.baidu.com&#x27;</span>)</span><br><span class="line">sleep(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 回退</span></span><br><span class="line">driver.back()</span><br><span class="line">sleep(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 前进</span></span><br><span class="line">driver.forward()</span><br><span class="line">sleep(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 退出浏览器</span></span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure><p>简单来说，流程可以分为</p><ol><li>创建驱动实例开启会话    <code>driver = webdriver.Chrome()</code></li><li>在浏览器中执行操作    <code>driver.get(&quot;https://www.baidu.com&quot;)</code></li><li>请求浏览器信息    <code>title = driver.title</code></li><li>建立等待策略（隐式或显示）    <code>driver.implicitly_wait(0.5)或者用sleep（1）</code></li><li>定位标签    <code>text_box = driver.find_element(by=By.NAME, value=&quot;my-text&quot;)</code></li><li>节点交互    <code>text_box.send_keys(&quot;Selenium&quot;)</code></li><li>获取信息     <code>value = message.text</code></li><li>结束会话，关闭浏览器    <code>driver.quit()</code></li></ol><h3 id="浏览器创建"><a href="#浏览器创建" class="headerlink" title="浏览器创建"></a>浏览器创建</h3><p>selenium支持的浏览器有Chrome、Firefox、Edge、Internet Explorer和Safari。参考<a href="https://www.selenium.dev/zh-cn/documentation/webdriver/browsers/">支持的浏览器列表 | Selenium</a></p><h3 id="元素定位"><a href="#元素定位" class="headerlink" title="元素定位"></a>元素定位</h3><p>webdriver提供了8种内置的定位方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"></span><br><span class="line">find_element(By.ID, <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line">find_element(By.NAME, <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line">find_element(By.CLASS_NAME, <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line">find_element(By.TAG_NAME, <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line">find_element(By.LINK_TEXT, <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line">find_element(By.PARTIAL_LINK_TEXT, <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line">find_element(By,XPATH, <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line">find_element(By.CSS_SELECTOR, <span class="string">&#x27;value&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="节点交互"><a href="#节点交互" class="headerlink" title="节点交互"></a>节点交互</h3><p>常见的节点交互有以下内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">driver.get(<span class="string">&quot;https://www.baidu.com&quot;</span>)<span class="comment"># 打开网站</span></span><br><span class="line">driver.back()<span class="comment"># 浏览器后退</span></span><br><span class="line">driver.forward()<span class="comment"># 浏览器前进</span></span><br><span class="line">driver.refresh()<span class="comment"># 浏览器刷新</span></span><br><span class="line">driver.add_cookie(&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>: <span class="string">&quot;value&quot;</span>&#125;)<span class="comment"># 当前浏览器添加cookie</span></span><br><span class="line">driver.find_element(By.LINK_TEXT, <span class="string">&quot;new window&quot;</span>).click()<span class="comment"># 新窗口中打开链接</span></span><br><span class="line">driver.find_element(By.ID, <span class="string">&#x27;value&#x27;</span>).send_keys(<span class="string">&#x27;value&#x27;</span>)<span class="comment"># 定位并发送内容</span></span><br><span class="line">driver.switch_to.new_window(<span class="string">&#x27;tab&#x27;</span>)<span class="comment"># 打开新标签页并切换到新标签页</span></span><br><span class="line">driver.switch_to.new_window(<span class="string">&#x27;window&#x27;</span>)<span class="comment"># 打开新窗口并切换到新窗口</span></span><br><span class="line">driver.switch_to.window(original_window)<span class="comment"># 切回之前的标签页或窗口</span></span><br><span class="line">driver.close()<span class="comment"># 关闭标签页或窗口</span></span><br><span class="line">driver.quit()<span class="comment"># 关闭浏览器</span></span><br></pre></td></tr></table></figure><h3 id="动作链"><a href="#动作链" class="headerlink" title="动作链"></a>动作链</h3><p>上面说的交互是对页面中存在的标签或者说是元素进行交互，而对于没有特定对象的，比对<strong>鼠标的双击、拖拽，鼠标滚轮的操作，键盘的输入</strong>等，这些操作就需要动作链来执行。<a href="https://www.selenium.dev/zh-cn/documentation/webdriver/actions_api/">该部分内容官网有详细介绍</a>，这里就举个例子了解一下怎么用的就行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> ActionChains</span><br><span class="line"></span><br><span class="line">bro = webdriver.Chrome(executable_path = <span class="string">&#x27;./chromedriver&#x27;</span>)</span><br><span class="line">bro.get(<span class="string">&#x27;https://www.runoob.com/try/try.php?filename=jqueryui-api-droppable&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果定位的标签是存在于iframe标签之中的则必须通过如下操作在进行标签定位</span></span><br><span class="line">bro.switch_to.frame(<span class="string">&#x27;iframeResult&#x27;</span>)<span class="comment"># 切换浏览器标签定位的作用域</span></span><br><span class="line">div = bro.find_element(By.ID, <span class="string">&#x27;draggable&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 动作链</span></span><br><span class="line">action = ActionChains(bro)</span><br><span class="line"><span class="comment"># 点击长按指定的标签</span></span><br><span class="line">action.click_and_hold(div)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    action.move_by_offset(<span class="number">5</span>,<span class="number">0</span>)<span class="comment"># move_by_offset(x,y):x水平方向 y竖直方向</span></span><br><span class="line">    action.perform()<span class="comment"># 执行动作链操作</span></span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line"><span class="comment">#释放动作链</span></span><br><span class="line">action.release()</span><br><span class="line">bro.quit()</span><br></pre></td></tr></table></figure><h3 id="微信公众号爬虫范例"><a href="#微信公众号爬虫范例" class="headerlink" title="微信公众号爬虫范例"></a>微信公众号爬虫范例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> DataFrame</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.wait <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> ChromeOptions</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="comment"># moder可以为author或者article，前者为按公众号搜索，后者为按文章关键字搜索</span></span><br><span class="line">modern=<span class="string">&#x27;author&#x27;</span></span><br><span class="line"><span class="comment"># 搜索的关键字，如果modern = author，输入公众号名字，否则输入文章关键字</span></span><br><span class="line">keyword = <span class="string">&#x27;冷兔&#x27;</span></span><br><span class="line"><span class="comment"># 爬取多少页，建议先手动搜索最大页码数，page大于最大页码将会报错</span></span><br><span class="line">page = <span class="number">2</span></span><br><span class="line">headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment"># 实现规避检测</span></span><br><span class="line">option = ChromeOptions()</span><br><span class="line">option.add_experimental_option(<span class="string">&#x27;excludeSwitches&#x27;</span>, [<span class="string">&#x27;enable-automation&#x27;</span>])</span><br><span class="line">bro = webdriver.Chrome(executable_path = <span class="string">&#x27;./chromedriver&#x27;</span>, options=option)</span><br><span class="line">bro.get(<span class="string">&quot;https://www.sogou.com/index.php&quot;</span>)</span><br><span class="line">wait = WebDriverWait(bro, <span class="number">2</span>)</span><br><span class="line">search_input = bro.find_element(By.ID, <span class="string">&#x27;query&#x27;</span>)</span><br><span class="line">search_input.send_keys(keyword)</span><br><span class="line"><span class="comment"># 点击搜索按钮</span></span><br><span class="line">btn = bro.find_element(By.ID, <span class="string">&#x27;stb&#x27;</span>)</span><br><span class="line">btn.click()</span><br><span class="line"><span class="comment"># 点击微信登陆</span></span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line">btn = bro.find_element(By.XPATH, <span class="string">&#x27;//*[@id=&quot;loginBtn&quot;]&#x27;</span>)</span><br><span class="line">btn.click()</span><br><span class="line"><span class="comment"># 用微信扫码，只有十秒</span></span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line">btn = bro.find_element(By.XPATH, <span class="string">&#x27;/html/body/div[3]/div[3]/div[2]/div[4]/div/a[2]&#x27;</span>)</span><br><span class="line">btn.click()</span><br><span class="line">time.sleep(<span class="number">10</span>)</span><br><span class="line">button = bro.find_element(By.ID, <span class="string">&#x27;sogou_weixin&#x27;</span>)</span><br><span class="line">button.click()</span><br><span class="line">article_button = bro.find_element(By.XPATH, <span class="string">&#x27;//*[@id=&quot;scroll-header&quot;]/form/div/input[1]&#x27;</span>)</span><br><span class="line">article_button.click()</span><br><span class="line"><span class="comment"># 最后需要爬取的文章url都在这里</span></span><br><span class="line">url_list=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(page):</span><br><span class="line">    page_text = bro.page_source</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析</span></span><br><span class="line">    tree = etree.HTML(page_text)</span><br><span class="line">    author=tree.xpath(<span class="string">&#x27;/html/body/div[2]/div[1]/div[3]/ul/li/div[2]/div/a/text()&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(author)</span><br><span class="line">    url_page_list=tree.xpath(<span class="string">&#x27;/html/body/div[2]/div[1]/div[3]/ul/li/div[2]/h3/a/@href&#x27;</span>)</span><br><span class="line">    <span class="comment"># 下面这个循环判断按author爬取还是按照aiticle爬取</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(author)):</span><br><span class="line">        <span class="keyword">if</span> author[j]==keyword:</span><br><span class="line">            url_list.append(url_page_list[j])</span><br><span class="line">        <span class="keyword">elif</span> modern==<span class="string">&#x27;article&#x27;</span>:</span><br><span class="line">            url_list.append(url_page_list[j])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> i != page - <span class="number">1</span>:</span><br><span class="line">        next_button = bro.find_element(By.ID, <span class="string">&#x27;sogou_next&#x27;</span>)</span><br><span class="line">        next_button.click()</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 拼接地址</span></span><br><span class="line">url_list=[<span class="string">&#x27;https://weixin.sogou.com/&#x27;</span>+i <span class="keyword">for</span> i <span class="keyword">in</span> url_list]</span><br><span class="line">title_list=[]</span><br><span class="line">content_list=[]</span><br><span class="line">time_list=[]</span><br><span class="line">author_list=[]</span><br><span class="line"><span class="keyword">for</span> url <span class="keyword">in</span> url_list:</span><br><span class="line">    response = bro.get(url=url)</span><br><span class="line">    time.sleep(random.randint(<span class="number">1</span>, <span class="number">3</span>))    <span class="comment"># 爬一个，休息1-3秒，怕被抓</span></span><br><span class="line">    page_text = bro.page_source</span><br><span class="line">    tree_content = etree.HTML(page_text)<span class="comment"># 获取爬到的动态页面源码</span></span><br><span class="line">    title = tree_content.xpath(<span class="string">&#x27;/html/body/div[1]/div[2]/div[1]/div/div[1]/h1/text()&#x27;</span>)</span><br><span class="line">    title = re.sub(<span class="string">r&#x27;\s&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>.join(title))<span class="comment"># 获取到的文章题目</span></span><br><span class="line">    content = tree_content.xpath(<span class="string">&#x27;/html/body/div[1]/div[2]/div[1]/div/div[1]/div[3]//text()&#x27;</span>)</span><br><span class="line">    content = re.sub(<span class="string">r&#x27;\s*&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>.join(content))<span class="comment"># 获取到的文章内容</span></span><br><span class="line">    time1=tree_content.xpath(<span class="string">&#x27;//*[@id=&quot;publish_time&quot;]/text()&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">    author=tree_content.xpath(<span class="string">&#x27;//*[@id=&quot;js_name&quot;]/text()&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">    author=re.sub(<span class="string">r&#x27;\s&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>.join(author))</span><br><span class="line">    title_list.append(title)</span><br><span class="line">    content_list.append(content)</span><br><span class="line">    time_list.append(time1)</span><br><span class="line">    author_list.append(author)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入xlsx文件中</span></span><br><span class="line">data = &#123;<span class="string">&#x27;title&#x27;</span>: title_list, <span class="string">&#x27;time&#x27;</span>:time_list,<span class="string">&#x27;author&#x27;</span>:author_list,<span class="string">&#x27;content&#x27;</span>: content_list&#125;</span><br><span class="line">df = DataFrame(data)</span><br><span class="line">df.to_excel(<span class="string">&#x27;./微信公众号_&#x27;</span>+keyword+<span class="string">&#x27;.xlsx&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里规避检测识别是设置Chromedriver的启动参数，在启动Chromedriver之前，为Chrome开启实验性功能参数<code>excludeSwitches</code>，它的值为<code>[‘enable-automation’]</code>。这个参数有什么作用呢？</p><p><img src="https://www.shelven.com/tuchuang/20221213/4.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221213/4.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>我们正常运行selenium时，最上方是有提示”Chrome正受到自动测试软件的控制“的，这个参数设置就是<strong>禁用浏览器的提示</strong>。如果我们用selenium模拟chrome浏览器访问网站，网站可以通过检查<code>window.navigator.webdriver</code>返回值判断我们是用正常的浏览器访问还是用selenium模拟浏览器发起的访问。</p><p><strong>如果返回值为undefined，说明是正常浏览器；如果返回true说明用selenium模拟的浏览器</strong>。</p><p>为Chrome开启实验性功能参数excludeSwitches后，和正常浏览器一样返回的是undefined。</p><p>当然，反爬手段不仅仅是这一个，这个以后的有空再细说。上面的爬虫代码参考了刘丹老师，不是最终版本，还可以对输出内容和样式继续做优化。简单看一下实现的结果：</p><p><img src="https://www.shelven.com/tuchuang/20221213/5.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221213/5.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇博客承接前面的HTTP基本原理，对requests、Xpath和selenium三个库&amp;#x2F;工具做个简单介绍，并且用三个爬虫实例由浅到深理解爬虫的构思和实现过程，最后是用selenium+chromedriver模拟浏览器，实现对微信公众号文章的爬取。&lt;/p&gt;</summary>
    
    
    
    <category term="网络相关" scheme="http://www.shelven.com/categories/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="爬虫" scheme="http://www.shelven.com/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="requests" scheme="http://www.shelven.com/tags/requests/"/>
    
    <category term="Xpath" scheme="http://www.shelven.com/tags/Xpath/"/>
    
    <category term="selenium" scheme="http://www.shelven.com/tags/selenium/"/>
    
  </entry>
  
  <entry>
    <title>HTTP基本原理</title>
    <link href="http://www.shelven.com/2022/12/10/a.html"/>
    <id>http://www.shelven.com/2022/12/10/a.html</id>
    <published>2022-12-10T15:10:45.000Z</published>
    <updated>2022-12-10T16:00:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>以前写过一篇博客如何爬取微博热搜的前50条，当时是从代码出发理解爬虫实现的过程。这篇博客主要讲一下HTTP的基本知识，知道从浏览器中输入网址到我们获取网页内容的过程中发生了什么，有助于进一步了解爬虫的基本原理。</p><span id="more"></span><h2 id="1-URI、URL和URN"><a href="#1-URI、URL和URN" class="headerlink" title="1. URI、URL和URN"></a>1. URI、URL和URN</h2><div class="story post-story"><p>先放上这三个名词的定义：</p><ul><li>URI：Uniform Resource Identifier 统一资源标志符</li><li>URL：Uniform Resource Locator 统一资源定位符</li><li>URN：Uniform Resource Name 统一资源名称</li></ul><p>URI是一个抽象定义，只要能定位到一个资源，都叫做URI。</p><p>URL和URN都是URI的子集，简单来说，<strong>URL用地址定位资源，URN用名称定位资源</strong>。只是后来URN在互联网中使用非常少，导致现在几乎所有的URI都是URL，因此我们可以将一般网页链接称之为URI或者URL（后者用的最多）。</p><p>那么URL或者URI具体指什么呢？</p><p>举个例子，本站图标地址<code>https://www.shelven.com/tuchuang/bitbug_favicon.ico</code>，通过这个地址可以访问到一只32*32像素大小的可爱小猫，通过这个地址URL&#x2F;URI指定了它的访问方式，包括了<strong>访问协议</strong>https，<strong>访问路径</strong>和<strong>资源名称</strong>bitbug_favicon.ico。这个访问资源可以是一个图片，一个CSS文档，一个HTML页面等等。</p><p>以HTTPS协议访问web服务器为例，拆解一下完整的URL结构：</p><p><code>https://user:password@www.shelven.com:443/tuchuang/bitbug_favicon.ico</code></p><ul><li><strong>协议</strong>：URL开头部分必须是协议类型，常见的https、http、ftp和mailto，指明浏览器应当使用的访问方法，用&#x2F;&#x2F;做分隔符</li><li><strong>用户名&#x2F;密码</strong>：user:password这部分可以省略</li><li><strong>域名</strong>：我这里域名是<code>www.shelven.com</code>，我们在发送请求前会向DNS服务器解析这个域名的ip地址，域名只是方便我们人类记忆的，计算机访问的最终都是ip地址。当然，如果你能记得住ip地址也可以直接输入。</li><li><strong>端口</strong>：用来区分不同网络服务（web服务、ftp服务等），和域名之间用冒号:分隔，端口不是URL必须的部分，http默认端口80，https默认端口443，ftp默认端口21。</li><li><strong>文件路径&#x2F;文件名</strong>：从域名第一个<code>/</code>到最后一个<code>/</code>之间是虚拟目录；从域名最后一个<code>/</code>到<code>?</code>部分是文件名，没有<code>?</code>则是到<code>#</code>为止，都没有则是从最后一个<code>/</code>一直到结束都是文件名部分。文件名是可以缺省的。</li></ul></div><h2 id="2-超文本"><a href="#2-超文本" class="headerlink" title="2. 超文本"></a>2. 超文本</h2><div class="story post-story"><p>超文本（Hyper Text, HT）是用超链接的方法，将不同空间文字信息组织在一起的网状文本。</p><p>举个例子，<strong>浏览器中看到的网页就是超文本解析而来的</strong>，网页本身就是一个文本文件，而超文本指这种文件既可以包含文本信息，又可以包含图片、视频、链接等非文字信息。</p><p>网页的源代码是一系列HTML（Hyper Text Markup Language, 超文本标记语言）代码，里面包含了一系列标签（尖括号&lt;&gt;包围的关键词，<strong>一般</strong>成对出现）和属性值。在浏览器中打开任意一个页面，按F12就可以打开浏览器的开发者工具，选择<strong>元素（Elements）</strong>选项卡就可以看到当前网页的源代码，而这些源代码都是超文本。</p><p><img src="https://www.shelven.com/tuchuang/20221210/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221210/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>红框框住的左上角箭头，点击以后可以在页面中用鼠标悬停选中元素，右边对应的源代码部分会高亮，方便我们进行元素审查。</p><p>这里顺便记录下HTML常用的标签和属性：</p><table><thead><tr><th>标签名</th><th>用法</th></tr></thead><tbody><tr><td><strong>基本结构标签</strong></td><td></td></tr><tr><td>HTML标签（根标签）</td><td>&lt;html&gt;&lt;&#x2F;html&gt;</td></tr><tr><td>文档头标签</td><td>&lt;head&gt;&lt;&#x2F;head&gt;</td></tr><tr><td>文档标题标签（网页标题）</td><td>&lt;title&gt;&lt;&#x2F;title&gt;</td></tr><tr><td>文档主体标签（页面内容）</td><td>&lt;body&gt;&lt;&#x2F;body&gt;</td></tr><tr><td><strong>列表标签</strong></td><td>（这里因为渲染问题&amp;emsp无法显示空格…知道HTML有缩进的意思就行）</td></tr><tr><td>无序列表</td><td>&lt;ul type&#x3D;”disc&#x2F;circle&#x2F;square”&gt;<br>&amp;emsp;&lt;li&gt;条目内容&lt;&#x2F;li&gt;<br>&lt;&#x2F;ul&gt;</td></tr><tr><td>有序列表</td><td>&lt;ol type&#x3D;”1&#x2F;a&#x2F;A&#x2F;i&#x2F;I”&gt;<br>&amp;emsp;&lt;li&gt;条目内容&lt;&#x2F;li&gt;<br>&lt;&#x2F;ol&gt;</td></tr><tr><td>定义列表</td><td>&lt;dl&gt;<br>&amp;emsp;&lt;dt&gt;列表标题标签&lt;&#x2F;dt&gt;<br>&amp;emsp;&lt;dd&gt;具体列表项&lt;&#x2F;dd&gt;<br>&lt;&#x2F;dl&gt;</td></tr><tr><td><strong>表格标签</strong></td><td></td></tr><tr><td>表格标签（tr为行）</td><td>&lt;table&gt;<br>&amp;emsp;&lt;tr&gt;<br>&amp;emsp;&amp;emsp;&lt;td&gt;单元格内容&lt;&#x2F;td&gt;<br>&amp;emsp;&lt;&#x2F;tr&gt;<br>&lt;&#x2F;table&gt;</td></tr><tr><td><strong>常用标签</strong></td><td></td></tr><tr><td>标题标签（h1-h6）</td><td>&lt;h1&gt;一级标题&lt;&#x2F;h1&gt;</td></tr><tr><td>段落标签</td><td>&lt;p&gt;这里是内容&lt;&#x2F;p&gt;</td></tr><tr><td>字体标签</td><td>&lt;font size&#x3D;”10” color&#x3D;”black” face&#x3D;”微软雅黑”&gt;你好&lt;&#x2F;font&gt;</td></tr><tr><td>换行标签</td><td>&lt;br&#x2F;&gt;</td></tr><tr><td>水平线标签</td><td>&lt;hr size&#x3D;”10” color&#x3D;”red” width&#x3D;”50%” align&#x3D;”left”&#x2F;&gt;</td></tr><tr><td>盒子标签div</td><td>&lt;div&gt;div标签内容独占一行&lt;&#x2F;div&gt;</td></tr><tr><td>盒子标签span</td><td>&lt;span&gt;span标签内容一行可以多个&lt;&#x2F;span&gt;</td></tr><tr><td>图片标签</td><td>&lt;img src&#x3D;”地址” width&#x3D;’”宽度” height&#x3D;”高度”&gt;&lt;&#x2F;img&gt;</td></tr><tr><td>超链接标签</td><td>&lt;a href&#x3D;”跳转网址” target&#x3D;”窗口弹出方式”&gt;&lt;&#x2F;a&gt;</td></tr><tr><td>注释标签</td><td>&lt;!– 注释内容 –&gt;</td></tr></tbody></table><p>还有表单标签&lt;form&gt;&lt;&#x2F;form&gt;等等，太多了这里就不一一详细说了，如果以后有必要再出一个详细的HTML笔记，现在只要看到这些标签心里有个数就行，真正要做前端再去详细探究。</p></div><h2 id="3-协议"><a href="#3-协议" class="headerlink" title="3. 协议"></a>3. 协议</h2><div class="story post-story"><p>前面说URL的开头必须指明协议类型，常用的是ftp（文件传输协议）、http（超文本传输协议）、https（http的安全版）、mailto（电子邮件协议）和smb（通信协议）。不需要对所有协议了如指掌，前三中协议是我们日常用的最多的，http和https是我们访问网站web服务所必须的，爬虫也可以通过这两种协议伪装成浏览器访问，从而抓取我们需要的页面。</p><ul><li><p><strong>HTTP</strong>（Hyper Text Transfer Protocol, 超文本传输协议）就是一个简单的请求-响应协议，运行在TCP之上，指定客户端发送什么样的消息以及得到什么响应，服务器端实现程序有httpd<del>（本站就是用的这个）</del>和nginx。</p></li><li><p><strong>HTTPs</strong>（Hyper Text Transfer Protocol over Secure Socket Layer）以安全为目标的HTTP通道，说白了就是安全版HTTP，在HTTP下加入SSL层，传输内容经过SSL加密。</p></li></ul><p>本站建站之初，我当时绕了一大圈才签下来SSL证书……<strong>HTTPS的安全基础是SSL，主要作用是建立一个信息安全通道</strong>，保证数据传输的安全；确认网站的真实性，<strong>使用https的网站可以通过浏览器地址栏的锁头标志，查看网站认证的真实信息</strong>。</p><p><img src="https://www.shelven.com/tuchuang/20221210/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221210/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>有些网站使用了HTTPs协议但还是会被浏览器提示不安全，那有可能是证书过期了，或者颁发CA证书的机构不是被信任的，这样就会提示”您的连接不是私密连接“。而要用爬虫爬取这种页面的话，<strong>需要设置忽略证书</strong>，否则会提示SSL证书连接错误。</p><p><img src="https://www.shelven.com/tuchuang/20221210/3.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221210/3.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><img src="https://www.shelven.com/tuchuang/20221210/4.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221210/4.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div><h2 id="4-HTTP请求过程"><a href="#4-HTTP请求过程" class="headerlink" title="4. HTTP请求过程"></a>4. HTTP请求过程</h2><div class="story post-story"><p>我们在浏览器中输入一个 URL，回车之后便会在浏览器中观察到页面内容。这个过程是浏览器向网站所在的服务器发送了一个请求，网站服务器接收到这个请求后进行处理和解析，然后返回对应的响应，接着传回给浏览器。响应里包含了页面的源代码等内容，浏览器再对其进行解析，将网页呈现出来。</p><p><img src="https://www.shelven.com/tuchuang/20221210/5.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221210/5.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>以本站作为演示，打开浏览器，按下F12进入开发者工具，点击网络（Network）选项；搜索框输入<code>https://www.shelven.com</code>，回车。观察整个过程中发生了怎样的网络请求。</p><p><img src="https://www.shelven.com/tuchuang/20221210/6.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221210/6.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>看下第一个网络请求<a href="http://www.shelven.com，各列的含义如下：">www.shelven.com，各列的含义如下：</a></p><ul><li>名称name：请求的名称，返回的每一条都是对应的数据包</li><li>状态status：响应的状态码，通过状态码判断发送请求之后是否得到正常的响应</li><li>类型type：请求的文档类型，这里是返回document，内容就是一些html代码</li><li>发起程序initiator：请求源，标记是哪个对象或者进程发起的请求</li><li>大小size：从服务器下载的文件和请求资源的大小</li><li>时间time：发起请求到获取响应的总时间</li><li>时间线waterfall：网络请求的可视化瀑布流</li></ul><p>点击具体条目可以看到更详细的信息。</p><p><img src="https://www.shelven.com/tuchuang/20221210/7.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221210/7.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>主要看三个部分，<strong>常规（general）、响应头（Response Headers）和请求头（Request Headers）</strong>。常规部分是总的数据包概括。请求头带有请求信息，例如Cookies、user-agent等信息，服务器会根据请求头内的信息判断请求是否合法，进而作出对应的响应。响应头就是响应的一部分，包含了服务器的类型、文档类型、日期等信息，浏览器接受到响应后，会解析响应内容，进而呈现网页内容。</p></div><h2 id="5-请求"><a href="#5-请求" class="headerlink" title="5. 请求"></a>5. 请求</h2><div class="story post-story"><p>请求指的是从客户端到服务器端的请求消息，发给服务器的请求称为请求报文，可以分为请求行（request line），请求头（request header）和请求体（request body）。</p><h3 id="5-1-请求行"><a href="#5-1-请求行" class="headerlink" title="5.1 请求行"></a>5.1 请求行</h3><p>请求行中包括了请求方法，请求协议和版本。</p><p>以百度首页为例：</p><p><img src="https://www.shelven.com/tuchuang/20221210/8.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221210/8.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>小框框起来的地方为请求行，可以看到百度首页的请求方法为get，请求协议为HTTP版本1.1</p><p>常见的请求方法有两种：<strong>GET和POST</strong></p><ul><li>GET 请求中的参数包含在URL里面，数据可以在URL中看到，而POST请求的URL不会包含这些数据，数据是通过<strong>表单形式</strong>传输的，会包含在请求体中。</li><li>GET 请求提交的数据最多只有1024字节，而POST方式没有限制。</li></ul><p>因为GET请求方式不涉及和数据库的交换，所以我们浏览网页用的都是GET请求；如果要在一个网站登录，就需要提交用户名和密码的表单，这个时候用的就是POST请求。还有一个重要的因素，<strong>GET方式请求的数据是在URL中完全暴露的</strong>，所以也不会用GET方式发送请求，不然容易造成密码泄露。</p><p>其他请求方法在<a href="https://www.shelven.com/2022/05/03/a.html?keyword=%E7%88%AC%E8%99%AB">前面一篇爬虫博客</a>有提到，这里列个表格：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>GET</td><td>请求页面，并返回页面内容</td></tr><tr><td>POST</td><td>大多用于提交表单或上传文件，数据包含在请求体中</td></tr><tr><td>HEAD</td><td>类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头</td></tr><tr><td>PUT</td><td>从客户端向服务器传送的数据取代指定文档中的内容</td></tr><tr><td>DELETE</td><td>请求服务器删除指定的页面</td></tr><tr><td>CONNECT</td><td>把服务器当作跳板，让服务器代替客户端访问其他网页</td></tr><tr><td>OPTIONS</td><td>允许客户端查看服务器的性能</td></tr><tr><td>TRACE</td><td>回显服务器收到的请求，主要用于测试或诊断</td></tr></tbody></table><p>表格参考：<a href="https://www.runoob.com/http/http-methods.html">HTTP 请求方法 | 菜鸟教程 (runoob.com)</a></p><h3 id="5-2-请求头"><a href="#5-2-请求头" class="headerlink" title="5.2 请求头"></a>5.2 请求头</h3><p>请求头是用来说明服务器使用的附加信息的，上面那个百度首页例子的大框框住部分就是请求头的信息。</p><p>同样列个表格记录下常用的头信息。</p><table><thead><tr><th>头信息</th><th>描述</th></tr></thead><tbody><tr><td>Accept</td><td>请求报头域，用于指定客户端可接受哪些类型的信息</td></tr><tr><td>Accept-Language</td><td>指定客户端可接受的语言类型</td></tr><tr><td>Accept-Encoding</td><td>指定客户端可接受的内容编码</td></tr><tr><td>Host</td><td>指定请求资源的主机IP和端口号</td></tr><tr><td>Cookie</td><td>而存储在用户本地的数据，主要功能是<strong>维持当前访问会话</strong></td></tr><tr><td>Referer</td><td>标识请求是从哪个页面发过来的，服务器可以拿来做来源统计、防盗链处理</td></tr><tr><td>User-Agent</td><td><strong>服务器识别客户使用的操作系统及版本、浏览器及版本等信息</strong>，爬虫伪装浏览器必备</td></tr><tr><td>Content-Type</td><td>请求的数据类型信息<a href="https://tool.oschina.net/commons">HTTP Content-type 对照表 (oschina.net)</a></td></tr></tbody></table><h3 id="5-3-请求体"><a href="#5-3-请求体" class="headerlink" title="5.3 请求体"></a>5.3 请求体</h3><p>请求体承载POST请求中的表单数据，<strong>GET请求的请求体为空</strong>。</p><p>这里以登录github捕获的请求体为例：</p><p><img src="https://www.shelven.com/tuchuang/20221210/11.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221210/11.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>登录的时候填写的用户名和密码信息，提交的时候就会以表单形式提交给服务器，这个时候可以看到请求头中的Cotent-Type为application&#x2F;x-www-form-urlencoded，表示以表单数据的形式提交给服务器。可以设置不同的Cotent-Type，以不同的方式提交数据，如果在做爬虫的时候要构造POST请求，需要注意一下<strong>使用正确的Cotent-Type（类型&#x2F;子类型）</strong>，不然可能会提交后无法正常响应。</p><table><thead><tr><th>Cotent-Type</th><th>数据提交的方式</th></tr></thead><tbody><tr><td>application&#x2F;x-www-form-urlencoded</td><td>表单数据</td></tr><tr><td>multipart&#x2F;form-data</td><td>表单文件上传</td></tr><tr><td>application&#x2F;json</td><td>序列化JSON数据</td></tr><tr><td>text&#x2F;xml</td><td>XML数据</td></tr><tr><td>application&#x2F;pdf</td><td>pdf格式</td></tr><tr><td>application&#x2F;octet-stream</td><td>二进制流数据（如常见的文件下载）</td></tr></tbody></table></div><h2 id="6-响应"><a href="#6-响应" class="headerlink" title="6. 响应"></a>6. 响应</h2><div class="story post-story"><p>和请求类似的，服务器进行HTTP响应也是分为三个部分：<strong>响应状态行，响应头和响应体</strong></p><h3 id="6-1-响应状态行"><a href="#6-1-响应状态行" class="headerlink" title="6.1 响应状态行"></a>6.1 响应状态行</h3><p>回到之前百度首页的例子，我们点开百度首页审查元素，这次点开响应那一栏查看源。</p><p><img src="https://www.shelven.com/tuchuang/20221210/10.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221210/10.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>小框框起来的地方是响应状态行，我们可以看到响应的协议版本是HTTP&#x2F;1.1，<strong>响应状态码是200</strong>，说明返回正常。</p><p>响应状态码其实并不陌生，顾名思义表示服务器的响应状态。200说明服务器正常响应返回正常数据，经常能看到404报错，代表的是页面未找到，403表示服务器拒绝执行请求，503代表服务器不可用，301代表网页被永久转移到其他URL。</p><p>因为状态码非常多，这里就记录一下状态码的分类，详细状态码列表可以参考<a href="https://www.runoob.com/http/http-status-codes.html">HTTP 状态码 | 菜鸟教程 (runoob.com)</a></p><table><thead><tr><th>分类</th><th>分类描述</th></tr></thead><tbody><tr><td>100-199</td><td>信息响应，服务器收到请求，需要请求者继续执行操作</td></tr><tr><td>200-299</td><td><strong>成功响应</strong>，操作被成功接收并处理</td></tr><tr><td>300-399</td><td>重定向，需要进一步的操作以完成请求</td></tr><tr><td>400-499</td><td><strong>客户端错误</strong>，请求包含语法错误或无法完成请求</td></tr><tr><td>500-599</td><td><strong>服务器错误</strong>，服务器在处理请求的过程中发生了错误</td></tr></tbody></table><h3 id="6-2-响应头"><a href="#6-2-响应头" class="headerlink" title="6.2 响应头"></a>6.2 响应头</h3><p>上面例子中红色大框框住的部分就是响应头，包含服务器对请求的应答信息。</p><p>响应头主要有如下的信息：</p><table><thead><tr><th>头信息</th><th>描述</th></tr></thead><tbody><tr><td>Date</td><td>标识响应产生的时间</td></tr><tr><td>Last-Modified</td><td>指定资源的最后修改时间</td></tr><tr><td>Content-Encoding</td><td>指定响应内容的编码</td></tr><tr><td>Server</td><td>服务器的信息，比如名称、版本号</td></tr><tr><td>Content-Type</td><td>返回的数据类型信息</td></tr><tr><td>Set-Cookie</td><td>设置 Cookies，下次请求会携带这个cookies</td></tr><tr><td>Expires</td><td>指定响应的过期时间</td></tr></tbody></table><h3 id="6-3-响应体"><a href="#6-3-响应体" class="headerlink" title="6.3 响应体"></a>6.3 响应体</h3><p>响应体就是响应的内容，请求网页的时候响应体就是对应的HTML源代码，请求一张图片，响应体就是返回的二进制数据。爬虫就是通过请求到网页后，解析响应体中的内容（有的时候是HTML代码，有的时候是JSON数据等等，这两者比较常见），然后从中提取我们要的信息。</p><p>在edge浏览器中，进入开发者工具，点击network选项，选中需要解析的项目名称，点击响应就可以看到返回的响应体数据了。</p><p><img src="https://www.shelven.com/tuchuang/20221210/12.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221210/12.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>以上暂时总结这么多HTTP的基础，参考了相当多的内容，后面做爬虫练习自然会用到。</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;以前写过一篇博客如何爬取微博热搜的前50条，当时是从代码出发理解爬虫实现的过程。这篇博客主要讲一下HTTP的基本知识，知道从浏览器中输入网址到我们获取网页内容的过程中发生了什么，有助于进一步了解爬虫的基本原理。&lt;/p&gt;</summary>
    
    
    
    <category term="网络相关" scheme="http://www.shelven.com/categories/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="爬虫" scheme="http://www.shelven.com/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="HTTP" scheme="http://www.shelven.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>python自学笔记（7）——模块、包和库</title>
    <link href="http://www.shelven.com/2022/11/29/b.html"/>
    <id>http://www.shelven.com/2022/11/29/b.html</id>
    <published>2022-11-29T14:30:03.000Z</published>
    <updated>2022-12-03T15:51:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>前面介绍递归函数的时候用到了sys模块，介绍文件操作函数的时候用到了os模块，之前只是简单说了这两个模块下部分函数的用法，这里详细介绍一下对于模块、包和库的概念，以及一些常见的模块用法。</p><span id="more"></span><p>不需要记住每个模块下所有函数用法，但是平常看到python文件导入模块操作的时候，要大概知道这几个模块有什么作用。</p><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><div class="story post-story"><h3 id="1-1-模块（module）"><a href="#1-1-模块（module）" class="headerlink" title="1.1 模块（module）"></a>1.1 模块（module）</h3><p>函数可以理解为完成特定功能的一段程序，类是包含一组数据及操作这些数据或传递消息的函数的集合，而<strong>模块（module）是在函数和类的基础上，将一系列相关代码组织到一起的集合体</strong>。</p><p>在python中，扩展名为.py的源程序文件就是一个模块，这个和C语言的头文件以及JAVA的包是类似的。</p><p>python官方网站上可以查看当前标准库中的所有模块，<a href="https://docs.python.org/3/py-modindex.html">点击这里</a>。</p><h3 id="1-2-包（package）"><a href="#1-2-包（package）" class="headerlink" title="1.2 包（package）"></a>1.2 包（package）</h3><p>为了方便调用将一些功能相近的模块组织在一起，或是将一个较为复杂的模块拆分为多个组成部分，可以将 .py 源程序文件放在<strong>同一个文件夹下</strong>，按照 Python 的规则进行管理，<strong>这样的文件夹和其中的文件就称为包（package）</strong>。</p><p>包的目录下需要创建__init__.py 模块，可以是一个空文件，可以写一些初始化代码，其作用就是告诉 Python 要将该目录当成包来处理，让python认为你这是一个包而不是单纯的一个目录（否则会显示找不到包）。<strong>有的博客说python3.3版本之后不需要空的__init__.py 模块来声明这是一个包了，但是我在vscode和jupyter运行python3.10的时候发现还是需要__init__.py 模块声明的</strong>，这里先存疑，我保留自己的观点。</p><ul><li>2022.12.3更新：准确来说，从包里导入模块需要__init__.py 声明；直接导入同目录下的模块不需要（3.3版本以后）</li></ul><p>简单来说，包就是有层次地文件目录结构，里面装着各种扩展名.py的python源程序文件，包中也可以含有包。</p><h3 id="1-3-库"><a href="#1-3-库" class="headerlink" title="1.3 库"></a>1.3 库</h3><p>库顾名思义则是功能相关联的包的集合。python的三大特色之一：强大的标准库，第三方库以及自定义模块。</p></div><h2 id="2-常用模块-x2F-库"><a href="#2-常用模块-x2F-库" class="headerlink" title="2. 常用模块&#x2F;库"></a>2. 常用模块&#x2F;库</h2><div class="story post-story"><p>python的三大特色对应三种类型的模块，标准库的内置模块，第三方库开源模块和自定义的模块，这里简单记录一下常用的模块&#x2F;库。</p><table><thead><tr><th>模块名称</th><th>介绍</th></tr></thead><tbody><tr><td><strong>内置模块</strong></td><td></td></tr><tr><td>os</td><td>普遍的操作系统功能接口，包括前面介绍的文件操作函数</td></tr><tr><td>sys</td><td>提供了一系列有关Python运行环境的变量和函数，sys.path.append()</td></tr><tr><td>random</td><td>生成随机数，random() 返回0&lt;n&lt;&#x3D;1</td></tr><tr><td>time</td><td>各种提供日期、时间功能的类和函数，time.time() 时间戳</td></tr><tr><td>datetime</td><td>对time模块的一个高级封装</td></tr><tr><td>logging</td><td>日志打印到了标准输出中</td></tr><tr><td>re</td><td>可以直接调用来实现正则匹配，re.split() 分割字符串，格式化列表</td></tr><tr><td>pymysql</td><td>连接数据库,并实现简单的增删改查</td></tr><tr><td>threading</td><td>提供了更强大的多线程管理方案</td></tr><tr><td>json</td><td>用于字符串和数据类型间进行转换json</td></tr><tr><td>subprocess</td><td>像linux一样创建运行子进程</td></tr><tr><td>shutil</td><td>对压缩包的处理、对文件和文件夹的高级处理，os的补充</td></tr><tr><td>tkinter</td><td>Python的标准Tk GUI工具包的接口</td></tr><tr><td><strong>第三方模块&#x2F;库</strong></td><td></td></tr><tr><td>Requsests</td><td>python最有名的第三方HTTP客户端库</td></tr><tr><td>Scrapy</td><td>屏幕抓取和web抓取框架，编写爬虫用到（上面的也可以）</td></tr><tr><td>Pillow</td><td>常用的图像处理库</td></tr><tr><td>Matplotlib</td><td>绘制二维数据图的库，使用方式对标matlab</td></tr><tr><td>NumPy</td><td>提供大型矩阵计算公式，在很多领域都用到</td></tr><tr><td>Pandas</td><td>基于Numpy 和 Matplotlib，和上面两个组成数据分析三剑客</td></tr><tr><td>Django</td><td>开源的web开发框架</td></tr><tr><td>PyTorch</td><td>开源的深度学习框架，各种张量操作、梯度计算，方便构建各种动态神经网络</td></tr><tr><td>TensorFlow</td><td>也是机器学习库，张量的操作和运算，tensorboard可视化数据很强大</td></tr></tbody></table><p>第三方库实在太多，这里只列举了我知道的比较常见的库；内置模块可以见1.1章节的官网链接，里面有所有内置模块的具体用法。接下来说说怎么导入模块和制作模块。</p></div><h2 id="3-导入包和模块"><a href="#3-导入包和模块" class="headerlink" title="3. 导入包和模块"></a>3. 导入包和模块</h2><div class="story post-story"><h3 id="3-1-导入模块"><a href="#3-1-导入模块" class="headerlink" title="3.1 导入模块"></a>3.1 导入模块</h3><p>制作模块要注意，<strong>自定义的模块名不能和系统内置的模块重名</strong>，否则被重名的系统模块无法被导入。</p><p>python中用关键字<strong>import</strong>引入某个模块，在调用模块中的函数时，需要以 <strong>模块名.函数名</strong> 的方式进行引用。自定义模块名中的函数是可以重名的，因为模块名不会相同（同一层目录下文件名不同），调用的时候可以进行区分，这很好理解。</p><h3 id="3-2-导入包"><a href="#3-2-导入包" class="headerlink" title="3.2 导入包"></a>3.2 导入包</h3><p>有的时候我们只需要包里的某个模块或者模块里的某个函数，而不需要包或者模块里的全部内容，这个时候我们可以用关键词 <strong>from 包名&#x2F;模块名 import 模块名&#x2F;函数名</strong> 来进行调用。</p><p>举个例子，在如下的文件结构中，main.py作为主程序入口，test文件夹相当于一个包，里面有4个.py后缀的模块，分别定义了四则运算的函数，__init__.py 是个空文件（暂时不做处理），声明test文件夹是个python包而不是普通的目录。</p><p><img src="https://www.shelven.com/tuchuang/20221129/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221129/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># add.py文件内容——定义加法运算</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="comment"># sub.py文件内容——定义减法运算</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a - b</span><br><span class="line"></span><br><span class="line"><span class="comment"># mul.py文件内容——定义乘法运算</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mul</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a * b</span><br><span class="line"></span><br><span class="line"><span class="comment"># dev.py文件内容——定义除法运算</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dev</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a / b</span><br></pre></td></tr></table></figure><p>我现在要做的是，在main.py文件里，导入test包里四个模块，调用各自模块中对应的函数，有以下几种调用方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># main.py的文件内容</span></span><br><span class="line"><span class="keyword">import</span> test.add<span class="comment"># 导入test包下的add模块</span></span><br><span class="line"><span class="keyword">import</span> test.sub <span class="keyword">as</span> sb<span class="comment"># 导入test包下的sub模块，并重命名为sb</span></span><br><span class="line"><span class="keyword">from</span> test <span class="keyword">import</span> mul<span class="comment"># 从test包中导入mul模块</span></span><br><span class="line"><span class="keyword">from</span> test.dev <span class="keyword">import</span> dev<span class="comment"># 从test包的dev模块导入dev函数，注意这里导入的是函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculate</span>(<span class="params">x, y, operate</span>):</span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> operate == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">        result = test.add.add(x, y)<span class="comment"># 调用test.add模块中的add函数</span></span><br><span class="line">    <span class="keyword">elif</span> operate == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        result = sb.sub(x, y)<span class="comment"># test.sub被重命名为sb，调用sb中的sub函数</span></span><br><span class="line">    <span class="keyword">elif</span> operate == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">        result = mul.mul(x, y)<span class="comment"># 调用mul模块中的mul函数</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        result = dev(x, y)<span class="comment"># dev函数已经被导入，可以直接调用函数名</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(calculate(<span class="number">100</span>, <span class="number">100</span>, <span class="string">&#x27;+&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(calculate(<span class="number">100</span>, <span class="number">100</span>, <span class="string">&#x27;-&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(calculate(<span class="number">100</span>, <span class="number">100</span>, <span class="string">&#x27;*&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(calculate(<span class="number">100</span>, <span class="number">100</span>, <span class="string">&#x27;/&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">200</span></span><br><span class="line"><span class="string">0</span></span><br><span class="line"><span class="string">10000</span></span><br><span class="line"><span class="string">1.0</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></div><h2 id="4-包和模块导入的思考"><a href="#4-包和模块导入的思考" class="headerlink" title="4. 包和模块导入的思考"></a>4. 包和模块导入的思考</h2><div class="story post-story"><h3 id="4-1-init-py的作用"><a href="#4-1-init-py的作用" class="headerlink" title="4.1 __init__.py的作用"></a>4.1 __init__.py的作用</h3><p>在上面的例子中__init__.py 是个空文件，是声明test文件夹是python包所必须的（<strong>主程序和包的位置在同一个目录下</strong>）。然而我们在编写main.py的主程序文件的时候，仍然要在开头导入相当多的模块，比较繁琐，这个时候可以在__init__.py中批量导入我们所需要的模块（导入包其实就是导入__init__.py文件）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在__init__.py中添加如下内容</span></span><br><span class="line"><span class="keyword">import</span> test.add</span><br><span class="line"><span class="keyword">import</span> test.sub</span><br><span class="line"><span class="keyword">import</span> test.mul</span><br><span class="line"><span class="keyword">import</span> test.dev</span><br><span class="line"></span><br><span class="line">add = test.add.add</span><br><span class="line">sub = test.sub.sub</span><br><span class="line">mul = test.mul.mul</span><br><span class="line">dev = test.dev.dev</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># main.py相应的改为如下内容</span></span><br><span class="line"><span class="keyword">from</span> test <span class="keyword">import</span> *<span class="comment"># 导入包相当于执行包下的__init__.py，这个文件已经将包里的四个模块分别导入了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculate</span>(<span class="params">x, y, operate</span>):</span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> operate == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">        result = add(x, y)</span><br><span class="line">    <span class="keyword">elif</span> operate == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        result = sub(x, y)</span><br><span class="line">    <span class="keyword">elif</span> operate == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">        result = mul(x, y)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        result = dev(x, y)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(calculate(<span class="number">100</span>, <span class="number">100</span>, <span class="string">&#x27;+&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(calculate(<span class="number">100</span>, <span class="number">100</span>, <span class="string">&#x27;-&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(calculate(<span class="number">100</span>, <span class="number">100</span>, <span class="string">&#x27;*&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(calculate(<span class="number">100</span>, <span class="number">100</span>, <span class="string">&#x27;/&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">200</span></span><br><span class="line"><span class="string">0</span></span><br><span class="line"><span class="string">10000</span></span><br><span class="line"><span class="string">1.0</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>可以看到上面的主程序代码量少了很多，起到简化代码的作用。</p><h3 id="4-2-if-name-x3D-x3D-‘-main-‘"><a href="#4-2-if-name-x3D-x3D-‘-main-‘" class="headerlink" title="4.2 if __name__ &#x3D;&#x3D; ‘__main__‘"></a>4.2 if __name__ &#x3D;&#x3D; ‘__main__‘</h3><p>首先来看一个现象，如果在add.py文件中不仅仅有定义函数的代码，还有编写代码时做的测试内容，如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># add.py文件中最后一行对这个函数做了测试</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">3</span>, <span class="number">4</span>))</span><br></pre></td></tr></table></figure><p>其他文件全都不变，再次运行main.py，会发现输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span><span class="comment"># add.py中测试内容也被输出</span></span><br><span class="line"><span class="number">200</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">10000</span></span><br><span class="line"><span class="number">1.0</span></span><br></pre></td></tr></table></figure><p>这显然不是我们想看到的，我们在导入add模块调用add函数的时候，并不想要其他无关的输出结果。</p><p>稍稍改变一下add.py内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># add.py文件内容</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(add(<span class="number">3</span>, <span class="number">4</span>))</span><br></pre></td></tr></table></figure><p>此时再次运行main.py则不会输出add.py中的测试内容。</p><p>首先要了解一个概念，在每个python文件创建的时候都有一个记录名称的变量__name__，当这个python文件作为脚本直接运行，那么__name__的值为‘”__main__“；当这个文件作为模块被导入其他文件中运行的时候，这个__name__的值为模块的名字，也就是说</p><ul><li><p><strong>当.py文件被直接运行时，if __name__ &#x3D;&#x3D; ‘__main__‘ 之下的代码块将被运行</strong></p></li><li><p><strong>当.py文件以模块形式被导入时，if __name__ &#x3D;&#x3D; ‘__main__‘ 之下的代码块不被运行</strong></p></li></ul><p>在导入的模块中有选择性地执行代码，这在实际开发应用中非常普遍。</p><h3 id="4-3-导入模块在主程序的父目录下"><a href="#4-3-导入模块在主程序的父目录下" class="headerlink" title="4.3 导入模块在主程序的父目录下"></a>4.3 导入模块在主程序的父目录下</h3><p>前面的导入模块操作，导入模块要么在主程序的子目录下（加入__init__.py 声明这是一个包），要么和主程序在同一个目录（直接import），如果导入模块在<strong>主程序的父目录</strong>下，应该怎么导入呢？</p><p>首先，按照一般流程直接import导入和加入__init__.py声明都会报错找不到这个包，这里就不演示了。</p><p>其实这个问题在前面的笔记中有记录，<a href="https://www.shelven.com/2022/04/29/a.html">点击这里</a>。 当时是刚用vscode搭建python环境，对python调用一知半解都算不上，现在才有了初步的理解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 两种解决办法</span></span><br><span class="line"><span class="comment"># 1.在主程序内部临时添加python运行环境路径</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">&#x27;父目录绝对路径或者相对路径&#x27;</span>)</span><br><span class="line"><span class="keyword">import</span> module</span><br><span class="line"><span class="comment"># 缺点：只能调用一次（临时加入的环境变量路径），且每个想要导入的自定义模块都要写一次，比较麻烦</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.在python安装目录下Libsite-packages中创建扩展名为.pth的文件，添加想要加入的路径。</span></span><br><span class="line"><span class="comment"># python在遍历已知的库文件目录过程中，如果见到一个.pth 文件，就会将文件中所记录的路径加入到sys.path设置中，于是.pth文件指向的地址也就可以被Python运行环境找到了。</span></span><br><span class="line"><span class="comment"># 这个已知的库文件目录可以通过sys.path查看。</span></span><br></pre></td></tr></table></figure><h3 id="4-4-相对导入"><a href="#4-4-相对导入" class="headerlink" title="4.4 相对导入"></a>4.4 相对导入</h3><p>前面3.2的例子中，包和模块的导入都是用的<strong>绝对导入</strong>（absolute import），导入时写明了工作环境中包的具体位置。</p><p>还有一种导入方式称为相对导入（relative import），还是用3.2的例子理解一下，在如下的文件结构中，主程序入口main.py和test包在同一层目录下，test包中有__init__.py（空文件），add.py和dev.py两个模块的内容如下：</p><p><img src="https://www.shelven.com/tuchuang/20221129/222.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221129/222.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># add.py内容</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="comment"># dev.py内容</span></span><br><span class="line"><span class="keyword">from</span> .add <span class="keyword">import</span> add<span class="comment"># 相对导入，从当前导入包的目录中找到add模块</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dev</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a / b</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>(<span class="params">a, b</span>):</span><br><span class="line">    a = dev(a, b) + add(a, b)</span><br><span class="line">    <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure><p>上面的例子意思是，我现在要在test包的dev.py模块中用add.py模块的函数方法（同一个包中的模块相互引用，这在实际工程中很常见）。如果dev.py是主程序，我们可以直接<code>import add</code>；但是我们这里main是主程序，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># main.py内容</span></span><br><span class="line"><span class="keyword">from</span> test <span class="keyword">import</span> dev</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(dev.func1(<span class="number">1</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>主程序main.py功能是导入test包dev模块，打印dev模块的函数func1(1, 2)执行结果。</p><p>如果我们在dev.py中直接导入<code>from add import add</code>（没有点，也就是不加当前目录），这个时候再运行main.py会报错找不到模块（因为main.py同目录下没有add.py模块）。这个时候就有两种导入方式，要么完善包名字，使用绝对导入<code>from test.add import add</code>；要么使用相对导入<code>from .add import add</code>。</p><p>这个相对导入就像是linux的文件操作方式，一个点代表当前目录，两个点代表父目录，还能用三个点表示linux无法做到的祖父目录，依此类推。</p><p><strong>相对导入的优点就一目了然：就算改变了包的名字，这个时候调用也不会出错，也就是简化代码，方便迁移。</strong></p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;前面介绍递归函数的时候用到了sys模块，介绍文件操作函数的时候用到了os模块，之前只是简单说了这两个模块下部分函数的用法，这里详细介绍一下对于模块、包和库的概念，以及一些常见的模块用法。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="编程自学" scheme="http://www.shelven.com/categories/%E7%BC%96%E7%A8%8B%E8%87%AA%E5%AD%A6/"/>
    
    
    <category term="python" scheme="http://www.shelven.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python自学笔记（6）——函数的变量和高级用法</title>
    <link href="http://www.shelven.com/2022/11/29/a.html"/>
    <id>http://www.shelven.com/2022/11/29/a.html</id>
    <published>2022-11-28T18:37:37.000Z</published>
    <updated>2022-12-03T15:54:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>前面在通过讲什么是高阶函数（能够接受函数作为参数传入的函数，或者可以返回函数对象的函数）引出了装饰器的由来和存在的意义。这里对python函数的其他基础概念做个补充和记录。</p><span id="more"></span><h2 id="1-函数的变量"><a href="#1-函数的变量" class="headerlink" title="1. 函数的变量"></a>1. 函数的变量</h2><div class="story post-story"><p>之前笔记中的例子已经对函数参数传递过程做了总结，提到了怎么调用函数的返回值，怎么实现函数的嵌套，基本概念用法都已经提过，这里只是做个思考和补充。</p><h3 id="1-1-局部变量"><a href="#1-1-局部变量" class="headerlink" title="1.1 局部变量"></a>1.1 局部变量</h3><ul><li>函数内部的定义的变量</li><li>局部变量只在函数内部生效，不同函数可以拥有同名的局部变量，互不影响（作用域为本函数）</li><li>局部变量的作用，为了临时保存数据需要在函数中定义变量来进行存储</li><li>局部变量在函数执行时被创建，函数执行完成后，局部变量会被系统回收</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 局部变量重名互不影响，只作用在当前函数中</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">added</span>(<span class="params">a, b</span>):</span><br><span class="line">    c = a + b</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">a, b</span>):</span><br><span class="line">    c = <span class="built_in">str</span>(a) + <span class="built_in">str</span>(b)</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(added(<span class="number">4</span>, <span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span>(connect(<span class="string">&#x27;Phantom&#x27;</span>, <span class="string">&#x27;Aria&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">9</span></span><br><span class="line"><span class="string">PhantomAria</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="1-2-全局变量"><a href="#1-2-全局变量" class="headerlink" title="1.2 全局变量"></a>1.2 全局变量</h3><ul><li>函数外部定义的变量</li><li>全局变量可以在多个函数中使用（作用域为所有函数）</li><li>全局变量如果和局部变量重名，<strong>只会使用局部变量</strong>（就近原则）</li><li>如果<strong>在函数中修改不可变类型全局变量</strong>，需要使用<strong>global声明</strong></li></ul><p>这里有一个很有意思的现象，前面在数据类型里说过，数据可以分为可变数据类型（列表，字典，集合）和不可变数据类型（数字，元组，字符串），而<strong>python的所有参数传递都是引用传递而非值传递</strong>。因此，对于可变类型的全局变量，在函数中可以被修改；而对于不可变全局对象则无法在函数中直接修改，其本质是修改不可变数据系统会创建一个新的对象（分配一个新的内存地址），然而这个对象名已经被占用了（也就是变量名无法被指向，原来的变量名也没有被收回）。下面举个栗子。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不可变类型全局变量在函数内部可以传递使用但是无法直接修改</span></span><br><span class="line">x = <span class="number">100</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">added</span>():</span><br><span class="line">    x = x + <span class="number">1</span>       <span class="comment"># 不可变数据修改，系统会创建新的对象，而变量名x已经是全局变量的变量名，无法成为新的对象的变量名</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">added()</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">---------------------------------------------------------------------------</span></span><br><span class="line"><span class="string">UnboundLocalError                         Traceback (most recent call last)</span></span><br><span class="line"><span class="string">d:\zhuomian\python\test.ipynb Cell 47 in &lt;cell line: 6&gt;()</span></span><br><span class="line"><span class="string">      3     x = x + 1</span></span><br><span class="line"><span class="string">      4     return x</span></span><br><span class="line"><span class="string">----&gt; 6 added(4)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">d:\zhuomian\python\test.ipynb Cell 47 in added(a)</span></span><br><span class="line"><span class="string">      2 def added(a):</span></span><br><span class="line"><span class="string">----&gt; 3     x = x + 1</span></span><br><span class="line"><span class="string">      4     return x</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">UnboundLocalError: local variable &#x27;x&#x27; referenced before assignment</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>对于global是如何运作，使得python解释器可以将不可变全局变量进行修改的？这点以我的功底还无法解释……暂时只能知道是这么个用法。</p><p>顺带一提，还有个嵌套函数对外围函数的不可变变量进行修改，需要用到类似的<strong>nonlocal</strong>进行声明。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">100</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">added</span>():</span><br><span class="line">    <span class="keyword">global</span> x        <span class="comment"># global声明x为全局变量</span></span><br><span class="line">    x = x + <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line">added()</span><br><span class="line">added()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">A</span>():</span><br><span class="line">    y = <span class="number">200</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">B</span>():</span><br><span class="line">        <span class="keyword">nonlocal</span> y      <span class="comment"># nonlocal声明y为外围函数的变量（不是全局变量！）</span></span><br><span class="line">        y = y + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line">    <span class="keyword">return</span> B</span><br><span class="line">test = A()</span><br><span class="line"><span class="built_in">print</span>(test())</span><br><span class="line"><span class="built_in">print</span>(test())</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">101</span></span><br><span class="line"><span class="string">102</span></span><br><span class="line"><span class="string">201</span></span><br><span class="line"><span class="string">202</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>上面的例子本质上是一样的，对于嵌套函数来说，要修改外围函数的不可变类型的变量（看起来似乎矛盾，不可变的怎么能叫变量呢？前面已经说过，重新赋值造成数字和字符串看起来是“可变的”假象，这里分清两个变分别指什么意思），相当于是上面例子的在函数内修改不可变类型的全局变量（作用域不同，只能说相当于），只不过二者<strong>声明的方式不同</strong>。</p><h3 id="1-3-修改可变全局变量引起的思考"><a href="#1-3-修改可变全局变量引起的思考" class="headerlink" title="1.3 修改可变全局变量引起的思考"></a>1.3 修改可变全局变量引起的思考</h3><p>一个很有意思的现象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add1</span>(<span class="params">ls</span>):</span><br><span class="line">    ls = ls + ls</span><br><span class="line"></span><br><span class="line">b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add2</span>(<span class="params">ls</span>):</span><br><span class="line">    ls += ls</span><br><span class="line"></span><br><span class="line">add1(a)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">add2(b)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">[1, 2, 3]</span></span><br><span class="line"><span class="string">[1, 2, 3, 1, 2, 3]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>a列表和b列表都是<strong>可变全局变量</strong>，同一个算法，为什么a在传入函数执行之后没有发生改变呢？</p><p>这里需要对可变数据类型做个回顾，可变对象可以对自身内容进行<strong>原地修改</strong>而不改变存储地址。原地修改画个重点，意思是利用方法比如reverse、sort、append等在<strong>原有对象上直接修改</strong>。</p><ul><li><p>‘&#x3D;’ 是赋值语句，将右边的表达式的结果对象，引用绑定到等号左边的变量名上。赋值是<strong>创建一个新对象</strong>，赋值给目标，返回的也是新对象，<strong>引用地址会发生改变</strong>。</p></li><li><p>‘+&#x3D;’ 是增强赋值语句，对左边的对象进行<strong>原地修改</strong>，返回值为None，<strong>引用地址不变</strong>。</p></li></ul><p>看到这里就能明白上面两个看似“同样”的操作为什么会返回不一样的结果，也加深了“可变”与“不可变”的理解。</p></div><h2 id="2-函数的高级用法"><a href="#2-函数的高级用法" class="headerlink" title="2. 函数的高级用法"></a>2. 函数的高级用法</h2><div class="story post-story"><p>前一篇笔记写的<strong>装饰器</strong>就是函数的高级用法之一，这里做个完善补充。</p><h3 id="2-1-匿名函数"><a href="#2-1-匿名函数" class="headerlink" title="2.1 匿名函数"></a>2.1 匿名函数</h3><p>除了用def关键字命名函数这种基础方法之外，还可以使用lambda表达式创建匿名函数。</p><p>lambda语法格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> param1,...paramN:expression</span><br></pre></td></tr></table></figure><p>匿名函数的语法比较简洁，能接受任何数量的参数但只能返回一个表达式的值。因为匿名函数比较简洁小巧，也常用在作为参数进行传递。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义匿名函数</span></span><br><span class="line">func1 = <span class="keyword">lambda</span> x, y : x + y</span><br><span class="line">result = func1(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;匿名函数func1执行结果：&quot;</span>,result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 匿名函数作为参数传递</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func2</span>(<span class="params">x, y, opt</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;函数func2执行结果为：&#x27;</span>, opt(x, y))</span><br><span class="line"></span><br><span class="line">func2(<span class="number">4</span>, <span class="number">5</span>, <span class="keyword">lambda</span> x, y : x + y)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">匿名函数func1执行结果： 3</span></span><br><span class="line"><span class="string">函数func2执行结果为： 9</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-嵌套调用"><a href="#2-2-嵌套调用" class="headerlink" title="2.2 嵌套调用"></a>2.2 嵌套调用</h3><p>相比来说函数嵌套调用可能算不上是高级用法，不过这里还是补充一下。嵌套调用指一个函数里调用另一个函数，<strong>注意和嵌套函数区分</strong>。</p><p>一个简单的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>():        <span class="comment"># 定义一个函数</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;第一个函数输出Phantom&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func2</span>():        <span class="comment"># 定义第二个函数</span></span><br><span class="line">    func1()     <span class="comment"># 在第二个函数里调用第一个函数功能</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;第二个函数输出Aria&#x27;</span>)</span><br><span class="line"></span><br><span class="line">func2()     <span class="comment"># 执行一个函数，实际上两个函数都执行了一遍</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">第一个函数输出Phantom</span></span><br><span class="line"><span class="string">第二个函数输出Aria</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="2-3-递归函数"><a href="#2-3-递归函数" class="headerlink" title="2.3 递归函数"></a>2.3 递归函数</h3><p>递归函数就是在一个函数内部调用自身的函数，本质上是一个循环，循环结束的点就是递归出口。</p><p>用阶乘举个最简单的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用迭代实现阶乘算法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">factorial</span>(<span class="params">n</span>):</span><br><span class="line">    result = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n +<span class="number">1</span>):</span><br><span class="line">        result *= i</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用递归实现阶乘算法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">factorial_1</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> n * factorial_1(n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(factorial(<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(factorial_1(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">3628800</span></span><br><span class="line"><span class="string">3628800</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><ul><li><p>迭代的方法，从1开始，进入for循环对之前的结果累积乘以 i，直至 n（上例函数被调用了1次）。</p></li><li><p>递归的方式更为直观，每次通过递减数字的方式递归调用自己（上例函数被调用了10次）。</p></li></ul><p><strong>整体上看递归更简洁明了，但是相比迭代会占用更多内存，运行时间会更长</strong>。</p><p>递归有最大深度限制，在计算机中，函数名、参数、值类型等，都是存放在栈上的。每进行一次函数调用，就会在栈上加一层，函数返回就减一层，由于栈的大小是有限的，递归次数过多就会导致<strong>堆栈溢出</strong>。</p><p>可以调用sys模块，<code>sys.setrecursionlimit(2000)</code>将栈的大小调整为2000，<code>sys.getrecursionlimit()</code>查看当前设置的最大递归深度。这种调整递归深度的方式不是无限大的，我的jupyter在调用递归函数3000次的时候就会直接退出……模块定义和调用方式后一篇笔记再说。</p></div><h2 id="3-文件操作函数"><a href="#3-文件操作函数" class="headerlink" title="3. 文件操作函数"></a>3. 文件操作函数</h2><div class="story post-story"><h3 id="3-1-open-amp-close"><a href="#3-1-open-amp-close" class="headerlink" title="3.1 open() &amp; close()"></a>3.1 open() &amp; close()</h3><p>函数open()可以<strong>打开一个文件，或者创建一个新文件</strong>，函数close()可以关闭文件。两者语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;文件名&#x27;</span>, <span class="string">&#x27;访问模式&#x27;</span>)</span><br><span class="line">f.close()       <span class="comment"># 注意最后一定要有close()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;文件名&#x27;</span>, <span class="string">&#x27;访问模式&#x27;</span>) <span class="keyword">as</span> f:       <span class="comment"># 自动调用close()</span></span><br><span class="line">    f.方法()</span><br></pre></td></tr></table></figure><table><thead><tr><th>访问模式</th><th>说明</th></tr></thead><tbody><tr><td>r</td><td>只读方式打开文件，默认模式，打开文件必须存在。</td></tr><tr><td>w</td><td>写入方式打开文件，已存在的文件会覆盖内容（相当于linux重定向操作符&gt;）。</td></tr><tr><td>a</td><td>追加方式打开文件，已存在的文件会将内容写到最后（相当于linux重定向操作符&gt;&gt;）。</td></tr><tr><td>x</td><td>只写方式打开文件，新建一个文件，若文件存在则报错。</td></tr><tr><td>r+</td><td>读写方式打开文件，打开文件必须存在。</td></tr><tr><td>w+</td><td>读写方式打开文件，已存在的文件会覆盖内容。</td></tr><tr><td>a+</td><td>读写方式打开文件，已存在的文件会将内容写到最后。</td></tr></tbody></table><p>一般用 with open() as 的方式打开文件，这种方式会自动帮我们调用f.close()</p><h3 id="3-2-write-amp-read"><a href="#3-2-write-amp-read" class="headerlink" title="3.2 write() &amp; read()"></a>3.2 write() &amp; read()</h3><p>write()向文件写入数据，以w方式访问，如果文件名存在会先清空文件内容，文件名不存在则新建；以a方式访问，如果文件名存在则续写，文件名不存在则新建；以r方式访问则报错。</p><p>read()从文件中读取数据，括号里面的参数代表读取的数据长度（字节数），如果不传入参数则读取所有数据。</p><p>readline()读取一行，同时会读取一行最后的换行符\n，所以打印出来的时候会多一行空行。</p><p>readlines()按照行的方式读取整个文件数据，返回的是一个列表，每行数据是一个元素，同样会读到换行符\n并且显示出来。</p><p>需要注意一点，<strong>在多次读取的操作中，后一次读取会从上一次读完的位置开始。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:    <span class="comment"># 只写模式创建一个新文件</span></span><br><span class="line">    f.write(<span class="string">&#x27;My name is Phantom. \nI am Aria.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> f:    <span class="comment"># 追加模式进行续写</span></span><br><span class="line">    f.write(<span class="string">&#x27;\nWell, it\&#x27;s been so long.&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">生成的test.txt内容：        # 实际前面两行末尾都有换行符</span></span><br><span class="line"><span class="string">My name is Phantom.</span></span><br><span class="line"><span class="string">I am Aria.</span></span><br><span class="line"><span class="string">Well, it&#x27;s been so long.</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:    <span class="comment"># 只读方式打开文件</span></span><br><span class="line">    line = f.read(<span class="number">1</span>)        <span class="comment"># read读取第一个字节</span></span><br><span class="line">    <span class="built_in">print</span>(line)</span><br><span class="line">    line = f.readline()     <span class="comment"># readline读取第一个字节后的第一行，因为读取了换行符，所以运行结果多一行空行</span></span><br><span class="line">    <span class="built_in">print</span>(line)</span><br><span class="line">    line = f.readlines()    <span class="comment"># readlines读取接下来的两行，每行数据为一个元素，返回一个列表</span></span><br><span class="line">    <span class="built_in">print</span>(line)</span><br><span class="line">    </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">M</span></span><br><span class="line"><span class="string">y name is Phantom. </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[&#x27;I am Aria.\n&#x27;, &quot;Well, it&#x27;s been so long.&quot;]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="3-3-os模块的文件操作函数"><a href="#3-3-os模块的文件操作函数" class="headerlink" title="3.3 os模块的文件操作函数"></a>3.3 os模块的文件操作函数</h3><p>os模块和上面递归函数最后提到的sys模块用的非常多，下篇笔记再详细说明，这里就记一下用法。</p><p>这几个函数也非常直观，举个例子就知道分别有什么作用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.rename(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;TEST.txt&#x27;</span>)   <span class="comment"># 文件重命名</span></span><br><span class="line">os.remove(<span class="string">&#x27;TEST.txt&#x27;</span>)   <span class="comment"># 文件删除</span></span><br><span class="line">os.mkdir(<span class="string">&#x27;./test&#x27;</span>)      <span class="comment"># 创建文件夹，文件夹存在的话会报错,且只能创建一级目录</span></span><br><span class="line">os.rmdir(<span class="string">&#x27;./test&#x27;</span>)      <span class="comment"># 删除文件夹</span></span><br><span class="line">os.makedirs(<span class="string">&#x27;./TEST/TEST1/TEST2&#x27;</span>)   <span class="comment">#递归的方式创建多级目录</span></span><br></pre></td></tr></table></figure></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;前面在通过讲什么是高阶函数（能够接受函数作为参数传入的函数，或者可以返回函数对象的函数）引出了装饰器的由来和存在的意义。这里对python函数的其他基础概念做个补充和记录。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="编程自学" scheme="http://www.shelven.com/categories/%E7%BC%96%E7%A8%8B%E8%87%AA%E5%AD%A6/"/>
    
    
    <category term="python" scheme="http://www.shelven.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python自学笔记（5）——装饰器</title>
    <link href="http://www.shelven.com/2022/11/28/a.html"/>
    <id>http://www.shelven.com/2022/11/28/a.html</id>
    <published>2022-11-27T19:03:55.000Z</published>
    <updated>2022-12-03T15:55:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>这里讲一讲前面提到的python装饰器，@classmethod和@staticmethod是python内置装饰器，在了解什么是装饰器之前首先要了解函数的几个特征。</p><span id="more"></span><h2 id="1-有关函数的几个概念"><a href="#1-有关函数的几个概念" class="headerlink" title="1. 有关函数的几个概念"></a>1. 有关函数的几个概念</h2><div class="story post-story"><h3 id="1-1-函数可以接收另一个函数作为参数传入"><a href="#1-1-函数可以接收另一个函数作为参数传入" class="headerlink" title="1.1 函数可以接收另一个函数作为参数传入"></a>1.1 函数可以接收另一个函数作为参数传入</h3><p>高阶函数可以接收另一个函数作为传入的参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 高阶函数，函数func2接收函数作为参数传入</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func2</span>(<span class="params">func, m, n</span>):</span><br><span class="line">    <span class="keyword">return</span> func(m, n)</span><br><span class="line"></span><br><span class="line">func2(func1, <span class="number">1</span>, <span class="number">2</span>)  </span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>从上面例子可以看到，在执行 func2函数的时候，函数对象func1作为参数被传入func2，返回func1(1, 2)的执行结果也就是3.</p><h3 id="1-2-函数可以把另一个函数作为结果返回"><a href="#1-2-函数可以把另一个函数作为结果返回" class="headerlink" title="1.2 函数可以把另一个函数作为结果返回"></a>1.2 函数可以把另一个函数作为结果返回</h3><p>高阶函数也可以将函数作为结果返回：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 高阶函数，把函数作为结果返回</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func2</span>():    <span class="comment"># 内层函数（嵌套函数）</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;执行func2函数&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> func2        <span class="comment"># 返回内层函数的引用</span></span><br><span class="line"></span><br><span class="line">a = func1()     <span class="comment"># 返回的函数对象func2的引用赋值给a</span></span><br><span class="line"><span class="built_in">print</span>(a)        <span class="comment"># 打印函数对象，获得存储地址</span></span><br><span class="line">a()     <span class="comment"># 执行内层函数func2()的功能</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">&lt;function func1.&lt;locals&gt;.func2 at 0x00000288D3701750&gt;</span></span><br><span class="line"><span class="string">执行func2函数</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>上面的例子可以看到，外围函数 func1将内层函数 func2的引用赋值给a，此时a就有了内层函数func2 的方法，此时打印的a是函数的存储地址，执行a() 就可以执行func2 函数的功能。</p><h3 id="1-3-嵌套函数可以引用外层函数的变量"><a href="#1-3-嵌套函数可以引用外层函数的变量" class="headerlink" title="1.3 嵌套函数可以引用外层函数的变量"></a>1.3 嵌套函数可以引用外层函数的变量</h3><p>稍稍修改1.2的例子，在外层函数添加局部变量msg：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>():    <span class="comment"># 外围函数</span></span><br><span class="line">    msg = <span class="string">&#x27;I am Phantom&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func2</span>():    <span class="comment"># 内层函数（嵌套函数）</span></span><br><span class="line">        <span class="built_in">print</span>(msg)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> func2</span><br><span class="line"></span><br><span class="line">a = func1()     <span class="comment"># 实际上这里获得的就是一个闭包</span></span><br><span class="line">a()     <span class="comment"># 引用外层函数的变量，执行内层函数func2()的功能</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">I am Phantom</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>这里先引用闭包的概念：</p><blockquote><p><strong>闭包</strong>：指延伸了作用域的函数，其中包含函数定义体中引用、但是不在定义体中定义的非全局变量。概念比较晦涩，简单来说就是<strong>嵌套函数引用了外层函数的变量</strong>。</p></blockquote><p>这个例子和上个例子唯一的区别是，msg是一个在外围函数中的局部变量，在print_msg()函数执行之后应该就不会存在了。但是嵌套函数引用了这个变量，将这个局部变量封闭在了嵌套函数中，这样就形成了一个<strong>闭包</strong>。</p><p>有了以上关于高阶函数和闭包的概念后，就可以开始理解什么是装饰器以及装饰器的作用了。</p></div><h2 id="2-装饰器decorator"><a href="#2-装饰器decorator" class="headerlink" title="2. 装饰器decorator"></a>2. 装饰器decorator</h2><div class="story post-story"><p><strong>装饰器的本质就是一个闭包，把一个函数当做参数然后返回一个替代版函数（函数的引用）。</strong></p><h3 id="2-1-标识符将装饰器应用到函数"><a href="#2-1-标识符将装饰器应用到函数" class="headerlink" title="2.1 @标识符将装饰器应用到函数"></a>2.1 @标识符将装饰器应用到函数</h3><p>下面将用代码方式简单演示装饰器是怎么应用的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>(<span class="params">func3</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func2</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;被装饰的函数<span class="subst">&#123;func3.__name__&#125;</span>即将执行&#x27;</span>)</span><br><span class="line">        func3()     <span class="comment"># 被装饰的函数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;被装饰的函数<span class="subst">&#123;func3.__name__&#125;</span>执行结束&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> func2</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">funcx</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;函数正在运行&#x27;</span>)</span><br><span class="line"></span><br><span class="line">a = func1(funcx)        <span class="comment"># 1</span></span><br><span class="line">a()     <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">被装饰的函数funcx即将执行</span></span><br><span class="line"><span class="string">函数正在运行</span></span><br><span class="line"><span class="string">被装饰的函数funcx执行结束</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>上面这个例子就是不用@标识符的装饰器，首先我定义了一个函数func1，它只有一个func3参数，这个函数里面定义了一个嵌套函数func2。func2的作用是调用func3前打印一串字符，然后执行被装饰的函数func3，结束之后再打印一串字符。</p><p>我们再定义一个测试函数funcx，功能是打印一段“函数正在运行”的字符串。</p><p>在1处，函数func1中传入函数funcx，返回函数func2的引用赋值给变量a，此时并没有执行函数，也不会有打印结果。在2处执行了func2函数，前面传入的函数funcx作为参数在原先的func3处执行，这个时候就会依次输出三行字符串。</p><p><strong>将@标识符应用到函数上，只需要在函数定义前加上@和装饰器的名称即可。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>(<span class="params">func3</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func2</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;被装饰的函数<span class="subst">&#123;func3.__name__&#125;</span>即将执行&#x27;</span>)</span><br><span class="line">        func3()     <span class="comment"># 被装饰函数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;被装饰的函数<span class="subst">&#123;func3.__name__&#125;</span>执行结束&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> func2</span><br><span class="line"></span><br><span class="line"><span class="meta">@func1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">funcx</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;函数正在运行&#x27;</span>)</span><br><span class="line"></span><br><span class="line">funcx()</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">被装饰的函数funcx即将执行</span></span><br><span class="line"><span class="string">函数正在运行</span></span><br><span class="line"><span class="string">被装饰的函数funcx执行结束</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>这里@func1就是装饰器，它接受被装饰的函数作为参数传入，返回内部嵌套函数的引用（注意这个时候并没有执行函数），内部嵌套函数func2持有被装饰函数func3的引用。</p><p>可以看到@语法只是将函数传入装饰器函数，并不是什么特别难理解的概念，主要作用就是节省代码量（避免了再一次的赋值操作）。</p><h3 id="2-2-带参数的装饰器"><a href="#2-2-带参数的装饰器" class="headerlink" title="2.2 带参数的装饰器"></a>2.2 带参数的装饰器</h3><p>前面示范的是不带参数的装饰器，带参数的装饰器也是类似的，我们只要知道<strong>装饰器最终返回的一定是嵌套函数的引用</strong>。在前面的参数传递博文中，我们说过<strong>*args和**kargs</strong>可以以包裹传递的方式传递不定长参数，这里也是一样的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>(<span class="params">func3</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func2</span>(<span class="params">*args, **kargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;被装饰的函数<span class="subst">&#123;func3.__name__&#125;</span>即将执行&#x27;</span>)</span><br><span class="line">        func3(*args, **kargs)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;被装饰的函数<span class="subst">&#123;func3.__name__&#125;</span>执行结束&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> func2</span><br><span class="line"></span><br><span class="line"><span class="meta">@func1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">funcx</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="built_in">print</span>(a + b)</span><br><span class="line"></span><br><span class="line"><span class="meta">@func1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">funcy</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(a) + <span class="built_in">str</span>(b) + <span class="built_in">str</span>(c))</span><br><span class="line"></span><br><span class="line">funcx(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*************************&#x27;</span>)</span><br><span class="line">funcy(<span class="string">&#x27;Phan&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;om&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">被装饰的函数funcx即将执行</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">被装饰的函数funcx执行结束</span></span><br><span class="line"><span class="string">*************************</span></span><br><span class="line"><span class="string">被装饰的函数funcy即将执行</span></span><br><span class="line"><span class="string">Phantom</span></span><br><span class="line"><span class="string">被装饰的函数funcy执行结束</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>上面的装饰器带的参数都是我们后面<strong>自定义函数里的参数</strong>，装饰器的语法允许我们在调用时提供<strong>其他参数</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#import functools</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>(<span class="params">text</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">func</span>):</span><br><span class="line">       <span class="comment"># @functools.wraps(func)</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">func2</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            <span class="keyword">if</span> text == <span class="string">&#x27;Phantom&#x27;</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;%s 正在运行&#x27;</span> % func.__name__)</span><br><span class="line">                <span class="built_in">print</span>(*args)</span><br><span class="line">                <span class="built_in">print</span>(text)</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> func2</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line">     </span><br><span class="line"><span class="meta">@func1(<span class="params">text = <span class="string">&quot;Phantom&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">funcx</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="built_in">print</span>(funcx.__name__)</span><br><span class="line"></span><br><span class="line">funcx(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">注释的运行结果：</span></span><br><span class="line"><span class="string">funcx 正在运行</span></span><br><span class="line"><span class="string">test</span></span><br><span class="line"><span class="string">Phantom</span></span><br><span class="line"><span class="string">func2</span></span><br><span class="line"><span class="string">*************************</span></span><br><span class="line"><span class="string">去掉注释的运行结果：</span></span><br><span class="line"><span class="string">funcx 正在运行</span></span><br><span class="line"><span class="string">test</span></span><br><span class="line"><span class="string">Phantom</span></span><br><span class="line"><span class="string">funcx</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>先不看导入的模块，后面再解释。</p><p>上面的例子看上去很复杂，可以一层一层剥开理解。func1是允许带参数的装饰器，实际上是<strong>原有装饰器decorator的再一次封装</strong>，并且返回了这个装饰器，可以理解为含有一个形参text的闭包。当我们使用@func1(text &#x3D; “Phantom”)时，python解释器将我们的实参“Phantom”传入到装饰器的环境。</p><p>而嵌套函数func2在检查到传入的text参数与字符串“Phantom”相同时，就会执行后面的打印函数名、funcx传入的实参和func1传入到decorate的实参。</p><p>通过特殊属性__name__可以看到，funcx函数指向了装饰器内部定义的func2函数，也就是经过装饰器装饰后丢失了原函数的元信息，<strong>我们真正调用的是装饰后生成的新函数</strong>。那么是不是每次都要使用<code>func2.__name__ = func.__name__</code>这样的代码来保留原函数信息呢？并不是，我们可以使用<strong>functools库中的@functools.wraps()来保留原函数的属性</strong>，其实这种保留只是将原始被装饰的函数的属性拷贝给了装饰函数，如果不干这件事，有些依赖函数签名的代码执行就会出错，感兴趣的小伙伴可以继续探究~</p><h3 id="2-3-内置装饰器"><a href="#2-3-内置装饰器" class="headerlink" title="2.3 内置装饰器"></a>2.3 内置装饰器</h3><p>上面说的@functools.wraps()其实也是内置装饰器，下面介绍其他几个常用的内置装饰器。</p><h4 id="2-3-1-property"><a href="#2-3-1-property" class="headerlink" title="2.3.1 @property"></a>2.3.1 @property</h4><p>这个内置装饰器用来装饰类函数，被装饰的类函数不可以在类被实例化后调用，只能通过访问与函数同名的属性进行调用（<strong>也就是把类的方法伪装成属性</strong>）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>():</span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">func1</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Phantom&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">  @property</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">func2</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Aria&#x27;</span>)</span><br><span class="line">  </span><br><span class="line">a = A()     <span class="comment"># 实例化一个对象</span></span><br><span class="line"></span><br><span class="line">a.func1()   <span class="comment"># 通过实例化对象访问类方法</span></span><br><span class="line">a.func2     <span class="comment"># 通过实例化对象将类方法伪装成属性调用</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">Phantom</span></span><br><span class="line"><span class="string">Aria</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>我们知道属性是可以被赋值的，但是<strong>经过property装饰的方法不可以像普通属性那样被赋值</strong>。</p><p>这个特性很有意思，我们可以实现对python类私有属性的安全访问（再次强调不存在严格意义的私有属性）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    __number = <span class="string">&#x27;Phantom&#x27;</span>        <span class="comment"># 类内的私有属性</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">number</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__number</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(a.__number)       <span class="comment"># 尝试直接访问类内的私有属性失败</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;访问私有属性失败&quot;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(a.number)     <span class="comment"># 通过类方法伪装的属性访问私有属性成功</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;访问私有属性成功&quot;</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    a.number = <span class="number">1</span>        <span class="comment"># 类方法伪装的属性无法被赋值</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;修改私有属性失败&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">访问私有属性失败</span></span><br><span class="line"><span class="string">Phantom</span></span><br><span class="line"><span class="string">访问私有属性成功</span></span><br><span class="line"><span class="string">修改私有属性失败</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="2-3-2-classmethod"><a href="#2-3-2-classmethod" class="headerlink" title="2.3.2 @classmethod"></a>2.3.2 @classmethod</h4><p>直接翻译，这个装饰器就是用来定义类方法的，<strong>被装饰的函数必须有一个cls参数用来绑定类本身</strong>，隐式地将类作为对象，传递给方法，调用地时候不需要进行实例化。</p><p>如果不加这个装饰器，<strong>必须要使用self参数</strong>，隐式地将类实例传递给方法，也就是说必须要实例化。</p><p><strong>强调一点，这里地cls和self只是为了方便编程的时候一眼看出来绑定的是类还是对象，都可以用别的xxx名字代替（但是不建议）。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>():</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">func1</span>(<span class="params">self,x,y</span>):      <span class="comment"># 实例方法</span></span><br><span class="line">    <span class="keyword">return</span> x * y</span><br><span class="line">  </span><br><span class="line"><span class="meta">  @classmethod</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">func2</span>(<span class="params">cls,x,y</span>):       <span class="comment"># 类方法</span></span><br><span class="line">    <span class="keyword">return</span> x * y</span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(A().func1(<span class="number">5</span>,<span class="number">5</span>))       <span class="comment"># 必须实例化A()之后通过实例化对象才可以调用方法</span></span><br><span class="line"><span class="built_in">print</span>(A.func2(<span class="number">5</span>,<span class="number">5</span>))     <span class="comment"># 不需要实例化，直接通过类对象调用</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">25</span></span><br><span class="line"><span class="string">25</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>由于被classmethod装饰的函数强制暴露了类自身，所以我们可以通过被classmethod装饰的函数对类的静态变量进行一定操作，在实例化之前和类进行交互。还有类方法可以通过实例对象或者类对象去访问，<a href="https://www.shelven.com/2022/11/25/a.html">所以有一个用途就是通过实例调用类方法实现对类属性的修改（点击见第三篇博客例子）</a>。</p><h4 id="2-3-3-staticmethod"><a href="#2-3-3-staticmethod" class="headerlink" title="2.3.3 @staticmethod"></a>2.3.3 @staticmethod</h4><p>前面博客介绍过，这个装饰器是声明静态方法的，静态方法和上面的类方法一样，不需要实例化就可以直接调用，但是<strong>这个方法不强制要求传递参数</strong>，无法直接使用任何类变量、类方法或者实例方法、实例变量（这里要注意，<strong>只有主动传参才可以调用</strong>，因为主动传参是可以按照逻辑去找需要的参数的）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>():</span><br><span class="line">    name = <span class="string">&#x27;Phantom&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name = <span class="string">&#x27;Aria&#x27;</span></span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getName</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;静态方法调用类属性&#x27;</span>, People.name)        </span><br><span class="line">        <span class="comment">#print(self.name)       #不能调用实例的属性，会报错，名义上是类方法，实际已经和类无关</span></span><br><span class="line"></span><br><span class="line">p = People()</span><br><span class="line">p.getName()     <span class="comment"># 可以通过 类.方法名 或者 实例.方法名 进行调用 </span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">静态方法调用类属性 Phantom</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>staticmethod更像是与实例无关但与类封装功能有关的函数，如果有一个功能实现的方法比较独立，可以考虑用静态方法来实现。</p><p>在继承类中，staticmethod和classmethod有以下区别</p><blockquote><p>子类的实例继承了父类的@staticmethod静态方法，调用该方法，还是调用的父类的方法和类属性。</p><p>子类的实例继承了父类的@classmethod类方法，调用该方法，调用的是子类的方法和子类的类属性。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>():</span><br><span class="line">    name = <span class="string">&#x27;Phantom&#x27;</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func1</span>():</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">print</span>(A.name)</span><br><span class="line">  </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func2</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">print</span>(cls.name)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    name = <span class="string">&#x27;Aria&#x27;</span></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">a.func1()</span><br><span class="line">a.func2()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;***********************&#x27;</span>)</span><br><span class="line">b = B()</span><br><span class="line">b.func1()</span><br><span class="line">b.func2()</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">Phantom</span></span><br><span class="line"><span class="string">Phantom</span></span><br><span class="line"><span class="string">***********************</span></span><br><span class="line"><span class="string">Phantom</span></span><br><span class="line"><span class="string">Aria</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>上面这个例子可以看出来，@classmethod装饰后的func1函数实际上已经和父类没什么关系了，尽管在父类方法里但也可以当作是个独立的函数，不管子类的实例化还是父类的实例化都是调用同一个函数，输出结果一致。而@classmethod装饰后的func2函数，cls参数绑定了类本身，子类在实例化后继承了父类@classmethod类方法，但是调用的是子类的方法和类属性。</p><p>所有装饰器存在的意义都是为函数扩展功能，总结以下几点：</p><blockquote><p>装饰器通过高级函数、嵌套函数和闭包实现</p><p>装饰器返回闭包函数的引用，这个闭包函数引用中有被装饰函数的引用</p><p>装饰器通过语法糖 @ 修饰</p><p>装饰器不修改原函数和调用方式（调用的是装饰后的新函数）</p></blockquote></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;这里讲一讲前面提到的python装饰器，@classmethod和@staticmethod是python内置装饰器，在了解什么是装饰器之前首先要了解函数的几个特征。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="编程自学" scheme="http://www.shelven.com/categories/%E7%BC%96%E7%A8%8B%E8%87%AA%E5%AD%A6/"/>
    
    
    <category term="python" scheme="http://www.shelven.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python自学笔记（4）——面向对象编程（下）</title>
    <link href="http://www.shelven.com/2022/11/26/a.html"/>
    <id>http://www.shelven.com/2022/11/26/a.html</id>
    <published>2022-11-26T15:59:03.000Z</published>
    <updated>2022-12-03T15:55:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>前面说到python中一切皆为对象，面向对象是python的核心，也通过代码方式了解了什么是类和对象、属性和方法以及具体的分类。这篇笔记主要记录下前面没讲完的面向对象编程具体的三个特征。</p><span id="more"></span><h2 id="面向对象编程的特征"><a href="#面向对象编程的特征" class="headerlink" title="面向对象编程的特征"></a>面向对象编程的特征</h2><div class="story post-story"><p>python是面向对象的语言，支持面向对象的三大特征：<strong>封装（隐藏），继承和多态</strong>。</p><h3 id="1-封装（隐藏）"><a href="#1-封装（隐藏）" class="headerlink" title="1. 封装（隐藏）"></a>1. 封装（隐藏）</h3><h4 id="1-1-封装概念"><a href="#1-1-封装概念" class="headerlink" title="1.1 封装概念"></a>1.1 封装概念</h4><p>隐藏对象的属性和实现细节，只对外提供必要的方法。相当于将“细节封装起来”，只对外暴露“相关调用方法”。</p><p>通过私有属性、私有方法（都是在属性或者方法前加上__来实现私有化，类外部不能直接访问）的方式，实现封装(Encapsulation)。封装的概念类似权限控制，有些属性或方法只想于类别内部使用，而不想公开于外部，除了减少代码因来源端不适当的使用发生问题外，也可保护其中重要的商业逻辑。</p><p>当然，前面说过python没有严格意义上的访问控制限制，更多还是靠编程人员的自觉&#x3D; &#x3D;</p><h3 id="2-继承"><a href="#2-继承" class="headerlink" title="2 继承"></a>2 继承</h3><h4 id="2-1-继承概念"><a href="#2-1-继承概念" class="headerlink" title="2.1 继承概念"></a>2.1 继承概念</h4><p>继承是创建新类的方式，是实现代码复用的重要手段（比如一个新类继承自设计好的类，就直接具备已有类的特征，减少代码重复编写）。对于<strong>已有的类</strong>，我们称为<strong>父类或基类</strong>，而要<strong>创建的新类</strong>，我们称为<strong>子类或派生类</strong>。python支持多继承，也就是<strong>新建的类可以有一个或者多个父类</strong>。</p><p>python3中默认继承<strong>object</strong>类，object是根类，是所有类的父亲。编写过程中object可以省略。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个父类(object可省)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, color</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.color = color</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s在进食&#x27;</span> % self.name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个子类，括号中为父类的名字</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pig</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setName</span>(<span class="params">self, newname</span>):</span><br><span class="line">        self.name = newname</span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line">Peggy = Pig(<span class="string">&#x27;猪&#x27;</span>, <span class="string">&#x27;粉色&#x27;</span>)   <span class="comment"># 实例化对象</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Peggy是%s,颜色是%s&#x27;</span> % (Peggy.name, Peggy.color))     <span class="comment"># 查看对象属性</span></span><br><span class="line">Peggy.eat()     <span class="comment"># 调用父类方法</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;现在Peggy的名字叫做%s&#x27;</span> % Peggy.setName(<span class="string">&#x27;George&#x27;</span>))    <span class="comment"># 调用子类方法</span></span><br><span class="line"><span class="built_in">print</span>(Pig.__mro__)      <span class="comment"># 查看类的继承层次结构，可以用类属性__mro__或者类方法mro()</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">Peggy是猪,颜色是粉色</span></span><br><span class="line"><span class="string">猪在进食</span></span><br><span class="line"><span class="string">现在Peggy的名字叫做George</span></span><br><span class="line"><span class="string">(&lt;class &#x27;__main__.Pig&#x27;&gt;, &lt;class &#x27;__main__.Animal&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>从上面的例子可以看到，子类Pig从父类Animal中继承了__init__()方法，从子类中实例化对象Peggy是可以调用父类的方法的。</p><p>需要注意：</p><blockquote><p><strong>私有的属性和方法（前面带有__）不能被子类继承，也不能被访问！</strong></p></blockquote><h4 id="2-2-多继承"><a href="#2-2-多继承" class="headerlink" title="2.2 多继承"></a>2.2 多继承</h4><p>顾名思义一个子类继承自多个直接父类，这样也就有了多个父类的特点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个父类马</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Horse</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">output</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;骡子的一半基因来自马&#x27;</span>)</span><br><span class="line"><span class="comment"># 定义一个父类驴</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Donkey</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">output</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;骡子的一半基因来自驴&#x27;</span>)</span><br><span class="line"><span class="comment"># 定义一个子类骡子，继承自马和驴</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mule</span>(Horse, Donkey):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">a = Mule()  <span class="comment"># 实例化一个对象骡子</span></span><br><span class="line">a.output()  <span class="comment"># 调用同名父类方法</span></span><br><span class="line"><span class="built_in">print</span>(Mule.__mro__)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">骡子的一半基因来自马</span></span><br><span class="line"><span class="string">(&lt;class &#x27;__main__.Mule&#x27;&gt;, &lt;class &#x27;__main__.Horse&#x27;&gt;, &lt;class &#x27;__main__.Donkey&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>上面的例子可以看到，子类骡子(Mule)继承自父类马(Horse)和驴(Donkey)，这样可以拥有两个父类各自的特征。但是，如果父类中如果有同名的方法(这里的output(self))，那么子类只会<strong>从左到右</strong>的顺序，调用<strong>先继承的父类</strong>(Horse)中的方法。</p><p>同样可以通过类属性__mro__来查看继承结构，显示结果也是从左到右的顺序，从子类开始一层层往上到父类，这就是继承的顺序。</p><p>一般情况下不建议用多继承<del>（一个人不可能有两个爹）</del>，代码可读性会变差。</p><h4 id="2-3-重写父类方法"><a href="#2-3-重写父类方法" class="headerlink" title="2.3 重写父类方法"></a>2.3 重写父类方法</h4><p>重写的意思是，当子类中有一个和父类相同的名字的方法，子类中的方法会重新定义覆盖掉父类中的方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;是个动物都会进食&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pig</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;只有猪才会吃了睡睡了吃&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Peggy = Pig()</span><br><span class="line">Peggy.eat()     <span class="comment"># 调用父类同名方法，子类的方法会覆盖</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">只有猪才会吃了睡睡了吃</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>如果想要在子类方法中调用父类的同名方法，最简单的实现方式是在<strong>子类方法中进行类调用</strong>，但是父类名如果修改过，在多继承时子类的方法也要重复改很多次，python为了解决这个问题引入了super()函数，需要注意super()代表父类的定义，而不是父类对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;是个动物都会进食&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pig</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().eat()       <span class="comment"># super()代表父类名，即使父类名改变这里也不需要改</span></span><br><span class="line"></span><br><span class="line">Peggy = Pig()</span><br><span class="line">Peggy.eat()</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">是个动物都会进食</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>一般而言，<strong>super在继承中经常用来继承父类的初始化方法</strong>，例如<code> super().__init__()</code></p><h3 id="3-多态"><a href="#3-多态" class="headerlink" title="3 多态"></a>3 多态</h3><h4 id="3-1-多态概念"><a href="#3-1-多态概念" class="headerlink" title="3.1 多态概念"></a>3.1 多态概念</h4><p>多态指不同对象对同一个方法调用，可能会产生不同的行为。举个栗子，对于同样一个吃饭的方法，不同对象比如中国人用筷子吃饭，印度三哥用手抓饭，欧美人用刀叉吃饭。</p><p>需要注意以下几点：</p><blockquote><ol><li>多态是方法的多态，属性没有多态</li><li>多态存在的必要条件：继承和方法重写</li></ol></blockquote><h4 id="3-2-代码演示多态和“鸭子类型”"><a href="#3-2-代码演示多态和“鸭子类型”" class="headerlink" title="3.2 代码演示多态和“鸭子类型”"></a>3.2 代码演示多态和“鸭子类型”</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Chinese</span>(<span class="title class_ inherited__">People</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;中国人用筷子吃饭&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Indian</span>(<span class="title class_ inherited__">People</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;印度人用手抓饭&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">American</span>(<span class="title class_ inherited__">People</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;欧美人用刀叉吃饭&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分别实例化，并定义一个统一的接口来使用</span></span><br><span class="line">XiaoMing = Chinese()</span><br><span class="line">ASan = Indian()</span><br><span class="line">George = American()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Eatting</span>(<span class="params">self</span>):</span><br><span class="line">    self.eat()</span><br><span class="line">Eatting(XiaoMing)   <span class="comment"># 相当于调用了XiaoMing.eat，以下同理</span></span><br><span class="line">Eatting(ASan)</span><br><span class="line">Eatting(George)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*******************************************&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># “鸭子类型”</span></span><br><span class="line"><span class="comment"># 定义三个不同的类（实际上也都继承自根类object）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Chinese</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;中国人用筷子吃饭&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Indian</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;印度人用手抓饭&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">American</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;欧美人用刀叉吃饭&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">People_list = [Chinese, Indian, American]   <span class="comment"># 封装好的类作为People_list的元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> person <span class="keyword">in</span> People_list:</span><br><span class="line">    person().eat()      <span class="comment"># person()是实例化对象的过程，分别调用不同类的同名方法</span></span><br><span class="line">    </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">中国人用筷子吃饭</span></span><br><span class="line"><span class="string">印度人用手抓饭</span></span><br><span class="line"><span class="string">欧美人用刀叉吃饭</span></span><br><span class="line"><span class="string">*******************************************</span></span><br><span class="line"><span class="string">中国人用筷子吃饭</span></span><br><span class="line"><span class="string">印度人用手抓饭</span></span><br><span class="line"><span class="string">欧美人用刀叉吃饭</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>不同对象调用同名方法，产生不同结果，这就体现了多态性，好处在于增强了程序的灵活性和可扩展性。</p><p>Python崇尚的“鸭子类型”就是动态类型的风格：“当看到一直鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以称为鸭子。”这种动态风格中，<strong>一个对象的有效语义，不是由继承自特定的类或实现特定的接口，而是由当前方法和属性的集合决定</strong>，也就是说，我们并不关心对象是什么类型，而是关心对象是怎么使用的。</p><p>总而言之，这种动态类型使得编程非常灵活，可以避免一些重写和继承，省去复制大量重复代码的操作。</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;前面说到python中一切皆为对象，面向对象是python的核心，也通过代码方式了解了什么是类和对象、属性和方法以及具体的分类。这篇笔记主要记录下前面没讲完的面向对象编程具体的三个特征。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="编程自学" scheme="http://www.shelven.com/categories/%E7%BC%96%E7%A8%8B%E8%87%AA%E5%AD%A6/"/>
    
    
    <category term="python" scheme="http://www.shelven.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python自学笔记（3）——面向对象编程（上）</title>
    <link href="http://www.shelven.com/2022/11/25/a.html"/>
    <id>http://www.shelven.com/2022/11/25/a.html</id>
    <published>2022-11-25T15:31:53.000Z</published>
    <updated>2022-12-03T15:55:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>面向对象是Python的核心概念，一开始在这些概念问题上一直绕不清，这里做个简单记录。</p><span id="more"></span><h2 id="1-面向对象编程"><a href="#1-面向对象编程" class="headerlink" title="1. 面向对象编程"></a>1. 面向对象编程</h2><div class="story post-story"><p>使用计算机语言编写代码时，有两种思路分别是面向过程编程和面向对象编程</p><blockquote><ol><li>面向过程：根据业务逻辑从上到下，直接分析解决问题的步骤，调用函数实现。强调怎么去做</li><li>面向对象：将问题分解成若干“对象”，建立对象是为了描述某个事物在解决问题过程中的行为。强调谁去做</li></ol></blockquote><p><strong>面向过程注重步骤和过程</strong>，所有步骤<strong>从到到尾逐步实现</strong>，将功能独立的代码<strong>封装成函数</strong>，最后完成代码就是<strong>按照顺序地调用不同函数</strong>。</p><p><strong>面向对象注重对象和职责</strong>，确认<strong>职责</strong>，根据职责确定不同对象，<strong>对象内部封装不同的方法</strong>，最后完成代码是按照顺序让<strong>不同对象调用不同方法</strong>。</p><p>python是面向对象编程思想的一门语言，包括做机器学习或者深度学习用的PyTorch、TensorFlow都是面向对象的思想，里面封装了非常多的方法，我们甚至可以不知道方法具体实现的过程和原理，直接调用函数就可以（初学的我就是一开始依葫芦画瓢，程序能跑通但是不能解释实现的原理），对于小白的入门学习确实提供了极大便利<del>（然后一出问题就开始恶补基础了）</del>。</p></div><h2 id="2-概念性名词"><a href="#2-概念性名词" class="headerlink" title="2. 概念性名词"></a>2. 概念性名词</h2><div class="story post-story"><p>先要了解概念性的专业名词，再通过代码的方式加深自己的理解。</p><p>面向对象有三个特性，封装性、继承性和多态性（下一篇博客再细说）。</p><blockquote><ol><li>封装性：把属性和方法放在一个类里面，可以通过访问类的权限属性区分开，不想释放的功能搞成私有机制</li><li>继承性：把实现好的代码和方法通过继承的方法拿过来用，节省代码量</li><li>多态性：同一个方法用不同的方式去实现，体现的多态性</li></ol></blockquote><p>先解释一下上面提到的几个专有名词：</p><blockquote><p>对象(object)：python中一切皆对象，对应现实生活中，任何事物都可以称为对象，有自己独特的特征。对象是通过类创建出的真实的个体（对象是类的实例化），对象由属性和方法组成。</p><p>类(class)：具有同种属性的对象，现实世界中具有共同特征的事物为一类，比如人类，植物类等，描述的是所有对象的共有特征。拥有相似属性和行为的对象都可以抽象出一个类。</p><p>属性(attribute)：属于对象静态的一面，描述对象的一些静态特征，比如小明的身高、体重、年龄等。</p><p>方法(method)：属于对象动态的一面，描述对象的动态特征，比如小明会说话，会码代码等。</p><p>实例化：对象由一个别名叫“实例”，通过类创建对象的过程为“实例化”。</p><p>抽象：由相同特征的对象抽取共同特征的过程为“抽象”。</p></blockquote></div><h2 id="3-代码方式理解类和对象"><a href="#3-代码方式理解类和对象" class="headerlink" title="3. 代码方式理解类和对象"></a>3. 代码方式理解类和对象</h2><div class="story post-story"><p>开头的class来创建一个新的类，class之后为类的名称（通常首字母大写）并以冒号结尾。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>:</span><br><span class="line">    <span class="comment"># 定义方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getPeopleInfo</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;名字:%s, 年龄:%d&#x27;</span> %(self.name, self.age))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化一个对象        </span></span><br><span class="line">Phantom = People()</span><br><span class="line">Phantom.name = <span class="string">&#x27;Phantom&#x27;</span>    <span class="comment"># 使用 . 的方法添加类属性</span></span><br><span class="line">Phantom.age = <span class="number">26</span></span><br><span class="line">Phantom.getPeopleInfo()     <span class="comment"># 使用 .函数名() 的方法调用类中创建的函数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Phantom.age)      <span class="comment"># 打印实例Phantom的年龄属性</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">名字:Phantom, 年龄:26</span></span><br><span class="line"><span class="string">26</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>在创建的类中定义方法，而类中的方法和普通的函数有一个区别——必须有一个额外的第一个参数名称, 按照惯例是 self。self指的是实例的本身，指向当前创建对象的内存地址。某个对象调用其方法时，python解释器会把这个对象作为第一个参数传递给self，所以我们只需要传递后面的参数。</p><p><strong>python是没有方法的重载的</strong>，如果定义了多个重名的方法，只会生效最后一个！</p><p>在上面的例子里我给Phantom添加了两个对象属性：name和age，但是如果再实例化一个其他对象，能否在创建时就给予属性而不用重新添加呢？答案是肯定的，这个时候我们可以用__init__()函数来定义属性的默认值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>:</span><br><span class="line">    <span class="comment"># 初始化函数，使对象的属性具有默认值</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, sex = <span class="string">&#x27;male&#x27;</span>, age = <span class="number">26</span></span>):</span><br><span class="line">        self.sex = sex</span><br><span class="line">        self.age = age</span><br><span class="line">    <span class="comment"># 定义类方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getPeopleInfo</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;性别:%s, 年龄:%d&#x27;</span> %(self.sex, self.age))</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 创建对象Phantom，不传参，属性使用默认值</span></span><br><span class="line">Phantom = People()</span><br><span class="line"><span class="built_in">print</span>(Phantom.sex, Phantom.age)</span><br><span class="line">Phantom.getPeopleInfo()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建第二个对象Aria，传参，新的参数代替默认值</span></span><br><span class="line">Aria = People(<span class="string">&#x27;Female&#x27;</span>, <span class="number">24</span>)</span><br><span class="line"><span class="built_in">print</span>(Aria.sex, Aria.age)</span><br><span class="line">Aria.getPeopleInfo()</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">male 26</span></span><br><span class="line"><span class="string">性别:male, 年龄:26</span></span><br><span class="line"><span class="string">Female 24</span></span><br><span class="line"><span class="string">性别:Female, 年龄:24</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>可以看到上面创建对象Phantom后，我没有传入参数，python解释器立刻调用了__init__()函数给与了两个属性sex和age，这个时候再调用类内的方法getPeopleInfo()，就会将属性的默认值作为实参传入。</p><p>__init__(self)中只有一个默认参数self，<strong>如果创建对象传入了两个实参，那么除了self以外还需要两个形参</strong>，比如__init__(self, sex, age)这个和自定义创建的类方法不一样，一定要做区分，后面会说到。这里的self是不需要我们传递的，python解释器会自动把当前对象的引用传递进去。</p></div><h2 id="4-代码方式理解属性和方法"><a href="#4-代码方式理解属性和方法" class="headerlink" title="4. 代码方式理解属性和方法"></a>4. 代码方式理解属性和方法</h2><div class="story post-story"><h3 id="4-1-类属性"><a href="#4-1-类属性" class="headerlink" title="4.1 类属性"></a>4.1 类属性</h3><p>类拥有的属性分为公有属性（public）和私有属性（private），python对于类的属性没有严格的访问控制限制，这与其他面向对象语言有所区别。</p><blockquote><ol><li><p>_xxx  保护属性，python编辑器不会做任何处理，是给程序员看的，不希望被外部访问</p></li><li><p>xxx  自己定义的公有属性</p></li><li><p>__xxx  类中的私有属性，<strong>不能从外部直接访问</strong>，但是可以通过 <strong>实例._类名__私有属性</strong> 的方式访问</p><p>再次强调，python不存在严格意义上的私有属性。</p></li></ol></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建类，object是对象，可以省略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    name = <span class="string">&#x27;Phantom&#x27;</span>    <span class="comment"># 公有的类属性</span></span><br><span class="line">    __age = <span class="number">26</span>      <span class="comment"># 私有的类属性</span></span><br><span class="line">    _sex = <span class="string">&#x27;male&#x27;</span>       <span class="comment"># 保护的类属性</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span>        <span class="comment"># 空语句，占位用，不会执行任何操作</span></span><br><span class="line">p = People()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(p.name)           <span class="comment"># 通过实例对象访问公有类属性</span></span><br><span class="line"><span class="built_in">print</span>(p._People__age)       <span class="comment"># 通过实例访问私有类属性</span></span><br><span class="line"><span class="built_in">print</span>(p._sex)       <span class="comment"># 访问保护的类属性（可以访问但是不推荐）</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">Phantom</span></span><br><span class="line"><span class="string">26</span></span><br><span class="line"><span class="string">male</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="4-2-实例属性"><a href="#4-2-实例属性" class="headerlink" title="4.2 实例属性"></a>4.2 实例属性</h3><p>实例属性是从属于实例对象的属性。</p><blockquote><ol><li>实例属性可以在__init__()方法中通过 <strong>self.实例属性名 &#x3D; 初始值</strong> 的方式进行定义</li><li>实例属性可以修改、新增和删除，不会影响到类属性</li></ol></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    name = <span class="string">&#x27;Phantom&#x27;</span></span><br><span class="line"></span><br><span class="line">p = People()</span><br><span class="line"><span class="built_in">print</span>(p.name, People.name)      <span class="comment"># 通过实例查看实例属性，通过类对象查看类属性</span></span><br><span class="line">p.name = <span class="string">&#x27;Aria&#x27;</span>     <span class="comment"># 修改实例属性</span></span><br><span class="line"><span class="built_in">print</span>(p.name, People.name)</span><br><span class="line">People.name = <span class="string">&#x27;Aria&#x27;</span>    <span class="comment"># 修改类属性</span></span><br><span class="line"><span class="built_in">print</span>(p.name, People.name)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Phantom Phantom</span></span><br><span class="line"><span class="string">Aria Phantom</span></span><br><span class="line"><span class="string">Aria Aria</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>可以看到通过一个实例对象去引用修改，只是修改了实例属性而不会影响到类属性。</p><h3 id="4-3-特殊属性"><a href="#4-3-特殊属性" class="headerlink" title="4.3 特殊属性"></a>4.3 特殊属性</h3><p>Python 对象中包含了很多双下划线开始和结束的属性，这些是特殊属性，有特殊的用法。</p><table><thead><tr><th>特殊方法</th><th>含义</th></tr></thead><tbody><tr><td>obj.__dict__</td><td>对象的属性字典</td></tr><tr><td>obj.__class__</td><td>对象所属的类</td></tr><tr><td>class.__bases__</td><td>类的基类元组(多继承)</td></tr><tr><td>class.__base__</td><td>类的基类</td></tr><tr><td>class.__mro__</td><td>类层次结构</td></tr><tr><td>class.__subclasses__</td><td>子类列表</td></tr></tbody></table><p>实际操作运行几个简单的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>:</span><br><span class="line">    name = <span class="string">&#x27;Phantom&#x27;</span>    <span class="comment"># 类属性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, sex, age</span>):       <span class="comment"># 实例属性</span></span><br><span class="line">        self.sex = sex</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">p = People(<span class="string">&#x27;male&#x27;</span>, <span class="number">26</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># dict 生成类属性信息的字典和实例对象属性信息的字典</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;People类属性为：&#x27;</span> + <span class="built_in">str</span>(People.__dict__))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;实例对象p属性为：&#x27;</span> + <span class="built_in">str</span>(p.__dict__))</span><br><span class="line"></span><br><span class="line"><span class="comment"># class 对实例对象查询所属类信息</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;实例对象p所属类信息：&#x27;</span> + <span class="built_in">str</span>(p.__class__))</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">People类属性为：&#123;&#x27;__module__&#x27;: &#x27;__main__&#x27;, &#x27;name&#x27;: &#x27;Phantom&#x27;, &#x27;__init__&#x27;: &lt;function People.__init__ at 0x000001A7D212AB00&gt;, &#x27;__dict__&#x27;: &lt;attribute &#x27;__dict__&#x27; of &#x27;People&#x27; objects&gt;, &#x27;__weakref__&#x27;: &lt;attribute &#x27;__weakref__&#x27; of &#x27;People&#x27; objects&gt;, &#x27;__doc__&#x27;: None&#125;</span></span><br><span class="line"><span class="string">实例对象p属性为：&#123;&#x27;sex&#x27;: &#x27;male&#x27;, &#x27;age&#x27;: 26&#125;</span></span><br><span class="line"><span class="string">实例对象p所属类信息：&lt;class &#x27;__main__.People&#x27;&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="4-4-实例方法和类方法"><a href="#4-4-实例方法和类方法" class="headerlink" title="4.4 实例方法和类方法"></a>4.4 实例方法和类方法</h3><p>在类中以def开头定义的方法都是实例方法，实例方法的特点是必须有一个以上的参数（<strong>self</strong>），用于指定这个方法的实例对象。</p><p>类方法也是最少需要一个参数（<strong>cls</strong>），是类对象有的方法，<strong>需要使用装饰器@classmethod来标识其为类方法</strong>，关于装饰器的概念我后面再写一篇博客，这里简单按照字面意思理解一下。类方法可以通过实例对象或者类对象去访问，有一个用途就是通过实例调用类方法实现对类属性的修改。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>():</span><br><span class="line">    name = <span class="string">&#x27;Phantm&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getName</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="keyword">return</span> cls.name</span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setName</span>(<span class="params">cls, name</span>):</span><br><span class="line">        cls.name = name</span><br><span class="line"></span><br><span class="line">p = People()</span><br><span class="line"><span class="built_in">print</span>(p.getName(), People.getName())        <span class="comment"># 通过实例和类对象调用类方法，先查看一下类属性</span></span><br><span class="line">p.setName(<span class="string">&#x27;Aria&#x27;</span>)       <span class="comment"># 通过实例调用类方法改变类属性</span></span><br><span class="line"><span class="built_in">print</span>(p.getName(), People.getName())</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">Phantm Phantm</span></span><br><span class="line"><span class="string">Aria Aria</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="4-5-静态方法"><a href="#4-5-静态方法" class="headerlink" title="4.5 静态方法"></a>4.5 静态方法</h3><p>python是动态的语言，我们可以动态地为类添加新的方法，或者动态地修改已有的方法。静态方法可以理解为不变的方法，不依赖于实例对象也不依赖于类对象，因此无论是实例对象还是类对象都可以调用。如果有一个功能实现的方法比较独立，可以考虑用静态方法来实现，<strong>静态方法需要使用装饰器@staticmethod来标识</strong>。</p><p>需要注意的是，<strong>静态方法无法使用实例的属性和方法</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>():</span><br><span class="line">    name = <span class="string">&#x27;Phantom&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name = <span class="string">&#x27;Aria&#x27;</span></span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getName</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;静态方法调用类属性&#x27;</span>, People.name)</span><br><span class="line">        <span class="comment">#print(self.name)       #不能调用实例的属性，会报错</span></span><br><span class="line"></span><br><span class="line">p = People()</span><br><span class="line">p.getName()</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">静态方法调用类属性 Phantom</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="4-6-特殊方法"><a href="#4-6-特殊方法" class="headerlink" title="4.6 特殊方法"></a>4.6 特殊方法</h3><p>前面的普通方法都是通过 对象名.方法名() 的方式调用，和前面有特殊属性一样，python也有一些特殊方法（或者叫魔术方法），这些特殊方法在符合条件的时候自动触发，不需要调用。</p><p>因为特殊方法非常多，这里只简单记录一些常用的。</p><table><thead><tr><th align="left">特殊方法</th><th>含义</th></tr></thead><tbody><tr><td align="left"><strong>构造类</strong></td><td></td></tr><tr><td align="left">__new__(cls, […])</td><td>对象实例化时调用的第一个方法，第一个参数时类，其他参数传递给__init__()，决定是否使用</td></tr><tr><td align="left">__init__(self, […])</td><td>构造器，当一个实例被创建时调用的初始化方法</td></tr><tr><td align="left">__del__(self)</td><td>构造器，当实例对象被销毁时调用的方法</td></tr><tr><td align="left"><strong>表示类</strong></td><td></td></tr><tr><td align="left">__str__(self)</td><td>描述类或对象信息，比如打印实例化对象，返回定义内容（给人看）</td></tr><tr><td align="left">__repr__(self)</td><td>描述类或对象信息，比如打印实例化对象，返回定义内容（给解释器看）</td></tr><tr><td align="left"><strong>访问控制类</strong></td><td></td></tr><tr><td align="left">__setattr__(self, key, value)</td><td>定义当一个属性被设置时的行为</td></tr><tr><td align="left">__getattr__(self, key)</td><td>定义用户试图获取一个不存在的属性时的行为</td></tr><tr><td align="left">__delattr__(self, key)</td><td>定义当一个属性被删除时的行为</td></tr><tr><td align="left">__getattribute__(self, key)</td><td>定义当该类属性被访问时的行为（所有属性&#x2F;方法调用都要经过这里）</td></tr><tr><td align="left">__dir__(self)</td><td>定义当dir()被调用时的行为</td></tr><tr><td align="left"><strong>比较操作类</strong></td><td></td></tr><tr><td align="left">__eq__(self, other)</td><td>判断两个对象是否相等</td></tr><tr><td align="left">__ne__(self,other)</td><td>判断两个对象是否不相等</td></tr><tr><td align="left">__lt__(self, other)</td><td>定义小于号的行为：x &lt; y 调用 x.__lt__(y)</td></tr><tr><td align="left">__gt__(self, other)</td><td>定义大于号的行为：x &gt; y 调用 x.__gt__(y)</td></tr><tr><td align="left"><strong>容器类</strong></td><td></td></tr><tr><td align="left">__setitem__(self, key, value)</td><td>定义设置容器中指定元素的操作，相当于 self[key] &#x3D; value</td></tr><tr><td align="left">__getitem__(self, key)</td><td>定义获取容器中指定元素的操作 ，相当于 self[key]</td></tr><tr><td align="left">__delitem__(self, key)</td><td>定义删除容器中指定元素的操作 ，相当于 del self[key]</td></tr><tr><td align="left">__len__(self)</td><td>定义当被 len() 调用时的操作，即返回容器中元素个数</td></tr><tr><td align="left">__iter__(self)</td><td>定义迭代容器中的元素的操作</td></tr><tr><td align="left">__contains__(self, item)</td><td>定义当使用成员测试运算符（in 或 not in）时的操作</td></tr><tr><td align="left">__reversed__(self)</td><td>定义当被 reversed() 调用时的操作</td></tr><tr><td align="left"><strong>可调用对象类</strong></td><td></td></tr><tr><td align="left">__call__(self, [args…])</td><td>使实例对象以 对象名() 的形式使用</td></tr></tbody></table><p>这些特殊方法比较常用，看到知道是怎么一回事就好。容器类的特殊方法稍微解释一下，python中常用<strong>字典、元组、列表和字符串</strong>作为容器，它们都实现了<strong>容器协议</strong>，可迭代。最后一个调用对象类特殊方法写个代码描述一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Calculate</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, m, n</span>):</span><br><span class="line">        self.m = m</span><br><span class="line">        self.n = n</span><br><span class="line">        SUM = m + n</span><br><span class="line">        <span class="keyword">return</span> SUM</span><br><span class="line"></span><br><span class="line">a = Calculate(<span class="number">100</span>, <span class="number">200</span>)  </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a(<span class="number">111</span>, <span class="number">222</span>))      <span class="comment"># __call__() 将实例化对象a当作一个方法来执行</span></span><br><span class="line"><span class="built_in">print</span>(a.x, a.y)     <span class="comment"># 实例属性并没有改变</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">333</span></span><br><span class="line"><span class="string">100 200</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>在上面这个例子中，首先初始化了一个Calculate实例a，调用 __init__() 方法，给与了实例属性x和y以及对应的值。但是对于实例对象a又做了调用 a(111, 222) ，实际上调用的是 __call__() 方法，传入自定义参数实现自己的逻辑，这在类实现一个装饰器的场景中比较常见。</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;面向对象是Python的核心概念，一开始在这些概念问题上一直绕不清，这里做个简单记录。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="编程自学" scheme="http://www.shelven.com/categories/%E7%BC%96%E7%A8%8B%E8%87%AA%E5%AD%A6/"/>
    
    
    <category term="python" scheme="http://www.shelven.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python自学笔记（2）——运算符和参数传递</title>
    <link href="http://www.shelven.com/2022/11/24/a.html"/>
    <id>http://www.shelven.com/2022/11/24/a.html</id>
    <published>2022-11-24T09:05:33.000Z</published>
    <updated>2022-12-03T15:57:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇笔记主要记录python基础的运算符和函数参数传递，以及自己学习过程的一些思考。</p><span id="more"></span><h2 id="1-运算符"><a href="#1-运算符" class="headerlink" title="1. 运算符"></a>1. 运算符</h2><div class="story post-story"><h3 id="1-1-比较运算符"><a href="#1-1-比较运算符" class="headerlink" title="1.1 比较运算符"></a>1.1 比较运算符</h3><p>python中常见的比较运算符如下：</p><blockquote><ol><li>&#x3D;&#x3D;  检查左右两个值是否相等，相等则返回True</li><li>!&#x3D;  检查左右两个值是否相等，不相等则返回True</li><li>&lt;&gt;  和 !&#x3D; 一样，检查两个值是否相等，不相等返回True</li><li>&gt;&#x3D;  字面意思，字面意思的还有&lt;&#x3D;、 &lt; 和 &gt;</li></ol></blockquote><h3 id="1-2-算数运算符"><a href="#1-2-算数运算符" class="headerlink" title="1.2 算数运算符"></a>1.2 算数运算符</h3><p>python常见的算数运算符：</p><blockquote><ol><li>&#x2F;  两个数相除，结果为浮点型</li><li>&#x2F;&#x2F;  两个数相除，结果为<strong>向下取整的整数</strong></li><li>%  取模，也就是两个整数相除的余数</li><li>**  幂运算，返回乘方的结果</li><li>+  两个数相加，<strong>或者字符串相连</strong></li><li>*  两个数相乘，<strong>或者返回重复若干次的字符串</strong></li><li>-  字面意思，两个数相减</li></ol></blockquote><h3 id="1-3-赋值运算符"><a href="#1-3-赋值运算符" class="headerlink" title="1.3 赋值运算符"></a>1.3 赋值运算符</h3><p>顾名思义都是在赋值的时候用到的运算符</p><blockquote><ol><li>&#x3D;  常规赋值运算，运算结果赋值给变量</li><li>+&#x3D;  加法赋值运算，a +&#x3D; b等效于a &#x3D; a+b</li><li>其他算数运算符都可以后面跟上&#x3D;，进行运算后赋值</li></ol></blockquote><h3 id="1-4-位运算符"><a href="#1-4-位运算符" class="headerlink" title="1.4 位运算符"></a>1.4 位运算符</h3><p>按位运算就是将数字转换为二进制来运算的运算形式，数值是用补码来表示和存储的，计算机用位运算符进行四则运算速度快。但是我们平常可能用不到，这里稍微记录一下。</p><blockquote><ol><li>&amp;  按位“与”：两个值如果相应位都为1，则结果为1，否则0</li><li>|  按位“或”：两个值相应位有一个位1，结果就为1</li><li>^  按位“异或”：两个值相应位相异，结果为1</li><li>~  按位“取反”：对数据的每个二进制位取反</li><li>&lt;&lt;  左移运算符：运算数的二进制全部座椅若干位，高位丢弃，低位补0；&gt;&gt;右移同理</li></ol></blockquote><h3 id="1-5-逻辑运算符"><a href="#1-5-逻辑运算符" class="headerlink" title="1.5 逻辑运算符"></a>1.5 逻辑运算符</h3><blockquote><ol><li>and  逻辑“与”，两个都为True则返回True，否则False</li><li>or  逻辑“或”，两个至少有一个True则返回True，否则False</li><li>not  逻辑“非”，字面意思</li></ol></blockquote><h3 id="1-6-成员和身份运算符"><a href="#1-6-成员和身份运算符" class="headerlink" title="1.6 成员和身份运算符"></a>1.6 成员和身份运算符</h3><p>python的成员运算符用来判断一个数据是否在指定的序列或者集合中，而身份运算符是用来判断两个变量是否引用自同一个对象。</p><blockquote><ol><li>in  成员运算符，在指定序列中找到值则返回True，否则False</li><li>not in  成员运算符，在指定序列中没有找到值则返回True，否则False</li><li>is  身份运算符，两个标识符是否引自同一个对象，是则返回True，否则False</li><li>is not  身份运算符，两个标识符是否引用同一个对象，不是则返回True，否则False</li></ol></blockquote><p>是否引自同一个对象，简单理解就是看存储的内存位置是否一样，通过函数id()可以查看变量在内存中的存储位置。</p><p><img src="https://www.shelven.com/tuchuang/20221124/111.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221124/111.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div><h2 id="2-参数传递"><a href="#2-参数传递" class="headerlink" title="2. 参数传递"></a>2. 参数传递</h2><div class="story post-story"><p>要理解参数传递的过程，首先要明白关于函数参数的两个具体概念：形参和实参</p><ul><li>定义时小括号中的参数，是用来接收参数的，称为“形参”，可以是缺省参数、不定长参数</li><li>调用时小括号中的参数，是用来传递参数给函数的，称为“实参”</li></ul><p>向函数传递实参的方式很多，确定传递参数个数可以使用位置实参或者关键字实参，不确定传递参数个数可以使用包裹（packing）传递的方式，来包裹位置或者关键字实参，进行参数传递。</p><h3 id="2-1-位置实参"><a href="#2-1-位置实参" class="headerlink" title="2.1 位置实参"></a>2.1 位置实参</h3><p>函数调用时每个实参都要关联到函数定义中的一个形参，最简单的是按照形参的位置从左到右按照顺序传递，位置参数必须一一对应，缺一不可。</p><p><img src="https://www.shelven.com/tuchuang/20221124/222.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221124/222.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>比如上面创建了一个describe_me()函数，形参定义了需要name和age两个参数，因此在调用这个函数的时候要按照顺序提供这两个参数。在上例中，从左到右实参‘Phantom’储存在形参name中，实参26储存在形参age中，<strong>参数传递本质上就是实参到形参的赋值操作</strong>。</p><h3 id="2-2-关键字实参"><a href="#2-2-关键字实参" class="headerlink" title="2.2 关键字实参"></a>2.2 关键字实参</h3><p>关键字实参顾名思义是传递函数的key-Value对，在实参中将关键字和值关联，因为这种对应关系是唯一的，在调用函数的时候就不需要考虑实参的顺序。</p><p><img src="https://www.shelven.com/tuchuang/20221124/333.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221124/333.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>这种参数传递方式比较直观，能一眼看出函数调用时各个值对应的用途。</p><p>关键字实参和位置实参时可以一起使用，需要注意：</p><ul><li>关键字实参必须在位置实参右边（写的时候<strong>位置实参优先</strong>）</li><li>对同一个形参不可重复传值</li></ul><h3 id="2-3-形参的缺省"><a href="#2-3-形参的缺省" class="headerlink" title="2.3 形参的缺省"></a>2.3 形参的缺省</h3><p>创建函数的时候可以给形参指定默认值（缺省）。</p><p><img src="https://www.shelven.com/tuchuang/20221124/444.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221124/444.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>对于缺省形参，需要注意：</p><ul><li>缺省参数要在非缺省参数之后（缺省形参放右边）</li><li>缺省参数是可选参数，可以不传；如果传入则按照传入的值进行运算</li></ul><h3 id="2-4-形参的不定长参数（包裹传递）"><a href="#2-4-形参的不定长参数（包裹传递）" class="headerlink" title="2.4 形参的不定长参数（包裹传递）"></a>2.4 形参的不定长参数（包裹传递）</h3><p>当传入的参数个数不确定时，可以使用包裹位置参数和包裹关键字参数进行参数传递。</p><ul><li>*+形参的方式传递参数，传入后根据参数的位置以<strong>元组</strong>形式保存</li><li>**+形参的方式传递参数，需要使用关键字，传入后以<strong>字典</strong>形式保存，形参名字是传入字典的键</li></ul><p><img src="https://www.shelven.com/tuchuang/20221124/555.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221124/555.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>上面例子形参中的args表示arguments位置参数，kargs表示key arguments关键字参数，这个是可以自定义的。</p><p>不同的参数传递方式可以混用，原则上要遵循<strong>位置参数，默认参数，包裹位置，包裹关键字</strong>的顺序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">name, age = <span class="number">26</span>, *args, **kargs</span>)  <span class="comment"># 定义和调用都遵循这样的顺序</span></span><br></pre></td></tr></table></figure><h3 id="2-5-对传参的思考"><a href="#2-5-对传参的思考" class="headerlink" title="2.5 对传参的思考"></a>2.5 对传参的思考</h3><p>在CSDN上看到一个总结写的很好，<strong>函数的参数传递本质上是从实参到形参的赋值操作，而所有的赋值操作都是“引用的赋值”，因此Python中参数的传递都是“引用传递”，不是“值传递</strong>”。这句话初看有点难以理解，首先看看什么是引用传递和值传递：</p><ul><li>值传递（pass by value）：调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</li><li>引用传递（pass by reference）：调用函数时将实际参数的地址直接传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</li></ul><p>根本区别在于引用传递不创建副本，最直接的理解方式就是通过查看对象的地址，看看传参前后对象在内存的位置是否改变。</p><h4 id="2-5-1-可变对象的传递"><a href="#2-5-1-可变对象的传递" class="headerlink" title="2.5.1 可变对象的传递"></a>2.5.1 可变对象的传递</h4><p>复习一下，可变对象有列表、字典和集合，我们这里以列表为例。</p><p><img src="https://www.shelven.com/tuchuang/20221124/777.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221124/777.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>可以看到，如果传递的对象是<strong>可变对象</strong>，实际上传递的是对象的引用（不创建副本，传递前后在内存中存储位置不变），在函数中修改对象后，<strong>直接在原始对象上做了相应的修改</strong>。</p><h4 id="2-5-2-不可变对象的传递"><a href="#2-5-2-不可变对象的传递" class="headerlink" title="2.5.2 不可变对象的传递"></a>2.5.2 不可变对象的传递</h4><p>如果传递的对象是不可变类型，比如元组，字符和数字，这里以数字为例。</p><p><img src="https://www.shelven.com/tuchuang/20221124/888.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221124/888.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>可以看到，如果传递的对象是<strong>不可变对象</strong>，传进函数的时候同样是对象的引用，但是不可变对象无法修改，因此在赋值操作时，系统新创建了一个对象（和原来a的存储地址不同）进行赋值，<strong>而原始对象并没有改变</strong>。</p><p>也就是说，不可变对象的传递起到类似值传递的效果，但是实际上依然是引用传递的方式进行传参。</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇笔记主要记录python基础的运算符和函数参数传递，以及自己学习过程的一些思考。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="编程自学" scheme="http://www.shelven.com/categories/%E7%BC%96%E7%A8%8B%E8%87%AA%E5%AD%A6/"/>
    
    
    <category term="python" scheme="http://www.shelven.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python自学笔记（1）——数据类型</title>
    <link href="http://www.shelven.com/2022/11/23/a.html"/>
    <id>http://www.shelven.com/2022/11/23/a.html</id>
    <published>2022-11-23T14:09:49.000Z</published>
    <updated>2022-12-03T16:03:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>这两个月经历了突然的疫情隔离，研究生开题，学术论坛，研究生创新项目等等……终于在这一周尘埃落定了，得以静下心来整理整理自己的一些学习笔记。之前我用过一些python编写的项目，我也只是依葫芦画瓢或者在demo上直接改，还没有系统性地学习过这门编程语言。这里就再记录下自己自学python的一些入门时的笔记，以及记录下几个机器学习方面的python库的使用方法。</p><span id="more"></span><h2 id="1-六大数据类型"><a href="#1-六大数据类型" class="headerlink" title="1. 六大数据类型"></a>1. 六大数据类型</h2><div class="story post-story"><p>很多编程语言的数据类型是相通或者有类似之处的，学习一门编程语言最基础的就是熟悉它的数据类型，python有6种标准数据类型。</p><h3 id="1-1-Numbers-数字类型"><a href="#1-1-Numbers-数字类型" class="headerlink" title="1.1 Numbers(数字类型)"></a>1.1 Numbers(数字类型)</h3><p>数字类型简单来说就是数值，在python中<strong>是不可变数据类型</strong>。python的Numbers数据类型又可以分为以下几个子类型</p><blockquote><ol><li>整型(int): 通常称为整型或整数，是正或负整数，不带小数点。python3整型没有大小限制，可以当作python2的Long类型使用，不像其他编程语言有 int，smallint，short，long，longint，long 等。</li><li>浮点型(float): 浮点型由整数和小数两个部分组成，只能以十进制表示或者科学计数法表示，有长度限制。</li><li>布尔型(bool): 布尔型就是逻辑，使用True和False表示。注意一下在上下文环境中，True当做1，False被当作0。</li><li>复数型(complex): 复数型由实数和虚数部分构成，可以用a + bj或者complex(a, b)表示，a和b都是浮点型。</li></ol></blockquote><h3 id="1-2-String-字符串"><a href="#1-2-String-字符串" class="headerlink" title="1.2 String(字符串)"></a>1.2 String(字符串)</h3><p>String是python中最常用的数据类型，说白了就是字符组成的一串内容。可以使用成对的单引号或者双引号(“或‘)创建字符串，用三个单引号或者双引号使字符串内容保持原样输出，可以包含特殊字符。<strong>在python中字符串是不可变变量。</strong></p><h4 id="1-2-1-字符串索引"><a href="#1-2-1-字符串索引" class="headerlink" title="1.2.1 字符串索引"></a>1.2.1 字符串索引</h4><p>索引就是字符的位置序号，使用[]进行字符串索引，python有两种索引方式，下标索引越界均会报错。</p><p>正向索引：字符串长度为n，<strong>从0开始</strong>，索引值范围0 ~ n-1</p><p>反向索引：字符串长度为n，<strong>从-1开始</strong>，索引值范围-1 ~ -n</p><p><img src="https://www.shelven.com/tuchuang/20221123/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221123/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="1-2-2-字符串切片"><a href="#1-2-2-字符串切片" class="headerlink" title="1.2.2 字符串切片"></a>1.2.2 字符串切片</h4><p>切片意思就是取出字符串中你想要的内容。切片的标准写法是两个冒号加三个数字，如a[1:2:3]，需要注意切片是<strong>左闭右开</strong>的取值，切片越界是不会报错的。</p><p>第一个数字表示切片的起始位置（省略就是从第 1 个字符开始，也就是0号位）</p><p>第二个数字表示切片的终止位置（不包括这个位置的字符，右开表现在这里；<strong>可省略，省略是最后一个字符结尾且包含</strong>）</p><p>第三个数字表示步长（缺省值为1，此时可以不写第二个冒号）</p><p><img src="https://www.shelven.com/tuchuang/20221123/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221123/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="1-2-3-转义"><a href="#1-2-3-转义" class="headerlink" title="1.2.3 转义"></a>1.2.3 转义</h4><p>如果使用带有特殊字符的字符串，则需要进行转义，使用反斜杠 \ 进行字符转义。</p><table><thead><tr><th>转义字符</th><th>描述</th></tr></thead><tbody><tr><td>\‘</td><td>表示单引号</td></tr><tr><td>\“</td><td>表示双引号</td></tr><tr><td>\n</td><td>换行</td></tr><tr><td>\t</td><td>制表符（即四个空格）</td></tr><tr><td>\b</td><td>退格（删除前面一个字符）</td></tr><tr><td>\\</td><td>表示反斜杠</td></tr></tbody></table><p>在字符串前加 ’r‘ 可以使整个字符串原样输出，不会被转义。</p><p><img src="https://www.shelven.com/tuchuang/20221123/4.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221123/4.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="1-2-4-格式化输出和占位符"><a href="#1-2-4-格式化输出和占位符" class="headerlink" title="1.2.4 格式化输出和占位符"></a>1.2.4 格式化输出和占位符</h4><p>格式化输出意思是按照格式说明所描述的文字规则进行输出，占位符的使用是格式化输出的表现形式。占位符的意思是替后面的变量占住这个位置，因此所有占位符最后都需要格式化定义占位符的映射（也就是解释占位符代表的东西）。</p><p>这里记录一下最常用的占位符</p><table><thead><tr><th>占位符</th><th>描述</th></tr></thead><tbody><tr><td>%s</td><td>针对所有数据类型</td></tr><tr><td>%d</td><td>针对整型数据类型</td></tr><tr><td>%f</td><td>只针对浮点数</td></tr><tr><td>%.xf</td><td>浮点数精确到小数点后x位，注意有个点</td></tr></tbody></table><p><img src="https://www.shelven.com/tuchuang/20221123/5.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221123/5.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>可以看到两种输出方式得到的结果是一样的，使用占位符进行格式化输出更简介，且更常用。</p><h3 id="1-2-5-常用函数"><a href="#1-2-5-常用函数" class="headerlink" title="1.2.5 常用函数"></a>1.2.5 常用函数</h3><p>python还有很多数据操作的函数，这里记录最常用的几个，以后继续补充</p><blockquote><p>type(): 查看数据类型</p><p>len(): 查看字符串长度</p><p>int(): 将数据类型转换为整数，如int(“1234”)得到结果整型1234</p><p>float(): 转换为浮点数，如float(“12.34”)得到结果浮点型12.34</p><p>str(): 转换为字符串，如str(123456)得到结果“123456”</p></blockquote><h3 id="1-3-List-列表"><a href="#1-3-List-列表" class="headerlink" title="1.3 List(列表)"></a>1.3 List(列表)</h3><p><strong>列表数据可以存储任意一种数据类型</strong>，是python特有的数据类型，列表用来存储由多个值构成的序列，可以嵌套其他列表，<strong>是一种可变数据类型</strong>。</p><p>不同数据项之间由逗号分开，整体放在一个方括号[]里，就可以创建列表，如ls &#x3D; [1, 2, 3, 4]就是一个列表。</p><h4 id="1-3-1-修改列表元素"><a href="#1-3-1-修改列表元素" class="headerlink" title="1.3.1 修改列表元素"></a>1.3.1 修改列表元素</h4><p>因为列表是可变数据类型，因此可以用索引或者切片的方法修改列表中的元素。</p><p><img src="https://www.shelven.com/tuchuang/20221123/6.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221123/6.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>可以使用del删除列表或者列表中索引为某个数的元素。</p><p><img src="https://www.shelven.com/tuchuang/20221123/7.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221123/7.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="1-3-2-列表生成式"><a href="#1-3-2-列表生成式" class="headerlink" title="1.3.2 列表生成式"></a>1.3.2 列表生成式</h4><p>除了直接创建列表，还可以使用列表生成式直接生成列表。</p><p><img src="https://www.shelven.com/tuchuang/20221123/9.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221123/9.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="1-3-3-列表的方法函数"><a href="#1-3-3-列表的方法函数" class="headerlink" title="1.3.3 列表的方法函数"></a>1.3.3 列表的方法函数</h4><p>记录一下操作列表的常用方法，这里就不演示了。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>list.append(obj)</td><td>列表<strong>末尾</strong>添加新的对象</td></tr><tr><td>list.count(obj)</td><td>返回某个元素在列表中出现的次数</td></tr><tr><td>list.extend(seq)</td><td>在列表末尾添加另一个列表的所有元素</td></tr><tr><td>list.index(obj)</td><td>返回第一个匹配的的索引值</td></tr><tr><td>list.insert(index, obj)</td><td>在指定索引插入对象</td></tr><tr><td>list.pop(index)</td><td>移除指定索引的值，并返回该值</td></tr><tr><td>list.sort()</td><td>对原列表进行升序排序（纯数字才可以），降序需要添加reverse&#x3D;True</td></tr><tr><td>list.reverse()</td><td>反转列表元素</td></tr><tr><td>list.remove(obj)</td><td>移除第一个匹配的某对象</td></tr></tbody></table><h3 id="1-4-Tuple-元组"><a href="#1-4-Tuple-元组" class="headerlink" title="1.4 Tuple(元组)"></a>1.4 Tuple(元组)</h3><p>元组也是python的一种特殊数据类型，和列表很相似，<strong>但是是不可变对象</strong>。如果想创建一个全局都不变的变量，可以考虑创建元组。</p><p>元组中的元素用逗号分隔，一般要使用小括号（小括号不是必须的，只是为了方便理解和美观）。</p><p><strong>元组中如果只有一个元素，需要在元素后加逗号。</strong>否则无法判断这是一个元组还是一个整型数据。</p><p><img src="https://www.shelven.com/tuchuang/20221123/8.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221123/8.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>同样元组数据也可以进行索引和切片，这里不赘述。</p><h4 id="1-4-1-元组和列表的互相转化"><a href="#1-4-1-元组和列表的互相转化" class="headerlink" title="1.4.1 元组和列表的互相转化"></a>1.4.1 元组和列表的互相转化</h4><p>元组转化列表使用list()函数，列表转化元组使用tuple()函数。</p><p><img src="https://www.shelven.com/tuchuang/20221123/10.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221123/10.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="1-4-2-结合元组的列表生成式"><a href="#1-4-2-结合元组的列表生成式" class="headerlink" title="1.4.2 结合元组的列表生成式"></a>1.4.2 结合元组的列表生成式</h4><p>元组不能通过和列表一样的生成式来创建，但是列表生成式中可以加入元组。</p><p><img src="https://www.shelven.com/tuchuang/20221123/11.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221123/11.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="1-5-Set-集合"><a href="#1-5-Set-集合" class="headerlink" title="1.5 Set(集合)"></a>1.5 Set(集合)</h3><p>集合是一个无序的不重复元素序列，可以使用大括号{}或者set()函数创建集合，但是创建一个空集合必须要用set()而不是{}，因为{}是用来创建一个空字典的。</p><p>因为用的不多，简单记录一下，集合有三个特点</p><blockquote><p>集合的元素是无序的。 如：{1, 2, 3}和{1, 3, 2}是完全相等的。</p><p>集合的元素是不重复的。 如：{1, 1, 1}只会保留一个值，打印结果为{1}。</p><p>集合的元素必须是不可变数据类型（数字、字符串和元组）。 如：{1, [1, 2]}打印结果会报错，因为列表是可变数据类型。</p></blockquote><h3 id="1-6-Dictionary-字典"><a href="#1-6-Dictionary-字典" class="headerlink" title="1.6 Dictionary(字典)"></a>1.6 Dictionary(字典)</h3><p>字典用的比较多，其存储特点是键值对的形式出现（Key-Value），一个键对应一个值，每个键值对用冒号隔开，每对键值对用逗号隔开。字典也可以存储任意类型数据。</p><p>需要注意的一点，在字典数据类型中，<strong>键必须是唯一的</strong>，但是值可以不唯一，<strong>值可以取任何数据类型，但是键必须是不可变数据类型。</strong></p><h4 id="1-6-1-字典创建和修改"><a href="#1-6-1-字典创建和修改" class="headerlink" title="1.6.1 字典创建和修改"></a>1.6.1 字典创建和修改</h4><p>字典数据可以通过花括号直接创建，或者通过dict()函数创建（非空）。</p><p><img src="https://www.shelven.com/tuchuang/20221123/13.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221123/13.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>通过访问键来访问对应的值，添加、删除和修改的方法均类似。</p><p><img src="https://www.shelven.com/tuchuang/20221123/14.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221123/14.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="1-6-2-字典的方法函数"><a href="#1-6-2-字典的方法函数" class="headerlink" title="1.6.2 字典的方法函数"></a>1.6.2 字典的方法函数</h4><p>记录一下常用的字典方法函数，就不演示了，具体用到的时候可以查。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>dict.keys()</td><td>返回所有键的列表dict_key对象，可以转换成列表、元组和集合</td></tr><tr><td>dict.values()</td><td>返回所有值的列表dict_values对象，也可以转换成列表、元组和集合</td></tr><tr><td>dict.items()</td><td>返回所有键值对的列表dict_items对象，同样可以转换成列表、元组和集合</td></tr><tr><td>dict.clear()</td><td>清空字典，无返回值，只剩下空字典</td></tr><tr><td>dict.get(key, default&#x3D;None)</td><td><strong>返回</strong>字典中指定key的<strong>value值</strong>，如果key不存在，则返回default值</td></tr><tr><td>dict.pop(key, default&#x3D;None)</td><td><strong>删除</strong>指定的key<strong>并返回</strong>对应的<strong>value值</strong>，如果key不存在，则返回default值</td></tr></tbody></table><p>简单小结一下关于python数据类型的注意点：</p><blockquote><p>1.可变数据类型：List、Dictionary、Set</p><p>2.不可变数据类型：Tuple、Numbers、String。不可变体现在索引这些变量名的元素不可被重新赋值</p><p>3.下标索引：String、List、Tuple支持下标索引，Dictionary是通过Key值索引</p><p>4.切片：String、List、Tuple支持切片操作</p></blockquote></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;这两个月经历了突然的疫情隔离，研究生开题，学术论坛，研究生创新项目等等……终于在这一周尘埃落定了，得以静下心来整理整理自己的一些学习笔记。之前我用过一些python编写的项目，我也只是依葫芦画瓢或者在demo上直接改，还没有系统性地学习过这门编程语言。这里就再记录下自己自学python的一些入门时的笔记，以及记录下几个机器学习方面的python库的使用方法。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="编程自学" scheme="http://www.shelven.com/categories/%E7%BC%96%E7%A8%8B%E8%87%AA%E5%AD%A6/"/>
    
    
    <category term="python" scheme="http://www.shelven.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>深度学习笔记</title>
    <link href="http://www.shelven.com/2022/09/20/a.html"/>
    <id>http://www.shelven.com/2022/09/20/a.html</id>
    <published>2022-09-19T16:58:05.000Z</published>
    <updated>2022-12-03T16:21:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>开坑记录一下学习人工智能(深度学习为主)的笔记，方便以后回顾学习~整理自点头教育</p><span id="more"></span><h2 id="人工智能的趋势展望"><a href="#人工智能的趋势展望" class="headerlink" title="人工智能的趋势展望"></a>人工智能的趋势展望</h2><div class="story post-story"><h3 id="1-前沿技术"><a href="#1-前沿技术" class="headerlink" title="1. 前沿技术"></a>1. 前沿技术</h3><h4 id="Transformer模型"><a href="#Transformer模型" class="headerlink" title="Transformer模型"></a>Transformer模型</h4><p>基于自注意力机制，有效提高模型训练效率</p><p>由Google的Ashish Vaswani等人和多伦多大学的Aidan N.Gomez于2017年首次提出，是一种基于<strong>自注意力机制</strong>（在Transformer模型中起基础作用，可减少对外部信息的依赖,更擅长捕捉数据或特征的内部关系，优化模型训练结果）的深度学习模型，该模型主要由编码器和解码器构成，模型本身并行度较高，在精度和性能上均要优于传统的循环神经网络（RNN）和卷积神经网络（CNN）。Transformer模型在简单语言问答和语言建模任务上有着较好表现。</p><p><img src="https://www.shelven.com/tuchuang/20220919/1.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/1.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="BERT模型"><a href="#BERT模型" class="headerlink" title="BERT模型"></a>BERT模型</h4><p>基于Transformer Encoder构建的预测模型</p><p>由Google于2018年提出，是基于Transformer Encoder构建的一种模型。模型基本思想：给定上下文来预测下一个词。BERT模型架构是由多接口组成的Transformer编码器层，即全连接神经网络增加自注意力机制。对于序列中的每个输入标记，每个接口计算键值和查询向量，相关向量用于创建加权表示，合并同一层中所有接口输出并通过全连接层运行。每个层使用跳跃连接进行包装，之后将层归一化处理。</p><p><img src="https://www.shelven.com/tuchuang/20220919/2.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="自监督学习"><a href="#自监督学习" class="headerlink" title="自监督学习"></a>自监督学习</h4><p>将无监督问题转化为有监督问题的方法</p><p>旨在对于无标签数据，通过设计辅助任务来挖掘数据自身的表征特性作为监督信息，来提升模型的特征提取能力，将无监督问题转化为有监督问题的方法。</p><p>说到自监督就顺便说下<strong>有监督学习</strong>和<strong>无监督学习</strong>，有监督给定的结果是确定的；无监督是实际应用场景中最多的，结果不确定，根据类别未知(没有被标记)的训练样本解决模式识别中的各种问题。</p><p><img src="https://www.shelven.com/tuchuang/20220919/3.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/3.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="类脑计算"><a href="#类脑计算" class="headerlink" title="类脑计算"></a>类脑计算</h4><p>模拟大脑结构和信息加工过程，提高机器认知能力、降低运行功耗</p><p>类脑计算(Brain-Inspired Computing): 又称神经形态计算，是借鉴生物神经系统信息处理模式和结构的计算理论、体系结构、芯片设计以及应用模型与算法的总称。类脑计算可模拟人类大脑信息处理方式，以极低的功耗对信息进行异步、并行、高速和分布式处理，并具备自主感知、识别和学习等多种能力，是实现通用人工智能的途径之一。</p><p><img src="https://www.shelven.com/tuchuang/20220919/4.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/4.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="AI大模型"><a href="#AI大模型" class="headerlink" title="AI大模型"></a>AI大模型</h4><p>包含万亿量级参数的预训练模型，显著降低模型训练成本</p><p>AI大模型(Foundation Models):是指经过大规模数据训练且在经微调后即可适应广泛下游任务的模型。随着参数规模不断扩大，AI大模型在语言、视觉、推理、人机交互等领域涌现出新能力。</p><p><img src="https://www.shelven.com/tuchuang/20220919/5.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/5.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="2-人工智能的产业融合"><a href="#2-人工智能的产业融合" class="headerlink" title="2. 人工智能的产业融合"></a>2. 人工智能的产业融合</h3><h4 id="人工智能与元宇宙"><a href="#人工智能与元宇宙" class="headerlink" title="人工智能与元宇宙"></a>人工智能与元宇宙</h4><p>元宇宙（Metaverse）：本质上是对现实世界的虚拟化、数字化过程，其主要包括基础设施、人机交互、空间计算等七层架构，其中计算机视觉、AI芯片和嵌入式AI等人工智能技术及基础设施共同助力元宇宙加速落地。元宇宙涵盖芯片、云计算、技术平台、通信、智能设备、内容服务等庞大生态系统。</p><p><img src="https://www.shelven.com/tuchuang/20220919/6.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/6.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="人工智能与生命科学"><a href="#人工智能与生命科学" class="headerlink" title="人工智能与生命科学"></a>人工智能与生命科学</h4><p>AlphaFold是由谷歌旗下DeepMind团队基于深度学习算法的<strong>蛋白质结构预测</strong>的人工智能系统，其被视作人工智能深入到生物领域的一大突破。目前AlphaFold已对98.5%的人类蛋白质结构做出预测，此外还对于大肠杆菌、果蝇、斑马鱼、小鼠等研究时常用生物的蛋白质结构进行预测。（这块比较感兴趣，有空继续了解一下）</p><p><img src="https://www.shelven.com/tuchuang/20220919/7.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/7.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="人工智能与新冠疫情"><a href="#人工智能与新冠疫情" class="headerlink" title="人工智能与新冠疫情"></a>人工智能与新冠疫情</h4><p>Eva是用于检测入境旅客新冠病毒的强化学习系统，其由美国南加州大学、美国宾夕法尼亚学、AgentRisk以及希腊相关专家合作开发。 </p><p>2020年，Eva系统被部署到希腊所有入境口岸（机场、港口、车站等），用于识别限制新冠无症状旅客入境。（这里存疑，用算法确定新冠受检者，虽然在一定程度上能缓解新冠检测用品有限的不利情况，但是无疑会漏掉部分入境的可能感染者，一旦感染爆发得不偿失）</p><p><img src="https://www.shelven.com/tuchuang/20220919/8.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/8.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="人工智能与半导体"><a href="#人工智能与半导体" class="headerlink" title="人工智能与半导体"></a>人工智能与半导体</h4><p>AI与EDA紧密融合，促使芯片PPA结果更加稳定</p><p>为使PPA优化结果更佳，同时为应对芯片安全性需求提升、设计规模攀升及工艺节点微缩等趋势，EDA厂商开始利用AI技术解决半导体芯片设计问题。在EDA中，数据快速提取模型、布局和布线、电路仿真模型、 PPA优化决策等环节均有AI技术参与。</p><p><img src="https://www.shelven.com/tuchuang/20220919/9.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/9.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="人工智能与碳中和"><a href="#人工智能与碳中和" class="headerlink" title="人工智能与碳中和"></a>人工智能与碳中和</h4><p>人工智能在预测、监测、优化三大环节赋能碳中和</p><p>当前，碳中和已获得全球超过40个国家和地区承诺，其中大部分国家宣布将于2050年左右实现碳中和目标。从整体来看，人工智能将从预测、监测、优化三大环节助力碳中和，如预测未来碳排放量、实时监测碳足迹、优化工作流程等。</p><p><img src="https://www.shelven.com/tuchuang/20220919/10.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/10.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="人工智能与冬奥会"><a href="#人工智能与冬奥会" class="headerlink" title="人工智能与冬奥会"></a>人工智能与冬奥会</h4><p>2022年2月，第24届冬季奥林匹克运动会成功在北京举办。人工智能技术在冬奥会开幕式、比赛项目、运动员训练等多个场景实现应用，助力科技冬奥目标实现。</p><p><img src="https://www.shelven.com/tuchuang/20220919/11.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/11.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="3-人工智能产业发展的路径探究"><a href="#3-人工智能产业发展的路径探究" class="headerlink" title="3. 人工智能产业发展的路径探究"></a>3. 人工智能产业发展的路径探究</h3><p>人工智能在“科研成果—商业化落地”过程中依然存在诸多挑战</p><p><img src="https://www.shelven.com/tuchuang/20220919/12.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/12.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="伦理与安全"><a href="#伦理与安全" class="headerlink" title="伦理与安全"></a>伦理与安全</h4><p>人工智能发展面临隐私保护与算法合规使用等方面挑战</p><p>随着人工智能技术的高速发展与普及应用，由其产生的伦理与安全问题日益受到关注。人工智能不但延续信息技术的伦理问题，又因深度学习算法具有不透明、难解释、自适应、运用广泛等特征而在基本人权、社会秩序、国家安全等方面产生新问题。</p><p><img src="https://www.shelven.com/tuchuang/20220919/13.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/13.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="国家间技术限制"><a href="#国家间技术限制" class="headerlink" title="国家间技术限制"></a>国家间技术限制</h4><p>国家间技术限制阻碍人工智能技术进步</p><p>当前，开源深度学习框架、开源工具集、开源应用软件快速发展，国际间AI技术交流不断深入，但部分国家和政府间组织为保持自身AI 技术优势，限制AI技术交流。如美国在2021年6月发布《创新与竞争法案》，在AI、无人机、芯片等多个领域限制与中国合作；美国商务部于2019年10月和2020年5月将商汤科技、科大讯飞等多家中国AI公司加入其实体清单，实施投资限制；2022年白宫修订“关键和新兴技术（CET）清单”，对AI技术具体分类并实行技术封锁。欧盟则于2021年9月通过最新出口管制法规，内容涵盖人脸识别等AI技术。 </p><p>上述相关政策与未来人工智能发展趋势背道而驰，不利于各国开展技术合作。</p><p><img src="https://www.shelven.com/tuchuang/20220919/14.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/14.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div><h2 id="深度学习算法部分内容"><a href="#深度学习算法部分内容" class="headerlink" title="深度学习算法部分内容"></a>深度学习算法部分内容</h2><div class="story post-story"><h3 id="迁移学习"><a href="#迁移学习" class="headerlink" title="迁移学习"></a>迁移学习</h3><p>将知识由源域迁移至目标域，提高机器学习效率</p><p>迁移学习（Transfer Learning,TL）：是一种机器学习方法,是把已训练好的模型参数迁移到新的模型来帮助新模型训练，其核心目标是将知识从源域迁移到目标域，让机器也可以做到“触类旁通”。</p><p>迁移学习的主要优点是节省模型训练时间，且在目标域训练数据不足时，模型仍能取得较好的性能。</p><p>迁移学习的训练框架可以概括为：1）选择源模型，从可用模型中挑选出预训练模型；2）重用模型，在目标域中使用源模型进行训练；3）调整模型。模型可以在目标数据集中对输入-输出进行选择性微调，以让其适应目标任务。</p><p>实现迁移学习的方式主要包括样本迁移、特征迁移、模型迁移。目前，迁移学习主要应用在<strong>计算机视觉</strong>、<strong>自然语言处理</strong>等领域。</p><p><img src="https://www.shelven.com/tuchuang/20220919/15.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/15.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="神经网络与卷积神经网络"><a href="#神经网络与卷积神经网络" class="headerlink" title="神经网络与卷积神经网络"></a>神经网络与卷积神经网络</h3><h4 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h4><p>具有适应性简单单元组成的广泛并行互联网络</p><p>神经网络（Neural Network）：由数千甚至数百万个紧密互连的简单处理节点组成，其主要包括输入层（输入数据）、中间层&#x2F;隐藏层（学习复杂决策边界）和输出层（输出结果）。</p><p>神经网络可以用于回归，但主要应用于分类问题。如下图所示：输入层表示输入图像（64维向量），中间层使用Sigmoid等非线性函数对于输入层数据进行计算，输出层使用非线性函数对于中间层数据进行计算。</p><p>神经网络通过采取设置中间层的方式，利用单一算法学习各种决策边界，调节中间层数量以及层的深度，神经网络可学习更复杂的边界特征，而得出更加准确的结果。</p><p><img src="https://www.shelven.com/tuchuang/20220919/16.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/16.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h4><p>以<strong>图像识别</strong>为核心的深度学习算法</p><p>卷积神经网络（Convolutional Neural Network,CNN）：由数千甚至数百万个紧密互连的简单处理节点组成，其主要包括输入层、卷积层、池化层、全连接层和输出层，<strong>适合处理图片、视频等类型数据</strong>。</p><p>1980年，日本科学家福岛邦彦提出一个包含卷积层、池化层的神经网络结构。在此基础上，Yann Lecun将BP算法应用到该神经网络结构的训练上，形成当代卷积神经网络的雏形；1988年，Wei Zhang提出第一个二维卷积神经网络：平移不变人工神经网络（SIANN），并将其应用于<strong>检测医学影像</strong>；1998年Yann LeCun及其合作者构建了更加完备的卷积神经网络LeNet-5并在手写数字的识别问题中取得成功。</p><p><img src="https://www.shelven.com/tuchuang/20220919/17.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/17.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><strong>卷积层</strong>：图片输入转化成RGB对应的数字，然后通过卷积核做卷积，目的是提取输入中的主要特征，卷积层中使用同一卷积核对每个输入样本进行卷积操作；</p><p><strong>池化层</strong>：作用在于减小卷积层产生的特征图尺寸（压缩特征映射图尺寸有助于降低后续网络处理的负载）；</p><p><strong>全连接层</strong>：计算激活值然后通过激活函数计算各单元输出值（激活函数包括<strong>Sigmoid、tanh、ReLU</strong>等）</p><p><strong>输出层</strong>：使用似然函数计算各类别似然概率。</p><p><img src="https://www.shelven.com/tuchuang/20220919/18.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/18.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="循环神经网络与图神经网络"><a href="#循环神经网络与图神经网络" class="headerlink" title="循环神经网络与图神经网络"></a>循环神经网络与图神经网络</h3><h4 id="循环神经网络"><a href="#循环神经网络" class="headerlink" title="循环神经网络"></a>循环神经网络</h4><p>用于处理<strong>序列数据</strong>的神经网络</p><p>循环神经网络（Recurrent Neural Network,RNN）：是一类以序列数据（指相互依赖的数据流，比如时间序列数据、信息性的字符串、对话等）为输入，在序列的演进方向进行递归且所有节点（循环单元）按链式连接的神经网络。目前，<strong>语言建模和文本生成、机器翻译、语音识别、生成图像描述、视频标记是RNN应用最多的领域</strong>。</p><p><img src="https://www.shelven.com/tuchuang/20220919/19.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/19.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="图神经网络"><a href="#图神经网络" class="headerlink" title="图神经网络"></a>图神经网络</h4><p>用于处理图结构数据的神经网络</p><p>图神经网络（Graph Neural Networks，GNN）：将图数据和神经网络进行结合，在图数据上面进行端对端的计算，具备端对端学习、擅长推理、可解释性强的特点。</p><p>图神经网络发展出多个分支，主要包括图卷积网络、图注意力网络、图自编码器、图生成网络和图时空网络等。</p><p>图神经网络的训练框架如下：首先，每个节点获取其相邻节点的所有特征信息，将聚合函数（如求和或取平均）应用于这些信息。 聚合函数的选择必须不受节点顺序和排列的影响。之后，将前一步得到的向量传入一个神经网络层（通常是乘以某个矩阵），然后使用非线性激活函数（如ReLU）来获得新的向量表示。</p><p>目前，图神经网络在许多领域的实际应用中都展现出<strong>强大的表达能力和预测能力，如物理仿真、科学研究、生物医药、金融风控等</strong>。</p><p><img src="https://www.shelven.com/tuchuang/20220919/20.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/20.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="长短期记忆神经网络"><a href="#长短期记忆神经网络" class="headerlink" title="长短期记忆神经网络"></a>长短期记忆神经网络</h3><p>在RNN中加入<strong>门控机制</strong>，解决梯度消失问题</p><p>长短期记忆神经网络（Long Short-Term Memory,LSTM）：LSTM是一种特殊的循环神经网络（RNN）。传统RNN在训练中，随着训练时间的加长和层数的增多，很容易出现梯度爆炸或梯度消失问题，导致无法处理长序列数据，LSTM可有效解决传统RNN“长期依赖”问题。</p><p>LSTM由状态单元、输入门（决定当前时刻网络的输入数据有多少需要保存到单元状态）、遗忘门（决定上一时刻的单元状态有多少需要保留到当前时刻）、输出门（控制当前单元状态有多少需要输出到当前输出值）组成，以此令长期记忆与短期记忆相结合，达到序列学习的目的</p><p>LSTM应用领域主要包括文本生成、机器翻译、语音识别、生成图像描述和视频标记等。（我前一篇博客做的tts用了Tacotron2，其编码器模块中就引入了一个双向LSTM层）</p><p><img src="https://www.shelven.com/tuchuang/20220919/21.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/21.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="自编码器"><a href="#自编码器" class="headerlink" title="自编码器"></a>自编码器</h3><p>通过期望输出等同于输入样本的过程，实现对输入样本抽象特征学习</p><p>典型深度无监督学习模型包括<strong>自编码器</strong>、<strong>受限波尔兹曼机</strong>与<strong>生成对抗网络</strong>。</p><p>自编码器（Autoencoder,AE）：包括编码器和解码器两部分，其中<strong>编码器将高维输入样本映射到低维抽象表示，实现样本压缩与降维</strong>；<strong>解码器将抽象表示转换为期望输出，实现输入样本的复现</strong>。自码器的输入与期望输出均为无标签样本，隐藏层输出则作为样本的抽象特征表示。</p><p>自编码器仅通过最小化输入样本与重构样本之间的误差来获取输入样本的抽象特征表示，无法保证自编码器提取到样本的本质特征。为避免上述问题，需要对自编码器添加约束或修改网络结构，进而产生稀疏自编码器、去噪自编码器、收缩自编码器等改进算法。</p><p>自编码器凭借其优异的特征提取能力，主要应用于目标识别、文本分类、图像重建等诸多领域。</p><p><img src="https://www.shelven.com/tuchuang/20220919/22.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/22.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="生成对抗网络"><a href="#生成对抗网络" class="headerlink" title="生成对抗网络"></a>生成对抗网络</h3><p>生成对抗网络（Generative Adversarial Network,GAN）：通过使用对抗训练机制对两个神经网络进行训练，避免反复应用马尔可夫链学习机制带来的配分函数计算，明显提高应用效率。</p><p>生成对抗网络包含一组相互对抗模型—判别器和生成器，判别器目的是正确区分真实数据和生成数据，使得判别准确率最大化，生成器是尽可能逼近真实数据的潜在分布。生成器类似于造假钞的人，其制造出以假乱真的假钞，判别器类似于警察，尽可能鉴别出假钞，最终造假钞的人和警察双方在博弈中不断提升各自能力。（同样是我前面一篇博客语音合成tts中，应用的HiFiGAN就是基于GAN的声码器）</p><p><img src="https://www.shelven.com/tuchuang/20220919/23.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/23.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;开坑记录一下学习人工智能(深度学习为主)的笔记，方便以后回顾学习~整理自点头教育&lt;/p&gt;</summary>
    
    
    
    <category term="深度学习" scheme="http://www.shelven.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="人工智能" scheme="http://www.shelven.com/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>go-cqhttp扫码登录异常的解决方法</title>
    <link href="http://www.shelven.com/2022/09/09/b.html"/>
    <id>http://www.shelven.com/2022/09/09/b.html</id>
    <published>2022-09-09T11:43:05.000Z</published>
    <updated>2022-12-03T16:10:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>假期用自己的服务器搭建了一个基于 Nonebot2 和 go-cqhttp 框架的QQ聊天机器人，使用的开源项目是绪山真寻bot（<a href="https://github.com/HibiKier/zhenxun_bot">项目地址点击这里</a>）。因为项目提供了一键安装包，这里就不详细说安装过程了，简单说下首次运行或者切换bot QQ号会碰到的go-cqhttp扫码登陆异常的问题。</p><span id="more"></span><h3 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h3><p>首次运行或者切换bot QQ号后，go-cqhttp会要求需要登录验证，由于纯linux系统无法使用浏览器抓取滑条，因此会自动跳转到手机QQ扫码验证。</p><p><img src="https://www.shelven.com/tuchuang/20220909_1/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220909_1/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>但是扫码会提示两个设备不在一个网络，无法登录。（很明显我的云端linux服务器不可能和手机能在一个网络中）</p><p><img src="https://www.shelven.com/tuchuang/20220909_1/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220909_1/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>这个问题是腾讯QQ安全机制引起的，很明显是限制QQ机器人的手段，也就是你扫码的网络环境要和服务器的网络环境一致才可以登录。</p><h3 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h3><h4 id="第一步-下载和运行win版go-cqhttp"><a href="#第一步-下载和运行win版go-cqhttp" class="headerlink" title="第一步 下载和运行win版go-cqhttp"></a>第一步 下载和运行win版go-cqhttp</h4><p>项目下载地址<a href="https://github.com/Mrs4s/go-cqhttp/releases">Releases · Mrs4s&#x2F;go-cqhttp (github.com)</a></p><p>选择下载最新版本的go-cqhttp_windows_amd64，解压后有三个文件</p><p><img src="https://www.shelven.com/tuchuang/20220909_1/3.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220909_1/3.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>双击exe文件，提示要在power shell中运行，确认，自动生成<strong>go-cqhttp.bat</strong>的批处理文件</p><p>双击运行<strong>go-cqhttp.bat</strong>，选择013，回车</p><p><img src="https://www.shelven.com/tuchuang/20220909_1/4.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220909_1/4.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>修改生成的config.yml配置文件（主要就是改bot QQ号和密码）</p><p>修改之后再次运行go-cqhttp.bat，看到连接成功，网络没有问题即可</p><p><img src="https://www.shelven.com/tuchuang/20220909_1/5.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220909_1/5.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>前面的反向代理失败统统不用管（因为我没有设置），我们只需要win版go-cqhttp提供设备登录信息文件（<strong>device.json</strong>）和密钥信息文件（<strong>session.token</strong>）即可。这两个文件特别重要，尤其是device.json，缺一个都将会导致登陆失败。</p><h4 id="第二步-替换文件"><a href="#第二步-替换文件" class="headerlink" title="第二步 替换文件"></a>第二步 替换文件</h4><p>替换linux服务器go-cqhttp文件夹下的<strong>device.json和session.token</strong>（有的话替换，无的话直接加进去）文件，<strong>config文件最好不要替换</strong>，你只要改一下qq号和密码就行，防止底下设置的反向连接端口出错（很重要！！）。</p><p><img src="https://www.shelven.com/tuchuang/20220909_1/6.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220909_1/6.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>重新在linux上启动go-cqhttp，问题解决。</p><p><img src="https://www.shelven.com/tuchuang/20220909_1/7.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220909_1/7.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;假期用自己的服务器搭建了一个基于 Nonebot2 和 go-cqhttp 框架的QQ聊天机器人，使用的开源项目是绪山真寻bot（&lt;a href=&quot;https://github.com/HibiKier/zhenxun_bot&quot;&gt;项目地址点击这里&lt;/a&gt;）。因为项目提供了一键安装包，这里就不详细说安装过程了，简单说下首次运行或者切换bot QQ号会碰到的go-cqhttp扫码登陆异常的问题。&lt;/p&gt;</summary>
    
    
    
    <category term="QQ机器人" scheme="http://www.shelven.com/categories/QQ%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    
    
    <category term="qq bot" scheme="http://www.shelven.com/tags/qq-bot/"/>
    
    <category term="go-cqhttp" scheme="http://www.shelven.com/tags/go-cqhttp/"/>
    
  </entry>
  
  <entry>
    <title>深度学习——语音合成tts笔记（下）</title>
    <link href="http://www.shelven.com/2022/09/09/a.html"/>
    <id>http://www.shelven.com/2022/09/09/a.html</id>
    <published>2022-09-08T19:32:17.000Z</published>
    <updated>2022-12-03T16:20:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>（接上篇博客）做完数据集，我们手里现在有训练集（train set）和测试集（test set）音频文件，以及对应的拼音文本，接下来就可以跑Tacotron2来训练模型了。</p><span id="more"></span><h2 id="2-训练模型-amp-合成语音"><a href="#2-训练模型-amp-合成语音" class="headerlink" title="2. 训练模型 &amp; 合成语音"></a>2. 训练模型 &amp; 合成语音</h2><div class="story post-story"><p><a href="https://github.com/NVIDIA/tacotron2">Tacotron2项目地址点击这里</a></p><p><a href="https://github.com/jik876/hifi-gan">HiFi-GAN项目地址点击这里</a></p><p>本篇博客训练模型&amp;合成语音基于以上两个开源项目，再次感谢原作者！</p><h3 id="2-1-Tacotron2简介"><a href="#2-1-Tacotron2简介" class="headerlink" title="2.1 Tacotron2简介"></a>2.1 Tacotron2简介</h3><p>简单讲一讲Tacotron2，它是由google推出的从文本中合成语音的神经网络结构，也就是一个语音合成（Text To Speech，TTS）框架，可以实现端到端的语音合成。Tacotron2与其前代Tacotron类似，比较重要的一个区别是在编码器模块中引入了一个双向LSTM层和卷积层，相比原来的CBHG堆叠结构和GRU循环层更为简洁。</p><p>模型主要由两部分组成：</p><ul><li><ol><li>声谱预测网络：特征预测网络，包含一个编码器和一个引入注意力机制（attention）的解码器，作用是将输入字符序列预测为梅尔频谱的帧序列。</li></ol></li><li><ol start="2"><li>声码器（vocoder）：将预测的梅尔频谱帧序列转换产生时域波形样本，算是WaveNet的修订版。</li></ol></li></ul><p>原项目中的声码器我们暂时不用（<strong>上面地址提供的Tacotron 2就是没有wavenet的版本</strong>），因为有更好的工具HiFi-GAN。</p><p>代码实现详解有很多博客可以参考（<a href="https://blog.csdn.net/whjkm/article/details/89321954#commentBox">(16条消息) Tacotron2 论文 + 代码详解_HJ_彼岸的博客-CSDN博客_tacotron2</a>），<strong>这里只要知道我们是用Tacotron2生成梅尔频谱，在此基础上结合我们输入的字符序列（也就是对应的拼音文本）训练模型。</strong></p><p><u>特别注意一点</u>：Tacotron 2是基于tensorflow1.5版本运行的，如果是自己电脑上配置环境的话，<strong>务必将python版本降到3.7以下！</strong>否则将会无法安装tensorflow1.5，除了tensorflow有硬性版本要求之外，其他依赖都可以安装最新版本——<strong>反复配置环境治好了我的精神内耗</strong></p><p>如果你不想和我一样配置好几天环境的话，我推荐最好使用google colab，一键解决环境问题，下面会说到。</p><h3 id="2-2-HiFi-GAN简介"><a href="#2-2-HiFi-GAN简介" class="headerlink" title="2.2 HiFi-GAN简介"></a>2.2 HiFi-GAN简介</h3><p>简单说下，<strong>声码器的作用就是将梅尔频谱转换成语音信号</strong>，和上面是对应的。</p><p>为什么我们没有用上面Tacotron2的声码器呢，主要原因就是现在有很多更优秀的声码器供我们选择。</p><p>早期比较有名的声码器WaveNet，它是一种自回归卷积神经网络，合成的效果非常好可以说和人类发声非常相似，但有个致命的缺点——合成速度太慢。直到2020年项目作者开发了这套基于GAN（生成式对抗网络）的神经网络声码器，从作者的论文里可以找到，HiFi-GAN在GPU上可以以比实时速度快167.9倍的速度生成22.05 kHz的语音，在CPU上可以以比自回归模型快13.4倍的速度生成语音，这就是它的牛逼之处。</p><p>HiFi-GAN主要有一个生成器和两个判别器，具体结构就不说了，知道一下生成器和两个判别器是通过<strong>对抗学习</strong>的方法训练的，新增加了<strong>两个损失函数</strong>来提高训练的稳定性和提高模型的性能。有能力的小伙伴可以看原论文（HiFi-GAN: Generative Adversarial Networks for Efficient and High Fidelity Speech Synthesis）了解详情。</p><p>需要注意一下作者使用VCTK数据集进行实验，测试了3个模型（V1、V2和V3），简单来说V1是最优模型，作者发布的预训练模型以及相应的配置文件都是以V1模型为基础的。我在这篇博客使用的HiFi-GAN模型<strong>g_02500000</strong>就是作者的预训练模型，配置文件为<strong>config.json</strong>。</p><blockquote><p>HiFi-GAN预训练模型与配置文件下载地址：</p><p><a href="https://drive.google.com/drive/folders/1YuOoV3lO2-Hhn1F2HJ2aQ4S0LC1JdKLd">UNIVERSAL_V1 - Google 云端硬盘</a></p></blockquote><h3 id="2-2-注册谷歌colab和谷歌云盘"><a href="#2-2-注册谷歌colab和谷歌云盘" class="headerlink" title="2.2 注册谷歌colab和谷歌云盘"></a>2.2 注册谷歌colab和谷歌云盘</h3><p>训练模型是一件非常消耗算力的过程，因为涉及到图形处理，我们要用GPU进行加速。我的笔记本GPU非常拉跨，跑模型立马爆显存，因此我个人比较推荐白嫖谷歌colab上面的免费专业级GPU（Nvidia K80），免费用户只能用这一种GPU，至少比我的笔记本好多了。</p><p>需要注意下colab<strong>最大连接时长是12小时</strong>，12小时后会强行关闭GPU连接，因此需要注意下你是什么时候开始用GPU跑模型的，并且及时保存数据。关闭后要等待24小时才可以继续使用GPU，所以<strong>理论上可以用三个号不间断白嫖GPU资源</strong><del>（我特地申请了4个谷歌号）</del>，<strong>你只需要偶尔切换屏幕看下是否有谷歌的人机验证就行</strong>。</p><p>这里为什么还推荐谷歌云盘呢，是因为谷歌云盘可以挂载到colab上，这样调用文件就非常方便，及时保存不用担心数据丢失。谷歌云盘提供15GB的免费空间，如果保存模型比较频繁的话可能不够用，但是我们可以申请无限量的团队盘（<strong>共享云端硬盘</strong>）<del>薅羊毛必备</del>。</p><p><img src="https://www.shelven.com/tuchuang/20220909/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220909/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="2-3-使用colab训练模型-amp-合成语音"><a href="#2-3-使用colab训练模型-amp-合成语音" class="headerlink" title="2.3 使用colab训练模型 &amp; 合成语音"></a>2.3 使用colab训练模型 &amp; 合成语音</h3><p>我使用的colab笔记文件因为时间久远已经找不到出处了（后续如果找到会标注出来，向原作者致谢！），为了跑中文语音模型，自己也修改了很多参数和步骤，一一解释过于麻烦了….感兴趣的小伙伴可以看笔记文件。具体操作流程在底下的视频（<a href="https://www.bilibili.com/video/BV1TG411b7zR">或者点击此处看我的B站视频</a>）。</p><div class="video"><video controls preload><source src='https://www.shelven.com/tuchuang/20220909/80584935.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><blockquote><p>所有工程文件和资源如下：</p><p>Tacotron2+HiFiGAN打包 链接：<a href="https://pan.baidu.com/s/1ngCUvifQM6ETwuG-NFQeGA">https://pan.baidu.com/s/1ngCUvifQM6ETwuG-NFQeGA</a>  提取码：z6h3  </p><p>400条派蒙语音测试集 链接：<a href="https://pan.baidu.com/s/1g0C0Ck4P_BxdTgMirKRc-g">https://pan.baidu.com/s/1g0C0Ck4P_BxdTgMirKRc-g</a>  提取码：5ew1  </p><p>1800条派蒙语音训练集 链接：<a href="https://pan.baidu.com/s/1IDA4lppAJGHnophQAwkxNg">https://pan.baidu.com/s/1IDA4lppAJGHnophQAwkxNg</a>  提取码：f2xk </p></blockquote><p>需要提及一点，colab在2022年8月1号之后不再支持tensorflow1.5，请教大佬之后我将Tacotron2项目下超参数配置hparams.py改成如下即可正常运行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> text <span class="keyword">import</span> symbols</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hparams</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line">    <span class="comment">################################</span></span><br><span class="line">    <span class="comment"># Experiment Parameters        #</span></span><br><span class="line">    <span class="comment">################################</span></span><br><span class="line">    epochs = <span class="number">3</span>  <span class="comment">#500</span></span><br><span class="line">    iters_per_checkpoint = <span class="number">1000</span></span><br><span class="line">    seed = <span class="number">1234</span></span><br><span class="line">    dynamic_loss_scaling = <span class="literal">True</span></span><br><span class="line">    fp16_run = <span class="literal">False</span></span><br><span class="line">    distributed_run = <span class="literal">False</span></span><br><span class="line">    dist_backend = <span class="string">&quot;nccl&quot;</span></span><br><span class="line">    dist_url = <span class="string">&quot;tcp://localhost:54321&quot;</span></span><br><span class="line">    cudnn_enabled = <span class="literal">True</span></span><br><span class="line">    cudnn_benchmark = <span class="literal">True</span></span><br><span class="line">    ignore_layers = [<span class="string">&#x27;embedding.weight&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">################################</span></span><br><span class="line">    <span class="comment"># Data Parameters             #</span></span><br><span class="line">    <span class="comment">################################</span></span><br><span class="line">    load_mel_from_disk = <span class="literal">False</span>  <span class="comment">#实际上是区别用 numpy读wav ，还是用scipy读wav</span></span><br><span class="line">    training_files = <span class="string">&#x27;filelists/zh_audio_text_train_filelist.txt&#x27;</span></span><br><span class="line">    validation_files = <span class="string">&#x27;filelists/zh_audio_text_val_filelist.txt&#x27;</span></span><br><span class="line">    text_cleaners = [<span class="string">&#x27;english_cleaners&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">################################</span></span><br><span class="line">    <span class="comment"># Audio Parameters             #</span></span><br><span class="line">    <span class="comment">################################</span></span><br><span class="line">    max_wav_value = <span class="number">32768.0</span></span><br><span class="line">    sampling_rate = <span class="number">22050</span>   <span class="comment">#22050</span></span><br><span class="line">    filter_length = <span class="number">1024</span></span><br><span class="line">    hop_length = <span class="number">256</span></span><br><span class="line">    win_length = <span class="number">1024</span></span><br><span class="line">    n_mel_channels = <span class="number">80</span></span><br><span class="line">    mel_fmin = <span class="number">0.0</span></span><br><span class="line">    mel_fmax = <span class="number">8000.0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">################################</span></span><br><span class="line">    <span class="comment"># Model Parameters             #</span></span><br><span class="line">    <span class="comment">################################</span></span><br><span class="line">    n_symbols = <span class="built_in">len</span>(symbols)</span><br><span class="line">    symbols_embedding_dim = <span class="number">512</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Encoder parameters</span></span><br><span class="line">    encoder_kernel_size = <span class="number">5</span></span><br><span class="line">    encoder_n_convolutions = <span class="number">3</span></span><br><span class="line">    encoder_embedding_dim = <span class="number">512</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Decoder parameters</span></span><br><span class="line">    n_frames_per_step = <span class="number">1</span>  <span class="comment"># currently only 1 is supported</span></span><br><span class="line">    decoder_rnn_dim = <span class="number">1024</span></span><br><span class="line">    prenet_dim = <span class="number">256</span></span><br><span class="line">    max_decoder_steps = <span class="number">1000</span></span><br><span class="line">    gate_threshold = <span class="number">0.5</span></span><br><span class="line">    p_attention_dropout = <span class="number">0.1</span></span><br><span class="line">    p_decoder_dropout = <span class="number">0.1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Attention parameters</span></span><br><span class="line">    attention_rnn_dim = <span class="number">1024</span></span><br><span class="line">    attention_dim = <span class="number">128</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Location Layer parameters</span></span><br><span class="line">    attention_location_n_filters = <span class="number">32</span></span><br><span class="line">    attention_location_kernel_size = <span class="number">31</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Mel-post processing network parameters</span></span><br><span class="line">    postnet_embedding_dim = <span class="number">512</span></span><br><span class="line">    postnet_kernel_size = <span class="number">5</span></span><br><span class="line">    postnet_n_convolutions = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">################################</span></span><br><span class="line">    <span class="comment"># Optimization Hyperparameters #</span></span><br><span class="line">    <span class="comment">################################</span></span><br><span class="line">    use_saved_learning_rate = <span class="literal">False</span></span><br><span class="line">    learning_rate = <span class="number">1e-3</span></span><br><span class="line">    weight_decay = <span class="number">1e-6</span></span><br><span class="line">    grad_clip_thresh = <span class="number">1.0</span></span><br><span class="line">    batch_size = <span class="number">2</span>  <span class="comment">#64</span></span><br><span class="line">    mask_padding = <span class="literal">True</span>  <span class="comment"># set model&#x27;s padded outputs to padded values</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_hparams</span>(<span class="params">hparams_string=<span class="literal">None</span>, verbose=<span class="literal">False</span></span>):</span><br><span class="line">    <span class="keyword">return</span> hparams</span><br></pre></td></tr></table></figure><h3 id="2-4-注意事项"><a href="#2-4-注意事项" class="headerlink" title="2.4 注意事项"></a>2.4 注意事项</h3><ul><li><ol><li>训练的epoch不是越多越好，我个人经验epoch 超过400会发生<strong>过拟合</strong>，测试集loss会越来越大，当然这和数据集有着密切的关系。过拟合具体表现为合成语音有部分字无法发音。</li></ol></li><li><ol start="2"><li>每个epoch自动保存模型且会覆盖谷歌云盘的原文件，因此务必要<strong>隔一段时间保存到本地</strong>，以免错过最佳模型（或者你改代码，比如50 epoch保存一次）。</li></ol></li><li><ol start="3"><li>对于文本的处理，需要参考Tacotron 2项目下的text文件夹中的四个文件cleaners.py、cmudict.py、numbers.py和symbols.py，我是进行了最简单的设置，可以根据自己需要更改。</li></ol></li><li><ol start="4"><li>如果你原封不动用的我的工程文件，想在本地运行合成语音的推理程序，<strong>务必将cleaners选择english_cleaner</strong><del>（否则会出现古神的低语）</del>。</li></ol></li><li><ol start="5"><li>如果你是自己训练模型，个人认为筛选数据集非常重要，尽量把语气词和背景噪音去掉，否则效果会很差。</li></ol></li><li><ol start="6"><li>训练模型的参数可以根据GPU自行调整，batch_size是影响训练速度最大的因素，当你不确定显卡性能如何，请务必确保运行一段时间后显存没有炸（<strong>我就是运行以后直接睡觉了，醒来发现显存在运行半小时的时候炸了，我心态也炸了</strong>）</li></ol></li></ul><p>其实这个模型效果仍然不是很让我满意，有电音的问题可以用HiFi-GAN再训练过滤一下，我是直接用的官方预训练模型，因此效果会差一点。由于现在开学了要忙着搞开题，最近也没时间再优化模型了，以后有想法会继续补充。</p><p>我自己有考虑过将模型传到服务器，用服务器cpu运行推理，摆脱colab的限制，但是服务器不堪重负…一运行推理运存就炸…github上有不少前人做过纯cpu推理的GUI（<a href="https://github.com/luoyily/MoeTTS">比如MoeTTS</a>），亲测可行。</p><p>哦对了，我在做这个项目的时候，发现已经有人<strong>基于VITS</strong>做了同个游戏的端到端语音合成，甚至开发公布了API…不得不感慨这些大佬真的用心了，有API就意味着有更多的使用方式。我搭了个顺风车，通过搭建QQ机器人，写了个原神语音合成插件，<strong>效果是可以指定原神任何角色合成任意想说的语音并且发在QQ群里</strong>（没有什么技术含量，内行看个笑话），有空尽量更新出来吧！</p><blockquote><p>2022&#x2F;9&#x2F;10更新</p><p>已将插件更新至我的github仓库，地址<a href="https://github.com/Phantom-Aria/zhenxun_plugin_tts">Phantom-Aria&#x2F;zhenxun_plugin_tts: 真寻bot插件，原神角色语音合成tts (github.com)</a></p><p>由于代码写的比较幼稚，就不申请官方插件索引了</p><p><img src="https://www.shelven.com/tuchuang/20220909/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220909/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><ul><li><p>适配绪山真寻bot</p></li><li><p>功能：指定某原神角色合成想要说的话</p></li><li><p>指令：[角色名]说&#x2F;说过[文本]</p></li></ul><p>2022&#x2F;10&#x2F;7更新<br>由于原API已下线，此插件不再生效，后续再更新</p></blockquote></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;（接上篇博客）做完数据集，我们手里现在有训练集（train set）和测试集（test set）音频文件，以及对应的拼音文本，接下来就可以跑Tacotron2来训练模型了。&lt;/p&gt;</summary>
    
    
    
    <category term="深度学习" scheme="http://www.shelven.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="google colab" scheme="http://www.shelven.com/tags/google-colab/"/>
    
    <category term="Tacotron2" scheme="http://www.shelven.com/tags/Tacotron2/"/>
    
    <category term="HiFiGAN" scheme="http://www.shelven.com/tags/HiFiGAN/"/>
    
  </entry>
  
  <entry>
    <title>深度学习——语音合成tts笔记（上）</title>
    <link href="http://www.shelven.com/2022/09/08/a.html"/>
    <id>http://www.shelven.com/2022/09/08/a.html</id>
    <published>2022-09-07T19:15:04.000Z</published>
    <updated>2022-12-03T16:20:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>两个月的暑假已经结束了，假期里自学了一点深度学习的内容，很多地方还是一知半解的，这里稍微记录一下。之前刷到一个很有意思的语音合成视频，抱着试试看的心态想自己做一个模型，于是给自己挖了一个大坑……涉及到深度学习的知识我还需要慢慢学，因此本篇博客重点还是记录下自己的踩坑操作<del>原理部分以后搞明白了再更新</del></p><span id="more"></span><p>总的来说，我通过拆包游戏客户端获得5.6万条语音文件，通过github上的一个声纹识别项目分离其中一个角色的语音文件。接着用百度的语音识别API将语音识别为文本后，人工校正一遍文本，然后转换为拼音+音标，以此制作语音数据训练集和测试集。基于开源项目Tacotron2训练角色语音模型，经历400 epoch后初步训练成型，最后基于HiFiGAN合成语音。整个后半段流程是在google colab上完成的，为了完成模型训练我申请了4个谷歌账号…不得不说<strong>白嫖的GPU真香~</strong></p><h2 id="1-制作数据集"><a href="#1-制作数据集" class="headerlink" title="1. 制作数据集"></a>1. 制作数据集</h2><div class="story post-story"><p>可以说整个项目大部分时间花费在整理数据集上，根据我自己的经验，数据集的语音长度在2秒-10秒之间效果最好，数量大约在2000条左右（为了涵盖尽可能多的汉字发音）。需要注意一点，不管拆包的原语音采样率如何，<strong>都要统一重采样到22050 hz</strong>，这是Tacotron2训练模型的要求。</p><h3 id="1-1-Extractor2-5-vgmstream-win拆包"><a href="#1-1-Extractor2-5-vgmstream-win拆包" class="headerlink" title="1.1 Extractor2.5 + vgmstream-win拆包"></a>1.1 Extractor2.5 + vgmstream-win拆包</h3><p>首先是这款国内游戏的拆包，所有角色的语音文件都在目录D:\Genshin Impact\Genshin Impact Game\YuanShen_Data\StreamingAssets\Audio\GeneratedSoundBanks\Windows\Chinese下，我们使用软件Extractor2.5进行音频文件拆包。</p><p>Extractor2.5是个非常好用的游戏解包工具，我们将所有pck源文件所在目录输进去（可以批量选中文件），确定输出目录，点击开始即可。</p><p><img src="https://www.shelven.com/tuchuang/20220908/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220908/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>运行结束之后可以看到这个游戏拆包有56958条语音文件…点击左下角反选，全部解压到自己的文件夹中。</p><p><img src="https://www.shelven.com/tuchuang/20220908/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220908/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>但是你会发现解压出来的wav文件无法打开，需要使用vgmstream进行解密和转码<a href="https://github.com/vgmstream/vgmstream/">（项目地址戳这里）</a>。</p><p>可以看到vgmstream-win文件夹只有一个可执行程序test.exe，其他都是dll库文件。</p><p><img src="https://www.shelven.com/tuchuang/20220908/3.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220908/3.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>这个test.exe是不能直接运行的，需要把程序拖到刚才拆包的语音文件上，但是几万条语音我们不可能一个个拖过去，因此我们<strong>在语音的文件夹下，</strong>写一个如下的批处理文件（命名为批处理.bat），运行批处理就可以了。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="keyword">for</span> /<span class="built_in">r</span> %%i <span class="keyword">in</span> (*.wav) <span class="keyword">do</span> (</span><br><span class="line">        <span class="string">&quot;D:\zhuomian\vgmstream-win\test.exe&quot;</span> <span class="string">&quot;%%~nxi&quot;</span>    <span class="comment">#路径改成你自己的，注意路径不能有中文</span></span><br><span class="line">)</span><br><span class="line">pause</span><br></pre></td></tr></table></figure><p>运行后生成的wav.wav文件就可以正常播放了，所有音频采样率均为48000Hz（采样率很重要，贯穿整个项目）。</p><p><img src="https://www.shelven.com/tuchuang/20220908/4.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220908/4.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="1-2-基于Tensorflow的声纹识别"><a href="#1-2-基于Tensorflow的声纹识别" class="headerlink" title="1.2 基于Tensorflow的声纹识别"></a>1.2 基于Tensorflow的声纹识别</h3><p>这部分内容来源于github（<a href="https://github.com/yeyupiaoling/VoiceprintRecognition-Tensorflow">项目地址戳这里</a>），作者基于tensorflow做了个声纹识别模型，通过把语音数据转换短时傅里叶变换的幅度谱，使用librosa计算音频的特征，以此来训练、评估模型。因为我只用到了对比部分，因此我下载了作者预训练的模型，以及对声纹对比文件<strong>infer_contrast.py</strong>做了修改。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> utils.reader <span class="keyword">import</span> load_audio</span><br><span class="line"><span class="keyword">from</span> utils.utility <span class="keyword">import</span> add_arguments, print_arguments</span><br><span class="line"><span class="keyword">import</span> os,shutil</span><br><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"></span><br><span class="line">os.environ[<span class="string">&#x27;TF_CPP_MIN_LOG_LEVEL&#x27;</span>]=<span class="string">&#x27;2&#x27;</span></span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser(description=__doc__)</span><br><span class="line">add_arg = functools.partial(add_arguments, argparser=parser)</span><br><span class="line">add_arg(<span class="string">&#x27;audio_path1&#x27;</span>,      <span class="built_in">str</span>,    <span class="string">&#x27;audio_db/Paimon.wav&#x27;</span>,          <span class="string">&#x27;标准的派蒙音频&#x27;</span>)   <span class="comment"># 自己准备的标准音频，下面两个也是</span></span><br><span class="line">add_arg(<span class="string">&#x27;audio_path2&#x27;</span>,      <span class="built_in">str</span>,    <span class="string">&#x27;audio_db/Klee.wav&#x27;</span>,          <span class="string">&#x27;标准的可莉音频&#x27;</span>)</span><br><span class="line">add_arg(<span class="string">&#x27;audio_path3&#x27;</span>,      <span class="built_in">str</span>,    <span class="string">&#x27;audio_db/Kokomi.wav&#x27;</span>,          <span class="string">&#x27;标准的心海音频&#x27;</span>)</span><br><span class="line">add_arg(<span class="string">&#x27;input_shape&#x27;</span>,      <span class="built_in">str</span>,    <span class="string">&#x27;(257, 257, 1)&#x27;</span>,          <span class="string">&#x27;数据输入的形状&#x27;</span>)</span><br><span class="line">add_arg(<span class="string">&#x27;threshold&#x27;</span>,        <span class="built_in">float</span>,   <span class="number">0.8</span>,                     <span class="string">&#x27;判断是否为同一个人的阈值&#x27;</span>)</span><br><span class="line">add_arg(<span class="string">&#x27;model_path&#x27;</span>,       <span class="built_in">str</span>,    <span class="string">&#x27;models1/infer_model.h5&#x27;</span>,  <span class="string">&#x27;预测模型的路径&#x27;</span>)    <span class="comment"># 作者的预训练模型</span></span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载模型</span></span><br><span class="line">model = tf.keras.models.load_model(args.model_path,<span class="built_in">compile</span>=<span class="literal">False</span>)</span><br><span class="line">model = tf.keras.models.Model(inputs=model.<span class="built_in">input</span>, outputs=model.get_layer(<span class="string">&#x27;batch_normalization&#x27;</span>).output)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据输入的形状</span></span><br><span class="line">input_shape = <span class="built_in">eval</span>(args.input_shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测音频</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">infer</span>(<span class="params">audio_path</span>):</span><br><span class="line">    data = load_audio(audio_path, mode=<span class="string">&#x27;test&#x27;</span>, spec_len=input_shape[<span class="number">1</span>])</span><br><span class="line">    data = data[np.newaxis, :]</span><br><span class="line">    feature = model.predict(data)</span><br><span class="line">    <span class="keyword">return</span> feature</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 预测的两个音频文件</span></span><br><span class="line">    feature1 = infer(args.audio_path1)[<span class="number">0</span>]</span><br><span class="line">    feature2 = infer(args.audio_path2)[<span class="number">0</span>]</span><br><span class="line">    feature3 = infer(args.audio_path3)[<span class="number">0</span>]</span><br><span class="line">    datapath = <span class="string">&quot;./test2&quot;</span>        <span class="comment">#上传到集群的解包音频文件位置</span></span><br><span class="line">    dirs = os.listdir(datapath)</span><br><span class="line">    <span class="keyword">for</span> audio <span class="keyword">in</span> dirs:</span><br><span class="line">        personx = <span class="string">&#x27;test2/%s&#x27;</span> % (audio)</span><br><span class="line">        featurex = infer(personx)[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 对角余弦值</span></span><br><span class="line">        dist1 = np.dot(feature1, featurex) / (np.linalg.norm(feature1) * np.linalg.norm(featurex))</span><br><span class="line">        <span class="keyword">if</span> dist1 &gt; args.threshold:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;%s 符合派蒙模型，相似度为：%f&quot;</span> % (personx, dist1))</span><br><span class="line">            shutil.move(<span class="string">&quot;./test2/%s&quot;</span> % (audio),<span class="string">&quot;./dataset/Paimon&quot;</span>)      <span class="comment"># 移动音频文件，路径自选</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dist2 = np.dot(feature2, featurex) / (np.linalg.norm(feature2) * np.linalg.norm(featurex))</span><br><span class="line">            <span class="keyword">if</span> dist2 &gt; args.threshold:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;%s 符合可莉模型，相似度为：%f&quot;</span> % (personx, dist2))</span><br><span class="line">                shutil.move(<span class="string">&quot;./test2/%s&quot;</span> % (audio),<span class="string">&quot;./dataset/Klee&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dist3 = np.dot(feature3, featurex) / (np.linalg.norm(feature3) * np.linalg.norm(featurex))</span><br><span class="line">                <span class="keyword">if</span> dist3 &gt; args.threshold:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;%s 符合心海模型，相似度为：%f&quot;</span> % (personx, dist3))</span><br><span class="line">                    shutil.move(<span class="string">&quot;./test2/%s&quot;</span> % (audio),<span class="string">&quot;./dataset/Kokomi&quot;</span>)</span><br><span class="line">        gc.collect()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>需要注意一点，为了提高识别的准确性，这个项目要求的语音长度不能低于1.7s，因此我用ffmpeg将所有长度低于2s的短音频全部过滤了（这里不赘述实现过程）。</p><p>之后将三个角色的标准语音分别放在audio_db文件夹下，识别的原理是通过预测函数提取三个角色的音频特征值，对5.6万条音频分别比对三个角色的标准音频特征，求对角余弦值，在多次试验后选择了对角余弦值0.8，作为判断两条语音是否为同一个人的阈值。</p><p>直接在集群上运行infer_contrast.py，相似度高于0.8的音频则会被挑选到对应的dataset文件夹中。</p><p><img src="https://www.shelven.com/tuchuang/20220908/5.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220908/5.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>实际上这个声纹识别的结果仅能作为参考，不能保证百分百正确，原因有很多：</p><ul><li><p>1.声优都是怪物，一个人用好多相似的声线配了不同角色，导致无法分辨出不同角色的语音（假阳性）。</p></li><li><p>2.一句话的语调不同会表现出音频特征值不同，而这个算法下会导致对角余弦值偏小，从而判断成发声的是不同的人（假阴性）。</p></li></ul><p>因此识别的结果需要进行人工校正，<strong>也就是需要自己听一遍到底是不是这个角色的语音</strong>&#x3D; &#x3D;（最好同下一步一起进行，省时间）</p><p>这里我验证并分离出2293条长度2秒以上的派蒙语音，以其中的1820条作为训练集，473条作为测试集。后续训练模型用到的时候会说。</p><h3 id="1-3-基于百度语音识别API的语音转文本"><a href="#1-3-基于百度语音识别API的语音转文本" class="headerlink" title="1.3 基于百度语音识别API的语音转文本"></a>1.3 基于百度语音识别API的语音转文本</h3><p>光有语音还不行，我们要训练模型就要有对应的<strong>文本</strong>。很多单机游戏（比如柚子社的游戏）有解包脚本，可以完整解出所有资源，其中就包括语音文件和对应的文本。但是解包有客户端的游戏不同，比如这款游戏发布不同版本的客户端，文件结构就会发生很大的改变，导致以前做的文件定位统统失效，而且包括文本在内的很多文件也是加密的，无法解出（也可能是我个人问题）。</p><p>因此，我们还是需要借助语音识别的软件将语音转成文本。这里涉及到另一个问题，不管多么强大的语音转文字技术，都是在已有的数据集基础上不断训练模型而产生的，游戏中有相当多新造的词（比如中二台词，游戏人名，地点等等），这在转化文本过程中是肯定无法百分百准确的，甚至会“空耳”产生歧义。</p><p>因此转文本这一步结束后需要人工校准，至少保证读音正确。</p><p>我是在<strong>百度AI开放平台</strong>申请了语音识别API，每个账号有200万次免费调用额度，但是限制并发数2<del>（没办法，既然是白嫖就忍忍）</del>。</p><p><img src="https://www.shelven.com/tuchuang/20220908/6.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220908/6.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>查看官方放在github上的demo，改一改就可以调用API了（每当问我不会使用的时候都是看demo然后魔改2333）。</p><p>我这里以官网提供的<strong>asr_raw.py</strong>为例，直接下载，并修改成如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">IS_PY3 = sys.version_info.major == <span class="number">3</span>        <span class="comment"># 判断你用的是python3.x还是2.x版本，推荐还是用3.x</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> IS_PY3:</span><br><span class="line">    <span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line">    <span class="keyword">from</span> urllib.request <span class="keyword">import</span> Request</span><br><span class="line">    <span class="keyword">from</span> urllib.error <span class="keyword">import</span> URLError</span><br><span class="line">    <span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlencode</span><br><span class="line">    timer = time.perf_counter</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">import</span> urllib2</span><br><span class="line">    <span class="keyword">from</span> urllib2 <span class="keyword">import</span> urlopen</span><br><span class="line">    <span class="keyword">from</span> urllib2 <span class="keyword">import</span> Request</span><br><span class="line">    <span class="keyword">from</span> urllib2 <span class="keyword">import</span> URLError</span><br><span class="line">    <span class="keyword">from</span> urllib <span class="keyword">import</span> urlencode</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> sys.platform == <span class="string">&quot;win32&quot;</span>:</span><br><span class="line">        timer = time.clock</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># On most other platforms the best timer is time.time()</span></span><br><span class="line">        timer = time.time</span><br><span class="line"></span><br><span class="line">API_KEY = <span class="string">&#x27;XXXXXXXX&#x27;</span>    <span class="comment"># 改成你自己的，下面一条一样</span></span><br><span class="line">SECRET_KEY = <span class="string">&#x27;XXXXXXXX&#x27;</span> </span><br><span class="line">FORMAT = <span class="string">&quot;wav&quot;</span>;  <span class="comment"># 文件后缀只支持 pcm/wav/amr 格式</span></span><br><span class="line">CUID = <span class="string">&#x27;123456PYTHON&#x27;</span>;</span><br><span class="line">RATE = <span class="number">16000</span>;  <span class="comment"># 固定值，这里一定一定要注意采样率</span></span><br><span class="line">DEV_PID = <span class="number">1537</span>;  <span class="comment"># 1537 表示识别普通话，使用输入法模型。根据文档填写PID，选择语言及识别模型</span></span><br><span class="line">ASR_URL = <span class="string">&#x27;http://vop.baidu.com/server_api&#x27;</span></span><br><span class="line">SCOPE = <span class="string">&#x27;audio_voice_assistant_get&#x27;</span>  <span class="comment"># 有此scope表示有asr能力，没有请在网页里勾选，非常旧的应用可能没有</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DemoError</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;  TOKEN start &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">TOKEN_URL = <span class="string">&#x27;http://aip.baidubce.com/oauth/2.0/token&#x27;</span></span><br><span class="line"><span class="comment"># 核对token</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fetch_token</span>():</span><br><span class="line">    params = &#123;<span class="string">&#x27;grant_type&#x27;</span>: <span class="string">&#x27;client_credentials&#x27;</span>,</span><br><span class="line">              <span class="string">&#x27;client_id&#x27;</span>: API_KEY,</span><br><span class="line">              <span class="string">&#x27;client_secret&#x27;</span>: SECRET_KEY&#125;</span><br><span class="line">    post_data = urlencode(params)</span><br><span class="line">    <span class="keyword">if</span> (IS_PY3):</span><br><span class="line">        post_data = post_data.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    req = Request(TOKEN_URL, post_data)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        f = urlopen(req)</span><br><span class="line">        result_str = f.read()</span><br><span class="line">    <span class="keyword">except</span> URLError <span class="keyword">as</span> err:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;token http response http code : &#x27;</span> + <span class="built_in">str</span>(err.code))</span><br><span class="line">        result_str = err.read()</span><br><span class="line">    <span class="keyword">if</span> (IS_PY3):</span><br><span class="line">        result_str = result_str.decode()</span><br><span class="line"></span><br><span class="line">    result = json.loads(result_str)</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&#x27;access_token&#x27;</span> <span class="keyword">in</span> result.keys() <span class="keyword">and</span> <span class="string">&#x27;scope&#x27;</span> <span class="keyword">in</span> result.keys()):</span><br><span class="line">        <span class="keyword">if</span> SCOPE <span class="keyword">and</span> (<span class="keyword">not</span> SCOPE <span class="keyword">in</span> result[<span class="string">&#x27;scope&#x27;</span>].split(<span class="string">&#x27; &#x27;</span>)):  <span class="comment"># SCOPE = False 忽略检查</span></span><br><span class="line">            <span class="keyword">raise</span> DemoError(<span class="string">&#x27;scope is not correct&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> result[<span class="string">&#x27;access_token&#x27;</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> DemoError(<span class="string">&#x27;MAYBE API_KEY or SECRET_KEY not correct: access_token or scope not found in token response&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;  TOKEN end &quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    token = fetch_token()</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    httpHandler = urllib2.HTTPHandler(debuglevel=1)</span></span><br><span class="line"><span class="string">    opener = urllib2.build_opener(httpHandler)</span></span><br><span class="line"><span class="string">    urllib2.install_opener(opener)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> audio <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">1825</span>):</span><br><span class="line">        AUDIO_FILE = <span class="built_in">str</span>(<span class="string">&#x27;/public/home/wlxie/test4voice/baiduyun/training_16K/train&#x27;</span> + <span class="built_in">str</span>(audio) + <span class="string">&#x27;.wav&#x27;</span>)     <span class="comment">#路径改成自己的</span></span><br><span class="line">        speech_data = []</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(AUDIO_FILE, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> speech_file:</span><br><span class="line">            speech_data = speech_file.read()</span><br><span class="line">        length = <span class="built_in">len</span>(speech_data)</span><br><span class="line">        <span class="keyword">if</span> length == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> DemoError(<span class="string">&#x27;file %s length read 0 bytes&#x27;</span> % AUDIO_FILE)</span><br><span class="line"></span><br><span class="line">        params = &#123;<span class="string">&#x27;cuid&#x27;</span>: CUID, <span class="string">&#x27;token&#x27;</span>: token, <span class="string">&#x27;dev_pid&#x27;</span>: DEV_PID&#125;</span><br><span class="line">        params_query = urlencode(params);</span><br><span class="line"></span><br><span class="line">        headers = &#123;</span><br><span class="line">            <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;audio/&#x27;</span> + FORMAT + <span class="string">&#x27;; rate=&#x27;</span> + <span class="built_in">str</span>(RATE),</span><br><span class="line">            <span class="string">&#x27;Content-Length&#x27;</span>: length</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        url = ASR_URL + <span class="string">&quot;?&quot;</span> + params_query</span><br><span class="line">        req = Request(ASR_URL + <span class="string">&quot;?&quot;</span> + params_query, speech_data, headers)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            begin = timer()</span><br><span class="line">            f = urlopen(req)</span><br><span class="line">            result_str = f.read()</span><br><span class="line">        <span class="keyword">except</span>  URLError <span class="keyword">as</span> err:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;asr http response http code : &#x27;</span> + <span class="built_in">str</span>(err.code))</span><br><span class="line">            result_str = err.read()</span><br><span class="line">    <span class="comment">#输出转文字结果</span></span><br><span class="line">        result_str = result_str.decode()</span><br><span class="line">        result = json.loads(result_str)</span><br><span class="line">        res = result[<span class="string">&#x27;result&#x27;</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;train&#x27;</span> +<span class="built_in">str</span>(audio) + <span class="string">&#x27;.wav&#x27;</span> + <span class="string">&#x27;识别结果：&#x27;</span> + res)</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;training_1800_result.txt&quot;</span>, <span class="string">&quot;a&quot;</span>) <span class="keyword">as</span> of:</span><br><span class="line">            of.write(<span class="string">&#x27;train&#x27;</span> + <span class="built_in">str</span>(audio) + <span class="string">&#x27;.wav&#x27;</span> + <span class="string">&quot;|&quot;</span> + res + <span class="string">&#x27;\n&#x27;</span>)  <span class="comment"># 转成“路径|文本”的格式，方便人工校准</span></span><br><span class="line">    gc.collect()</span><br></pre></td></tr></table></figure><p>这里也有一个<strong>大坑</strong>，这个语音转文本API要求音源采样率必须是16000Hz，前面说到我们解包得到的音频是48000Hz，而且后面训练模型要求采样率为22050Hz！也就是说如果我们现在把所有音频转成16000Hz的话，势必会对训练模型产生影响（高频可以转低频，但是低频转高频语音质量不会有一丁点儿的提升），因此我这边用拆包音频做了两个备份，一个是转成16000Hz，放在training_16K文件下，专门用于语音转文本；一个是转成22050Hz，放在training_22K文件下，专门用于后续训练模型。重采样仍然用我们的老朋友<strong>ffmpeg</strong>，因为就一行命令的事这里也不赘述了。</p><p>前面也说到这个API并发数限制为2，经常是用着用着就断开了（也是我比较笨比，不会写限制并发数发送请求的代码），所以我将训练集的1825个语音写了个小脚本，重命名为train1.wav-train1825.wav，所以才用了for循环一句一句调用API转文本，到哪个地方断了也可以迅速找出来并继续。</p><p>总之效果如下，训练集1825条语音和测试集473条语音全部转换为文本，且能清晰地看到一一对应关系：</p><p><img src="https://www.shelven.com/tuchuang/20220908/7.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220908/7.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>一眼看效果还不错，为了保证准确率，将txt文件传回本地，<strong>人工校正吧</strong>（语气词部分本来是要去除的，但是工作量会比较大放弃了，起码要保证发音没问题）。</p><p>这个数据集因为不是标准的普通话数据集（标准数据集可以找标贝，就有那种纯合成的标准普通话），声优也有特殊的口癖和发音，额，这是无法避免的。</p><h3 id="1-4-基于pypinyin的汉字转拼音"><a href="#1-4-基于pypinyin的汉字转拼音" class="headerlink" title="1.4 基于pypinyin的汉字转拼音"></a>1.4 基于pypinyin的汉字转拼音</h3><p>因为后面训练模型的Tacotron2是基于英文模型开发出来的，我们无法直接用中文文本训练。一个行之有效的方法是将中文转换成拼音+数字声调的方式，这样数据就可以顺利地被载入。</p><p>这里推荐一下pypinyin模块，该模块安装比较方便（直接用pip），也是个非常实用和高质量的汉字拼音转换工具！</p><p>我将人工校准后的txt文件传回集群，去掉前面的“|”之前的内容，再写个小脚本<strong>将所有标点符号删除</strong>，接着汉字转拼音，这里就记录下pypinyin的用法吧。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pypinyin <span class="keyword">import</span> lazy_pinyin, Style</span><br><span class="line"><span class="keyword">import</span> linecache</span><br><span class="line"></span><br><span class="line">output_file = <span class="built_in">open</span>(<span class="string">&quot;/public/home/wlxie/test4voice/baiduyun/training_pinyin.txt&quot;</span>,<span class="string">&quot;w&quot;</span>)</span><br><span class="line">readlist = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">1821</span>))  <span class="comment"># 人工校准的时候去掉了4条不是该角色的音频</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> readlist:</span><br><span class="line">    text = linecache.getline(<span class="string">&quot;/public/home/wlxie/test4voice/baiduyun/cheat_training.txt&quot;</span>,i)        </span><br><span class="line">    text = <span class="string">&quot; &quot;</span>.join(lazy_pinyin(text, style=Style.TONE3))</span><br><span class="line">    output_file.write(text)</span><br></pre></td></tr></table></figure><p>然后将拼音前按照Tacotron2训练的要求，加上了音频文件对应的colab路径（为什么用这个路径我下一篇博客再说明），以及每句话末尾加个英文的句号，最后输出结果如下：</p><p><img src="https://www.shelven.com/tuchuang/20220908/8.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220908/8.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>同样的方法对测试集也转拼音，这样前期的数据集文件就制作完成啦！接下来就是重点——训练模型。下篇博客接着说完。</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;两个月的暑假已经结束了，假期里自学了一点深度学习的内容，很多地方还是一知半解的，这里稍微记录一下。之前刷到一个很有意思的语音合成视频，抱着试试看的心态想自己做一个模型，于是给自己挖了一个大坑……涉及到深度学习的知识我还需要慢慢学，因此本篇博客重点还是记录下自己的踩坑操作&lt;del&gt;原理部分以后搞明白了再更新&lt;/del&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="深度学习" scheme="http://www.shelven.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="拆包" scheme="http://www.shelven.com/tags/%E6%8B%86%E5%8C%85/"/>
    
    <category term="声纹识别" scheme="http://www.shelven.com/tags/%E5%A3%B0%E7%BA%B9%E8%AF%86%E5%88%AB/"/>
    
    <category term="语音转文本" scheme="http://www.shelven.com/tags/%E8%AF%AD%E9%9F%B3%E8%BD%AC%E6%96%87%E6%9C%AC/"/>
    
  </entry>
  
</feed>
