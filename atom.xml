<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>我的小破站</title>
  
  
  <link href="http://www.shelven.com/atom.xml" rel="self"/>
  
  <link href="http://www.shelven.com/"/>
  <updated>2022-11-26T16:06:09.422Z</updated>
  <id>http://www.shelven.com/</id>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python自学笔记（4）——面向对象编程（下）</title>
    <link href="http://www.shelven.com/2022/11/26/a.html"/>
    <id>http://www.shelven.com/2022/11/26/a.html</id>
    <published>2022-11-26T15:59:03.000Z</published>
    <updated>2022-11-26T16:06:09.422Z</updated>
    
    <content type="html"><![CDATA[<p>前面说到python中一切皆为对象，面向对象是python的核心，也通过代码方式了解了什么是类和对象、属性和方法以及具体的分类。这篇笔记主要记录下前面没讲完的面向对象编程具体的三个特征。</p><h2 id="面向对象编程的特征"><a href="#面向对象编程的特征" class="headerlink" title="面向对象编程的特征"></a>面向对象编程的特征</h2><div class="story post-story"><p>python是面向对象的语言，支持面向对象的三大特征：<strong>封装（隐藏），继承和多态</strong>。</p><h3 id="1-封装（隐藏）"><a href="#1-封装（隐藏）" class="headerlink" title="1. 封装（隐藏）"></a>1. 封装（隐藏）</h3><h4 id="1-1-封装概念"><a href="#1-1-封装概念" class="headerlink" title="1.1 封装概念"></a>1.1 封装概念</h4><p>隐藏对象的属性和实现细节，只对外提供必要的方法。相当于将“细节封装起来”，只对外暴露“相关调用方法”。</p><p>通过私有属性、私有方法（都是在属性或者方法前加上__来实现私有化，类外部不能直接访问）的方式，实现封装(Encapsulation)。封装的概念类似权限控制，有些属性或方法只想于类别内部使用，而不想公开于外部，除了减少代码因来源端不适当的使用发生问题外，也可保护其中重要的商业逻辑。</p><p>当然，前面说过python没有严格意义上的访问控制限制，更多还是靠编程人员的自觉&#x3D; &#x3D;</p><h3 id="2-继承"><a href="#2-继承" class="headerlink" title="2 继承"></a>2 继承</h3><h4 id="2-1-继承概念"><a href="#2-1-继承概念" class="headerlink" title="2.1 继承概念"></a>2.1 继承概念</h4><p>继承是创建新类的方式，是实现代码复用的重要手段（比如一个新类继承自设计好的类，就直接具备已有类的特征，减少代码重复编写）。对于<strong>已有的类</strong>，我们称为<strong>父类或基类</strong>，而要<strong>创建的新类</strong>，我们称为<strong>子类或派生类</strong>。python支持多继承，也就是<strong>新建的类可以有一个或者多个父类</strong>。</p><p>python3中默认继承<strong>object</strong>类，object是根类，是所有类的父亲。编写过程中object可以省略。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个父类(object可省)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, color</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.color = color</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s在进食&#x27;</span> % self.<span class="built_in">type</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个子类，括号中为父类的名字</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pig</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setName</span>(<span class="params">self, newname</span>):</span><br><span class="line">        self.name = newname</span><br><span class="line">        <span class="keyword">return</span> self.<span class="built_in">type</span></span><br><span class="line"></span><br><span class="line">Peggy = Pig(<span class="string">&#x27;猪&#x27;</span>, <span class="string">&#x27;粉色&#x27;</span>)   <span class="comment"># 实例化对象</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Peggy是%s,颜色是%s&#x27;</span> % (Peggy.name, Peggy.color))     <span class="comment"># 查看对象属性</span></span><br><span class="line">Peggy.eat()     <span class="comment"># 调用父类方法</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;现在Peggy的名字叫做%s&#x27;</span> % Peggy.setName(<span class="string">&#x27;George&#x27;</span>))    <span class="comment"># 调用子类方法</span></span><br><span class="line"><span class="built_in">print</span>(Pig.__mro__)      <span class="comment"># 查看类的继承层次结构，可以用类属性__mro__或者类方法mro()</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">Peggy是猪,颜色是粉色</span></span><br><span class="line"><span class="string">猪在进食</span></span><br><span class="line"><span class="string">现在Peggy的名字叫做George</span></span><br><span class="line"><span class="string">(&lt;class &#x27;__main__.Pig&#x27;&gt;, &lt;class &#x27;__main__.Animal&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>从上面的例子可以看到，子类Pig从父类Animal中继承了__init__()方法，从子类中实例化对象Peggy是可以调用父类的方法的。</p><p>需要注意：</p><blockquote><p><strong>私有的属性和方法（前面带有__）不能被子类继承，也不能被访问！</strong></p></blockquote><h4 id="2-2-多继承"><a href="#2-2-多继承" class="headerlink" title="2.2 多继承"></a>2.2 多继承</h4><p>顾名思义一个子类继承自多个直接父类，这样也就有了多个父类的特点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个父类马</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Horse</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">output</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;骡子的一半基因来自马&#x27;</span>)</span><br><span class="line"><span class="comment"># 定义一个父类驴</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Donkey</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">output</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;骡子的一半基因来自驴&#x27;</span>)</span><br><span class="line"><span class="comment"># 定义一个子类骡子，继承自马和驴</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mule</span>(Horse, Donkey):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">a = Mule()  <span class="comment"># 实例化一个对象骡子</span></span><br><span class="line">a.output()  <span class="comment"># 调用同名父类方法</span></span><br><span class="line"><span class="built_in">print</span>(Mule.__mro__)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">骡子的一半基因来自马</span></span><br><span class="line"><span class="string">(&lt;class &#x27;__main__.Mule&#x27;&gt;, &lt;class &#x27;__main__.Horse&#x27;&gt;, &lt;class &#x27;__main__.Donkey&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>上面的例子可以看到，子类骡子(Mule)继承自父类马(Horse)和驴(Donkey)，这样可以拥有两个父类各自的特征。但是，如果父类中如果有同名的方法(这里的output(self))，那么子类只会<strong>从左到右</strong>的顺序，调用<strong>先继承的父类</strong>(Horse)中的方法。</p><p>同样可以通过类属性__mro__来查看继承结构，显示结果也是从左到右的顺序，从子类开始一层层往上到父类，这就是继承的顺序。</p><p>一般情况下不建议用多继承<del>（一个人不可能有两个爹）</del>，代码可读性会变差。</p><h4 id="2-3-重写父类方法"><a href="#2-3-重写父类方法" class="headerlink" title="2.3 重写父类方法"></a>2.3 重写父类方法</h4><p>重写的意思是，当子类中有一个和父类相同的名字的方法，子类中的方法会重新定义覆盖掉父类中的方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;是个动物都会进食&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pig</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;只有猪才会吃了睡睡了吃&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Peggy = Pig()</span><br><span class="line">Peggy.eat()     <span class="comment"># 调用父类同名方法，子类的方法会覆盖</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">只有猪才会吃了睡睡了吃</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>如果想要在子类方法中调用父类的同名方法，最简单的实现方式是在<strong>子类方法中进行类调用</strong>，但是父类名如果修改过，在多继承时子类的方法也要重复改很多次，python为了解决这个问题引入了super()函数，需要注意super()代表父类的定义，而不是父类对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;是个动物都会进食&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pig</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().eat()       <span class="comment"># super()代表父类名，即使父类名改变这里也不需要改</span></span><br><span class="line"></span><br><span class="line">Peggy = Pig()</span><br><span class="line">Peggy.eat()</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">是个动物都会进食</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>一般而言，<strong>super在继承中经常用来继承父类的初始化方法</strong>，例如<code> super().__init__()</code></p><h3 id="3-多态"><a href="#3-多态" class="headerlink" title="3 多态"></a>3 多态</h3><h4 id="3-1-多态概念"><a href="#3-1-多态概念" class="headerlink" title="3.1 多态概念"></a>3.1 多态概念</h4><p>多态指不同对象对同一个方法调用，可能会产生不同的行为。举个栗子，对于同样一个吃饭的方法，不同对象比如中国人用筷子吃饭，印度三哥用手抓饭，欧美人用刀叉吃饭。</p><p>需要注意以下几点：</p><blockquote><ol><li>多态是方法的多态，属性没有多态</li><li>多态存在的必要条件：继承和方法重写</li></ol></blockquote><h4 id="3-2-代码演示多态和“鸭子类型”"><a href="#3-2-代码演示多态和“鸭子类型”" class="headerlink" title="3.2 代码演示多态和“鸭子类型”"></a>3.2 代码演示多态和“鸭子类型”</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Chinese</span>(<span class="title class_ inherited__">People</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;中国人用筷子吃饭&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Indian</span>(<span class="title class_ inherited__">People</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;印度人用手抓饭&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">American</span>(<span class="title class_ inherited__">People</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;欧美人用刀叉吃饭&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分别实例化，并定义一个统一的接口来使用</span></span><br><span class="line">XiaoMing = Chinese()</span><br><span class="line">ASan = Indian()</span><br><span class="line">George = American()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Eatting</span>(<span class="params">self</span>):</span><br><span class="line">    self.eat()</span><br><span class="line">Eatting(XiaoMing)   <span class="comment"># 相当于调用了XiaoMing.eat，以下同理</span></span><br><span class="line">Eatting(ASan)</span><br><span class="line">Eatting(George)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*******************************************&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># “鸭子类型”</span></span><br><span class="line"><span class="comment"># 定义三个不同的类（实际上也都继承自根类object）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Chinese</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;中国人用筷子吃饭&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Indian</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;印度人用手抓饭&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">American</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;欧美人用刀叉吃饭&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">People_list = [Chinese, Indian, American]   <span class="comment"># 封装好的类作为People_list的元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> person <span class="keyword">in</span> People_list:</span><br><span class="line">    person().eat()      <span class="comment"># person()是实例化对象的过程，分别调用不同类的同名方法</span></span><br><span class="line">    </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">中国人用筷子吃饭</span></span><br><span class="line"><span class="string">印度人用手抓饭</span></span><br><span class="line"><span class="string">欧美人用刀叉吃饭</span></span><br><span class="line"><span class="string">*******************************************</span></span><br><span class="line"><span class="string">中国人用筷子吃饭</span></span><br><span class="line"><span class="string">印度人用手抓饭</span></span><br><span class="line"><span class="string">欧美人用刀叉吃饭</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>不同对象调用同名方法，产生不同结果，这就体现了多态性，好处在于增强了程序的灵活性和可扩展性。</p><p>Python崇尚的“鸭子类型”就是动态类型的风格：“当看到一直鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以称为鸭子。”这种动态风格中，<strong>一个对象的有效语义，不是由继承自特定的类或实现特定的接口，而是由当前方法和属性的集合决定</strong>，也就是说，我们并不关心对象是什么类型，而是关心对象是怎么使用的。</p><p>总而言之，这种动态类型使得编程非常灵活，可以避免一些重写和继承，省去复制大量重复代码的操作。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前面说到python中一切皆为对象，面向对象是python的核心，也通过代码方式了解了什么是类和对象、属性和方法以及具体的分类。这篇笔记主要记录下前面没讲完的面向对象编程具体的三个特征。&lt;/p&gt;
&lt;h2 id=&quot;面向对象编程的特征&quot;&gt;&lt;a href=&quot;#面向对象编程的特征&quot;</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="编程自学" scheme="http://www.shelven.com/categories/%E7%BC%96%E7%A8%8B%E8%87%AA%E5%AD%A6/"/>
    
    
    <category term="python" scheme="http://www.shelven.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python自学笔记（3）——面向对象编程（上）</title>
    <link href="http://www.shelven.com/2022/11/25/a.html"/>
    <id>http://www.shelven.com/2022/11/25/a.html</id>
    <published>2022-11-25T15:31:53.000Z</published>
    <updated>2022-11-26T05:27:39.989Z</updated>
    
    <content type="html"><![CDATA[<p>面向对象是Python的核心概念，一开始在这些概念问题上一直绕不清，这里做个简单记录。</p><h2 id="1-面向对象编程"><a href="#1-面向对象编程" class="headerlink" title="1. 面向对象编程"></a>1. 面向对象编程</h2><div class="story post-story"><p>使用计算机语言编写代码时，有两种思路分别是面向过程编程和面向对象编程</p><blockquote><ol><li>面向过程：根据业务逻辑从上到下，直接分析解决问题的步骤，调用函数实现。强调怎么去做</li><li>面向对象：将问题分解成若干“对象”，建立对象是为了描述某个事物在解决问题过程中的行为。强调谁去做</li></ol></blockquote><p><strong>面向过程注重步骤和过程</strong>，所有步骤<strong>从到到尾逐步实现</strong>，将功能独立的代码<strong>封装成函数</strong>，最后完成代码就是<strong>按照顺序地调用不同函数</strong>。</p><p><strong>面向对象注重对象和职责</strong>，确认<strong>职责</strong>，根据职责确定不同对象，<strong>对象内部封装不同的方法</strong>，最后完成代码是按照顺序让<strong>不同对象调用不同方法</strong>。</p><p>python是面向对象编程思想的一门语言，包括做机器学习或者深度学习用的PyTorch、TensorFlow都是面向对象的思想，里面封装了非常多的方法，我们甚至可以不知道方法具体实现的过程和原理，直接调用函数就可以（初学的我就是一开始依葫芦画瓢，程序能跑通但是不能解释实现的原理），对于小白的入门学习确实提供了极大便利<del>（然后一出问题就开始恶补基础了）</del>。</p></div><h2 id="2-概念性名词"><a href="#2-概念性名词" class="headerlink" title="2. 概念性名词"></a>2. 概念性名词</h2><div class="story post-story"><p>先要了解概念性的专业名词，再通过代码的方式加深自己的理解。</p><p>面向对象有三个特性，封装性、继承性和多态性（下一篇博客再细说）。</p><blockquote><ol><li>封装性：把属性和方法放在一个类里面，可以通过访问类的权限属性区分开，不想释放的功能搞成私有机制</li><li>继承性：把实现好的代码和方法通过继承的方法拿过来用，节省代码量</li><li>多态性：同一个方法用不同的方式去实现，体现的多态性</li></ol></blockquote><p>先解释一下上面提到的几个专有名词：</p><blockquote><p>对象(object)：python中一切皆对象，对应现实生活中，任何事物都可以称为对象，有自己独特的特征。对象是通过类创建出的真实的个体（对象是类的实例化），对象由属性和方法组成。</p><p>类(class)：具有同种属性的对象，现实世界中具有共同特征的事物为一类，比如人类，植物类等，描述的是所有对象的共有特征。拥有相似属性和行为的对象都可以抽象出一个类。</p><p>属性(attribute)：属于对象静态的一面，描述对象的一些静态特征，比如小明的身高、体重、年龄等。</p><p>方法(method)：属于对象动态的一面，描述对象的动态特征，比如小明会说话，会码代码等。</p><p>实例化：对象由一个别名叫“实例”，通过类创建对象的过程为“实例化”。</p><p>抽象：由相同特征的对象抽取共同特征的过程为“抽象”。</p></blockquote></div><h2 id="3-代码方式理解类和对象"><a href="#3-代码方式理解类和对象" class="headerlink" title="3. 代码方式理解类和对象"></a>3. 代码方式理解类和对象</h2><div class="story post-story"><p>开头的class来创建一个新的类，class之后为类的名称（通常首字母大写）并以冒号结尾。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>:</span><br><span class="line">    <span class="comment"># 定义方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getPeopleInfo</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;名字:%s, 年龄:%d&#x27;</span> %(self.name, self.age))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化一个对象        </span></span><br><span class="line">Phantom = People()</span><br><span class="line">Phantom.name = <span class="string">&#x27;Phantom&#x27;</span>    <span class="comment"># 使用 . 的方法添加类属性</span></span><br><span class="line">Phantom.age = <span class="number">26</span></span><br><span class="line">Phantom.getPeopleInfo()     <span class="comment"># 使用 .函数名() 的方法调用类中创建的函数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Phantom.age)      <span class="comment"># 打印实例Phantom的年龄属性</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">名字:Phantom, 年龄:26</span></span><br><span class="line"><span class="string">26</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>在创建的类中定义方法，而类中的方法和普通的函数有一个区别——必须有一个额外的第一个参数名称, 按照惯例是 self。self指的是实例的本身，指向当前创建对象的内存地址。某个对象调用其方法时，python解释器会把这个对象作为第一个参数传递给self，所以我们只需要传递后面的参数。</p><p><strong>python是没有方法的重载的</strong>，如果定义了多个重名的方法，只会生效最后一个！</p><p>在上面的例子里我给Phantom添加了两个对象属性：name和age，但是如果再实例化一个其他对象，能否在创建时就给予属性而不用重新添加呢？答案是肯定的，这个时候我们可以用__init__()函数来定义属性的默认值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>:</span><br><span class="line">    <span class="comment"># 初始化函数，使对象的属性具有默认值</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, sex = <span class="string">&#x27;male&#x27;</span>, age = <span class="number">26</span></span>):</span><br><span class="line">        self.sex = sex</span><br><span class="line">        self.age = age</span><br><span class="line">    <span class="comment"># 定义类方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getPeopleInfo</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;性别:%s, 年龄:%d&#x27;</span> %(self.sex, self.age))</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 创建对象Phantom，不传参，属性使用默认值</span></span><br><span class="line">Phantom = People()</span><br><span class="line"><span class="built_in">print</span>(Phantom.sex, Phantom.age)</span><br><span class="line">Phantom.getPeopleInfo()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建第二个对象Aria，传参，新的参数代替默认值</span></span><br><span class="line">Aria = People(<span class="string">&#x27;Female&#x27;</span>, <span class="number">24</span>)</span><br><span class="line"><span class="built_in">print</span>(Aria.sex, Aria.age)</span><br><span class="line">Aria.getPeopleInfo()</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">male 26</span></span><br><span class="line"><span class="string">性别:male, 年龄:26</span></span><br><span class="line"><span class="string">Female 24</span></span><br><span class="line"><span class="string">性别:Female, 年龄:24</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>可以看到上面创建对象Phantom后，我没有传入参数，python解释器立刻调用了__init__()函数给与了两个属性sex和age，这个时候再调用类内的方法getPeopleInfo()，就会将属性的默认值作为实参传入。</p><p>__init__(self)中只有一个默认参数self，<strong>如果创建对象传入了两个实参，那么除了self以外还需要两个形参</strong>，比如__init__(self, sex, age)这个和自定义创建的类方法不一样，一定要做区分，后面会说到。这里的self是不需要我们传递的，python解释器会自动把当前对象的引用传递进去。</p></div><h2 id="4-代码方式理解属性和方法"><a href="#4-代码方式理解属性和方法" class="headerlink" title="4. 代码方式理解属性和方法"></a>4. 代码方式理解属性和方法</h2><div class="story post-story"><h3 id="4-1-类属性"><a href="#4-1-类属性" class="headerlink" title="4.1 类属性"></a>4.1 类属性</h3><p>类拥有的属性分为公有属性（public）和私有属性（private），python对于类的属性没有严格的访问控制限制，这与其他面向对象语言有所区别。</p><blockquote><ol><li><p>_xxx  保护属性，python编辑器不会做任何处理，是给程序员看的，不希望被外部访问</p></li><li><p>xxx  自己定义的公有属性</p></li><li><p>__xxx  类中的私有属性，<strong>不能从外部直接访问</strong>，但是可以通过 <strong>实例._类名__私有属性</strong> 的方式访问</p><p>再次强调，python不存在严格意义上的私有属性。</p></li></ol></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建类，object是对象，可以省略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    name = <span class="string">&#x27;Phantom&#x27;</span>    <span class="comment"># 公有的类属性</span></span><br><span class="line">    __age = <span class="number">26</span>      <span class="comment"># 私有的类属性</span></span><br><span class="line">    _sex = <span class="string">&#x27;male&#x27;</span>       <span class="comment"># 保护的类属性</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span>        <span class="comment"># 空语句，占位用，不会执行任何操作</span></span><br><span class="line">p = People()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(p.name)           <span class="comment"># 通过实例对象访问公有类属性</span></span><br><span class="line"><span class="built_in">print</span>(p._People__age)       <span class="comment"># 通过实例访问私有类属性</span></span><br><span class="line"><span class="built_in">print</span>(p._sex)       <span class="comment"># 访问保护的类属性（可以访问但是不推荐）</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">Phantom</span></span><br><span class="line"><span class="string">26</span></span><br><span class="line"><span class="string">male</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="4-2-实例属性"><a href="#4-2-实例属性" class="headerlink" title="4.2 实例属性"></a>4.2 实例属性</h3><p>实例属性是从属于实例对象的属性。</p><blockquote><ol><li>实例属性可以在__init__()方法中通过 <strong>self.实例属性名 &#x3D; 初始值</strong> 的方式进行定义</li><li>实例属性可以修改、新增和删除，不会影响到类属性</li></ol></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    name = <span class="string">&#x27;Phantom&#x27;</span></span><br><span class="line"></span><br><span class="line">p = People()</span><br><span class="line"><span class="built_in">print</span>(p.name, People.name)      <span class="comment"># 通过实例查看实例属性，通过类对象查看类属性</span></span><br><span class="line">p.name = <span class="string">&#x27;Aria&#x27;</span>     <span class="comment"># 修改实例属性</span></span><br><span class="line"><span class="built_in">print</span>(p.name, People.name)</span><br><span class="line">People.name = <span class="string">&#x27;Aria&#x27;</span>    <span class="comment"># 修改类属性</span></span><br><span class="line"><span class="built_in">print</span>(p.name, People.name)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Phantom Phantom</span></span><br><span class="line"><span class="string">Aria Phantom</span></span><br><span class="line"><span class="string">Aria Aria</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>可以看到通过一个实例对象去引用修改，只是修改了实例属性而不会影响到类属性。</p><h3 id="4-3-特殊属性"><a href="#4-3-特殊属性" class="headerlink" title="4.3 特殊属性"></a>4.3 特殊属性</h3><p>Python 对象中包含了很多双下划线开始和结束的属性，这些是特殊属性，有特殊的用法。</p><table><thead><tr><th>特殊方法</th><th>含义</th></tr></thead><tbody><tr><td>obj.__dict__</td><td>对象的属性字典</td></tr><tr><td>obj.__class__</td><td>对象所属的类</td></tr><tr><td>class.__bases__</td><td>类的基类元组(多继承)</td></tr><tr><td>class.__base__</td><td>类的基类</td></tr><tr><td>class.__mro__</td><td>类层次结构</td></tr><tr><td>class.__subclasses__</td><td>子类列表</td></tr></tbody></table><p>实际操作运行几个简单的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>:</span><br><span class="line">    name = <span class="string">&#x27;Phantom&#x27;</span>    <span class="comment"># 类属性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, sex, age</span>):       <span class="comment"># 实例属性</span></span><br><span class="line">        self.sex = sex</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">p = People(<span class="string">&#x27;male&#x27;</span>, <span class="number">26</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># dict 生成类属性信息的字典和实例对象属性信息的字典</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;People类属性为：&#x27;</span> + <span class="built_in">str</span>(People.__dict__))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;实例对象p属性为：&#x27;</span> + <span class="built_in">str</span>(p.__dict__))</span><br><span class="line"></span><br><span class="line"><span class="comment"># class 对实例对象查询所属类信息</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;实例对象p所属类信息：&#x27;</span> + <span class="built_in">str</span>(p.__class__))</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">People类属性为：&#123;&#x27;__module__&#x27;: &#x27;__main__&#x27;, &#x27;name&#x27;: &#x27;Phantom&#x27;, &#x27;__init__&#x27;: &lt;function People.__init__ at 0x000001A7D212AB00&gt;, &#x27;__dict__&#x27;: &lt;attribute &#x27;__dict__&#x27; of &#x27;People&#x27; objects&gt;, &#x27;__weakref__&#x27;: &lt;attribute &#x27;__weakref__&#x27; of &#x27;People&#x27; objects&gt;, &#x27;__doc__&#x27;: None&#125;</span></span><br><span class="line"><span class="string">实例对象p属性为：&#123;&#x27;sex&#x27;: &#x27;male&#x27;, &#x27;age&#x27;: 26&#125;</span></span><br><span class="line"><span class="string">实例对象p所属类信息：&lt;class &#x27;__main__.People&#x27;&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="4-4-实例方法和类方法"><a href="#4-4-实例方法和类方法" class="headerlink" title="4.4 实例方法和类方法"></a>4.4 实例方法和类方法</h3><p>在类中以def开头定义的方法都是实例方法，实例方法的特点是必须有一个以上的参数（<strong>self</strong>），用于指定这个方法的实例对象。</p><p>类方法也是最少需要一个参数（<strong>cls</strong>），是类对象有的方法，<strong>需要使用装饰器@classmethod来标识其为类方法</strong>，关于装饰器的概念我后面再写一篇博客，这里简单按照字面意思理解一下。类方法可以通过实例对象或者类对象去访问，有一个用途就是通过实例调用类方法实现对类属性的修改。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>():</span><br><span class="line">    name = <span class="string">&#x27;Phantm&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getName</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="keyword">return</span> cls.name</span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setName</span>(<span class="params">cls, name</span>):</span><br><span class="line">        cls.name = name</span><br><span class="line"></span><br><span class="line">p = People()</span><br><span class="line"><span class="built_in">print</span>(p.getName(), People.getName())        <span class="comment"># 通过实例和类对象调用类方法，先查看一下类属性</span></span><br><span class="line">p.setName(<span class="string">&#x27;Aria&#x27;</span>)       <span class="comment"># 通过实例调用类方法改变类属性</span></span><br><span class="line"><span class="built_in">print</span>(p.getName(), People.getName())</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">Phantm Phantm</span></span><br><span class="line"><span class="string">Aria Aria</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="4-5-静态方法"><a href="#4-5-静态方法" class="headerlink" title="4.5 静态方法"></a>4.5 静态方法</h3><p>python是动态的语言，我们可以动态地为类添加新的方法，或者动态地修改已有的方法。静态方法可以理解为不变的方法，不依赖于实例对象也不依赖于类对象，因此无论是实例对象还是类对象都可以调用。如果有一个功能实现的方法比较独立，可以考虑用静态方法来实现，<strong>静态方法需要使用装饰器@staticmethod来标识</strong>。</p><p>需要注意的是，<strong>静态方法无法使用实例的属性和方法</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>():</span><br><span class="line">    name = <span class="string">&#x27;Phantom&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name = <span class="string">&#x27;Aria&#x27;</span></span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getName</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;静态方法调用类属性&#x27;</span>, People.name)</span><br><span class="line">        <span class="comment">#print(self.name)       #不能调用实例的属性，会报错</span></span><br><span class="line"></span><br><span class="line">p = People()</span><br><span class="line">p.getName()</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">静态方法调用类属性 Phantom</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="4-6-特殊方法"><a href="#4-6-特殊方法" class="headerlink" title="4.6 特殊方法"></a>4.6 特殊方法</h3><p>前面的普通方法都是通过 对象名.方法名() 的方式调用，和前面有特殊属性一样，python也有一些特殊方法（或者叫魔术方法），这些特殊方法在符合条件的时候自动触发，不需要调用。</p><p>因为特殊方法非常多，这里只简单记录一些常用的。</p><table><thead><tr><th align="left">特殊方法</th><th>含义</th></tr></thead><tbody><tr><td align="left"><strong>构造类</strong></td><td></td></tr><tr><td align="left">__new__(cls, […])</td><td>对象实例化时调用的第一个方法，第一个参数时类，其他参数传递给__init__()，决定是否使用</td></tr><tr><td align="left">__init__(self, […])</td><td>构造器，当一个实例被创建时调用的初始化方法</td></tr><tr><td align="left">__del__(self)</td><td>构造器，当实例对象被销毁时调用的方法</td></tr><tr><td align="left"><strong>表示类</strong></td><td></td></tr><tr><td align="left">__str__(self)</td><td>描述类或对象信息，比如打印实例化对象，返回定义内容（给人看）</td></tr><tr><td align="left">__repr__(self)</td><td>描述类或对象信息，比如打印实例化对象，返回定义内容（给解释器看）</td></tr><tr><td align="left"><strong>访问控制类</strong></td><td></td></tr><tr><td align="left">__setattr__(self, key, value)</td><td>定义当一个属性被设置时的行为</td></tr><tr><td align="left">__getattr__(self, key)</td><td>定义用户试图获取一个不存在的属性时的行为</td></tr><tr><td align="left">__delattr__(self, key)</td><td>定义当一个属性被删除时的行为</td></tr><tr><td align="left">__getattribute__(self, key)</td><td>定义当该类属性被访问时的行为（所有属性&#x2F;方法调用都要经过这里）</td></tr><tr><td align="left">__dir__(self)</td><td>定义当dir()被调用时的行为</td></tr><tr><td align="left"><strong>比较操作类</strong></td><td></td></tr><tr><td align="left">__eq__(self, other)</td><td>判断两个对象是否相等</td></tr><tr><td align="left">__ne__(self,other)</td><td>判断两个对象是否不相等</td></tr><tr><td align="left">__lt__(self, other)</td><td>定义小于号的行为：x &lt; y 调用 x.__lt__(y)</td></tr><tr><td align="left">__gt__(self, other)</td><td>定义大于号的行为：x &gt; y 调用 x.__gt__(y)</td></tr><tr><td align="left"><strong>容器类</strong></td><td></td></tr><tr><td align="left">__setitem__(self, key, value)</td><td>定义设置容器中指定元素的操作，相当于 self[key] &#x3D; value</td></tr><tr><td align="left">__getitem__(self, key)</td><td>定义获取容器中指定元素的操作 ，相当于 self[key]</td></tr><tr><td align="left">__delitem__(self, key)</td><td>定义删除容器中指定元素的操作 ，相当于 del self[key]</td></tr><tr><td align="left">__len__(self)</td><td>定义当被 len() 调用时的操作，即返回容器中元素个数</td></tr><tr><td align="left">__iter__(self)</td><td>定义迭代容器中的元素的操作</td></tr><tr><td align="left">__contains__(self, item)</td><td>定义当使用成员测试运算符（in 或 not in）时的操作</td></tr><tr><td align="left">__reversed__(self)</td><td>定义当被 reversed() 调用时的操作</td></tr><tr><td align="left"><strong>可调用对象类</strong></td><td></td></tr><tr><td align="left">__call__(self, [args…])</td><td>使实例对象以 对象名() 的形式使用</td></tr></tbody></table><p>这些特殊方法比较常用，看到知道是怎么一回事就好。容器类的特殊方法稍微解释一下，python中常用<strong>字典、元组、列表和字符串</strong>作为容器，它们都实现了<strong>容器协议</strong>，可迭代。最后一个调用对象类特殊方法写个代码描述一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Calculate</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, m, n</span>):</span><br><span class="line">        self.m = m</span><br><span class="line">        self.n = n</span><br><span class="line">        SUM = m + n</span><br><span class="line">        <span class="keyword">return</span> SUM</span><br><span class="line"></span><br><span class="line">a = Calculate(<span class="number">100</span>, <span class="number">200</span>)  </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a(<span class="number">111</span>, <span class="number">222</span>))      <span class="comment"># __call__() 将实例化对象a当作一个方法来执行</span></span><br><span class="line"><span class="built_in">print</span>(a.x, a.y)     <span class="comment"># 实例属性并没有改变</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">333</span></span><br><span class="line"><span class="string">100 200</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>在上面这个例子中，首先初始化了一个Calculate实例a，调用 __init__() 方法，给与了实例属性x和y以及对应的值。但是对于实例对象a又做了调用 a(111, 222) ，实际上调用的是 __call__() 方法，传入自定义参数实现自己的逻辑，这在类实现一个装饰器的场景中比较常见。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;面向对象是Python的核心概念，一开始在这些概念问题上一直绕不清，这里做个简单记录。&lt;/p&gt;
&lt;h2 id=&quot;1-面向对象编程&quot;&gt;&lt;a href=&quot;#1-面向对象编程&quot; class=&quot;headerlink&quot; title=&quot;1. 面向对象编程&quot;&gt;&lt;/a&gt;1. 面向对象编程&lt;</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="编程自学" scheme="http://www.shelven.com/categories/%E7%BC%96%E7%A8%8B%E8%87%AA%E5%AD%A6/"/>
    
    
    <category term="python" scheme="http://www.shelven.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python自学笔记（2）——运算符和参数传递</title>
    <link href="http://www.shelven.com/2022/11/24/a.html"/>
    <id>http://www.shelven.com/2022/11/24/a.html</id>
    <published>2022-11-24T09:05:33.000Z</published>
    <updated>2022-11-24T09:11:28.128Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-运算符"><a href="#1-运算符" class="headerlink" title="1. 运算符"></a>1. 运算符</h2><div class="story post-story"><h3 id="1-1-比较运算符"><a href="#1-1-比较运算符" class="headerlink" title="1.1 比较运算符"></a>1.1 比较运算符</h3><p>python中常见的比较运算符如下：</p><blockquote><ol><li>&#x3D;&#x3D;  检查左右两个值是否相等，相等则返回True</li><li>!&#x3D;  检查左右两个值是否相等，不相等则返回True</li><li>&lt;&gt;  和 !&#x3D; 一样，检查两个值是否相等，不相等返回True</li><li>&gt;&#x3D;  字面意思，字面意思的还有&lt;&#x3D;、 &lt; 和 &gt;</li></ol></blockquote><h3 id="1-2-算数运算符"><a href="#1-2-算数运算符" class="headerlink" title="1.2 算数运算符"></a>1.2 算数运算符</h3><p>python常见的算数运算符：</p><blockquote><ol><li>&#x2F;  两个数相除，结果为浮点型</li><li>&#x2F;&#x2F;  两个数相除，结果为<strong>向下取整的整数</strong></li><li>%  取模，也就是两个整数相除的余数</li><li>**  幂运算，返回乘方的结果</li><li>+  两个数相加，<strong>或者字符串相连</strong></li><li>*  两个数相乘，<strong>或者返回重复若干次的字符串</strong></li><li>-  字面意思，两个数相减</li></ol></blockquote><h3 id="1-3-赋值运算符"><a href="#1-3-赋值运算符" class="headerlink" title="1.3 赋值运算符"></a>1.3 赋值运算符</h3><p>顾名思义都是在赋值的时候用到的运算符</p><blockquote><ol><li>&#x3D;  常规赋值运算，运算结果赋值给变量</li><li>+&#x3D;  加法赋值运算，a +&#x3D; b等效于a &#x3D; a+b</li><li>其他算数运算符都可以后面跟上&#x3D;，进行运算后赋值</li></ol></blockquote><h3 id="1-4-位运算符"><a href="#1-4-位运算符" class="headerlink" title="1.4 位运算符"></a>1.4 位运算符</h3><p>按位运算就是将数字转换为二进制来运算的运算形式，数值是用补码来表示和存储的，计算机用位运算符进行四则运算速度快。但是我们平常可能用不到，这里稍微记录一下。</p><blockquote><ol><li>&amp;  按位“与”：两个值如果相应位都为1，则结果为1，否则0</li><li>|  按位“或”：两个值相应位有一个位1，结果就为1</li><li>^  按位“异或”：两个值相应位相异，结果为1</li><li>~  按位“取反”：对数据的每个二进制位取反</li><li>&lt;&lt;  左移运算符：运算数的二进制全部座椅若干位，高位丢弃，低位补0；&gt;&gt;右移同理</li></ol></blockquote><h3 id="1-5-逻辑运算符"><a href="#1-5-逻辑运算符" class="headerlink" title="1.5 逻辑运算符"></a>1.5 逻辑运算符</h3><blockquote><ol><li>and  逻辑“与”，两个都为True则返回True，否则False</li><li>or  逻辑“或”，两个至少有一个True则返回True，否则False</li><li>not  逻辑“非”，字面意思</li></ol></blockquote><h3 id="1-6-成员和身份运算符"><a href="#1-6-成员和身份运算符" class="headerlink" title="1.6 成员和身份运算符"></a>1.6 成员和身份运算符</h3><p>python的成员运算符用来判断一个数据是否在指定的序列或者集合中，而身份运算符是用来判断两个变量是否引用自同一个对象。</p><blockquote><ol><li>in  成员运算符，在指定序列中找到值则返回True，否则False</li><li>not in  成员运算符，在指定序列中没有找到值则返回True，否则False</li><li>is  身份运算符，两个标识符是否引自同一个对象，是则返回True，否则False</li><li>is not  身份运算符，两个标识符是否引用同一个对象，不是则返回True，否则False</li></ol></blockquote><p>是否引自同一个对象，简单理解就是看存储的内存位置是否一样，通过函数id()可以查看变量在内存中的存储位置。</p><p><img src="https://www.shelven.com/tuchuang/20221124/111.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221124/111.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div><h2 id="2-参数传递"><a href="#2-参数传递" class="headerlink" title="2. 参数传递"></a>2. 参数传递</h2><div class="story post-story"><p>要理解参数传递的过程，首先要明白关于函数参数的两个具体概念：形参和实参</p><ul><li>定义时小括号中的参数，是用来接收参数的，称为“形参”，可以是缺省参数、不定长参数</li><li>调用时小括号中的参数，是用来传递参数给函数的，称为“实参”</li></ul><p>向函数传递实参的方式很多，确定传递参数个数可以使用位置实参或者关键字实参，不确定传递参数个数可以使用包裹（packing）传递的方式，来包裹位置或者关键字实参，进行参数传递。</p><h3 id="2-1-位置实参"><a href="#2-1-位置实参" class="headerlink" title="2.1 位置实参"></a>2.1 位置实参</h3><p>函数调用时每个实参都要关联到函数定义中的一个形参，最简单的是按照形参的位置从左到右按照顺序传递，位置参数必须一一对应，缺一不可。</p><p><img src="https://www.shelven.com/tuchuang/20221124/222.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221124/222.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>比如上面创建了一个describe_me()函数，形参定义了需要name和age两个参数，因此在调用这个函数的时候要按照顺序提供这两个参数。在上例中，从左到右实参‘Phantom’储存在形参name中，实参26储存在形参age中，<strong>参数传递本质上就是实参到形参的赋值操作</strong>。</p><h3 id="2-2-关键字实参"><a href="#2-2-关键字实参" class="headerlink" title="2.2 关键字实参"></a>2.2 关键字实参</h3><p>关键字实参顾名思义是传递函数的key-Value对，在实参中将关键字和值关联，因为这种对应关系是唯一的，在调用函数的时候就不需要考虑实参的顺序。</p><p><img src="https://www.shelven.com/tuchuang/20221124/333.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221124/333.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>这种参数传递方式比较直观，能一眼看出函数调用时各个值对应的用途。</p><p>关键字实参和位置实参时可以一起使用，需要注意：</p><ul><li>关键字实参必须在位置实参右边（写的时候<strong>位置实参优先</strong>）</li><li>对同一个形参不可重复传值</li></ul><h3 id="2-3-形参的缺省"><a href="#2-3-形参的缺省" class="headerlink" title="2.3 形参的缺省"></a>2.3 形参的缺省</h3><p>创建函数的时候可以给形参指定默认值（缺省）。</p><p><img src="https://www.shelven.com/tuchuang/20221124/444.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221124/444.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>对于缺省形参，需要注意：</p><ul><li>缺省参数要在非缺省参数之后（缺省形参放右边）</li><li>缺省参数是可选参数，可以不传；如果传入则按照传入的值进行运算</li></ul><h3 id="2-4-形参的不定长参数（包裹传递）"><a href="#2-4-形参的不定长参数（包裹传递）" class="headerlink" title="2.4 形参的不定长参数（包裹传递）"></a>2.4 形参的不定长参数（包裹传递）</h3><p>当传入的参数个数不确定时，可以使用包裹位置参数和包裹关键字参数进行参数传递。</p><ul><li>*+形参的方式传递参数，传入后根据参数的位置以<strong>元组</strong>形式保存</li><li>**+形参的方式传递参数，需要使用关键字，传入后以<strong>字典</strong>形式保存，形参名字是传入字典的键</li></ul><p><img src="https://www.shelven.com/tuchuang/20221124/555.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221124/555.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>上面例子形参中的args表示arguments位置参数，kargs表示key arguments关键字参数，这个是可以自定义的。</p><p>不同的参数传递方式可以混用，原则上要遵循<strong>位置参数，默认参数，包裹位置，包裹关键字</strong>的顺序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">name, age = <span class="number">26</span>, *args, **kargs</span>)  <span class="comment"># 定义和调用都遵循这样的顺序</span></span><br></pre></td></tr></table></figure><h3 id="2-5-对传参的思考"><a href="#2-5-对传参的思考" class="headerlink" title="2.5 对传参的思考"></a>2.5 对传参的思考</h3><p>在CSDN上看到一个总结写的很好，<strong>函数的参数传递本质上是从实参到形参的赋值操作，而所有的赋值操作都是“引用的赋值”，因此Python中参数的传递都是“引用传递”，不是“值传递</strong>”。这句话初看有点难以理解，首先看看什么是引用传递和值传递：</p><ul><li>值传递（pass by value）：调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</li><li>引用传递（pass by reference）：调用函数时将实际参数的地址直接传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</li></ul><p>根本区别在于引用传递不创建副本，最直接的理解方式就是通过查看对象的地址，看看传参前后对象在内存的位置是否改变。</p><h4 id="2-5-1-可变对象的传递"><a href="#2-5-1-可变对象的传递" class="headerlink" title="2.5.1 可变对象的传递"></a>2.5.1 可变对象的传递</h4><p>复习一下，可变对象有列表、字典和集合，我们这里以列表为例。</p><p><img src="https://www.shelven.com/tuchuang/20221124/777.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221124/777.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>可以看到，如果传递的对象是<strong>可变对象</strong>，实际上传递的是对象的引用（不创建副本，传递前后在内存中存储位置不变），在函数中修改对象后，<strong>直接在原始对象上做了相应的修改</strong>。</p><h4 id="2-5-2-不可变对象的传递"><a href="#2-5-2-不可变对象的传递" class="headerlink" title="2.5.2 不可变对象的传递"></a>2.5.2 不可变对象的传递</h4><p>如果传递的对象是不可变类型，比如元组，字符和数字，这里以数字为例。</p><p><img src="https://www.shelven.com/tuchuang/20221124/888.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221124/888.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>可以看到，如果传递的对象是<strong>不可变对象</strong>，传进函数的时候同样是对象的引用，但是不可变对象无法修改，因此在赋值操作时，系统新创建了一个对象（和原来a的存储地址不同）进行赋值，<strong>而原始对象并没有改变</strong>。</p><p>也就是说，不可变对象的传递起到类似值传递的效果，但是实际上依然是引用传递的方式进行传参。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-运算符&quot;&gt;&lt;a href=&quot;#1-运算符&quot; class=&quot;headerlink&quot; title=&quot;1. 运算符&quot;&gt;&lt;/a&gt;1. 运算符&lt;/h2&gt;&lt;div class=&quot;story post-story&quot;&gt;&lt;h3 id=&quot;1-1-比较运算符&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="编程自学" scheme="http://www.shelven.com/categories/%E7%BC%96%E7%A8%8B%E8%87%AA%E5%AD%A6/"/>
    
    
    <category term="python" scheme="http://www.shelven.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python自学笔记（1）——数据类型</title>
    <link href="http://www.shelven.com/2022/11/23/a.html"/>
    <id>http://www.shelven.com/2022/11/23/a.html</id>
    <published>2022-11-23T14:09:49.000Z</published>
    <updated>2022-11-24T09:14:48.278Z</updated>
    
    <content type="html"><![CDATA[<p>这两个月经历了突然的疫情隔离，研究生开题，学术论坛，研究生创新项目等等……终于在这一周尘埃落定了，得以静下心来整理整理自己的一些学习笔记。</p><p>之前我用过一些python编写的项目，我也只是依葫芦画瓢或者在demo上直接改，还没有系统性地学习过这门编程语言。这里就再记录下自己自学python的一些入门时的笔记，以及记录下几个机器学习方面的python库的使用方法。</p><h2 id="1-六大数据类型"><a href="#1-六大数据类型" class="headerlink" title="1. 六大数据类型"></a>1. 六大数据类型</h2><div class="story post-story"><p>很多编程语言的数据类型是相通或者有类似之处的，学习一门编程语言最基础的就是熟悉它的数据类型，python有6种标准数据类型。</p><h3 id="1-1-Numbers-数字类型"><a href="#1-1-Numbers-数字类型" class="headerlink" title="1.1 Numbers(数字类型)"></a>1.1 Numbers(数字类型)</h3><p>数字类型简单来说就是数值，在python中<strong>是不可变数据类型</strong>。python的Numbers数据类型又可以分为以下几个子类型</p><blockquote><ol><li>整型(int): 通常称为整型或整数，是正或负整数，不带小数点。python3整型没有大小限制，可以当作python2的Long类型使用，不像其他编程语言有 int，smallint，short，long，longint，long 等。</li><li>浮点型(float): 浮点型由整数和小数两个部分组成，只能以十进制表示或者科学计数法表示，有长度限制。</li><li>布尔型(bool): 布尔型就是逻辑，使用True和False表示。注意一下在上下文环境中，True当做1，False被当作0。</li><li>复数型(complex): 复数型由实数和虚数部分构成，可以用a + bj或者complex(a, b)表示，a和b都是浮点型。</li></ol></blockquote><h3 id="1-2-String-字符串"><a href="#1-2-String-字符串" class="headerlink" title="1.2 String(字符串)"></a>1.2 String(字符串)</h3><p>String是python中最常用的数据类型，说白了就是字符组成的一串内容。可以使用成对的单引号或者双引号(“或‘)创建字符串，用三个单引号或者双引号使字符串内容保持原样输出，可以包含特殊字符。<strong>在python中字符串是不可变变量。</strong></p><h4 id="1-2-1-字符串索引"><a href="#1-2-1-字符串索引" class="headerlink" title="1.2.1 字符串索引"></a>1.2.1 字符串索引</h4><p>索引就是字符的位置序号，使用[]进行字符串索引，python有两种索引方式，下标索引越界均会报错。</p><p>正向索引：字符串长度为n，<strong>从0开始</strong>，索引值范围0 ~ n-1</p><p>反向索引：字符串长度为n，<strong>从-1开始</strong>，索引值范围-1 ~ -n</p><p><img src="https://www.shelven.com/tuchuang/20221123/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221123/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="1-2-2-字符串切片"><a href="#1-2-2-字符串切片" class="headerlink" title="1.2.2 字符串切片"></a>1.2.2 字符串切片</h4><p>切片意思就是取出字符串中你想要的内容。切片的标准写法是两个冒号加三个数字，如a[1:2:3]，需要注意切片是<strong>左闭右开</strong>的取值，切片越界是不会报错的。</p><p>第一个数字表示切片的起始位置（省略就是从第 1 个字符开始，也就是0号位）</p><p>第二个数字表示切片的终止位置（不包括这个位置的字符，右开表现在这里；<strong>可省略，省略是最后一个字符结尾且包含</strong>）</p><p>第三个数字表示步长（缺省值为1，此时可以不写第二个冒号）</p><p><img src="https://www.shelven.com/tuchuang/20221123/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221123/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="1-2-3-转义"><a href="#1-2-3-转义" class="headerlink" title="1.2.3 转义"></a>1.2.3 转义</h4><p>如果使用带有特殊字符的字符串，则需要进行转义，使用反斜杠 \ 进行字符转义。</p><table><thead><tr><th>转义字符</th><th>描述</th></tr></thead><tbody><tr><td>\‘</td><td>表示单引号</td></tr><tr><td>\“</td><td>表示双引号</td></tr><tr><td>\n</td><td>换行</td></tr><tr><td>\t</td><td>制表符（即四个空格）</td></tr><tr><td>\b</td><td>退格（删除前面一个字符）</td></tr><tr><td>\\</td><td>表示反斜杠</td></tr></tbody></table><p>在字符串前加 ’r‘ 可以使整个字符串原样输出，不会被转义。</p><p><img src="https://www.shelven.com/tuchuang/20221123/4.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221123/4.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="1-2-4-格式化输出和占位符"><a href="#1-2-4-格式化输出和占位符" class="headerlink" title="1.2.4 格式化输出和占位符"></a>1.2.4 格式化输出和占位符</h4><p>格式化输出意思是按照格式说明所描述的文字规则进行输出，占位符的使用是格式化输出的表现形式。占位符的意思是替后面的变量占住这个位置，因此所有占位符最后都需要格式化定义占位符的映射（也就是解释占位符代表的东西）。</p><p>这里记录一下最常用的占位符</p><table><thead><tr><th>占位符</th><th>描述</th></tr></thead><tbody><tr><td>%s</td><td>针对所有数据类型</td></tr><tr><td>%d</td><td>针对整型数据类型</td></tr><tr><td>%f</td><td>只针对浮点数</td></tr><tr><td>%.xf</td><td>浮点数精确到小数点后x位，注意有个点</td></tr></tbody></table><p><img src="https://www.shelven.com/tuchuang/20221123/5.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221123/5.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>可以看到两种输出方式得到的结果是一样的，使用占位符进行格式化输出更简介，且更常用。</p><h3 id="1-2-5-常用函数"><a href="#1-2-5-常用函数" class="headerlink" title="1.2.5 常用函数"></a>1.2.5 常用函数</h3><p>python还有很多数据操作的函数，这里记录最常用的几个，以后继续补充</p><blockquote><p>type(): 查看数据类型</p><p>len(): 查看字符串长度</p><p>int(): 将数据类型转换为整数，如int(“1234”)得到结果整型1234</p><p>float(): 转换为浮点数，如float(“12.34”)得到结果浮点型12.34</p><p>str(): 转换为字符串，如str(123456)得到结果“123456”</p></blockquote><h3 id="1-3-List-列表"><a href="#1-3-List-列表" class="headerlink" title="1.3 List(列表)"></a>1.3 List(列表)</h3><p><strong>列表数据可以存储任意一种数据类型</strong>，是python特有的数据类型，列表用来存储由多个值构成的序列，可以嵌套其他列表，<strong>是一种可变数据类型</strong>。</p><p>不同数据项之间由逗号分开，整体放在一个方括号[]里，就可以创建列表，如ls &#x3D; [1, 2, 3, 4]就是一个列表。</p><h4 id="1-3-1-修改列表元素"><a href="#1-3-1-修改列表元素" class="headerlink" title="1.3.1 修改列表元素"></a>1.3.1 修改列表元素</h4><p>因为列表是可变数据类型，因此可以用索引或者切片的方法修改列表中的元素。</p><p><img src="https://www.shelven.com/tuchuang/20221123/6.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221123/6.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>可以使用del删除列表或者列表中索引为某个数的元素。</p><p><img src="https://www.shelven.com/tuchuang/20221123/7.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221123/7.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="1-3-2-列表生成式"><a href="#1-3-2-列表生成式" class="headerlink" title="1.3.2 列表生成式"></a>1.3.2 列表生成式</h4><p>除了直接创建列表，还可以使用列表生成式直接生成列表。</p><p><img src="https://www.shelven.com/tuchuang/20221123/9.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221123/9.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="1-3-3-列表的方法函数"><a href="#1-3-3-列表的方法函数" class="headerlink" title="1.3.3 列表的方法函数"></a>1.3.3 列表的方法函数</h4><p>记录一下操作列表的常用方法，这里就不演示了。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>list.append(obj)</td><td>列表<strong>末尾</strong>添加新的对象</td></tr><tr><td>list.count(obj)</td><td>返回某个元素在列表中出现的次数</td></tr><tr><td>list.extend(seq)</td><td>在列表末尾添加另一个列表的所有元素</td></tr><tr><td>list.index(obj)</td><td>返回第一个匹配的的索引值</td></tr><tr><td>list.insert(index, obj)</td><td>在指定索引插入对象</td></tr><tr><td>list.pop(index)</td><td>移除指定索引的值，并返回该值</td></tr><tr><td>list.sort()</td><td>对原列表进行升序排序（纯数字才可以），降序需要添加reverse&#x3D;True</td></tr><tr><td>list.reverse()</td><td>反转列表元素</td></tr><tr><td>list.remove(obj)</td><td>移除第一个匹配的某对象</td></tr></tbody></table><h3 id="1-4-Tuple-元组"><a href="#1-4-Tuple-元组" class="headerlink" title="1.4 Tuple(元组)"></a>1.4 Tuple(元组)</h3><p>元组也是python的一种特殊数据类型，和列表很相似，<strong>但是是不可变对象</strong>。如果想创建一个全局都不变的变量，可以考虑创建元组。</p><p>元组中的元素用逗号分隔，一般要使用小括号（小括号不是必须的，只是为了方便理解和美观）。</p><p><strong>元组中如果只有一个元素，需要在元素后加逗号。</strong>否则无法判断这是一个元组还是一个整型数据。</p><p><img src="https://www.shelven.com/tuchuang/20221123/8.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221123/8.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>同样元组数据也可以进行索引和切片，这里不赘述。</p><h4 id="1-4-1-元组和列表的互相转化"><a href="#1-4-1-元组和列表的互相转化" class="headerlink" title="1.4.1 元组和列表的互相转化"></a>1.4.1 元组和列表的互相转化</h4><p>元组转化列表使用list()函数，列表转化元组使用tuple()函数。</p><p><img src="https://www.shelven.com/tuchuang/20221123/10.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221123/10.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="1-4-2-结合元组的列表生成式"><a href="#1-4-2-结合元组的列表生成式" class="headerlink" title="1.4.2 结合元组的列表生成式"></a>1.4.2 结合元组的列表生成式</h4><p>元组不能通过和列表一样的生成式来创建，但是列表生成式中可以加入元组。</p><p><img src="https://www.shelven.com/tuchuang/20221123/11.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221123/11.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="1-5-Set-集合"><a href="#1-5-Set-集合" class="headerlink" title="1.5 Set(集合)"></a>1.5 Set(集合)</h3><p>集合是一个无序的不重复元素序列，可以使用大括号{}或者set()函数创建集合，但是创建一个空集合必须要用set()而不是{}，因为{}是用来创建一个空字典的。</p><p>因为用的不多，简单记录一下，集合有三个特点</p><blockquote><p>集合的元素是无序的。 如：{1, 2, 3}和{1, 3, 2}是完全相等的。</p><p>集合的元素是不重复的。 如：{1, 1, 1}只会保留一个值，打印结果为{1}。</p><p>集合的元素必须是不可变数据类型（数字、字符串和元组）。 如：{1, [1, 2]}打印结果会报错，因为列表是可变数据类型。</p></blockquote><h3 id="1-6-Dictionary-字典"><a href="#1-6-Dictionary-字典" class="headerlink" title="1.6 Dictionary(字典)"></a>1.6 Dictionary(字典)</h3><p>字典用的比较多，其存储特点是键值对的形式出现（Key-Value），一个键对应一个值，每个键值对用冒号隔开，每对键值对用逗号隔开。字典也可以存储任意类型数据。</p><p>需要注意的一点，在字典数据类型中，<strong>键必须是唯一的</strong>，但是值可以不唯一，<strong>值可以取任何数据类型，但是键必须是不可变数据类型。</strong></p><h4 id="1-6-1-字典创建和修改"><a href="#1-6-1-字典创建和修改" class="headerlink" title="1.6.1 字典创建和修改"></a>1.6.1 字典创建和修改</h4><p>字典数据可以通过花括号直接创建，或者通过dict()函数创建（非空）。</p><p><img src="https://www.shelven.com/tuchuang/20221123/13.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221123/13.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>通过访问键来访问对应的值，添加、删除和修改的方法均类似。</p><p><img src="https://www.shelven.com/tuchuang/20221123/14.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221123/14.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="1-6-2-字典的方法函数"><a href="#1-6-2-字典的方法函数" class="headerlink" title="1.6.2 字典的方法函数"></a>1.6.2 字典的方法函数</h4><p>记录一下常用的字典方法函数，就不演示了，具体用到的时候可以查。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>dict.keys()</td><td>返回所有键的列表dict_key对象，可以转换成列表、元组和集合</td></tr><tr><td>dict.values()</td><td>返回所有值的列表dict_values对象，也可以转换成列表、元组和集合</td></tr><tr><td>dict.items()</td><td>返回所有键值对的列表dict_items对象，同样可以转换成列表、元组和集合</td></tr><tr><td>dict.clear()</td><td>清空字典，无返回值，只剩下空字典</td></tr><tr><td>dict.get(key, default&#x3D;None)</td><td><strong>返回</strong>字典中指定key的<strong>value值</strong>，如果key不存在，则返回default值</td></tr><tr><td>dict.pop(key, default&#x3D;None)</td><td><strong>删除</strong>指定的key<strong>并返回</strong>对应的<strong>value值</strong>，如果key不存在，则返回default值</td></tr></tbody></table><p>简单小结一下关于python数据类型的注意点：</p><blockquote><p>1.可变数据类型：List、Dictionary、Set</p><p>2.不可变数据类型：Tuple、Numbers、String。不可变体现在索引这些变量名的元素不可被重新赋值</p><p>3.下标索引：String、List、Tuple支持下标索引，Dictionary是通过Key值索引</p><p>4.切片：String、List、Tuple支持切片操作</p></blockquote></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这两个月经历了突然的疫情隔离，研究生开题，学术论坛，研究生创新项目等等……终于在这一周尘埃落定了，得以静下心来整理整理自己的一些学习笔记。&lt;/p&gt;
&lt;p&gt;之前我用过一些python编写的项目，我也只是依葫芦画瓢或者在demo上直接改，还没有系统性地学习过这门编程语言。这里就</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="编程自学" scheme="http://www.shelven.com/categories/%E7%BC%96%E7%A8%8B%E8%87%AA%E5%AD%A6/"/>
    
    
    <category term="python" scheme="http://www.shelven.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>深度学习笔记（1）</title>
    <link href="http://www.shelven.com/2022/09/20/a.html"/>
    <id>http://www.shelven.com/2022/09/20/a.html</id>
    <published>2022-09-19T16:58:05.000Z</published>
    <updated>2022-09-19T17:06:39.345Z</updated>
    
    <content type="html"><![CDATA[<p>开坑记录一下学习人工智能(深度学习为主)的笔记，方便以后回顾学习~整理自点头教育</p><h2 id="人工智能的趋势展望"><a href="#人工智能的趋势展望" class="headerlink" title="人工智能的趋势展望"></a>人工智能的趋势展望</h2><div class="story post-story"><h3 id="1-前沿技术"><a href="#1-前沿技术" class="headerlink" title="1. 前沿技术"></a>1. 前沿技术</h3><h4 id="Transformer模型"><a href="#Transformer模型" class="headerlink" title="Transformer模型"></a>Transformer模型</h4><p>基于自注意力机制，有效提高模型训练效率</p><p>由Google的Ashish Vaswani等人和多伦多大学的Aidan N.Gomez于2017年首次提出，是一种基于<strong>自注意力机制</strong>（在Transformer模型中起基础作用，可减少对外部信息的依赖,更擅长捕捉数据或特征的内部关系，优化模型训练结果）的深度学习模型，该模型主要由编码器和解码器构成，模型本身并行度较高，在精度和性能上均要优于传统的循环神经网络（RNN）和卷积神经网络（CNN）。Transformer模型在简单语言问答和语言建模任务上有着较好表现。</p><p><img src="https://www.shelven.com/tuchuang/20220919/1.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/1.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="BERT模型"><a href="#BERT模型" class="headerlink" title="BERT模型"></a>BERT模型</h4><p>基于Transformer Encoder构建的预测模型</p><p>由Google于2018年提出，是基于Transformer Encoder构建的一种模型。模型基本思想：给定上下文来预测下一个词。BERT模型架构是由多接口组成的Transformer编码器层，即全连接神经网络增加自注意力机制。对于序列中的每个输入标记，每个接口计算键值和查询向量，相关向量用于创建加权表示，合并同一层中所有接口输出并通过全连接层运行。每个层使用跳跃连接进行包装，之后将层归一化处理。</p><p><img src="https://www.shelven.com/tuchuang/20220919/2.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="自监督学习"><a href="#自监督学习" class="headerlink" title="自监督学习"></a>自监督学习</h4><p>将无监督问题转化为有监督问题的方法</p><p>旨在对于无标签数据，通过设计辅助任务来挖掘数据自身的表征特性作为监督信息，来提升模型的特征提取能力，将无监督问题转化为有监督问题的方法。</p><p>说到自监督就顺便说下<strong>有监督学习</strong>和<strong>无监督学习</strong>，有监督给定的结果是确定的；无监督是实际应用场景中最多的，结果不确定，根据类别未知(没有被标记)的训练样本解决模式识别中的各种问题。</p><p><img src="https://www.shelven.com/tuchuang/20220919/3.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/3.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="类脑计算"><a href="#类脑计算" class="headerlink" title="类脑计算"></a>类脑计算</h4><p>模拟大脑结构和信息加工过程，提高机器认知能力、降低运行功耗</p><p>类脑计算(Brain-Inspired Computing): 又称神经形态计算，是借鉴生物神经系统信息处理模式和结构的计算理论、体系结构、芯片设计以及应用模型与算法的总称。类脑计算可模拟人类大脑信息处理方式，以极低的功耗对信息进行异步、并行、高速和分布式处理，并具备自主感知、识别和学习等多种能力，是实现通用人工智能的途径之一。</p><p><img src="https://www.shelven.com/tuchuang/20220919/4.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/4.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="AI大模型"><a href="#AI大模型" class="headerlink" title="AI大模型"></a>AI大模型</h4><p>包含万亿量级参数的预训练模型，显著降低模型训练成本</p><p>AI大模型(Foundation Models):是指经过大规模数据训练且在经微调后即可适应广泛下游任务的模型。随着参数规模不断扩大，AI大模型在语言、视觉、推理、人机交互等领域涌现出新能力。</p><p><img src="https://www.shelven.com/tuchuang/20220919/5.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/5.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="2-人工智能的产业融合"><a href="#2-人工智能的产业融合" class="headerlink" title="2. 人工智能的产业融合"></a>2. 人工智能的产业融合</h3><h4 id="人工智能与元宇宙"><a href="#人工智能与元宇宙" class="headerlink" title="人工智能与元宇宙"></a>人工智能与元宇宙</h4><p>元宇宙（Metaverse）：本质上是对现实世界的虚拟化、数字化过程，其主要包括基础设施、人机交互、空间计算等七层架构，其中计算机视觉、AI芯片和嵌入式AI等人工智能技术及基础设施共同助力元宇宙加速落地。元宇宙涵盖芯片、云计算、技术平台、通信、智能设备、内容服务等庞大生态系统。</p><p><img src="https://www.shelven.com/tuchuang/20220919/6.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/6.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="人工智能与生命科学"><a href="#人工智能与生命科学" class="headerlink" title="人工智能与生命科学"></a>人工智能与生命科学</h4><p>AlphaFold是由谷歌旗下DeepMind团队基于深度学习算法的<strong>蛋白质结构预测</strong>的人工智能系统，其被视作人工智能深入到生物领域的一大突破。目前AlphaFold已对98.5%的人类蛋白质结构做出预测，此外还对于大肠杆菌、果蝇、斑马鱼、小鼠等研究时常用生物的蛋白质结构进行预测。（这块比较感兴趣，有空继续了解一下）</p><p><img src="https://www.shelven.com/tuchuang/20220919/7.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/7.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="人工智能与新冠疫情"><a href="#人工智能与新冠疫情" class="headerlink" title="人工智能与新冠疫情"></a>人工智能与新冠疫情</h4><p>Eva是用于检测入境旅客新冠病毒的强化学习系统，其由美国南加州大学、美国宾夕法尼亚学、AgentRisk以及希腊相关专家合作开发。 </p><p>2020年，Eva系统被部署到希腊所有入境口岸（机场、港口、车站等），用于识别限制新冠无症状旅客入境。（这里存疑，用算法确定新冠受检者，虽然在一定程度上能缓解新冠检测用品有限的不利情况，但是无疑会漏掉部分入境的可能感染者，一旦感染爆发得不偿失）</p><p><img src="https://www.shelven.com/tuchuang/20220919/8.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/8.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="人工智能与半导体"><a href="#人工智能与半导体" class="headerlink" title="人工智能与半导体"></a>人工智能与半导体</h4><p>AI与EDA紧密融合，促使芯片PPA结果更加稳定</p><p>为使PPA优化结果更佳，同时为应对芯片安全性需求提升、设计规模攀升及工艺节点微缩等趋势，EDA厂商开始利用AI技术解决半导体芯片设计问题。在EDA中，数据快速提取模型、布局和布线、电路仿真模型、 PPA优化决策等环节均有AI技术参与。</p><p><img src="https://www.shelven.com/tuchuang/20220919/9.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/9.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="人工智能与碳中和"><a href="#人工智能与碳中和" class="headerlink" title="人工智能与碳中和"></a>人工智能与碳中和</h4><p>人工智能在预测、监测、优化三大环节赋能碳中和</p><p>当前，碳中和已获得全球超过40个国家和地区承诺，其中大部分国家宣布将于2050年左右实现碳中和目标。从整体来看，人工智能将从预测、监测、优化三大环节助力碳中和，如预测未来碳排放量、实时监测碳足迹、优化工作流程等。</p><p><img src="https://www.shelven.com/tuchuang/20220919/10.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/10.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="人工智能与冬奥会"><a href="#人工智能与冬奥会" class="headerlink" title="人工智能与冬奥会"></a>人工智能与冬奥会</h4><p>2022年2月，第24届冬季奥林匹克运动会成功在北京举办。人工智能技术在冬奥会开幕式、比赛项目、运动员训练等多个场景实现应用，助力科技冬奥目标实现。</p><p><img src="https://www.shelven.com/tuchuang/20220919/11.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/11.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="3-人工智能产业发展的路径探究"><a href="#3-人工智能产业发展的路径探究" class="headerlink" title="3. 人工智能产业发展的路径探究"></a>3. 人工智能产业发展的路径探究</h3><p>人工智能在“科研成果—商业化落地”过程中依然存在诸多挑战</p><p><img src="https://www.shelven.com/tuchuang/20220919/12.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/12.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="伦理与安全"><a href="#伦理与安全" class="headerlink" title="伦理与安全"></a>伦理与安全</h4><p>人工智能发展面临隐私保护与算法合规使用等方面挑战</p><p>随着人工智能技术的高速发展与普及应用，由其产生的伦理与安全问题日益受到关注。人工智能不但延续信息技术的伦理问题，又因深度学习算法具有不透明、难解释、自适应、运用广泛等特征而在基本人权、社会秩序、国家安全等方面产生新问题。</p><p><img src="https://www.shelven.com/tuchuang/20220919/13.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/13.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="国家间技术限制"><a href="#国家间技术限制" class="headerlink" title="国家间技术限制"></a>国家间技术限制</h4><p>国家间技术限制阻碍人工智能技术进步</p><p>当前，开源深度学习框架、开源工具集、开源应用软件快速发展，国际间AI技术交流不断深入，但部分国家和政府间组织为保持自身AI 技术优势，限制AI技术交流。如美国在2021年6月发布《创新与竞争法案》，在AI、无人机、芯片等多个领域限制与中国合作；美国商务部于2019年10月和2020年5月将商汤科技、科大讯飞等多家中国AI公司加入其实体清单，实施投资限制；2022年白宫修订“关键和新兴技术（CET）清单”，对AI技术具体分类并实行技术封锁。欧盟则于2021年9月通过最新出口管制法规，内容涵盖人脸识别等AI技术。 </p><p>上述相关政策与未来人工智能发展趋势背道而驰，不利于各国开展技术合作。</p><p><img src="https://www.shelven.com/tuchuang/20220919/14.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/14.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div><h2 id="深度学习算法部分内容"><a href="#深度学习算法部分内容" class="headerlink" title="深度学习算法部分内容"></a>深度学习算法部分内容</h2><div class="story post-story"><h3 id="迁移学习"><a href="#迁移学习" class="headerlink" title="迁移学习"></a>迁移学习</h3><p>将知识由源域迁移至目标域，提高机器学习效率</p><p>迁移学习（Transfer Learning,TL）：是一种机器学习方法,是把已训练好的模型参数迁移到新的模型来帮助新模型训练，其核心目标是将知识从源域迁移到目标域，让机器也可以做到“触类旁通”。</p><p>迁移学习的主要优点是节省模型训练时间，且在目标域训练数据不足时，模型仍能取得较好的性能。</p><p>迁移学习的训练框架可以概括为：1）选择源模型，从可用模型中挑选出预训练模型；2）重用模型，在目标域中使用源模型进行训练；3）调整模型。模型可以在目标数据集中对输入-输出进行选择性微调，以让其适应目标任务。</p><p>实现迁移学习的方式主要包括样本迁移、特征迁移、模型迁移。目前，迁移学习主要应用在<strong>计算机视觉</strong>、<strong>自然语言处理</strong>等领域。</p><p><img src="https://www.shelven.com/tuchuang/20220919/15.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/15.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="神经网络与卷积神经网络"><a href="#神经网络与卷积神经网络" class="headerlink" title="神经网络与卷积神经网络"></a>神经网络与卷积神经网络</h3><h4 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h4><p>具有适应性简单单元组成的广泛并行互联网络</p><p>神经网络（Neural Network）：由数千甚至数百万个紧密互连的简单处理节点组成，其主要包括输入层（输入数据）、中间层&#x2F;隐藏层（学习复杂决策边界）和输出层（输出结果）。</p><p>神经网络可以用于回归，但主要应用于分类问题。如下图所示：输入层表示输入图像（64维向量），中间层使用Sigmoid等非线性函数对于输入层数据进行计算，输出层使用非线性函数对于中间层数据进行计算。</p><p>神经网络通过采取设置中间层的方式，利用单一算法学习各种决策边界，调节中间层数量以及层的深度，神经网络可学习更复杂的边界特征，而得出更加准确的结果。</p><p><img src="https://www.shelven.com/tuchuang/20220919/16.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/16.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h4><p>以<strong>图像识别</strong>为核心的深度学习算法</p><p>卷积神经网络（Convolutional Neural Network,CNN）：由数千甚至数百万个紧密互连的简单处理节点组成，其主要包括输入层、卷积层、池化层、全连接层和输出层，<strong>适合处理图片、视频等类型数据</strong>。</p><p>1980年，日本科学家福岛邦彦提出一个包含卷积层、池化层的神经网络结构。在此基础上，Yann Lecun将BP算法应用到该神经网络结构的训练上，形成当代卷积神经网络的雏形；1988年，Wei Zhang提出第一个二维卷积神经网络：平移不变人工神经网络（SIANN），并将其应用于<strong>检测医学影像</strong>；1998年Yann LeCun及其合作者构建了更加完备的卷积神经网络LeNet-5并在手写数字的识别问题中取得成功。</p><p><img src="https://www.shelven.com/tuchuang/20220919/17.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/17.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><strong>卷积层</strong>：图片输入转化成RGB对应的数字，然后通过卷积核做卷积，目的是提取输入中的主要特征，卷积层中使用同一卷积核对每个输入样本进行卷积操作；</p><p><strong>池化层</strong>：作用在于减小卷积层产生的特征图尺寸（压缩特征映射图尺寸有助于降低后续网络处理的负载）；</p><p><strong>全连接层</strong>：计算激活值然后通过激活函数计算各单元输出值（激活函数包括<strong>Sigmoid、tanh、ReLU</strong>等）</p><p><strong>输出层</strong>：使用似然函数计算各类别似然概率。</p><p><img src="https://www.shelven.com/tuchuang/20220919/18.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/18.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="循环神经网络与图神经网络"><a href="#循环神经网络与图神经网络" class="headerlink" title="循环神经网络与图神经网络"></a>循环神经网络与图神经网络</h3><h4 id="循环神经网络"><a href="#循环神经网络" class="headerlink" title="循环神经网络"></a>循环神经网络</h4><p>用于处理<strong>序列数据</strong>的神经网络</p><p>循环神经网络（Recurrent Neural Network,RNN）：是一类以序列数据（指相互依赖的数据流，比如时间序列数据、信息性的字符串、对话等）为输入，在序列的演进方向进行递归且所有节点（循环单元）按链式连接的神经网络。目前，<strong>语言建模和文本生成、机器翻译、语音识别、生成图像描述、视频标记是RNN应用最多的领域</strong>。</p><p><img src="https://www.shelven.com/tuchuang/20220919/19.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/19.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="图神经网络"><a href="#图神经网络" class="headerlink" title="图神经网络"></a>图神经网络</h4><p>用于处理图结构数据的神经网络</p><p>图神经网络（Graph Neural Networks，GNN）：将图数据和神经网络进行结合，在图数据上面进行端对端的计算，具备端对端学习、擅长推理、可解释性强的特点。</p><p>图神经网络发展出多个分支，主要包括图卷积网络、图注意力网络、图自编码器、图生成网络和图时空网络等。</p><p>图神经网络的训练框架如下：首先，每个节点获取其相邻节点的所有特征信息，将聚合函数（如求和或取平均）应用于这些信息。 聚合函数的选择必须不受节点顺序和排列的影响。之后，将前一步得到的向量传入一个神经网络层（通常是乘以某个矩阵），然后使用非线性激活函数（如ReLU）来获得新的向量表示。</p><p>目前，图神经网络在许多领域的实际应用中都展现出<strong>强大的表达能力和预测能力，如物理仿真、科学研究、生物医药、金融风控等</strong>。</p><p><img src="https://www.shelven.com/tuchuang/20220919/20.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/20.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="长短期记忆神经网络"><a href="#长短期记忆神经网络" class="headerlink" title="长短期记忆神经网络"></a>长短期记忆神经网络</h3><p>在RNN中加入<strong>门控机制</strong>，解决梯度消失问题</p><p>长短期记忆神经网络（Long Short-Term Memory,LSTM）：LSTM是一种特殊的循环神经网络（RNN）。传统RNN在训练中，随着训练时间的加长和层数的增多，很容易出现梯度爆炸或梯度消失问题，导致无法处理长序列数据，LSTM可有效解决传统RNN“长期依赖”问题。</p><p>LSTM由状态单元、输入门（决定当前时刻网络的输入数据有多少需要保存到单元状态）、遗忘门（决定上一时刻的单元状态有多少需要保留到当前时刻）、输出门（控制当前单元状态有多少需要输出到当前输出值）组成，以此令长期记忆与短期记忆相结合，达到序列学习的目的</p><p>LSTM应用领域主要包括文本生成、机器翻译、语音识别、生成图像描述和视频标记等。（我前一篇博客做的tts用了Tacotron2，其编码器模块中就引入了一个双向LSTM层）</p><p><img src="https://www.shelven.com/tuchuang/20220919/21.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/21.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="自编码器"><a href="#自编码器" class="headerlink" title="自编码器"></a>自编码器</h3><p>通过期望输出等同于输入样本的过程，实现对输入样本抽象特征学习</p><p>典型深度无监督学习模型包括<strong>自编码器</strong>、<strong>受限波尔兹曼机</strong>与<strong>生成对抗网络</strong>。</p><p>自编码器（Autoencoder,AE）：包括编码器和解码器两部分，其中<strong>编码器将高维输入样本映射到低维抽象表示，实现样本压缩与降维</strong>；<strong>解码器将抽象表示转换为期望输出，实现输入样本的复现</strong>。自码器的输入与期望输出均为无标签样本，隐藏层输出则作为样本的抽象特征表示。</p><p>自编码器仅通过最小化输入样本与重构样本之间的误差来获取输入样本的抽象特征表示，无法保证自编码器提取到样本的本质特征。为避免上述问题，需要对自编码器添加约束或修改网络结构，进而产生稀疏自编码器、去噪自编码器、收缩自编码器等改进算法。</p><p>自编码器凭借其优异的特征提取能力，主要应用于目标识别、文本分类、图像重建等诸多领域。</p><p><img src="https://www.shelven.com/tuchuang/20220919/22.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/22.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="生成对抗网络"><a href="#生成对抗网络" class="headerlink" title="生成对抗网络"></a>生成对抗网络</h3><p>生成对抗网络（Generative Adversarial Network,GAN）：通过使用对抗训练机制对两个神经网络进行训练，避免反复应用马尔可夫链学习机制带来的配分函数计算，明显提高应用效率。</p><p>生成对抗网络包含一组相互对抗模型—判别器和生成器，判别器目的是正确区分真实数据和生成数据，使得判别准确率最大化，生成器是尽可能逼近真实数据的潜在分布。生成器类似于造假钞的人，其制造出以假乱真的假钞，判别器类似于警察，尽可能鉴别出假钞，最终造假钞的人和警察双方在博弈中不断提升各自能力。（同样是我前面一篇博客语音合成tts中，应用的HiFiGAN就是基于GAN的声码器）</p><p><img src="https://www.shelven.com/tuchuang/20220919/23.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/23.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;开坑记录一下学习人工智能(深度学习为主)的笔记，方便以后回顾学习~整理自点头教育&lt;/p&gt;
&lt;h2 id=&quot;人工智能的趋势展望&quot;&gt;&lt;a href=&quot;#人工智能的趋势展望&quot; class=&quot;headerlink&quot; title=&quot;人工智能的趋势展望&quot;&gt;&lt;/a&gt;人工智能的趋势展望&lt;/</summary>
      
    
    
    
    <category term="深度学习" scheme="http://www.shelven.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="人工智能" scheme="http://www.shelven.com/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>go-cqhttp扫码登录异常的解决方法</title>
    <link href="http://www.shelven.com/2022/09/09/b.html"/>
    <id>http://www.shelven.com/2022/09/09/b.html</id>
    <published>2022-09-09T11:43:05.000Z</published>
    <updated>2022-09-09T11:45:10.054Z</updated>
    
    <content type="html"><![CDATA[<p>假期用自己的服务器搭建了一个基于 Nonebot2 和 go-cqhttp 框架的QQ聊天机器人，使用的开源项目是绪山真寻bot（<a href="https://github.com/HibiKier/zhenxun_bot">项目地址点击这里</a>）。因为项目提供了一键安装包，这里就不详细说安装过程了，简单说下首次运行或者切换bot QQ号会碰到的go-cqhttp扫码登陆异常的问题。</p><h3 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h3><p>首次运行或者切换bot QQ号后，go-cqhttp会要求需要登录验证，由于纯linux系统无法使用浏览器抓取滑条，因此会自动跳转到手机QQ扫码验证。</p><p><img src="https://www.shelven.com/tuchuang/20220909_1/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220909_1/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>但是扫码会提示两个设备不在一个网络，无法登录。（很明显我的云端linux服务器不可能和手机能在一个网络中）</p><p><img src="https://www.shelven.com/tuchuang/20220909_1/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220909_1/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>这个问题是腾讯QQ安全机制引起的，很明显是限制QQ机器人的手段，也就是你扫码的网络环境要和服务器的网络环境一致才可以登录。</p><h3 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h3><h4 id="第一步-下载和运行win版go-cqhttp"><a href="#第一步-下载和运行win版go-cqhttp" class="headerlink" title="第一步 下载和运行win版go-cqhttp"></a>第一步 下载和运行win版go-cqhttp</h4><p>项目下载地址<a href="https://github.com/Mrs4s/go-cqhttp/releases">Releases · Mrs4s&#x2F;go-cqhttp (github.com)</a></p><p>选择下载最新版本的go-cqhttp_windows_amd64，解压后有三个文件</p><p><img src="https://www.shelven.com/tuchuang/20220909_1/3.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220909_1/3.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>双击exe文件，提示要在power shell中运行，确认，自动生成<strong>go-cqhttp.bat</strong>的批处理文件</p><p>双击运行<strong>go-cqhttp.bat</strong>，选择013，回车</p><p><img src="https://www.shelven.com/tuchuang/20220909_1/4.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220909_1/4.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>修改生成的config.yml配置文件（主要就是改bot QQ号和密码）</p><p>修改之后再次运行go-cqhttp.bat，看到连接成功，网络没有问题即可</p><p><img src="https://www.shelven.com/tuchuang/20220909_1/5.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220909_1/5.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>前面的反向代理失败统统不用管（因为我没有设置），我们只需要win版go-cqhttp提供设备登录信息文件（<strong>device.json</strong>）和密钥信息文件（<strong>session.token</strong>）即可。这两个文件特别重要，尤其是device.json，缺一个都将会导致登陆失败。</p><h4 id="第二步-替换文件"><a href="#第二步-替换文件" class="headerlink" title="第二步 替换文件"></a>第二步 替换文件</h4><p>替换linux服务器go-cqhttp文件夹下的<strong>device.json和session.token</strong>（有的话替换，无的话直接加进去）文件，<strong>config文件最好不要替换</strong>，你只要改一下qq号和密码就行，防止底下设置的反向连接端口出错（很重要！！）。</p><p><img src="https://www.shelven.com/tuchuang/20220909_1/6.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220909_1/6.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>重新在linux上启动go-cqhttp，问题解决。</p><p><img src="https://www.shelven.com/tuchuang/20220909_1/7.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220909_1/7.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;假期用自己的服务器搭建了一个基于 Nonebot2 和 go-cqhttp 框架的QQ聊天机器人，使用的开源项目是绪山真寻bot（&lt;a href=&quot;https://github.com/HibiKier/zhenxun_bot&quot;&gt;项目地址点击这里&lt;/a&gt;）。因为项目提供了一</summary>
      
    
    
    
    <category term="QQ机器人" scheme="http://www.shelven.com/categories/QQ%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    
    
    <category term="qq bot" scheme="http://www.shelven.com/tags/qq-bot/"/>
    
    <category term="go-cqhttp" scheme="http://www.shelven.com/tags/go-cqhttp/"/>
    
  </entry>
  
  <entry>
    <title>深度学习——语音合成tts笔记（下）</title>
    <link href="http://www.shelven.com/2022/09/09/a.html"/>
    <id>http://www.shelven.com/2022/09/09/a.html</id>
    <published>2022-09-08T19:32:17.000Z</published>
    <updated>2022-10-08T07:00:04.980Z</updated>
    
    <content type="html"><![CDATA[<p>（接上篇博客）做完数据集，我们手里现在有训练集（train set）和测试集（test set）音频文件，以及对应的拼音文本，接下来就可以跑Tacotron2来训练模型了。</p><h2 id="2-训练模型-amp-合成语音"><a href="#2-训练模型-amp-合成语音" class="headerlink" title="2. 训练模型 &amp; 合成语音"></a>2. 训练模型 &amp; 合成语音</h2><div class="story post-story"><p><a href="https://github.com/NVIDIA/tacotron2">Tacotron2项目地址点击这里</a></p><p><a href="https://github.com/jik876/hifi-gan">HiFi-GAN项目地址点击这里</a></p><p>本篇博客训练模型&amp;合成语音基于以上两个开源项目，再次感谢原作者！</p><h3 id="2-1-Tacotron2简介"><a href="#2-1-Tacotron2简介" class="headerlink" title="2.1 Tacotron2简介"></a>2.1 Tacotron2简介</h3><p>简单讲一讲Tacotron2，它是由google推出的从文本中合成语音的神经网络结构，也就是一个语音合成（Text To Speech，TTS）框架，可以实现端到端的语音合成。Tacotron2与其前代Tacotron类似，比较重要的一个区别是在编码器模块中引入了一个双向LSTM层和卷积层，相比原来的CBHG堆叠结构和GRU循环层更为简洁。</p><p>模型主要由两部分组成：</p><ul><li><ol><li>声谱预测网络：特征预测网络，包含一个编码器和一个引入注意力机制（attention）的解码器，作用是将输入字符序列预测为梅尔频谱的帧序列。</li></ol></li><li><ol start="2"><li>声码器（vocoder）：将预测的梅尔频谱帧序列转换产生时域波形样本，算是WaveNet的修订版。</li></ol></li></ul><p>原项目中的声码器我们暂时不用（<strong>上面地址提供的Tacotron 2就是没有wavenet的版本</strong>），因为有更好的工具HiFi-GAN。</p><p>代码实现详解有很多博客可以参考（<a href="https://blog.csdn.net/whjkm/article/details/89321954#commentBox">(16条消息) Tacotron2 论文 + 代码详解_HJ_彼岸的博客-CSDN博客_tacotron2</a>），<strong>这里只要知道我们是用Tacotron2生成梅尔频谱，在此基础上结合我们输入的字符序列（也就是对应的拼音文本）训练模型。</strong></p><p><u>特别注意一点</u>：Tacotron 2是基于tensorflow1.5版本运行的，如果是自己电脑上配置环境的话，<strong>务必将python版本降到3.7以下！</strong>否则将会无法安装tensorflow1.5，除了tensorflow有硬性版本要求之外，其他依赖都可以安装最新版本——<strong>反复配置环境治好了我的精神内耗</strong></p><p>如果你不想和我一样配置好几天环境的话，我推荐最好使用google colab，一键解决环境问题，下面会说到。</p><h3 id="2-2-HiFi-GAN简介"><a href="#2-2-HiFi-GAN简介" class="headerlink" title="2.2 HiFi-GAN简介"></a>2.2 HiFi-GAN简介</h3><p>简单说下，<strong>声码器的作用就是将梅尔频谱转换成语音信号</strong>，和上面是对应的。</p><p>为什么我们没有用上面Tacotron2的声码器呢，主要原因就是现在有很多更优秀的声码器供我们选择。</p><p>早期比较有名的声码器WaveNet，它是一种自回归卷积神经网络，合成的效果非常好可以说和人类发声非常相似，但有个致命的缺点——合成速度太慢。直到2020年项目作者开发了这套基于GAN（生成式对抗网络）的神经网络声码器，从作者的论文里可以找到，HiFi-GAN在GPU上可以以比实时速度快167.9倍的速度生成22.05 kHz的语音，在CPU上可以以比自回归模型快13.4倍的速度生成语音，这就是它的牛逼之处。</p><p>HiFi-GAN主要有一个生成器和两个判别器，具体结构就不说了，知道一下生成器和两个判别器是通过<strong>对抗学习</strong>的方法训练的，新增加了<strong>两个损失函数</strong>来提高训练的稳定性和提高模型的性能。有能力的小伙伴可以看原论文（HiFi-GAN: Generative Adversarial Networks for Efficient and High Fidelity Speech Synthesis）了解详情。</p><p>需要注意一下作者使用VCTK数据集进行实验，测试了3个模型（V1、V2和V3），简单来说V1是最优模型，作者发布的预训练模型以及相应的配置文件都是以V1模型为基础的。我在这篇博客使用的HiFi-GAN模型<strong>g_02500000</strong>就是作者的预训练模型，配置文件为<strong>config.json</strong>。</p><blockquote><p>HiFi-GAN预训练模型与配置文件下载地址：</p><p><a href="https://drive.google.com/drive/folders/1YuOoV3lO2-Hhn1F2HJ2aQ4S0LC1JdKLd">UNIVERSAL_V1 - Google 云端硬盘</a></p></blockquote><h3 id="2-2-注册谷歌colab和谷歌云盘"><a href="#2-2-注册谷歌colab和谷歌云盘" class="headerlink" title="2.2 注册谷歌colab和谷歌云盘"></a>2.2 注册谷歌colab和谷歌云盘</h3><p>训练模型是一件非常消耗算力的过程，因为涉及到图形处理，我们要用GPU进行加速。我的笔记本GPU非常拉跨，跑模型立马爆显存，因此我个人比较推荐白嫖谷歌colab上面的免费专业级GPU（Nvidia K80），免费用户只能用这一种GPU，至少比我的笔记本好多了。</p><p>需要注意下colab<strong>最大连接时长是12小时</strong>，12小时后会强行关闭GPU连接，因此需要注意下你是什么时候开始用GPU跑模型的，并且及时保存数据。关闭后要等待24小时才可以继续使用GPU，所以<strong>理论上可以用三个号不间断白嫖GPU资源</strong><del>（我特地申请了4个谷歌号）</del>，<strong>你只需要偶尔切换屏幕看下是否有谷歌的人机验证就行</strong>。</p><p>这里为什么还推荐谷歌云盘呢，是因为谷歌云盘可以挂载到colab上，这样调用文件就非常方便，及时保存不用担心数据丢失。谷歌云盘提供15GB的免费空间，如果保存模型比较频繁的话可能不够用，但是我们可以申请无限量的团队盘（<strong>共享云端硬盘</strong>）<del>薅羊毛必备</del>。</p><p><img src="https://www.shelven.com/tuchuang/20220909/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220909/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="2-3-使用colab训练模型-amp-合成语音"><a href="#2-3-使用colab训练模型-amp-合成语音" class="headerlink" title="2.3 使用colab训练模型 &amp; 合成语音"></a>2.3 使用colab训练模型 &amp; 合成语音</h3><p>我使用的colab笔记文件因为时间久远已经找不到出处了（后续如果找到会标注出来，向原作者致谢！），为了跑中文语音模型，自己也修改了很多参数和步骤，一一解释过于麻烦了….感兴趣的小伙伴可以看笔记文件。具体操作流程在底下的视频（<a href="https://www.bilibili.com/video/BV1TG411b7zR">或者点击此处看我的B站视频</a>）。</p><div class="video"><video controls preload><source src='https://www.shelven.com/tuchuang/20220909/80584935.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><blockquote><p>所有工程文件和资源如下：</p><p>Tacotron2+HiFiGAN打包 链接：<a href="https://pan.baidu.com/s/1ngCUvifQM6ETwuG-NFQeGA">https://pan.baidu.com/s/1ngCUvifQM6ETwuG-NFQeGA</a>  提取码：z6h3  </p><p>400条派蒙语音测试集 链接：<a href="https://pan.baidu.com/s/1g0C0Ck4P_BxdTgMirKRc-g">https://pan.baidu.com/s/1g0C0Ck4P_BxdTgMirKRc-g</a>  提取码：5ew1  </p><p>1800条派蒙语音训练集 链接：<a href="https://pan.baidu.com/s/1IDA4lppAJGHnophQAwkxNg">https://pan.baidu.com/s/1IDA4lppAJGHnophQAwkxNg</a>  提取码：f2xk </p></blockquote><p>需要提及一点，colab在2022年8月1号之后不再支持tensorflow1.5，请教大佬之后我将Tacotron2项目下超参数配置hparams.py改成如下即可正常运行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> text <span class="keyword">import</span> symbols</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hparams</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line">    <span class="comment">################################</span></span><br><span class="line">    <span class="comment"># Experiment Parameters        #</span></span><br><span class="line">    <span class="comment">################################</span></span><br><span class="line">    epochs = <span class="number">3</span>  <span class="comment">#500</span></span><br><span class="line">    iters_per_checkpoint = <span class="number">1000</span></span><br><span class="line">    seed = <span class="number">1234</span></span><br><span class="line">    dynamic_loss_scaling = <span class="literal">True</span></span><br><span class="line">    fp16_run = <span class="literal">False</span></span><br><span class="line">    distributed_run = <span class="literal">False</span></span><br><span class="line">    dist_backend = <span class="string">&quot;nccl&quot;</span></span><br><span class="line">    dist_url = <span class="string">&quot;tcp://localhost:54321&quot;</span></span><br><span class="line">    cudnn_enabled = <span class="literal">True</span></span><br><span class="line">    cudnn_benchmark = <span class="literal">True</span></span><br><span class="line">    ignore_layers = [<span class="string">&#x27;embedding.weight&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">################################</span></span><br><span class="line">    <span class="comment"># Data Parameters             #</span></span><br><span class="line">    <span class="comment">################################</span></span><br><span class="line">    load_mel_from_disk = <span class="literal">False</span>  <span class="comment">#实际上是区别用 numpy读wav ，还是用scipy读wav</span></span><br><span class="line">    training_files = <span class="string">&#x27;filelists/zh_audio_text_train_filelist.txt&#x27;</span></span><br><span class="line">    validation_files = <span class="string">&#x27;filelists/zh_audio_text_val_filelist.txt&#x27;</span></span><br><span class="line">    text_cleaners = [<span class="string">&#x27;english_cleaners&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">################################</span></span><br><span class="line">    <span class="comment"># Audio Parameters             #</span></span><br><span class="line">    <span class="comment">################################</span></span><br><span class="line">    max_wav_value = <span class="number">32768.0</span></span><br><span class="line">    sampling_rate = <span class="number">22050</span>   <span class="comment">#22050</span></span><br><span class="line">    filter_length = <span class="number">1024</span></span><br><span class="line">    hop_length = <span class="number">256</span></span><br><span class="line">    win_length = <span class="number">1024</span></span><br><span class="line">    n_mel_channels = <span class="number">80</span></span><br><span class="line">    mel_fmin = <span class="number">0.0</span></span><br><span class="line">    mel_fmax = <span class="number">8000.0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">################################</span></span><br><span class="line">    <span class="comment"># Model Parameters             #</span></span><br><span class="line">    <span class="comment">################################</span></span><br><span class="line">    n_symbols = <span class="built_in">len</span>(symbols)</span><br><span class="line">    symbols_embedding_dim = <span class="number">512</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Encoder parameters</span></span><br><span class="line">    encoder_kernel_size = <span class="number">5</span></span><br><span class="line">    encoder_n_convolutions = <span class="number">3</span></span><br><span class="line">    encoder_embedding_dim = <span class="number">512</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Decoder parameters</span></span><br><span class="line">    n_frames_per_step = <span class="number">1</span>  <span class="comment"># currently only 1 is supported</span></span><br><span class="line">    decoder_rnn_dim = <span class="number">1024</span></span><br><span class="line">    prenet_dim = <span class="number">256</span></span><br><span class="line">    max_decoder_steps = <span class="number">1000</span></span><br><span class="line">    gate_threshold = <span class="number">0.5</span></span><br><span class="line">    p_attention_dropout = <span class="number">0.1</span></span><br><span class="line">    p_decoder_dropout = <span class="number">0.1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Attention parameters</span></span><br><span class="line">    attention_rnn_dim = <span class="number">1024</span></span><br><span class="line">    attention_dim = <span class="number">128</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Location Layer parameters</span></span><br><span class="line">    attention_location_n_filters = <span class="number">32</span></span><br><span class="line">    attention_location_kernel_size = <span class="number">31</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Mel-post processing network parameters</span></span><br><span class="line">    postnet_embedding_dim = <span class="number">512</span></span><br><span class="line">    postnet_kernel_size = <span class="number">5</span></span><br><span class="line">    postnet_n_convolutions = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">################################</span></span><br><span class="line">    <span class="comment"># Optimization Hyperparameters #</span></span><br><span class="line">    <span class="comment">################################</span></span><br><span class="line">    use_saved_learning_rate = <span class="literal">False</span></span><br><span class="line">    learning_rate = <span class="number">1e-3</span></span><br><span class="line">    weight_decay = <span class="number">1e-6</span></span><br><span class="line">    grad_clip_thresh = <span class="number">1.0</span></span><br><span class="line">    batch_size = <span class="number">2</span>  <span class="comment">#64</span></span><br><span class="line">    mask_padding = <span class="literal">True</span>  <span class="comment"># set model&#x27;s padded outputs to padded values</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_hparams</span>(<span class="params">hparams_string=<span class="literal">None</span>, verbose=<span class="literal">False</span></span>):</span><br><span class="line">    <span class="keyword">return</span> hparams</span><br></pre></td></tr></table></figure><h3 id="2-4-注意事项"><a href="#2-4-注意事项" class="headerlink" title="2.4 注意事项"></a>2.4 注意事项</h3><ul><li><ol><li>训练的epoch不是越多越好，我个人经验epoch 超过400会发生<strong>过拟合</strong>，测试集loss会越来越大，当然这和数据集有着密切的关系。过拟合具体表现为合成语音有部分字无法发音。</li></ol></li><li><ol start="2"><li>每个epoch自动保存模型且会覆盖谷歌云盘的原文件，因此务必要<strong>隔一段时间保存到本地</strong>，以免错过最佳模型（或者你改代码，比如50 epoch保存一次）。</li></ol></li><li><ol start="3"><li>对于文本的处理，需要参考Tacotron 2项目下的text文件夹中的四个文件cleaners.py、cmudict.py、numbers.py和symbols.py，我是进行了最简单的设置，可以根据自己需要更改。</li></ol></li><li><ol start="4"><li>如果你原封不动用的我的工程文件，想在本地运行合成语音的推理程序，<strong>务必将cleaners选择english_cleaner</strong><del>（否则会出现古神的低语）</del>。</li></ol></li><li><ol start="5"><li>如果你是自己训练模型，个人认为筛选数据集非常重要，尽量把语气词和背景噪音去掉，否则效果会很差。</li></ol></li><li><ol start="6"><li>训练模型的参数可以根据GPU自行调整，batch_size是影响训练速度最大的因素，当你不确定显卡性能如何，请务必确保运行一段时间后显存没有炸（<strong>我就是运行以后直接睡觉了，醒来发现显存在运行半小时的时候炸了，我心态也炸了</strong>）</li></ol></li></ul><p>其实这个模型效果仍然不是很让我满意，有电音的问题可以用HiFi-GAN再训练过滤一下，我是直接用的官方预训练模型，因此效果会差一点。由于现在开学了要忙着搞开题，最近也没时间再优化模型了，以后有想法会继续补充。</p><p>我自己有考虑过将模型传到服务器，用服务器cpu运行推理，摆脱colab的限制，但是服务器不堪重负…一运行推理运存就炸…github上有不少前人做过纯cpu推理的GUI（<a href="https://github.com/luoyily/MoeTTS">比如MoeTTS</a>），亲测可行。</p><p>哦对了，我在做这个项目的时候，发现已经有人<strong>基于VITS</strong>做了同个游戏的端到端语音合成，甚至开发公布了API…不得不感慨这些大佬真的用心了，有API就意味着有更多的使用方式。我搭了个顺风车，通过搭建QQ机器人，写了个原神语音合成插件，<strong>效果是可以指定原神任何角色合成任意想说的语音并且发在QQ群里</strong>（没有什么技术含量，内行看个笑话），有空尽量更新出来吧！</p><blockquote><p>2022&#x2F;9&#x2F;10更新</p><p>已将插件更新至我的github仓库，地址<a href="https://github.com/Phantom-Aria/zhenxun_plugin_tts">Phantom-Aria&#x2F;zhenxun_plugin_tts: 真寻bot插件，原神角色语音合成tts (github.com)</a></p><p>由于代码写的比较幼稚，就不申请官方插件索引了</p><p><img src="https://www.shelven.com/tuchuang/20220909/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220909/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><ul><li><p>适配绪山真寻bot</p></li><li><p>功能：指定某原神角色合成想要说的话</p></li><li><p>指令：[角色名]说&#x2F;说过[文本]</p></li></ul><p>2022&#x2F;10&#x2F;7更新<br>由于原API已下线，此插件不再生效，后续再更新</p></blockquote></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;（接上篇博客）做完数据集，我们手里现在有训练集（train set）和测试集（test set）音频文件，以及对应的拼音文本，接下来就可以跑Tacotron2来训练模型了。&lt;/p&gt;
&lt;h2 id=&quot;2-训练模型-amp-合成语音&quot;&gt;&lt;a href=&quot;#2-训练模型-amp-</summary>
      
    
    
    
    <category term="深度学习" scheme="http://www.shelven.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="google colab" scheme="http://www.shelven.com/tags/google-colab/"/>
    
    <category term="Tacotron2" scheme="http://www.shelven.com/tags/Tacotron2/"/>
    
    <category term="HiFiGAN" scheme="http://www.shelven.com/tags/HiFiGAN/"/>
    
  </entry>
  
  <entry>
    <title>深度学习——语音合成tts笔记（上）</title>
    <link href="http://www.shelven.com/2022/09/08/a.html"/>
    <id>http://www.shelven.com/2022/09/08/a.html</id>
    <published>2022-09-07T19:15:04.000Z</published>
    <updated>2022-09-07T19:23:17.251Z</updated>
    
    <content type="html"><![CDATA[<p>两个月的暑假已经结束了，假期里自学了一点深度学习的内容，很多地方还是一知半解的，这里稍微记录一下。之前刷到一个很有意思的语音合成视频，抱着试试看的心态想自己做一个模型，于是给自己挖了一个大坑……涉及到深度学习的知识我还需要慢慢学，因此本篇博客重点还是记录下自己的踩坑操作<del>原理部分以后搞明白了再更新</del>。</p><p>总的来说，我通过拆包游戏客户端获得5.6万条语音文件，通过github上的一个声纹识别项目分离其中一个角色的语音文件。接着用百度的语音识别API将语音识别为文本后，人工校正一遍文本，然后转换为拼音+音标，以此制作语音数据训练集和测试集。基于开源项目Tacotron2训练角色语音模型，经历400 epoch后初步训练成型，最后基于HiFiGAN合成语音。整个后半段流程是在google colab上完成的，为了完成模型训练我申请了4个谷歌账号…不得不说<strong>白嫖的GPU真香~</strong></p><h2 id="1-制作数据集"><a href="#1-制作数据集" class="headerlink" title="1. 制作数据集"></a>1. 制作数据集</h2><div class="story post-story"><p>可以说整个项目大部分时间花费在整理数据集上，根据我自己的经验，数据集的语音长度在2秒-10秒之间效果最好，数量大约在2000条左右（为了涵盖尽可能多的汉字发音）。需要注意一点，不管拆包的原语音采样率如何，<strong>都要统一重采样到22050 hz</strong>，这是Tacotron2训练模型的要求。</p><h3 id="1-1-Extractor2-5-vgmstream-win拆包"><a href="#1-1-Extractor2-5-vgmstream-win拆包" class="headerlink" title="1.1 Extractor2.5 + vgmstream-win拆包"></a>1.1 Extractor2.5 + vgmstream-win拆包</h3><p>首先是这款国内游戏的拆包，所有角色的语音文件都在目录D:\Genshin Impact\Genshin Impact Game\YuanShen_Data\StreamingAssets\Audio\GeneratedSoundBanks\Windows\Chinese下，我们使用软件Extractor2.5进行音频文件拆包。</p><p>Extractor2.5是个非常好用的游戏解包工具，我们将所有pck源文件所在目录输进去（可以批量选中文件），确定输出目录，点击开始即可。</p><p><img src="https://www.shelven.com/tuchuang/20220908/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220908/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>运行结束之后可以看到这个游戏拆包有56958条语音文件…点击左下角反选，全部解压到自己的文件夹中。</p><p><img src="https://www.shelven.com/tuchuang/20220908/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220908/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>但是你会发现解压出来的wav文件无法打开，需要使用vgmstream进行解密和转码<a href="https://github.com/vgmstream/vgmstream/">（项目地址戳这里）</a>。</p><p>可以看到vgmstream-win文件夹只有一个可执行程序test.exe，其他都是dll库文件。</p><p><img src="https://www.shelven.com/tuchuang/20220908/3.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220908/3.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>这个test.exe是不能直接运行的，需要把程序拖到刚才拆包的语音文件上，但是几万条语音我们不可能一个个拖过去，因此我们<strong>在语音的文件夹下，</strong>写一个如下的批处理文件（命名为批处理.bat），运行批处理就可以了。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="keyword">for</span> /<span class="built_in">r</span> %%i <span class="keyword">in</span> (*.wav) <span class="keyword">do</span> (</span><br><span class="line">        <span class="string">&quot;D:\zhuomian\vgmstream-win\test.exe&quot;</span> <span class="string">&quot;%%~nxi&quot;</span>    <span class="comment">#路径改成你自己的，注意路径不能有中文</span></span><br><span class="line">)</span><br><span class="line">pause</span><br></pre></td></tr></table></figure><p>运行后生成的wav.wav文件就可以正常播放了，所有音频采样率均为48000Hz（采样率很重要，贯穿整个项目）。</p><p><img src="https://www.shelven.com/tuchuang/20220908/4.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220908/4.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="1-2-基于Tensorflow的声纹识别"><a href="#1-2-基于Tensorflow的声纹识别" class="headerlink" title="1.2 基于Tensorflow的声纹识别"></a>1.2 基于Tensorflow的声纹识别</h3><p>这部分内容来源于github（<a href="https://github.com/yeyupiaoling/VoiceprintRecognition-Tensorflow">项目地址戳这里</a>），作者基于tensorflow做了个声纹识别模型，通过把语音数据转换短时傅里叶变换的幅度谱，使用librosa计算音频的特征，以此来训练、评估模型。因为我只用到了对比部分，因此我下载了作者预训练的模型，以及对声纹对比文件<strong>infer_contrast.py</strong>做了修改。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> utils.reader <span class="keyword">import</span> load_audio</span><br><span class="line"><span class="keyword">from</span> utils.utility <span class="keyword">import</span> add_arguments, print_arguments</span><br><span class="line"><span class="keyword">import</span> os,shutil</span><br><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"></span><br><span class="line">os.environ[<span class="string">&#x27;TF_CPP_MIN_LOG_LEVEL&#x27;</span>]=<span class="string">&#x27;2&#x27;</span></span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser(description=__doc__)</span><br><span class="line">add_arg = functools.partial(add_arguments, argparser=parser)</span><br><span class="line">add_arg(<span class="string">&#x27;audio_path1&#x27;</span>,      <span class="built_in">str</span>,    <span class="string">&#x27;audio_db/Paimon.wav&#x27;</span>,          <span class="string">&#x27;标准的派蒙音频&#x27;</span>)   <span class="comment"># 自己准备的标准音频，下面两个也是</span></span><br><span class="line">add_arg(<span class="string">&#x27;audio_path2&#x27;</span>,      <span class="built_in">str</span>,    <span class="string">&#x27;audio_db/Klee.wav&#x27;</span>,          <span class="string">&#x27;标准的可莉音频&#x27;</span>)</span><br><span class="line">add_arg(<span class="string">&#x27;audio_path3&#x27;</span>,      <span class="built_in">str</span>,    <span class="string">&#x27;audio_db/Kokomi.wav&#x27;</span>,          <span class="string">&#x27;标准的心海音频&#x27;</span>)</span><br><span class="line">add_arg(<span class="string">&#x27;input_shape&#x27;</span>,      <span class="built_in">str</span>,    <span class="string">&#x27;(257, 257, 1)&#x27;</span>,          <span class="string">&#x27;数据输入的形状&#x27;</span>)</span><br><span class="line">add_arg(<span class="string">&#x27;threshold&#x27;</span>,        <span class="built_in">float</span>,   <span class="number">0.8</span>,                     <span class="string">&#x27;判断是否为同一个人的阈值&#x27;</span>)</span><br><span class="line">add_arg(<span class="string">&#x27;model_path&#x27;</span>,       <span class="built_in">str</span>,    <span class="string">&#x27;models1/infer_model.h5&#x27;</span>,  <span class="string">&#x27;预测模型的路径&#x27;</span>)    <span class="comment"># 作者的预训练模型</span></span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载模型</span></span><br><span class="line">model = tf.keras.models.load_model(args.model_path,<span class="built_in">compile</span>=<span class="literal">False</span>)</span><br><span class="line">model = tf.keras.models.Model(inputs=model.<span class="built_in">input</span>, outputs=model.get_layer(<span class="string">&#x27;batch_normalization&#x27;</span>).output)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据输入的形状</span></span><br><span class="line">input_shape = <span class="built_in">eval</span>(args.input_shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测音频</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">infer</span>(<span class="params">audio_path</span>):</span><br><span class="line">    data = load_audio(audio_path, mode=<span class="string">&#x27;test&#x27;</span>, spec_len=input_shape[<span class="number">1</span>])</span><br><span class="line">    data = data[np.newaxis, :]</span><br><span class="line">    feature = model.predict(data)</span><br><span class="line">    <span class="keyword">return</span> feature</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 预测的两个音频文件</span></span><br><span class="line">    feature1 = infer(args.audio_path1)[<span class="number">0</span>]</span><br><span class="line">    feature2 = infer(args.audio_path2)[<span class="number">0</span>]</span><br><span class="line">    feature3 = infer(args.audio_path3)[<span class="number">0</span>]</span><br><span class="line">    datapath = <span class="string">&quot;./test2&quot;</span>        <span class="comment">#上传到集群的解包音频文件位置</span></span><br><span class="line">    dirs = os.listdir(datapath)</span><br><span class="line">    <span class="keyword">for</span> audio <span class="keyword">in</span> dirs:</span><br><span class="line">        personx = <span class="string">&#x27;test2/%s&#x27;</span> % (audio)</span><br><span class="line">        featurex = infer(personx)[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 对角余弦值</span></span><br><span class="line">        dist1 = np.dot(feature1, featurex) / (np.linalg.norm(feature1) * np.linalg.norm(featurex))</span><br><span class="line">        <span class="keyword">if</span> dist1 &gt; args.threshold:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;%s 符合派蒙模型，相似度为：%f&quot;</span> % (personx, dist1))</span><br><span class="line">            shutil.move(<span class="string">&quot;./test2/%s&quot;</span> % (audio),<span class="string">&quot;./dataset/Paimon&quot;</span>)      <span class="comment"># 移动音频文件，路径自选</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dist2 = np.dot(feature2, featurex) / (np.linalg.norm(feature2) * np.linalg.norm(featurex))</span><br><span class="line">            <span class="keyword">if</span> dist2 &gt; args.threshold:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;%s 符合可莉模型，相似度为：%f&quot;</span> % (personx, dist2))</span><br><span class="line">                shutil.move(<span class="string">&quot;./test2/%s&quot;</span> % (audio),<span class="string">&quot;./dataset/Klee&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dist3 = np.dot(feature3, featurex) / (np.linalg.norm(feature3) * np.linalg.norm(featurex))</span><br><span class="line">                <span class="keyword">if</span> dist3 &gt; args.threshold:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;%s 符合心海模型，相似度为：%f&quot;</span> % (personx, dist3))</span><br><span class="line">                    shutil.move(<span class="string">&quot;./test2/%s&quot;</span> % (audio),<span class="string">&quot;./dataset/Kokomi&quot;</span>)</span><br><span class="line">        gc.collect()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>需要注意一点，为了提高识别的准确性，这个项目要求的语音长度不能低于1.7s，因此我用ffmpeg将所有长度低于2s的短音频全部过滤了（这里不赘述实现过程）。</p><p>之后将三个角色的标准语音分别放在audio_db文件夹下，识别的原理是通过预测函数提取三个角色的音频特征值，对5.6万条音频分别比对三个角色的标准音频特征，求对角余弦值，在多次试验后选择了对角余弦值0.8，作为判断两条语音是否为同一个人的阈值。</p><p>直接在集群上运行infer_contrast.py，相似度高于0.8的音频则会被挑选到对应的dataset文件夹中。</p><p><img src="https://www.shelven.com/tuchuang/20220908/5.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220908/5.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>实际上这个声纹识别的结果仅能作为参考，不能保证百分百正确，原因有很多：</p><ul><li><p>1.声优都是怪物，一个人用好多相似的声线配了不同角色，导致无法分辨出不同角色的语音（假阳性）。</p></li><li><p>2.一句话的语调不同会表现出音频特征值不同，而这个算法下会导致对角余弦值偏小，从而判断成发声的是不同的人（假阴性）。</p></li></ul><p>因此识别的结果需要进行人工校正，<strong>也就是需要自己听一遍到底是不是这个角色的语音</strong>&#x3D; &#x3D;（最好同下一步一起进行，省时间）</p><p>这里我验证并分离出2293条长度2秒以上的派蒙语音，以其中的1820条作为训练集，473条作为测试集。后续训练模型用到的时候会说。</p><h3 id="1-3-基于百度语音识别API的语音转文本"><a href="#1-3-基于百度语音识别API的语音转文本" class="headerlink" title="1.3 基于百度语音识别API的语音转文本"></a>1.3 基于百度语音识别API的语音转文本</h3><p>光有语音还不行，我们要训练模型就要有对应的<strong>文本</strong>。很多单机游戏（比如柚子社的游戏）有解包脚本，可以完整解出所有资源，其中就包括语音文件和对应的文本。但是解包有客户端的游戏不同，比如这款游戏发布不同版本的客户端，文件结构就会发生很大的改变，导致以前做的文件定位统统失效，而且包括文本在内的很多文件也是加密的，无法解出（也可能是我个人问题）。</p><p>因此，我们还是需要借助语音识别的软件将语音转成文本。这里涉及到另一个问题，不管多么强大的语音转文字技术，都是在已有的数据集基础上不断训练模型而产生的，游戏中有相当多新造的词（比如中二台词，游戏人名，地点等等），这在转化文本过程中是肯定无法百分百准确的，甚至会“空耳”产生歧义。</p><p>因此转文本这一步结束后需要人工校准，至少保证读音正确。</p><p>我是在<strong>百度AI开放平台</strong>申请了语音识别API，每个账号有200万次免费调用额度，但是限制并发数2<del>（没办法，既然是白嫖就忍忍）</del>。</p><p><img src="https://www.shelven.com/tuchuang/20220908/6.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220908/6.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>查看官方放在github上的demo，改一改就可以调用API了（每当问我不会使用的时候都是看demo然后魔改2333）。</p><p>我这里以官网提供的<strong>asr_raw.py</strong>为例，直接下载，并修改成如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">IS_PY3 = sys.version_info.major == <span class="number">3</span>        <span class="comment"># 判断你用的是python3.x还是2.x版本，推荐还是用3.x</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> IS_PY3:</span><br><span class="line">    <span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line">    <span class="keyword">from</span> urllib.request <span class="keyword">import</span> Request</span><br><span class="line">    <span class="keyword">from</span> urllib.error <span class="keyword">import</span> URLError</span><br><span class="line">    <span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlencode</span><br><span class="line">    timer = time.perf_counter</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">import</span> urllib2</span><br><span class="line">    <span class="keyword">from</span> urllib2 <span class="keyword">import</span> urlopen</span><br><span class="line">    <span class="keyword">from</span> urllib2 <span class="keyword">import</span> Request</span><br><span class="line">    <span class="keyword">from</span> urllib2 <span class="keyword">import</span> URLError</span><br><span class="line">    <span class="keyword">from</span> urllib <span class="keyword">import</span> urlencode</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> sys.platform == <span class="string">&quot;win32&quot;</span>:</span><br><span class="line">        timer = time.clock</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># On most other platforms the best timer is time.time()</span></span><br><span class="line">        timer = time.time</span><br><span class="line"></span><br><span class="line">API_KEY = <span class="string">&#x27;XXXXXXXX&#x27;</span>    <span class="comment"># 改成你自己的，下面一条一样</span></span><br><span class="line">SECRET_KEY = <span class="string">&#x27;XXXXXXXX&#x27;</span> </span><br><span class="line">FORMAT = <span class="string">&quot;wav&quot;</span>;  <span class="comment"># 文件后缀只支持 pcm/wav/amr 格式</span></span><br><span class="line">CUID = <span class="string">&#x27;123456PYTHON&#x27;</span>;</span><br><span class="line">RATE = <span class="number">16000</span>;  <span class="comment"># 固定值，这里一定一定要注意采样率</span></span><br><span class="line">DEV_PID = <span class="number">1537</span>;  <span class="comment"># 1537 表示识别普通话，使用输入法模型。根据文档填写PID，选择语言及识别模型</span></span><br><span class="line">ASR_URL = <span class="string">&#x27;http://vop.baidu.com/server_api&#x27;</span></span><br><span class="line">SCOPE = <span class="string">&#x27;audio_voice_assistant_get&#x27;</span>  <span class="comment"># 有此scope表示有asr能力，没有请在网页里勾选，非常旧的应用可能没有</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DemoError</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;  TOKEN start &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">TOKEN_URL = <span class="string">&#x27;http://aip.baidubce.com/oauth/2.0/token&#x27;</span></span><br><span class="line"><span class="comment"># 核对token</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fetch_token</span>():</span><br><span class="line">    params = &#123;<span class="string">&#x27;grant_type&#x27;</span>: <span class="string">&#x27;client_credentials&#x27;</span>,</span><br><span class="line">              <span class="string">&#x27;client_id&#x27;</span>: API_KEY,</span><br><span class="line">              <span class="string">&#x27;client_secret&#x27;</span>: SECRET_KEY&#125;</span><br><span class="line">    post_data = urlencode(params)</span><br><span class="line">    <span class="keyword">if</span> (IS_PY3):</span><br><span class="line">        post_data = post_data.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    req = Request(TOKEN_URL, post_data)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        f = urlopen(req)</span><br><span class="line">        result_str = f.read()</span><br><span class="line">    <span class="keyword">except</span> URLError <span class="keyword">as</span> err:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;token http response http code : &#x27;</span> + <span class="built_in">str</span>(err.code))</span><br><span class="line">        result_str = err.read()</span><br><span class="line">    <span class="keyword">if</span> (IS_PY3):</span><br><span class="line">        result_str = result_str.decode()</span><br><span class="line"></span><br><span class="line">    result = json.loads(result_str)</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&#x27;access_token&#x27;</span> <span class="keyword">in</span> result.keys() <span class="keyword">and</span> <span class="string">&#x27;scope&#x27;</span> <span class="keyword">in</span> result.keys()):</span><br><span class="line">        <span class="keyword">if</span> SCOPE <span class="keyword">and</span> (<span class="keyword">not</span> SCOPE <span class="keyword">in</span> result[<span class="string">&#x27;scope&#x27;</span>].split(<span class="string">&#x27; &#x27;</span>)):  <span class="comment"># SCOPE = False 忽略检查</span></span><br><span class="line">            <span class="keyword">raise</span> DemoError(<span class="string">&#x27;scope is not correct&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> result[<span class="string">&#x27;access_token&#x27;</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> DemoError(<span class="string">&#x27;MAYBE API_KEY or SECRET_KEY not correct: access_token or scope not found in token response&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;  TOKEN end &quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    token = fetch_token()</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    httpHandler = urllib2.HTTPHandler(debuglevel=1)</span></span><br><span class="line"><span class="string">    opener = urllib2.build_opener(httpHandler)</span></span><br><span class="line"><span class="string">    urllib2.install_opener(opener)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> audio <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">1825</span>):</span><br><span class="line">        AUDIO_FILE = <span class="built_in">str</span>(<span class="string">&#x27;/public/home/wlxie/test4voice/baiduyun/training_16K/train&#x27;</span> + <span class="built_in">str</span>(audio) + <span class="string">&#x27;.wav&#x27;</span>)     <span class="comment">#路径改成自己的</span></span><br><span class="line">        speech_data = []</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(AUDIO_FILE, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> speech_file:</span><br><span class="line">            speech_data = speech_file.read()</span><br><span class="line">        length = <span class="built_in">len</span>(speech_data)</span><br><span class="line">        <span class="keyword">if</span> length == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> DemoError(<span class="string">&#x27;file %s length read 0 bytes&#x27;</span> % AUDIO_FILE)</span><br><span class="line"></span><br><span class="line">        params = &#123;<span class="string">&#x27;cuid&#x27;</span>: CUID, <span class="string">&#x27;token&#x27;</span>: token, <span class="string">&#x27;dev_pid&#x27;</span>: DEV_PID&#125;</span><br><span class="line">        params_query = urlencode(params);</span><br><span class="line"></span><br><span class="line">        headers = &#123;</span><br><span class="line">            <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;audio/&#x27;</span> + FORMAT + <span class="string">&#x27;; rate=&#x27;</span> + <span class="built_in">str</span>(RATE),</span><br><span class="line">            <span class="string">&#x27;Content-Length&#x27;</span>: length</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        url = ASR_URL + <span class="string">&quot;?&quot;</span> + params_query</span><br><span class="line">        req = Request(ASR_URL + <span class="string">&quot;?&quot;</span> + params_query, speech_data, headers)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            begin = timer()</span><br><span class="line">            f = urlopen(req)</span><br><span class="line">            result_str = f.read()</span><br><span class="line">        <span class="keyword">except</span>  URLError <span class="keyword">as</span> err:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;asr http response http code : &#x27;</span> + <span class="built_in">str</span>(err.code))</span><br><span class="line">            result_str = err.read()</span><br><span class="line">    <span class="comment">#输出转文字结果</span></span><br><span class="line">        result_str = result_str.decode()</span><br><span class="line">        result = json.loads(result_str)</span><br><span class="line">        res = result[<span class="string">&#x27;result&#x27;</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;train&#x27;</span> +<span class="built_in">str</span>(audio) + <span class="string">&#x27;.wav&#x27;</span> + <span class="string">&#x27;识别结果：&#x27;</span> + res)</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;training_1800_result.txt&quot;</span>, <span class="string">&quot;a&quot;</span>) <span class="keyword">as</span> of:</span><br><span class="line">            of.write(<span class="string">&#x27;train&#x27;</span> + <span class="built_in">str</span>(audio) + <span class="string">&#x27;.wav&#x27;</span> + <span class="string">&quot;|&quot;</span> + res + <span class="string">&#x27;\n&#x27;</span>)  <span class="comment"># 转成“路径|文本”的格式，方便人工校准</span></span><br><span class="line">    gc.collect()</span><br></pre></td></tr></table></figure><p>这里也有一个<strong>大坑</strong>，这个语音转文本API要求音源采样率必须是16000Hz，前面说到我们解包得到的音频是48000Hz，而且后面训练模型要求采样率为22050Hz！也就是说如果我们现在把所有音频转成16000Hz的话，势必会对训练模型产生影响（高频可以转低频，但是低频转高频语音质量不会有一丁点儿的提升），因此我这边用拆包音频做了两个备份，一个是转成16000Hz，放在training_16K文件下，专门用于语音转文本；一个是转成22050Hz，放在training_22K文件下，专门用于后续训练模型。重采样仍然用我们的老朋友<strong>ffmpeg</strong>，因为就一行命令的事这里也不赘述了。</p><p>前面也说到这个API并发数限制为2，经常是用着用着就断开了（也是我比较笨比，不会写限制并发数发送请求的代码），所以我将训练集的1825个语音写了个小脚本，重命名为train1.wav-train1825.wav，所以才用了for循环一句一句调用API转文本，到哪个地方断了也可以迅速找出来并继续。</p><p>总之效果如下，训练集1825条语音和测试集473条语音全部转换为文本，且能清晰地看到一一对应关系：</p><p><img src="https://www.shelven.com/tuchuang/20220908/7.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220908/7.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>一眼看效果还不错，为了保证准确率，将txt文件传回本地，<strong>人工校正吧</strong>（语气词部分本来是要去除的，但是工作量会比较大放弃了，起码要保证发音没问题）。</p><p>这个数据集因为不是标准的普通话数据集（标准数据集可以找标贝，就有那种纯合成的标准普通话），声优也有特殊的口癖和发音，额，这是无法避免的。</p><h3 id="1-4-基于pypinyin的汉字转拼音"><a href="#1-4-基于pypinyin的汉字转拼音" class="headerlink" title="1.4 基于pypinyin的汉字转拼音"></a>1.4 基于pypinyin的汉字转拼音</h3><p>因为后面训练模型的Tacotron2是基于英文模型开发出来的，我们无法直接用中文文本训练。一个行之有效的方法是将中文转换成拼音+数字声调的方式，这样数据就可以顺利地被载入。</p><p>这里推荐一下pypinyin模块，该模块安装比较方便（直接用pip），也是个非常实用和高质量的汉字拼音转换工具！</p><p>我将人工校准后的txt文件传回集群，去掉前面的“|”之前的内容，再写个小脚本<strong>将所有标点符号删除</strong>，接着汉字转拼音，这里就记录下pypinyin的用法吧。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pypinyin <span class="keyword">import</span> lazy_pinyin, Style</span><br><span class="line"><span class="keyword">import</span> linecache</span><br><span class="line"></span><br><span class="line">output_file = <span class="built_in">open</span>(<span class="string">&quot;/public/home/wlxie/test4voice/baiduyun/training_pinyin.txt&quot;</span>,<span class="string">&quot;w&quot;</span>)</span><br><span class="line">readlist = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">1821</span>))  <span class="comment"># 人工校准的时候去掉了4条不是该角色的音频</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> readlist:</span><br><span class="line">    text = linecache.getline(<span class="string">&quot;/public/home/wlxie/test4voice/baiduyun/cheat_training.txt&quot;</span>,i)        </span><br><span class="line">    text = <span class="string">&quot; &quot;</span>.join(lazy_pinyin(text, style=Style.TONE3))</span><br><span class="line">    output_file.write(text)</span><br></pre></td></tr></table></figure><p>然后将拼音前按照Tacotron2训练的要求，加上了音频文件对应的colab路径（为什么用这个路径我下一篇博客再说明），以及每句话末尾加个英文的句号，最后输出结果如下：</p><p><img src="https://www.shelven.com/tuchuang/20220908/8.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220908/8.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>同样的方法对测试集也转拼音，这样前期的数据集文件就制作完成啦！接下来就是重点——训练模型。下篇博客接着说完。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;两个月的暑假已经结束了，假期里自学了一点深度学习的内容，很多地方还是一知半解的，这里稍微记录一下。之前刷到一个很有意思的语音合成视频，抱着试试看的心态想自己做一个模型，于是给自己挖了一个大坑……涉及到深度学习的知识我还需要慢慢学，因此本篇博客重点还是记录下自己的踩坑操作&lt;d</summary>
      
    
    
    
    <category term="深度学习" scheme="http://www.shelven.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="拆包" scheme="http://www.shelven.com/tags/%E6%8B%86%E5%8C%85/"/>
    
    <category term="声纹识别" scheme="http://www.shelven.com/tags/%E5%A3%B0%E7%BA%B9%E8%AF%86%E5%88%AB/"/>
    
    <category term="语音转文本" scheme="http://www.shelven.com/tags/%E8%AF%AD%E9%9F%B3%E8%BD%AC%E6%96%87%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>frp内网穿透配置笔记</title>
    <link href="http://www.shelven.com/2022/07/13/a.html"/>
    <id>http://www.shelven.com/2022/07/13/a.html</id>
    <published>2022-07-12T19:55:04.000Z</published>
    <updated>2022-07-12T19:57:29.299Z</updated>
    
    <content type="html"><![CDATA[<p>过一段时间要到校外学习，而学校的资源只能在校园内网下才能使用（登录集群可以看到登录ip是10开头的A类地址，无法公网ip访问）。为了方便在校外访问校园内网的集群，我手里正好也有一个备案过的服务器和域名，于是自己用frp搭建了一个反向代理服务器，穿透了校园内网，这里记录下自己搭建过程。</p><p>其实一开始我打算直接用开发比较成熟的花生壳软件做内网穿透，但是不知道怎么回事，显示连接成功但是ssh远程登陆不上，后来就放弃了，最后决定用自己的服务器和域名穿透<del>（后来我还申请了花生壳学生版，羊毛先薅到以后再说用不用）</del>。</p><p><img src="https://www.shelven.com/tuchuang/20220713/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220713/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>frp是一个go语言写的开源内网穿透和反向代理软件，支持tcp, udp, http, https等协议，支持linux、mac、windows平台，操作也很方便，非常适合我这种小白。</p><h2 id="1-下载frp"><a href="#1-下载frp" class="headerlink" title="1 下载frp"></a>1 下载frp</h2><div class="story post-story"><p>源代码作者发布在github，<a href="https://github.com/fatedier/frp">点击这里</a>。</p><p>选择最新的release版本，注意frp在service端和client端有两个不同的程序和配置文件，<strong>service端是你想要做反向代理的有公网ip的服务器，client端是处于内网之下的你想要穿透的服务器</strong>。</p><p>service端和client端一定要<strong>同一个版本</strong>。这里我的service端和client端都是linux操作系统，所以我直接下载了linux_arm64.tar.gz（我想顺便远程操控实验室电脑，所以也下载了windows版本，默认windows远程桌面端口号是3389，这个以后再说）。</p><p><img src="https://www.shelven.com/tuchuang/20220713/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220713/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>将tar.gz文件传到两台服务器上，tar -zxvf解压就可以使用了<del>（不需要编译，就是这么简单）</del>。</p><p><strong>在service端保留frps程序和相应的ini配置文件，在client端保留frpc程序和相应的ini配置文件</strong>（主要防止自己搞错）。配置文件有两种，我们可以选择其中一个；ini是最简单的配置文件，full.ini配置文件中记录了全部配置参数和英文解释，需要的时候可以自己根据情况修改。</p></div><h2 id="2-修改配置文件"><a href="#2-修改配置文件" class="headerlink" title="2 修改配置文件"></a>2 修改配置文件</h2><div class="story post-story"><p>网上的教程很多，full.ini也记载了全部的配置方法，我这里只记录下我自己的配置（敏感信息就不展示了）。</p><h3 id="2-1-service端配置"><a href="#2-1-service端配置" class="headerlink" title="2.1 service端配置"></a>2.1 service端配置</h3><p>frps.ini配置文件修改如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_port = 7000    # frp监听的端口，默认7000，可改</span><br><span class="line">bind_udp_port = 7400    # UDP通讯端口，可不设置，用于点对点穿透</span><br><span class="line">token = xxxxxxxx    # 安全考虑需要设置口令，client端需要用到</span><br><span class="line"></span><br><span class="line">dashboard_port = 7500   # frp管理端口，可改</span><br><span class="line">dashboard_user = xxxx   # 管理端口认证的用户名，用于身份识别，自己设置</span><br><span class="line">dashboard_pwd = xxxx    # 管理端口认证的密码，用于身份识别，自己设置</span><br><span class="line">enable_prometheus = true</span><br><span class="line"></span><br><span class="line">subdomain_host = xxx.xxx.xxx    # 设置子域名，主要方便登录管理界面。不用ip地址，用域名+端口的方式直接访问</span><br><span class="line"></span><br><span class="line">log_file = /usr/local/frp/frps.log  # frp日志配置，这里是记录3天的日志信息</span><br><span class="line">log_level = info</span><br><span class="line">log_max_days = 3</span><br></pre></td></tr></table></figure><p>子域名设置主要是方便登录管理界面，不是必须的，反正我记不住服务器一长串ip地址…<strong>这个域名需要DNS解析后才能使用</strong></p><p>后台不挂起运行frps：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./frps -c frps.ini &amp;</span><br></pre></td></tr></table></figure><p>这个时候我们是看不到运行日志的，打开刚刚设置的frps.log文件</p><p><img src="https://www.shelven.com/tuchuang/20220713/3.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220713/3.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>几个设置端口都监听成功，最后也显示frps started successfully说明开启成功。</p><h3 id="2-2-client端配置"><a href="#2-2-client端配置" class="headerlink" title="2.2 client端配置"></a>2.2 client端配置</h3><p>frpc.ini配置文件修改如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = xxx.xxx.xxx.xxx   # 填写你的service端服务器公网ip，这里我写我的云服务器ip</span><br><span class="line">server_port = 7000  # 前面设置的frp监听端口，需要保持一致</span><br><span class="line">token = xxxxxxxx    # 前面设置的口令</span><br><span class="line"></span><br><span class="line">[ssh]   # 这里只演示ssh端口的映射，其他参考frpc_full.ini</span><br><span class="line">type = tcp  # tcp协议</span><br><span class="line">local_ip = 127.0.0.1    # 这个地址代表本机</span><br><span class="line">local_port = 22     # ssh端口，默认22，由你ssh登录的client服务器决定</span><br><span class="line">remote_port = 6000  # 映射的service端服务器的端口，自己定义</span><br></pre></td></tr></table></figure><p>注意下remote_port这个设置的是service端也就是云服务器的端口，通过这个端口访问client端的22端口，也就是端口映射。</p><p>同样的后台不挂起运行frpc：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./frpc -c frpc.ini &amp;</span><br></pre></td></tr></table></figure><p>打开nohup的输出文件：</p><p><img src="https://www.shelven.com/tuchuang/20220713/4.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220713/4.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>显示login to service success表示和service端连接成功。</p><p><strong>全部设置完成后，理论上我就可以通过云服务器的主机地址+6000端口，通过ssh方式访问学校内网中的集群主机地址+22端口了。</strong></p><p><strong>但是我的云服务器比较特殊，还需要进行一步开放防火墙端口。</strong></p></div><h2 id="3-开放serviced服务器端口"><a href="#3-开放serviced服务器端口" class="headerlink" title="3 开放serviced服务器端口"></a>3 开放serviced服务器端口</h2><div class="story post-story"><p>如果在2.2这一步配置之后一直连不上service端，<strong>那极有可能是service服务器的端口没有开放</strong>。</p><p>特别注意一点，如果是买的云服务器（比如我买的腾讯云服务器），<strong>不仅要在控制台页面开放端口，还需要在linux云服务器开放端口</strong>。举个例子，我们这里用到的云服务器端口是7000，7400，7500和6000，首先要在控制台防火墙页面 开放这几个端口。</p><p><img src="https://www.shelven.com/tuchuang/20220713/6.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220713/6.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>然后在云服务器上打开防火墙，开放对应端口：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">systemctl start firewalld   # 打开防火墙</span><br><span class="line">firewall-cmd --permanent --add-port=7000/tcp    # 永久开放指定的7000端口（其他端口同理）</span><br><span class="line">firewall-cmd --reload   # 重启防火墙</span><br><span class="line">firewall-cmd --list-ports   # 查看防火墙开放的所有端口</span><br></pre></td></tr></table></figure><p>注意一下防火墙端口设定完成后，<strong>需要重载防火墙才会生效</strong>。</p><p>我们把自己云服务器的防火墙和端口配置好就行<del>（学校集群你不是root用户你也配置不了，一般来说也不会设置防火墙）</del>。</p></div><h2 id="4-frp管理面板"><a href="#4-frp管理面板" class="headerlink" title="4 frp管理面板"></a>4 frp管理面板</h2><div class="story post-story"><p>有两种方式可以访问：</p><ul><li><ol><li>service端服务器  ip地址:端口号</li></ol></li><li><ol start="2"><li>设置子域名后可以用  子域名:端口号</li></ol></li></ul><p>用户名密码认证后，可以看到如下页面：</p><p><img src="https://www.shelven.com/tuchuang/20220713/8.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220713/8.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>主要就是看一下连接数量，连接方式，产生的流量等等，具体就不细说了。</p><p>开个手机热点，用xshell登陆一下集群，发现显示的登录ip变成了localhost，而不是10开头的A类地址了，说明反向代理成功。</p><p><img src="https://www.shelven.com/tuchuang/20220713/9.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220713/9.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>连接速度非常快，而且稳定！以后登录集群就再也不用校园网啦！</p></div><h2 id="5-写在最后"><a href="#5-写在最后" class="headerlink" title="5 写在最后"></a>5 写在最后</h2><div class="story post-story"><p>这种用外网服务器做反向代理服务器，通过端口转发的方式访问内网服务器还是有一定安全风险的，该开防火墙开防火墙，小心驶得万年船。</p><p>还有，这种方法也有个缺点。打个比方如果你在校外，而<strong>学校服务器因为某种不可抗力重启了</strong><del>（比如停电，这在新疆真的太常见了）</del>这就相当于你挂在后台nohup的程序被强制杀掉了。等到管理员重启后，client端的frpc程序就需要再执行一次才能生效，这个时候就只能拜托有学校集群账号的人帮你在后台执行nohup，你才能从外网访问集群。</p><p>要应对这种情况，最简单的是你写个开机自启动脚本执行frpc，但是你没有root权限是不可行的…或者你让集群管理员给你su权限，这一般来说也不太可能…如何完美解决这个问题还有待研究</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;过一段时间要到校外学习，而学校的资源只能在校园内网下才能使用（登录集群可以看到登录ip是10开头的A类地址，无法公网ip访问）。为了方便在校外访问校园内网的集群，我手里正好也有一个备案过的服务器和域名，于是自己用frp搭建了一个反向代理服务器，穿透了校园内网，这里记录下自己</summary>
      
    
    
    
    <category term="网络相关" scheme="http://www.shelven.com/categories/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="内网穿透" scheme="http://www.shelven.com/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    
    <category term="反向代理" scheme="http://www.shelven.com/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>blastn &amp; blastp 寻找同源基因</title>
    <link href="http://www.shelven.com/2022/07/05/a.html"/>
    <id>http://www.shelven.com/2022/07/05/a.html</id>
    <published>2022-07-05T11:25:26.000Z</published>
    <updated>2022-07-05T11:35:03.990Z</updated>
    
    <content type="html"><![CDATA[<p>今天接到一个任务，大致内容是在一个植物的全长转录组数据中找拟南芥的三个同源基因。简简单单的描述，我的想法也很简单，直接找基因的<strong>CDS序列做blastn</strong>比对就完事了，结果却没有那么顺利…记录一下踩的坑和解决办法。</p><h2 id="1-blastn寻找同源基因"><a href="#1-blastn寻找同源基因" class="headerlink" title="1 blastn寻找同源基因"></a>1 blastn寻找同源基因</h2><div class="story post-story"><p>三个基因TAIR号是AT4G28590、AT2G43010和AT2G34640，从全长转录组测序报告中，我找到了非冗余的转录本序列文件CD-hit-est.fasta，首先第一步就是本地建核酸序列库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">makeblastdb -in CD-hit-est.fasta -dbtype nucl -input_type fasta -out Kc</span><br></pre></td></tr></table></figure><p>因为给的是TAIR号，所以直接去<a href="%5Bwww.arabidopsis.org%5D(https://www.arabidopsis.org/)">TRIR</a>官网查找相应基因的CDS序列做比对</p><p><img src="https://www.shelven.com/tuchuang/20220705/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220705/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>手动创建query gene的fa序列文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim RCB_cds.fna</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">手动创建fa文件</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">AT4G28590</span></span><br><span class="line">ATGAGTTTCTTCGCTGTTGCTTGCTCCGCGCCAAGATCTTCTATGCTTCTCACCGGCTTGAATTCGAGCTTCTCTGATATGCATCGCAGCCCACTATTTGTTTTCCCGGTGACTATATCATCCCGGAGCGTGAAACGCTTCGCCGCTGTTTCGTCTGATTCCGTACTAGACCCTGAATCCAAAAATCAAACTCGGTCCCGTCGCAAAAATAAGGAAGCAGTTACGCCAATTGCTGAAACCGAGAACAATGAAAAGTTTCCGACAAAGGTCCCGCGTAAATCGAAGCGTGGGCGGCGGAGTGAAGCAGACGCTGTGGAAGATTACGTGAGAAGCTCCCTCGAGCGTACTTTCTCCACCATAAAGGAGCAGAATCCGGAGGTTTTTGAGAACAAGGAGAAGGCGAATTTCATCAAAGACAGAGGCGTTGATGAAGAAGAGGAAGAAGAAGAAGAGATGGTGGTGGAAGAGGAAGATCCAGATTGGCCAGTAGATACAGACGTTGGATGGGGAATCAAAGCTTCGGAGTATTTCGATACACATCCAATCAAAAACGTGGTTGGAGATGATGGGAGTGAGATTGATTGGGAAGGTGAGATTGATGATAGTTGGGTCAAGGAGATCAATTGTTTGGAATGGGAAAGCTTTGCTTTTCATCCTAGTCCACTCGTTGTCCTTGTATTCGAGCGATACAAAAGAGCTAGTGATAACTGGAAGACATTGAAGGAGCTTGAGAAAGCTATCAAAGTTTATTGGGATGCGAAAGATCGATTACCTCCACGGGCGGTTAAGATTGACCTGAACATCGAGACAGATTTGGCATATGCTCTTAAAGCTAAGGAATGCCCACAGATTCTCTTCTTACGCGGAAACCGGATTCTGTACAGGGAGAAAGACTTTCGCACGGCGGATGAATTGGTTCATATGATTGCGCATTTCTACTATAAAGCGAAGAGGCCTTCGTGTGTCGACAAGGCTAATGTAACCCCGTACTGTTAG</span><br></pre></td></tr></table></figure><p>blastn比对</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blastn -query RCB_cds.fna -out RCB_blastn_Kc.out -db Kc -outfmt 6 -evalue 1e-5 -num_threads 4</span><br></pre></td></tr></table></figure><p>RCB_blastn_Kc.out是blast的m8格式输出文件，找到匹配长度最长的（也就是第一条）subject gene id，回到非冗余转录本，找到subject gene在哪行，最后找出转录本序列。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">找到subject gene所在行（subject gene <span class="built_in">id</span>中有所在行数，这里验证下）</span></span><br><span class="line">cat CD-hit-est.fasta | grep -n &quot;Kc-zong_1-10k_transcript/10791&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">提取序列</span></span><br><span class="line">awk &#x27;NR&gt;=10719 &amp;&amp; NR&lt;=10720&#x27; CD-hit-est.fasta</span><br></pre></td></tr></table></figure><p><img src="https://www.shelven.com/tuchuang/20220705/3.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220705/3.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><strong>紧接着出现一个问题</strong>：AT2G43010和AT2G34640这两个基因无法通过blastn比对找到同源序列，evalue值不管放到多宽都比对不上。</p><p>因为这个植物在NCBI上没有参考基因组，我们课题组也只测了全长转录组而没有测基因组，所以当一开始没有比对出结果的时候，我一度怀疑是这种植物压根儿就没有这俩基因，或者这个样品叶片（测序的部位）在检测的时间点就没有转录相应的基因。</p><p>本地blast找不到同源基因，我又从近缘菊科植物开始折腾，思路是如果菊科有同源基因则寻找保守结构域，设计引物将CDS区域克隆出来。至今已发表的植物基因组可以从网站<a href="https://www.plabipd.de/plant_genomes_pa.ep">Plabipd（本站网址导航栏有收录）</a>找到，<strong>这个网站很贴心地把物种种属关系也列了出来</strong>，可以很方便地找物种学名和近缘关系。</p><p>理想很丰满现实很骨感，我从菊科一级一级往上找，直到Eudicotyledoneae（真双子叶植物分支）才用blastn比对上同源基因，而且无一例外比对上的全是十字花科（拟南芥所在科）植物，根本不算近缘物种….无奈之下试了blast的其他功能，用氨基酸序列跑了一遍blastp，然后发现菊科也有序列可以比对上了！这才打开新世界的大门</p></div><h2 id="2-blastp寻找同源基因"><a href="#2-blastp寻找同源基因" class="headerlink" title="2 blastp寻找同源基因"></a>2 blastp寻找同源基因</h2><div class="story post-story"><p>基于翻译阅读框对去冗余的全长转录本进行CDS预测（TransDecoder软件），结果以fasta格式保存，后续我会对这个文件验证一遍，先建蛋白库做blastp比对。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">makeblastdb -in transdecoder.pep.fa -dbtype prot -input_type fasta -out nr_Kc</span><br></pre></td></tr></table></figure><p><img src="https://www.shelven.com/tuchuang/20220705/4.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220705/4.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><strong>可以看到只有25128个编码蛋白基因，对于基因组大小在1G左右的菊科物种来说，这个基因数量过少</strong>。因此后续还需要对全长转录组数据再跑一遍验证一下，这个是后话。</p><p>通过TAIR号在TAIR官网查找蛋白序列，创建fa文件后进行本地blastp比对</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">blastp -query PIF4_pep.fna -out PIF4_blastp_nr_Kc.out -db nr_Kc -outfmt 6 -evalue 1e-5 -num_threads 4</span><br><span class="line">blastp -query HMR_pep.fna -out HMR_blastp_nr_Kc.out -db nr_Kc -outfmt 6 -evalue 1e-5 -num_threads 4</span><br></pre></td></tr></table></figure><p>注意下结果文件名写清楚什么基因，用的什么方法比对，比对的什么库。这个时候再查看各自的结果文件，发现有比对结果，再回到非冗余转录本文件找对应的cds序列。操作过程都一样，这里不再赘述了。</p></div><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><div class="story post-story"><p>找三条同源基因花了一整天的时间，主要原因还是对同源序列了解不够深刻。</p><p>同源就是有共同的进化祖先，序列相似性搜索可以通过检测<strong>过高的</strong>相似性来识别同源蛋白质或基因：当两个序列的相似性超过偶然的预期时，我们推断这两个序列存在同源性。 当观察到过高的相似性时，这两个序列不是独立出现的，它们起源于一个共同的祖先。</p><p>通过算法进行序列对库比对的工具，比如blast等，是通过过高相似性来减少假阳性的结果。所以通过算法在统计学上找不到库里显著的匹配项，不代表这个物种中一定没有同源基因。</p><p>从这次blastn和blastp比对结果来看，核酸序列比对可能更不容易找到同源序列。其实也好理解，生物在进化的几亿年时间里，很难保证不同物种有高相似性的核酸序列。同个氨基酸有不同密码子（简并性），也能证明蛋白质一级结构才是对生物影响最大的，蛋白质序列相同，就会有相似结构和功能。因此，蛋白质序列也就是氨基酸序列，对相似性的搜索比核酸序列要敏感的多。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天接到一个任务，大致内容是在一个植物的全长转录组数据中找拟南芥的三个同源基因。简简单单的描述，我的想法也很简单，直接找基因的&lt;strong&gt;CDS序列做blastn&lt;/strong&gt;比对就完事了，结果却没有那么顺利…记录一下踩的坑和解决办法。&lt;/p&gt;
&lt;h2 id=&quot;1-</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="blast" scheme="http://www.shelven.com/tags/blast/"/>
    
  </entry>
  
  <entry>
    <title>0基础学习基因组三代测序组装（4）——初步组装二代数据</title>
    <link href="http://www.shelven.com/2022/07/03/a.html"/>
    <id>http://www.shelven.com/2022/07/03/a.html</id>
    <published>2022-07-03T11:28:52.000Z</published>
    <updated>2022-07-03T11:33:05.956Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><div class="story post-story"><p>经过前面的全基因组特征调查（survey）后，我们发现这是一个复杂基因组，杂合度较高，可以以二代+三代测序技术相结合的策略进行全基因组组装，还可以以Hi-C（高通量染色体捕获技术，High-through chromosome conformation capture）技术进行辅助组装。</p><p>这里我用华大开发的二代测序组装工具SOAPdenovo，用二代测序数据对进行初步基因组组装。</p></div><h2 id="1-安装SOAPdenovo-2-0"><a href="#1-安装SOAPdenovo-2-0" class="headerlink" title="1 安装SOAPdenovo 2.0"></a>1 安装SOAPdenovo 2.0</h2><div class="story post-story"><p>github上这个软件的版本是2.0，网址点击<a href="https://github.com/aquaskyline/SOAPdenovo2">这里</a></p><p>软件下载安装过程非常顺利，如果有报错无法解决的话可以在Issue里向作者反馈。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">集群如果无法登录github，下载源码包，通过xftp传到集群</span></span><br><span class="line">tar -zxvf SOAPdenovo2</span><br><span class="line">cd SOAPdenovo2-r242</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>编译之后可以看到有如下几个文件</p><p><img src="https://www.shelven.com/tuchuang/20220702/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220702/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>SOAPdenovo-127mer和SOAPdenovo-63mer是用于组装的两个程序，分<strong>别代表支持的最大k-mer为127和63</strong>，用法上是完全相同的。</p><p>example.config是配置文件，组装之前我们要设置其中的参数内容；README.md是帮助文件，详细记录了各项参数的作用和设置方法。这个后面会讲到。</p></div><h2 id="2-kmergenie计算最佳k值"><a href="#2-kmergenie计算最佳k值" class="headerlink" title="2 kmergenie计算最佳k值"></a>2 kmergenie计算最佳k值</h2><div class="story post-story"><p>现在组装基因组的算法主要有三种：De Bruijn graph，Overlap-Layout-Consensus和String Graph。SOAPdenovo软件组装基因组用的是De Bruijn graph算法，简单理解是通过将reads打断成k-mer后，利用k-mer之间的重复部分构建图，得到最优化路径从而拼接contig。要具体了解什么是De Bruijn graph，可以参考<a href="https://blog.csdn.net/u010608296/article/details/113879863">这一篇博文</a>。</p><p>不同k-mer值构建的De Bruijn graph不一样，会导致组装质量的差异，因此我们需要选择一个最佳的组装k-mer大小（尽管可以用默认值<strong>23</strong>直接组装，但是效果不一定是最好的）。</p><p><strong>kmergenie软件和之前的Jellyfish类似</strong>，都可以用于统计k-mer数量，kmergenie最大优点是可以对预设的多个k-mer进行分析，找到最佳的k-mer。<a href="http://kmergenie.bx.psu.edu/">点击这里进入Kmergenie官网</a>，下载最新版本的软件。</p><p><strong>注意下这个软件安装需要python &gt; 2.7，并且需要安装R和zlib</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf kmergenie-1.7051.tar.gz</span><br><span class="line">cd kmergenie-1.7051</span><br><span class="line">make</span><br><span class="line">python setup.py install --user  # 安装到用户环境中，不报错说明可以使用</span><br><span class="line"></span><br><span class="line">vim file.txt    # 将两个fq文件路径写进去，一行一个</span><br><span class="line"></span><br><span class="line">/public/home/wlxie/biosoft/kmergenie-1.7051/kmergenie file.txt -o ./kmergenie_res -l 15 -k 65 -s 5 -t 30 --diploid      # 运行kmergenie</span><br></pre></td></tr></table></figure><ul><li>-o    # 输出文件位置和名称</li><li>-l    # 设定的最小k值</li><li>-k    # 设定的最大k值</li><li>-s    # 最小k值到最大k值，每次增加的间隔（根据需要设定间隔大小）</li><li>-t    # 运行的线程（CPU核）数</li><li>--diploid    # 二倍体模式，前面我们已经用jellyfish确认过这是个复杂基因组。默认是单倍体模式</li></ul><p><strong>其原理就是设置不同k值进行基因组大小预估，将组装的基因组最大的k值作为最佳k值。</strong></p><p>最终会给出kmergenie_res为前缀的一系列报告，生成的.histo文件还可以用来上一篇笔记中的GenomeScope分析，这里我们只需要看总结的html文件。</p><p><img src="https://www.shelven.com/tuchuang/20220702/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220702/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>确定组装的最佳k值为51</p></div><h2 id="3-SOAPdenovo2组装contigs-x2F-scaffolds"><a href="#3-SOAPdenovo2组装contigs-x2F-scaffolds" class="headerlink" title="3 SOAPdenovo2组装contigs&#x2F;scaffolds"></a>3 SOAPdenovo2组装contigs&#x2F;scaffolds</h2><div class="story post-story"><p>复制一份example.config配置文件，重命名为run_config，修改部分参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">maximal <span class="built_in">read</span> length</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">全局配置参数，只要高于这个参数的序列都会被截取到这个长度</span></span><br><span class="line">max_rd_len=150</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">文库配置以[LIB]开头</span></span><br><span class="line">[LIB]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">average insert size</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">文库插入片段的平均长度，在实际设置时，可以参考文库size分布图，取峰值（默认200）</span></span><br><span class="line">avg_ins=200</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="keyword">if</span> sequence needs to be reversed</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">是否需要将序列反向互补，对于pair-end数据，不需要反向互补，设置为0；对于mate-pair数据，需要反向互补，设置为1</span></span><br><span class="line">reverse_seq=0</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="keyword">in</span> <span class="built_in">which</span> part(s) the reads are used</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1表示只组装contig，2表示只组装scaffold，3表示同时组装contig和scaffold，4表示只补gap</span></span><br><span class="line">asm_flags=3</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">use only first 100 bps of each <span class="built_in">read</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">序列长度阈值，作用和max_rd_len相同，大于该长度的序列会被切除到该长度</span></span><br><span class="line">rd_len_cutoff=150</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="keyword">in</span> <span class="built_in">which</span> order the reads are used <span class="keyword">while</span> scaffolding</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置不同文库数据的优先级顺序，取值范围为整数，rank值相同的多个文库，在组装scaffold时，会同时使用。</span></span><br><span class="line">rank=1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">cutoff of pair number <span class="keyword">for</span> a reliable connection (at least 3 <span class="keyword">for</span> short insert size)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">contig或者scaffold之前的最小overlap个数，对于pair-end数据，默认值为3；对于mate-paird数据，默认值为5</span></span><br><span class="line">pair_num_cutoff=3</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">minimum aligned length to contigs <span class="keyword">for</span> a reliable <span class="built_in">read</span> location (at least 32 <span class="keyword">for</span> short insert size)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">比对长度的最小阈值，对于pair-end数据，默认值为32；对于mate-pair数据，默认值为35</span></span><br><span class="line">map_len=32</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">a pair of fastq file, <span class="built_in">read</span> 1 file should always be followed by <span class="built_in">read</span> 2 file</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">过滤后的双端测序数据文件路径，q为fastq格式，f为fasta格式，b为bam格式</span></span><br><span class="line">q1=/public/home/wlxie/luobuma/luobuma/sample_1_rawdata/Second-generation_sequencing/20211106-BaiYiHuiNeng01/01.rawFq/00.mergeRawFq/1/clean_data/1_r    aw_1_val_1.fq</span><br><span class="line">q2=/public/home/wlxie/luobuma/luobuma/sample_1_rawdata/Second-generation_sequencing/20211106-BaiYiHuiNeng01/01.rawFq/00.mergeRawFq/1/clean_data/1_r    aw_2_val_2.fq</span><br></pre></td></tr></table></figure><p>SOAPdenovo有6个子命令<strong>pregraph、sparse_pregraph、contig、map、scaff和all</strong>，前5个命令对应5个组装步骤，第一和第二是两种不同构图方式，all命令一次执行所有步骤，用all命令比较省事儿。</p><p>SOAPdenovo命令还有一些参数用于调整，<a href="https://zhuanlan.zhihu.com/p/286159368">参数参考</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-s  # 配置文件</span><br><span class="line">-o  # 输出文件的前缀</span><br><span class="line">-K  # 输入的K-mer值大小，默认值23</span><br><span class="line">-p  # 程序运行时设定的线程数，默认值8</span><br><span class="line">-R  # 利用read鉴别短的重复序列，默认值不进行此操作</span><br><span class="line">-d  # 去除频数不大于该值的k-mer，默认值为0</span><br><span class="line">-D  # 去除频数不大于该值的由k-mer连接的边，默认值为1，即该边上每个点的频数都小于等于1时才去除</span><br><span class="line">-M  # 连接contig时合并相似序列的等级，默认值为1，最大值3。</span><br><span class="line">-F  # 利用read对scaffold中的gap进行填补，默认不执行</span><br><span class="line">-u  # 构建scaffold前不屏蔽高覆盖度的contig，这里高频率覆盖度指平均contig覆盖深度的2倍。默认屏蔽</span><br><span class="line">-G  # 估计gap的大小和实际补gap的大小的差异，默认值为50bp。</span><br><span class="line">-L  # 用于构建scaffold的contig的最短长度，默认为：Kmer参数值 ×2</span><br><span class="line">-k  # map步骤中kmer的大小，默认是和K一样的kmer大小</span><br><span class="line">-N  # 基因组大小</span><br><span class="line">-V  # 输出可视化的组装信息</span><br></pre></td></tr></table></figure><p>运行组装命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/public/home/wlxie/biosoft/SOAPdenovo2-r242/SOAPdenovo-63mer all -s /public/home/wlxie/biosoft/SOAPdenovo2-r242/run_config -K 51 -R -V -o A_venetum -p 30</span><br></pre></td></tr></table></figure><p>程序运行了3个小时，结束后生成了以下文件</p><p><img src="https://www.shelven.com/tuchuang/20220702/3.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220702/3.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div><h2 id="4-组装结果解读"><a href="#4-组装结果解读" class="headerlink" title="4 组装结果解读"></a>4 组装结果解读</h2><div class="story post-story"><p>组装结果文件其实只有两个，分别以**.contig结尾和.scafseq结尾**。因为我是在集群上运行的，slurm-11168.out是集群的输出日志文件，记录了详细的组装过程和结果。</p><p>最终得到935861个contigs，总长度295302126 bp，平均长度315 bp，最长的长度38673 bp，contig N50是532 bp，contig N90是103 bp；scaffold个数77918，总长度192992858 bp，平均长度2476 bp，最长的长度108587 bp，scaffold N50是3385 bp，scaffold N90是130 bp。（可以做一个统计表）</p><p>从组装的contig覆盖深度和数量还可以做一个柱状图，理论上来说是和前面k-mer分布图呈现一样的趋势，也就是一个主峰和一个杂峰，两个图相互印证目标基因组是个复杂基因组。</p><p>其他的结果文件在<a href="https://github.com/aquaskyline/SOAPdenovo2">github</a>上有解释，我先直接复制过来，以后用到再翻译翻译……</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">1. Output files from the command &quot;pregraph&quot;</span><br><span class="line">a. *.kmerFreq</span><br><span class="line">      Each row shows the number of Kmers with a frequency equals the row number. Note that those peaks of frequencies which are the integral multiple of 63 are due to the data structure.</span><br><span class="line">b. *.edge</span><br><span class="line">      Each record gives the information of an edge in the pre-graph: length, Kmers on both ends, average kmer coverage, whether it&#x27;s reverse-complementarily identical and the sequence.</span><br><span class="line">c. *.markOnEdge &amp; *.path</span><br><span class="line">      These two files are for using reads to solve small repeats.</span><br><span class="line">e. *.preArc</span><br><span class="line">      Connections between edges which are established by the read paths.</span><br><span class="line">f. *.vertex</span><br><span class="line">      Kmers at the ends of edges.</span><br><span class="line">g. *.preGraphBasic</span><br><span class="line">      Some basic information about the pre-graph: number of vertex, K value, number of edges, maximum read length etc.</span><br><span class="line">      </span><br><span class="line">2. Output files from the command &quot;contig&quot;</span><br><span class="line">a. *.contig</span><br><span class="line">      Contig information: corresponding edge index, length, kmer coverage, whether it&#x27;s tip and the sequence. Either a contig or its reverse complementry counterpart is included. Each reverse complementary contig index is indicated in the *.ContigIndex file.</span><br><span class="line">b. *.Arc</span><br><span class="line">      Arcs coming out of each edge and their corresponding coverage by reads</span><br><span class="line">c. *.updated.edge</span><br><span class="line">      Some information for each edge in graph: length, Kmers at both ends, index difference between the reverse-complementary edge and this one.</span><br><span class="line">d. *.ContigIndex</span><br><span class="line">      Each record gives information about each contig in the *.contig: it&#x27;s edge index, length, the index difference between its reverse-complementary counterpart and itself.</span><br><span class="line">      </span><br><span class="line">3. Output files from the command &quot;map&quot;</span><br><span class="line">a. *.peGrads</span><br><span class="line">      Information for each clone library: insert-size, read index upper bound, rank and pair number cutoff for a reliable link. This file can be revised manually for scaffolding tuning.</span><br><span class="line">b. *.readOnContig</span><br><span class="line">      Reads&#x27; locations on contigs. Here contigs are referred by their edge index. Howerver about half of them are not listed in the *.contig file for their reverse-complementary counterparts are included already.</span><br><span class="line">c. *.readInGap</span><br><span class="line">      This file includes reads that could be located in gaps between contigs. This information will be used to close gaps in scaffolds if &quot;-F&quot; is set.</span><br><span class="line">      </span><br><span class="line">4. Output files from the command &quot;scaff&quot;</span><br><span class="line">a. *.newContigIndex</span><br><span class="line">      Contigs are sorted according their length before scaffolding. Their new index are listed in this file.  This is useful if one wants to corresponds contigs in *.contig with those in *.links.</span><br><span class="line">b. *.links</span><br><span class="line">      Links between contigs which are established by read pairs. New index are used.</span><br><span class="line">c. *.scaf_gap</span><br><span class="line">      Contigs in gaps found by contig graph outputted by the contiging procedure. Here new index are used.</span><br><span class="line">d. *.scaf</span><br><span class="line">      Contigs for each scaffold: contig index (concordant to index in *.contig),  approximate start position on scaffold, orientation, contig length, and its links to others contigs.</span><br><span class="line">e. *.gapSeq</span><br><span class="line">      Gap sequences between contigs.</span><br><span class="line">f. *.scafSeq</span><br><span class="line">      Sequences of each scaffolds.</span><br><span class="line">g. *.contigPosInscaff</span><br><span class="line">      Contigs&#x27; positions in each scaffold.</span><br><span class="line">h. *.bubbleInScaff</span><br><span class="line">      Contigs that form bubble structures in scaffolds. Every two contigs form a bubble and the contig with higher coverage will be kept in scaffold.</span><br><span class="line">i. *.scafStatistics</span><br><span class="line">      Statistic information of final scaffold and contig.</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;div class=&quot;story post-story&quot;&gt;&lt;p&gt;经过前面的全基因组特征调查（survey）后，我们发现这是一个复杂基因组，杂合度</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="基因组三代测序分析" scheme="http://www.shelven.com/categories/%E5%9F%BA%E5%9B%A0%E7%BB%84%E4%B8%89%E4%BB%A3%E6%B5%8B%E5%BA%8F%E5%88%86%E6%9E%90/"/>
    
    
    <category term="kmergenie" scheme="http://www.shelven.com/tags/kmergenie/"/>
    
    <category term="SOAPdenovo2" scheme="http://www.shelven.com/tags/SOAPdenovo2/"/>
    
  </entry>
  
  <entry>
    <title>0基础学习基因组三代测序组装（3）——全基因组Survey</title>
    <link href="http://www.shelven.com/2022/07/02/a.html"/>
    <id>http://www.shelven.com/2022/07/02/a.html</id>
    <published>2022-07-02T07:08:17.000Z</published>
    <updated>2022-07-02T07:30:31.832Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><div class="story post-story"><p>之前说到如何对三代测序数据做污染评估，取随机序列做blastn比对nt库，确定物种分布情况。实际blast比对还要考虑比对的序列长度和ONT本身数据错误率，以及结合GC-depth确定是否有污染。</p><p>基因组三代测序数据组装之前，我们还要做一个全基因组survey。主要是为了减少盲目性，先做低深度的基因组分析，也是初步了解物种<strong>基因组特征</strong>的有效方法，比如评估基因组大小和杂合情况，为后续全基因组de novo组装策略指定提供指导。</p><p>基因组复杂程度的经验性标准：</p><ul><li>简单基因组: 单倍体；或纯合二倍体；或杂合度低于0.5%, 且重复序列低于50%, 且GC含量在35%-65%的二倍体。</li><li>复杂基因组: 杂合度在0.5%~1.2%之间，或重复序列高于50%，或GC含量异常(&lt;35%或&gt;65%)的二倍体，或者多倍体。<strong>复杂基因组可以采用“2+3”即二代和三代测序技术相结合，加之Hi-C辅助组装的组装策略。</strong></li><li>高复杂基因组: 杂合度&gt;1.2%；或重复序列占比大于65%。</li></ul><p>有条件的话，也可以用流式细胞仪对基因组大小做个预估。我这里只有二代基因组测序数据，因此用基因组二代测序数据做全基因组survey。当然，这里要注意一点，做全基因组survey的样本和后续de novo组装的样本要来自同<strong>一个个体</strong>，避免个体间基因组特征的差异。</p></div><h2 id="1-原始数据质控"><a href="#1-原始数据质控" class="headerlink" title="1 原始数据质控"></a>1 原始数据质控</h2><div class="story post-story"><p>因为是对二代测序数据进行分析，质控的过程本质上和之前处理转录组二代数据一样，这里只提下过程和结果。</p><h3 id="1-1-fastqc生成质控报告"><a href="#1-1-fastqc生成质控报告" class="headerlink" title="1.1 fastqc生成质控报告"></a>1.1 fastqc生成质控报告</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastqc *.fq.gz -o ./</span><br></pre></td></tr></table></figure><p><img src="https://www.shelven.com/tuchuang/20220630/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220630/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><img src="https://www.shelven.com/tuchuang/20220630/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220630/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><img src="https://www.shelven.com/tuchuang/20220630/3.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220630/3.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>二代测序是双端测序结果，我这里只截图了部分qc报告，可以看出GC含量比较稳定，测序质量也比较高。</p><h3 id="1-2-trim-galore数据过滤"><a href="#1-2-trim-galore数据过滤" class="headerlink" title="1.2 trim-galore数据过滤"></a>1.2 trim-galore数据过滤</h3><p>报告中的结果虽然好，但是还是需要过滤一遍，把末端接头adapter序列过滤掉。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trim_galore -q 25 -phred33 -length 100 -stringency 1 -paired -o clean_data 1_raw_1.fq.gz 1_raw_2.fq.gz</span><br></pre></td></tr></table></figure><p>参数在这篇博客 <a href="https://www.shelven.com/2022/04/14/a.html?keyword=trim">转录组数据分析笔记（1）——如何用fastqc和trim-galore做测序数据质控</a> 有提到，这里不再赘述。</p><p><img src="https://www.shelven.com/tuchuang/20220630/4.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220630/4.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>看下report文件，过滤了Q值25以下的reads和adapter序列</p><p><img src="https://www.shelven.com/tuchuang/20220630/5.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220630/5.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div><h2 id="2-k-mer分析"><a href="#2-k-mer分析" class="headerlink" title="2 k-mer分析"></a>2 k-mer分析</h2><div class="story post-story"><p>先说一下k-mer的概念：k-mer在这里指将reads迭代拆分成包含k个碱基的序列（类似blast中的word length，蛋白质是3，核酸是11），我们后面要分析的基因组特征都是基于k-mer分布基础上进行的。</p><ul><li>基因组大小可以通过总 <strong>（K-mer 数量）&#x2F;（K-mer 期望测序深度）</strong>来估计</li><li>k-mer分布曲线的主峰所在横坐标可以作为<strong>期望的测序深度</strong></li><li>测序覆盖均匀、不存在测序误差和基因组重复序列的理论条件下，K-mer分布曲线会符合泊松分布</li><li><strong>单倍体或纯合基因组的 K-mer 分布曲线只有一个主峰</strong></li><li>杂合二倍体基因组的 K-mer 分布曲线有两个峰， 分别为<strong>杂合峰（主峰1&#x2F;2处）和纯合峰（主峰）</strong>，前者深度只有后者的一半</li><li>重复序列含量较高时会在主峰后面形成一个<strong>重复峰（主峰的2倍处）</strong>或者形成拖尾</li><li>一般选择<strong>17-mer</strong>评估基因组大小，因为ATCG组成长度为17的核酸序列，理论上有4的17次方种可能，足以覆盖一般的正常基因组。为了避免回文序列，K-mer分析选择K长度均为<strong>奇数</strong>。</li></ul><h3 id="2-1-安装jellyfish"><a href="#2-1-安装jellyfish" class="headerlink" title="2.1 安装jellyfish"></a>2.1 安装jellyfish</h3><p>根据上面说的k-mer概念，可以理解k-mer分析是非常耗计算资源的。我们要自己用脚本实现的话，需要将十几个G的reads分割成不同长度片段，再统计出现的次数，耗时而且麻烦。jellyfish是一款统计DNA序列中Kmer的分布的软件，它运行速度快，内存消耗低，支持并行，也是用的最多的统计k-mer的软件。</p><p><del>重点是可以通过conda直接安装……</del>最好不要用conda安装，我之前运行了1天没出结果也没报错（一度怀疑我的参数设置是不是有问题），百思不得其解。后来从github上重新下载，编译和安装之后，不到10分钟就跑出结果了…我不知道两种安装方式有什么区别，<strong>这里就记录下自己踩的坑</strong>。</p><p><strong>因为jellyfish不支持.gz的压缩文件</strong>，所以之前用tram galore过滤后得到的clean reads需要用gunzip命令解压。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install -c bioconda jellyfish  # 可以用conda安装，我运行的时候出了问题，暂未解决，不推荐</span><br></pre></td></tr></table></figure><p><a href="https://github.com/gmarcais/Jellyfish">点击这里进入jellyfish的github下载地址</a></p><p>我们用本地安装的方式，先下载tar.gz的源码包，tar -zxvf解压后进入jellyfish-2.3.0文件夹。</p><p>我是集群登录的，下面讲的步骤都是在集群上操作（非root账户）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第一步检测。本质上是一个shell脚本，根据系统环境产生合适的makefile文件或者C的头文件（.h结尾的文件），非root账户下--prefix后面接上自己账户的绝对路径。</span></span><br><span class="line">./configure --prefix=/public/home/wlxie</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第二步编译。对源代码包进行编译，如果有错误自己看是否有依赖库的缺失，主要是这个问题。</span></span><br><span class="line">make</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第三步安装。如果前面没有指定自己账户的路径，这一步是会报错没有权限的（用户不能向系统目录写入文件）。</span></span><br><span class="line">make install</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第四步自检。</span></span><br><span class="line">make check</span><br></pre></td></tr></table></figure><p>make和make check这两步都会因为<strong>动态链接库命名不同</strong>，导致报错无法找到动态库；以及我在检测通过之后，用集群运行程序仍然出现了动态库的某个模块无法调用的情况。这里统一说下解决方法。</p><p>前面configure会在我们的家目录下生成<strong>bin、lib和share目录</strong>，这里比较重要的是bin和lib目录。我们运行的命令在bin目录里，对应要改环境变量<strong>PATH</strong>；而需要调用的动态库是在lib目录下，对应要改环境变量<strong>LD_LIBRARY_PATH</strong>。家目录下的.bashrc文件加入以下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export PATH=&quot;/public/home/wlxie/bin:$PATH&quot;</span><br><span class="line">export LD_LIBRARY_PATH=&quot;/public/home/wlxie/lib:$LD_LIBRARY_PATH&quot;</span><br></pre></td></tr></table></figure><p>添加之后保存退出，并且source ~&#x2F;.bashrc刷新一下系统环境变量。</p><p>我碰到的报错是<strong>libcrypto.so.1.0.0和libstdc++.so.6</strong>这两个动态库找不到，但是locate命令查看这两个动态库，在系统目录&#x2F;lib64&#x2F;下都能找到文件，因此将这两个动态库文件直接复制到家目录的lib文件夹，问题就全部解决了。</p><p>如果libstdc++.so.6报错某版本的文件不存在，可以先到动态库目录下，运行strings命令查看动态库中是否有对应的文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings /lib64/libstdc++.so.6 | grep CXXABI   # 比如找不到GLIBCXX_3.4.26，看看动态库中是否存在这个版本的文件，如果不存在，更新动态库；如果存在但是找不到，建议直接拷贝到自己的lib目录下</span><br></pre></td></tr></table></figure><p>make check之后会生成一个日志文件test-suite.log，没有fail的项目说明软件安装成功，没有问题。</p><p><img src="https://www.shelven.com/tuchuang/20220630/6.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220630/6.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="2-2-k-mer频数分布"><a href="#2-2-k-mer频数分布" class="headerlink" title="2.2 k-mer频数分布"></a>2.2 k-mer频数分布</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">k-mer计数</span></span><br><span class="line">jellyfish count -m 17 -s 300M -t 50 -C -o 17-mer.jf ./1_raw_1_val_1.fq ./1_raw_2_val_2.fq</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">k-mer频数统计</span></span><br><span class="line">jellyfish histo -t 4 17-mer.jf &gt; 17-mer.histo</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">统计总k-mer数和特征k-mer数等</span></span><br><span class="line">jellyfish stats 17-mer.jf -o counts_stats.txt</span><br></pre></td></tr></table></figure><p>记录一下各个参数的意义：</p><blockquote><ul><li>-m    # k-mer长度设置为17bp，进行计数</li><li>-s    # 存储用的hash表大小，说实话我没看懂什么意思，基因组估计有多大就用多大就是了，单位是M或者G</li><li>-t    # 使用的线程数，也就是cpu核数</li><li>-C    # 大写的C，对正负链reads都进行统计，双端测序一定要加这个参数</li><li>-o    # 结果文件的前缀名，结果文件是一个二进制文件</li></ul></blockquote><p>正常来说，<strong>10分钟就能跑完程序并给出k-mer计数结果文件</strong>。我用conda安装的jellyfish同样条件运行了20个小时没有结束……而且还不报错！第一次运行这个软件，没有人参考和交流，百度到的教程都是抄来抄去的也没有人说明时间的问题……以后还是去官网安装生信软件了，虽然麻烦一点但是靠谱……</p><p><img src="https://www.shelven.com/tuchuang/20220630/7.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220630/7.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><strong>这个软件的帮助文档在&#x2F;jellyfish-2.3.0&#x2F;doc目录下，所有功能和参数都有英文详解</strong>。</p><p>k-mer频数统计是在计数结果文件上进一步统计各个k-mer出现的次数，频数统计结果文件17-mer.histo将k-mer从1统计到10000，最后一行是10001以后对应的总频次。counts_stats.txt是总的统计结果，包括k-mer总数（Total），特异的k-mer数目（Distinct）只出现过一次的k-mer数量（Unique），频数最高的k-mer数量（Max_count）四项。</p><p><img src="https://www.shelven.com/tuchuang/20220630/8.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220630/8.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><img src="https://www.shelven.com/tuchuang/20220630/10.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220630/10.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>有了频数统计结果文件17-mer.histo就可以用R作图了，以下R作图代码来自于CSDN博主 <a href="https://blog.csdn.net/qq_40569830/article/details/125287781">生信技工</a></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kmer <span class="operator">&lt;-</span> read.table<span class="punctuation">(</span><span class="string">&#x27;17-mer.histo&#x27;</span><span class="punctuation">)</span></span><br><span class="line">kmer <span class="operator">&lt;-</span> subset<span class="punctuation">(</span>kmer<span class="punctuation">,</span> V1 <span class="operator">&gt;=</span><span class="number">5</span> <span class="operator">&amp;</span> V1 <span class="operator">&lt;=</span><span class="number">500</span><span class="punctuation">)</span>     <span class="comment"># 只取5-500bp长度的k-mer统计频次</span></span><br><span class="line">Frequency <span class="operator">&lt;-</span> kmer<span class="operator">$</span>V1</span><br><span class="line">Number <span class="operator">&lt;-</span> kmer<span class="operator">$</span>V2</span><br><span class="line">png<span class="punctuation">(</span><span class="string">&#x27;kmer_plot.png&#x27;</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>Frequency<span class="punctuation">,</span> Number<span class="punctuation">,</span> type <span class="operator">=</span> <span class="string">&#x27;l&#x27;</span><span class="punctuation">,</span> col <span class="operator">=</span> <span class="string">&#x27;blue&#x27;</span><span class="punctuation">)</span></span><br><span class="line">dev.off<span class="punctuation">(</span><span class="punctuation">)</span>       <span class="comment"># 保存png</span></span><br></pre></td></tr></table></figure><p>k-mer分布图如下，当然这只是一个简略图，上面R作图代码还有很多细节可以补充</p><p><img src="https://www.shelven.com/tuchuang/20220630/9.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220630/9.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="2-3-基因组大小、重复率、杂合率估算"><a href="#2-3-基因组大小、重复率、杂合率估算" class="headerlink" title="2.3 基因组大小、重复率、杂合率估算"></a>2.3 基因组大小、重复率、杂合率估算</h3><p>横坐标表示k-mer深度，纵坐标为k-mer数量，可以看得出来测序的样本是个杂合二倍体。主峰坐标（116，2584902），杂合峰坐标（57，1188461），也就是说k-mer期望深度为116；k-mer总数为34655456060；主峰2倍深度也就是232之后的k-mer为重复序列k-mer，总数可以通过导出17-mer.histo文件进行统计（改成csv格式直接两步算出），共16361378388</p><ul><li><p><strong>k-mer分布曲线中无异常峰</strong>，说明二代测序提取的DNA纯度较高，没有被污染</p></li><li><p>根据<strong>（K-mer 数量）&#x2F;（K-mer 期望测序深度）</strong>估算基因组大小为298M。去除深度小于5的错误k-mer，估算基因组大小为292M.</p></li><li><p>根据<strong>（重复序列的k-mer总数）&#x2F;（K-mer 期望测序深度）</strong>估计重复序列大小为141M，即重复率48.29%</p></li><li><p>单拷贝序列大小U&#x3D;292-141&#x3D;151M，要计算杂合率，需要统计非重复k-mer的总数，也就是计算杂合峰面积，建议还是用软件或者在线工具比如<a href="http://qb.cshl.edu/genomescope/genomescope2.0/">genomescope2.0</a></p></li></ul><p>jellyfish + GenomeScope是一套应用非常广泛的基因组survey方法，GenomeScope2.0适合用于分析<strong>二倍体</strong>生物。</p><p><img src="https://www.shelven.com/tuchuang/20220630/11.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220630/11.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>上面是GenomeScope2.0网页版界面，只要我们提供jellyfish生成的.histo结果文件，设置参数就行</p><ul><li>k-mer length    # k-mer长度</li><li>Ploidy    # 染色体倍性</li><li>Max k-mer coverage     # 默认-1，即不限制最大k-mer深度，我这里限制了10000</li><li>Average k-mer coverage for polyploid genome    # 默认-1，不进行筛选</li></ul><p>提交后几分钟就生成了可用于发表的图和报告</p><p><img src="https://www.shelven.com/tuchuang/20220630/12.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220630/12.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>可以看到估计的基因组大小是200M，杂合率0.865%，杂合峰覆盖度（深度）58.3。下面说下这个图如何解读：</p><ul><li>蓝色区域是实际观测值</li><li>黑色拟合线是去除错误（errors）后剩下的k-mer分布，认为是正确的数据并以此评估基因组大小</li><li>黄色拟合线是非重复区域的k-mer分布（理想情况）</li><li>橙色拟合线区域是低深度的错误k-mer，认为是测序错误引入的</li><li>黑色虚线是k-mer的几个峰值</li></ul><p>之所以估计的基因组大小比之前自己估计的要小，是因为去除error的标准不同，我之前只是简单去除了k-mer深度1-4的错误序列，这里是构建模型选择的错误序列，更准确一些。</p><p>网页版最后的results里还有总的统计结果，可以很方便地计算重复率，一眼就能看明白这里就不赘述了。</p><p><img src="https://www.shelven.com/tuchuang/20220630/13.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220630/13.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;div class=&quot;story post-story&quot;&gt;&lt;p&gt;之前说到如何对三代测序数据做污染评估，取随机序列做blastn比对nt库，确定物</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="基因组三代测序分析" scheme="http://www.shelven.com/categories/%E5%9F%BA%E5%9B%A0%E7%BB%84%E4%B8%89%E4%BB%A3%E6%B5%8B%E5%BA%8F%E5%88%86%E6%9E%90/"/>
    
    
    <category term="jellyfish" scheme="http://www.shelven.com/tags/jellyfish/"/>
    
    <category term="GenomeScope2.0" scheme="http://www.shelven.com/tags/GenomeScope2-0/"/>
    
  </entry>
  
  <entry>
    <title>0基础学习基因组三代测序组装（2）——数据污染评估</title>
    <link href="http://www.shelven.com/2022/06/20/a.html"/>
    <id>http://www.shelven.com/2022/06/20/a.html</id>
    <published>2022-06-19T17:17:30.000Z</published>
    <updated>2022-06-20T15:55:41.002Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><div class="story post-story"><p>做完基因组三代测序数据质控之后，我们把所有reads的Q值控制在7以上，每个read的长度在1000bp以上。我们不能明确自己的测序数据是否被其他物种污染，这个时候就要用balst比对的方法确定测序数据是否被污染，以及污染的来源。</p></div><h2 id="1-下载balst-工具和数据库"><a href="#1-下载balst-工具和数据库" class="headerlink" title="1 下载balst+工具和数据库"></a>1 下载balst+工具和数据库</h2><div class="story post-story"><p>在之前的一篇博客中，我详细介绍了如何本地安装NCBI的blast+工具，以及下载nr&#x2F;nt库，建立本地的数据库。<a href="https://www.shelven.com/2022/06/17/a.html">详情点击这里</a>。</p><p>在做数据污染评估的时候，我们还需要知道blast最佳结果对应的物种名，因此还需要下载分类数据库的以下两个子库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ascp工具下载大数据，wget命令下载小文件（md5校验文件）</span></span><br><span class="line">ascp -QT -i /public/home/wlxie/miniconda3/envs/biosoft/etc/asperaweb_id_dsa.openssh -k1 -l 500m anonftp@ftp.ncbi.nlm.nih.gov:/pub/taxonomy/accession2taxid/nucl_gb.accession2taxid.gz ./</span><br><span class="line"></span><br><span class="line">wget https://ftp.ncbi.nlm.nih.gov/pub/taxonomy/accession2taxid/nucl_gb.accession2taxid.gz.md5</span><br><span class="line"></span><br><span class="line">ascp -QT -i /public/home/wlxie/miniconda3/envs/biosoft/etc/asperaweb_id_dsa.openssh -k1 -l 500m anonftp@ftp.ncbi.nlm.nih.gov:/pub/taxonomy/taxdump.tar.gz ./</span><br><span class="line"></span><br><span class="line">wget https://ftp.ncbi.nlm.nih.gov/pub/taxonomy/taxdump.tar.gz.md5</span><br></pre></td></tr></table></figure><p>md5文件校验完成之后，两个数据库分别解压。注意.gz文件用gunzip，.tar.gz文件用tar -zxvf</p><p>看看这两个数据库长什么样：</p><p><img src="https://www.shelven.com/tuchuang/20220619/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220619/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><img src="https://www.shelven.com/tuchuang/20220619/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220619/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>第一张图片是<strong>nucl_gb.accession2taxid</strong>，我们需要用到第二列版本信息和第三列的taxid。</p><p>第二张图片是<strong>names.dmp</strong>，我们需要用到有taxid，学名和scientific name字符串的行。</p><p>这两个数据库怎么使用后面会详细说明。分析思路来自于CSDN的博主<a href="https://blog.csdn.net/qq_42962326/article/details/105081327">风风是超人</a>，遗憾的是从17年开始，NCBI不再提供gi号与blastn结果的关联，博主的本地数据库可能版本比较早，采用的是gi号分析。</p><p>我将后续的代码做了修改，下载的也都是最新的数据库。总的逻辑是利用blast结果的version号，得到nucl_gb.accession2taxid数据库中的taxid号，最后通过names.dmp中的taxid号得到学名。代码方面做了少许优化，对集群服务器可能更友好一点？</p></div><h2 id="2-fq文件处理和blast"><a href="#2-fq文件处理和blast" class="headerlink" title="2 fq文件处理和blast"></a>2 fq文件处理和blast</h2><div class="story post-story"><p>质控后的数据fq文件是“@”开头的，我们要改成fa格式也就是“&gt;”开头。取前10000条序列，每个序列有4行，只取第一行标题和第二行序列。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">NR表示当前行，判断除以4的余数，余数1为标题行，只输出第一个元素即reads <span class="built_in">id</span>；余数2则为序列行，输出所有元素也就是整条序列。最后替换@符号，文件名为test.fa</span></span><br><span class="line">zcat clean_filter.fq.gz | head -n 40000 | awk &#x27;&#123;if(NR%4==1)&#123;print $1&#125;else if(NR%4==2)&#123;print $0&#125;&#125;&#x27; | sed &#x27;s/@/&gt;/g&#x27; &gt;test.fa</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">批量blast程序</span></span><br><span class="line">blastn -query test.fa -out test_blastn_nt.xml -db nt -outfmt 5 -evalue 1e-5 -num_threads 20 -max_target_seqs 1</span><br></pre></td></tr></table></figure><p>批量blast程序注意下我们输出的格式为xml格式，也就是- outfmt 5。为什么要用xml格式，因为xml格式能给出的信息最全，我们需要知道输出的版本号</p><p>evalue值根据需要设定，这里我设置1e-5</p><p>最大匹配数量注意下设置1，我们只需要知道和哪个物种相似度最高，一个输出结果就足够了（虽然设置1会有警告）。</p><p>看下blast生成的test_blastn_nt.xml这个结果文件：</p><p><img src="https://www.shelven.com/tuchuang/20220619/3.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220619/3.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>虽然是第一次接触xml格式，但是感觉非常熟悉！之前做的一个<a href="https://www.shelven.com/2022/05/03/a.html">微博爬虫小程序</a>就是扒了一个类似的html格式的文件……xml格式也挺容易解析的，可以看到比对信息以标签&lt;Iteration&gt;开始，以&lt;&#x2F;Iteration&gt;标签结束，&lt;Hit&gt;标签开始表示的是比对上的结果（因为我设置了最大比对序列数量是1，所以&lt;Hit_num&gt;只有1）；&lt;Hsp&gt;标签表示某一块的比对结果（同一条序列，若干片段比对上），因此&lt;Hsp_num&gt;标签的数量可能不止一个。</p><p>当然，这些都可以不用关心，分析需要的信息我用红框标了出来。比较重要的是&lt;Hit_def&gt;标签，里面的字符串是空格隔开的，<strong>第一个元素是我们需要的物种版本号</strong>。</p></div><h2 id="3-XML文件解析"><a href="#3-XML文件解析" class="headerlink" title="3 XML文件解析"></a>3 XML文件解析</h2><div class="story post-story"><p>前面说了解析的思路，以下是代码的实现。因为用的python语言写的程序，我的建议是在vscode一类的编程软件中写这些代码，如果有错误可以及时调试。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以不写，我是为了确保导入父目录的模块不出错</span></span><br><span class="line">sys.path.append(<span class="string">&quot;./&quot;</span>)</span><br><span class="line"></span><br><span class="line">xmlfile = <span class="built_in">open</span>(<span class="string">&quot;/public/home/wlxie/luobuma/luobuma/sample_1_rawdata/Third_generation_sequencing/test_blastn_nt.xml&quot;</span>,<span class="string">&quot;r&quot;</span>)</span><br><span class="line">outfile = <span class="built_in">open</span>(<span class="string">&quot;/public/home/wlxie/luobuma/luobuma/sample_1_rawdata/Third_generation_sequencing/filted_accession_version.txt&quot;</span>,<span class="string">&quot;w&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个空的字典，提取有queryID和subjectID的行</span></span><br><span class="line">dict1 = defaultdict(<span class="built_in">list</span>)</span><br><span class="line"><span class="keyword">for</span> lines <span class="keyword">in</span> xmlfile:</span><br><span class="line">    line = lines.strip()</span><br><span class="line">    read_id = re.match(<span class="string">&#x27;&lt;Iteration_query-def&gt;.*&lt;/Iteration_query-def&gt;&#x27;</span>,line)</span><br><span class="line">    Hit_def = re.match(<span class="string">&#x27;&lt;Hit_def&gt;.*&lt;/Hit_def&gt;&#x27;</span>,line)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 解析queryID</span></span><br><span class="line">    <span class="keyword">if</span> read_id != <span class="literal">None</span>:     </span><br><span class="line">        read_id = read_id.group()</span><br><span class="line">        read_id = read_id.split(<span class="string">&quot;&lt;&quot;</span>)[<span class="number">1</span>].split(<span class="string">&quot;&gt;&quot;</span>)[<span class="number">1</span>]</span><br><span class="line">        key=read_id</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 字典key值和value值赋值</span></span><br><span class="line">    <span class="keyword">elif</span> Hit_def !=<span class="literal">None</span>:        </span><br><span class="line">        Hit_def = Hit_def.group()</span><br><span class="line">        Hit_def = Hit_def.split(<span class="string">&quot;&lt;&quot;</span>)[<span class="number">1</span>].split(<span class="string">&quot;&gt;&quot;</span>)[<span class="number">1</span>]</span><br><span class="line">        dict1[key].append(Hit_def)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入文件，制表符分割</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> dict1:</span><br><span class="line">    outfile.write(key + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;\t&quot;</span>.join(dict1[key])+<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>看下运行结束后解析得到的文件：</p><p><img src="https://www.shelven.com/tuchuang/20220619/4.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220619/4.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>一共是两列，第一列是reads的queryID，第二列subjectID就是比对上的序列信息。可以看到第二列可以以空格为分隔符，提取第一个元素也就是物种版本号，后面会说。</p><p>为什么要把物种版本号提出来而不直接用这段内容里的物种名呢？因为不同的物种名<strong>字段数量和位置不一样</strong>，无法用统一的命令直接提取，精确的版本号可以对应<strong>唯一一个taxid</strong>，从而被精准地注释上物种学名。</p></div><h2 id="4-匹配物种学名"><a href="#4-匹配物种学名" class="headerlink" title="4 匹配物种学名"></a>4 匹配物种学名</h2><div class="story post-story"><p>这里需要注意一个问题，blast用的nt库还有物种分类用到的两个数据库，他们的<strong>更新时间是不一致的</strong>。也就是说，物种版本号不一定能完全匹配上taxid，而taxid也不一定能匹配上学名。</p><p>而python语言写的程序，用到字典类型数据的时候，如果没有对应的key值匹配是会报错的，不会继续执行下去。一会儿解释，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;./&quot;</span>)</span><br><span class="line"></span><br><span class="line">accession = <span class="built_in">open</span>(<span class="string">&quot;/public/home/wlxie/luobuma/luobuma/sample_1_rawdata/Third_generation_sequencing/filted_accession_version.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)</span><br><span class="line">accession2taxid = <span class="built_in">open</span>(<span class="string">&quot;/public/home/wlxie/luobuma/luobuma/sample_1_rawdata/Third_generation_sequencing/nucl_gb.accession2taxid&quot;</span>,<span class="string">&quot;r&quot;</span>)</span><br><span class="line">taxid2name = <span class="built_in">open</span>(<span class="string">&quot;/public/home/wlxie/luobuma/luobuma/sample_1_rawdata/Third_generation_sequencing/names.dmp&quot;</span>,<span class="string">&quot;r&quot;</span>)</span><br><span class="line">final_res = <span class="built_in">open</span>(<span class="string">&quot;/public/home/wlxie/luobuma/luobuma/sample_1_rawdata/Third_generation_sequencing/final_res.txt&quot;</span>,<span class="string">&quot;w&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从names.dmp提取taxid和学名，匹配有scientific name的行</span></span><br><span class="line">taxid_name_dict = &#123;&#125;        </span><br><span class="line"><span class="keyword">for</span> lines <span class="keyword">in</span> taxid2name:</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;scientific name&quot;</span> <span class="keyword">in</span> lines:</span><br><span class="line">        line = lines.strip().split(<span class="string">&quot;|&quot;</span>)</span><br><span class="line">        taxid = line[<span class="number">0</span>].strip()</span><br><span class="line">        name = line[<span class="number">1</span>].strip()</span><br><span class="line">        taxid_name_dict[taxid] = name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从nucl_gb.accession2taxid提取taxid和版本号</span></span><br><span class="line">accession_taxid_dict = &#123;&#125;       </span><br><span class="line"><span class="keyword">for</span> lines <span class="keyword">in</span> accession2taxid:</span><br><span class="line">    line = lines.strip().split(<span class="string">&quot;\t&quot;</span>)</span><br><span class="line">    TAXID = line[<span class="number">2</span>]</span><br><span class="line">    VERSION = line[<span class="number">1</span>]</span><br><span class="line">    accession_taxid_dict[VERSION] = TAXID</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加两个判断条件，版本号匹配不上taxid和taxid匹配不上学名的情况。gc.collect()释放内存。</span></span><br><span class="line"><span class="keyword">for</span> lines <span class="keyword">in</span> accession:</span><br><span class="line">    line = lines.strip().split(<span class="string">&quot;\t&quot;</span>)</span><br><span class="line">    version = line[<span class="number">1</span>].split()[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> version <span class="keyword">in</span> accession_taxid_dict:</span><br><span class="line">        taxid = accession_taxid_dict[version]</span><br><span class="line">        <span class="keyword">if</span> taxid <span class="keyword">in</span> taxid_name_dict:</span><br><span class="line">            final_res.write(<span class="string">&quot;\t&quot;</span>.join(line)+<span class="string">&quot;\t&quot;</span>+taxid_name_dict[taxid]+<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            final_res.write(<span class="string">&quot;\t&quot;</span>.join(line)+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;INVALID TAXID&quot;</span>+<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        final_res.write(<span class="string">&quot;\t&quot;</span>.join(line)+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;INVALID ACCESSION VERSION&quot;</span>+<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    gc.collect()</span><br></pre></td></tr></table></figure><p>如果不加最后两个判断条件，程序会在报错的那行read序列终止。</p><p>通过比较两个输出结果文件行数是否一致来判断匹配是否完全。</p><p><img src="https://www.shelven.com/tuchuang/20220619/5.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220619/5.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>两个文件输出结果一致说明匹配完成，<strong>为什么这里是9338而不是我们一开始blast的10000条序列呢？那是因为有662条序列balst结果的E值大于1e-5，没有在nt中比对上合适的序列</strong></p></div><h2 id="5-输出物种注释分布结果"><a href="#5-输出物种注释分布结果" class="headerlink" title="5 输出物种注释分布结果"></a>5 输出物种注释分布结果</h2><div class="story post-story"><p>到这一步就有很多种处理方法了，可以把结果文件直接用excel打开，统计reads在nt库的分布情况和比对上的物种分布。也可以直接写个python脚本做个数据统计。</p><p>统计前我们先检查一下是否存在上一步匹配失败的reads。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">统计匹配失败的reads</span></span><br><span class="line">cat final_res.txt | grep &quot;INVALID TAXID&quot;</span><br><span class="line">cat final_res.txt | grep &quot;INVALID ACCESSION VERSION&quot;</span><br></pre></td></tr></table></figure><p><img src="https://www.shelven.com/tuchuang/20220619/6.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220619/6.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>提示有8条reads的物种版本号比对不上taxid，且都是Pyrus x bretschneideri这个物种，说明这个物种还未在nucl_gb.accession2taxid这个NCBI官方数据库中更新。在结果文件中将其替换掉。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sed命令在原文件进行全局替换</span></span><br><span class="line">sed -i &#x27;s/INVALID ACCESSION VERSION/Pyrus x bretschneideri/g&#x27; final_res.txt</span><br></pre></td></tr></table></figure><p>修改完成，检查无误后，用以下python脚本统计物种注释分布：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter     <span class="comment"># 引入counter模块</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;./&quot;</span>)</span><br><span class="line"></span><br><span class="line">name_file = <span class="built_in">open</span>(<span class="string">&quot;/public/home/wlxie/luobuma/luobuma/sample_1_rawdata/Third_generation_sequencing/final_res.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)</span><br><span class="line">res_stastics = <span class="built_in">open</span>(<span class="string">&quot;/public/home/wlxie/luobuma/luobuma/sample_1_rawdata/Third_generation_sequencing/stastics.txt&quot;</span>,<span class="string">&quot;w&quot;</span>)</span><br><span class="line"></span><br><span class="line">name_list = []</span><br><span class="line"><span class="keyword">for</span> lines <span class="keyword">in</span> name_file:</span><br><span class="line">    line = lines.strip().split(<span class="string">&quot;\t&quot;</span>)</span><br><span class="line">    name = line[-<span class="number">1</span>]     <span class="comment"># 取最后一列</span></span><br><span class="line">    name_list.append(name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Counter()函数统计词频</span></span><br><span class="line">count_result = Counter(name_list)</span><br><span class="line">count_list = <span class="built_in">list</span>(count_result.items())     <span class="comment"># 注意需要创建一个list</span></span><br><span class="line">count_list.append((<span class="string">&#x27;Unmap&#x27;</span>,<span class="number">662</span>))        <span class="comment"># 注意手动添加blast失败的序列条数到list中</span></span><br><span class="line">count_list.sort(key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>],reverse=<span class="literal">True</span>) <span class="comment"># 以第二维数据值，即统计的物种学名出现次数排序</span></span><br><span class="line"></span><br><span class="line">res_stastics.write(<span class="string">&quot;Name\tHit_reads\tpercentage\n&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> count_list:</span><br><span class="line">    name = i[<span class="number">0</span>]</span><br><span class="line">    number = i[<span class="number">1</span>]</span><br><span class="line">    reads_num = <span class="number">10000</span></span><br><span class="line">    percentage =<span class="string">&quot;%.2f%%&quot;</span>%(<span class="number">100</span>*<span class="built_in">float</span>(number)/<span class="built_in">float</span>(reads_num))       <span class="comment"># 浮点两位小数的百分比</span></span><br><span class="line">    res_stastics.write(name+<span class="string">&quot;\t&quot;</span>+<span class="built_in">str</span>(number)+<span class="string">&quot;\t&quot;</span>+<span class="built_in">str</span>(percentage)+<span class="string">&quot;\n&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>需要注意手动添加blast失败的序列条数</strong>，方便最后一起统计。打开生成的stastics.txt文件：</p><p><img src="https://www.shelven.com/tuchuang/20220619/8.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220619/8.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>这个数据是制表符分割的，可以用excel做一个分布统计表，或者用R做一个柱状图，底下展示结果</p><p><img src="https://www.shelven.com/tuchuang/20220619/9.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220619/9.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>可以看到，10000条序列比对结果占比最高的前两条序列（橘黄色的）是细菌的核酸序列，总数达到3437条。992条序列比对上罗布麻，662条序列未比对上nt库。可以认为这个序测序数据被细菌污染，可以和测序公司battle要求重新测一遍了……</p></div><h2 id="6-补充说明"><a href="#6-补充说明" class="headerlink" title="6 补充说明"></a>6 补充说明</h2><div class="story post-story"><p>秉着科学严谨的态度，再更新一些内容查漏补缺。</p><p>质控过滤后的reads有183万条，而我只取了前1万条。考虑到测序开头的低质量reads可能会对分析结果产生干扰（比如开头的电信号不稳定），我写了个python脚本对过滤后的数据<strong>随机</strong>取10000条reads，这样就只有随机误差影响分析结果了。</p><p>在第2步fq文件处理部分，为了python调用方便，先解压clean_filter.fq.gz文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gunzip clean_filter.fq.gz</span><br></pre></td></tr></table></figure><p>读取解压后的文件需要49G内存，我只能在集群上处理，接着运行如下python脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random       <span class="comment"># 调用random模块产生随机数</span></span><br><span class="line"><span class="keyword">import</span> linecache    <span class="comment"># 调用linecache模块读入指定行</span></span><br><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"></span><br><span class="line">output_file = <span class="built_in">open</span>(<span class="string">&quot;/public/home/wlxie/luobuma/luobuma/sample_1_rawdata/Third_generation_sequencing/random_test.fa&quot;</span>,<span class="string">&quot;w&quot;</span>)</span><br><span class="line"></span><br><span class="line">reads_list = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">1834926</span>))     <span class="comment"># 共有1834925条reads</span></span><br><span class="line">line = random.sample(reads_list,<span class="number">10000</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> line:</span><br><span class="line">    text1 = linecache.getline(<span class="string">&quot;/public/home/wlxie/luobuma/luobuma/sample_1_rawdata/Third_generation_sequencing/clean_filter.fq&quot;</span>,<span class="number">4</span>*i-<span class="number">3</span>)</span><br><span class="line">    text2 = linecache.getline(<span class="string">&quot;/public/home/wlxie/luobuma/luobuma/sample_1_rawdata/Third_generation_sequencing/clean_filter.fq&quot;</span>,<span class="number">4</span>*i-<span class="number">2</span>)</span><br><span class="line">    query_id = text1.split()[<span class="number">0</span>]</span><br><span class="line">    query_id_fa = query_id.replace(<span class="string">&quot;@&quot;</span>, <span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">    output_file.write(query_id_fa + <span class="string">&quot;\n&quot;</span> + text2)</span><br><span class="line">    gc.collect()</span><br></pre></td></tr></table></figure><p>处理方式比之前多了几步，我运行了两次脚本，发现两次产生的文件大小都在135M左右，也就是随机取10000条reads产生的文件比取前10000条reads产生的文件大了40M。证明<strong>三代测序开头测得序列质量不太行</strong>（短序列不一定质量不好，但是质量不好的序列一定是短序列），拿到随机产生的10000条reads做blast，后续步骤都一样。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;div class=&quot;story post-story&quot;&gt;&lt;p&gt;做完基因组三代测序数据质控之后，我们把所有reads的Q值控制在7以上，每个re</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="基因组三代测序分析" scheme="http://www.shelven.com/categories/%E5%9F%BA%E5%9B%A0%E7%BB%84%E4%B8%89%E4%BB%A3%E6%B5%8B%E5%BA%8F%E5%88%86%E6%9E%90/"/>
    
    
    <category term="python" scheme="http://www.shelven.com/tags/python/"/>
    
    <category term="blast+" scheme="http://www.shelven.com/tags/blast/"/>
    
  </entry>
  
  <entry>
    <title>0基础学习基因组三代测序组装（1）——数据质控</title>
    <link href="http://www.shelven.com/2022/06/17/b.html"/>
    <id>http://www.shelven.com/2022/06/17/b.html</id>
    <published>2022-06-17T14:31:19.000Z</published>
    <updated>2022-06-17T15:32:47.737Z</updated>
    
    <content type="html"><![CDATA[<p>最近拿到一个植物基因组的三代和二代测序数据，想通过以三代测序数据为主，二代测序数据为辅的方式学习一下如何拼接组装一个基因组。但是三代测序数据刚到手就懵了，与之前学习的转录组分析不一样，三代测序返回的几个文件不是单纯的fq文件，如下所示：</p><p><img src="https://www.shelven.com/tuchuang/20220617/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220617/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>于是我又开始恶补了一些三代测序的基础知识，开坑写个三代基因组测序组装的系列笔记~</p><h2 id="1-技术背景"><a href="#1-技术背景" class="headerlink" title="1 技术背景"></a>1 技术背景</h2><div class="story post-story"><p>当第二代高通量测序技术进入成熟阶段后，读长过短、PCR扩增带来的偏向性等问题开始日益凸显；作为基因组学上新的转折点，以PacBio单分子实时测序技术及纳米孔单分子测序技术为首的第三代高通量测序技术（Third-generation Sequencing）开始进入科研应用，从单分子水平上对DNA分子的实时测序，成功解决了二代测序几大困扰：<strong>极端 GC含量区域覆盖度低、高度重复区域无法较好地拼装、大片段变异难以准确检测、不能直接检测碱基修饰</strong>等问题。</p><p>ONT（Oxford Nanopore Technologies）牛津纳米孔测序技术作为第三代单分子实时测序技术，其原理是基于高分子膜两侧电压和其中的蛋白质纳米孔，当单分子DNA从纳米孔通过时，会引起孔两侧电位差来实现信号检测， 而ATCG四种碱基的带电性质不一样，因此利用<strong>电信号的差异</strong>就能检测出通过的碱基类型，从而实现测序。</p><p>Nanopore商业化平台有三个：MinION、GridION及PromethION。本系列笔记的三代测序数据来源于<strong>PromethION</strong>测序平台测序的一个cell，PromethION测序仪拥有48个流动槽，每个流动槽拥有3000个纳米孔通道（总计144000个），适用于大样本量的高通量快速测序。</p></div><h2 id="2-数据质控"><a href="#2-数据质控" class="headerlink" title="2 数据质控"></a>2 数据质控</h2><div class="story post-story"><h3 id="basecalling"><a href="#basecalling" class="headerlink" title="basecalling"></a>basecalling</h3><p>在ONT的测序平台中，将通过纳米孔的DNA或RNA链产生的电位信号转化为相应的碱基序列的过程，称为<strong>basecalling</strong>。Nanopore测序的下机数据的原始数据格式为包含原始测序电信号的<strong>fast5格式</strong>，官方有提供工具Guppy进行basecalling，以<strong>mean_qscore_template的数值大于等于7</strong>为标准（也就是测序质量大于7的reads）得到原始测序数据，这样得到的basecalling数据为<strong>fastq格式</strong>（.fastq或者.fq结尾），所以我拿到的就是已经basecalling后的结果。</p><ul><li>fast5: 原始电信号文件，以.fast5为文件结尾。此文件既有测序得到的序列信息，还有甲基化修饰信息（甲基化位点电信号会不一样）。</li><li>fastq: fast5文件转换而来，四行一个单位，序列和碱基质量一一对应。</li></ul><p>basecalling的同时还可以一起拆分barcode条码序列，这里我没用到guppy这个软件，了解一下就行。经过basecalling后，文件会分为<strong>fail和pass</strong>两部分，pass部分就是满足<strong>Q值&gt;7</strong>的序列（二代测序质控标准是Q20，这里的三代测序质控标准是Q7，准确性不及二代测序）。</p><p>还有一个summary.txt文件，这是一个测序汇总文件，结构如下：</p><p><img src="https://www.shelven.com/tuchuang/20220617/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220617/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>第一眼看上去很乱，几个重要的列含义如下：</p><blockquote><ol><li>filename_fastq  fasq文件名</li><li>filename_fast5  fast5文件名</li><li>read_id  每条read对应的id号</li><li>run_id  这一次运行产生的id号，一个flowcell通常为一个run</li><li>channel mux  该条read在哪个channel测的</li><li>start_time  这条read测序起始时间</li><li>duration  这条read测序经过时间</li><li>passes_filtering  <strong>Q值大于7为TRUE否则为FALSE</strong></li><li>sequence_length_template   read长度，<strong>三代测序数据过滤的指标之一</strong></li><li>mean_qscore_template  非常重要的指标，<strong>每一个read的平均Q值</strong></li><li>有关barcode的都是标签序列相关参数，因为不同样品接头会添加不同的标签序列，混测的时候根据标签序列与样品的对应关系来区分不同样品。</li></ol></blockquote><p>返回的数据是guppy处理过的，也就是raw reads，接下来质控的过程就需要自己动手了。</p><h3 id="nanoplot质控"><a href="#nanoplot质控" class="headerlink" title="nanoplot质控"></a>nanoplot质控</h3><p>先说明下为什么要用这个工具，三代测序的数据读长比二代测序长很多，而且每条序列的长度都是不一样的。不能用之前转录组数据分析中的fastq工具，会报错，因此使用nanoplot工具来生成质检报告，同样也是会生成各种html文件方便浏览结果。</p><p>先创建一个nanoplot专用的环境，下载nanoplot，之后的质控过程都在这个环境下进行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建环境并下载nanoplot</span></span><br><span class="line">conda create -n nanoplot -y -c bioconda nanoplot</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">激活环境</span></span><br><span class="line">. activate nanoplot</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成质检报告。可以用pass.fq文件，也可以直接用summery.txt文件。-o参数后面是输出文件夹名称。</span></span><br><span class="line">NanoPlot --summary summary.txt --loglength -o summary-plots-log-transformed</span><br><span class="line">NanoPlot -t 4 --fastq pass.fq.gz --plots hex dot -o nanoplot_out</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">详细参数设置可以在NanoPlot --<span class="built_in">help</span>中查看</span></span><br></pre></td></tr></table></figure><p>运行结束之后会生成summary-plots-log-transformed这个文件夹，我们可以用xftp工具查看里面的html结果文件，也可以挑取一些数据做数据质量统计表。</p><p>放一张原始测序数据读长分布图示意一下：</p><p><img src="https://www.shelven.com/tuchuang/20220617/5.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220617/5.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><a href="https://www.shelven.com/tuchuang/20220617/NanoPlot-report.html">点击这里查看用summary.txt生成的质控报告</a></p><p><a href="https://www.shelven.com/tuchuang/20220617/NanoPlot-report1.html">点击这里查看用pass.fq.gz生成的质控报告</a><strong>（推荐用这个）</strong></p><p>两种方法生成的质控报告略微有点差别，因为summary.txt文件中记录了所有序列，可以看到有部分序列质量在Q5-Q7之间；而pass.fg.gz生成的质控报告中，<strong>所有序列的质量都在Q7及以上</strong>。后续以分析pass.fq.gz文件生成的质控报告为准，对这个文件序列的长度进行过滤。</p><p>如果不需要图，只需要知道有多少条reads、reads平均长度、N50、N90这些数据做表格的话，还有一个比较实用的<strong>perl脚本</strong>，怎么使用就不赘述了，源代码放底下参考。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#/usr/bin/perl -w</span></span><br><span class="line"><span class="keyword">use</span> strict;</span><br><span class="line"><span class="keyword">use</span> warnings;</span><br><span class="line"></span><br><span class="line"><span class="comment">### *fastq.gz 数据统计 N50 N90 num_seqs sum_len min_len avg_len max_len </span></span><br><span class="line"><span class="comment">### usage: perl stat.fastq.gz.N50.N90.pl *.fastq.gz</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">my</span> $fastq_gz = $ARGV[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">open</span>(IN,<span class="string">&quot;gzip -dc $fastq_gz|&quot;</span>) <span class="keyword">or</span> <span class="keyword">die</span> (<span class="string">&quot;can not open $fastq_gz\n&quot;</span>);</span><br><span class="line"><span class="keyword">open</span>(OUT,<span class="string">&quot;&gt;$fastq_gz.stat&quot;</span>);</span><br><span class="line"><span class="keyword">print</span> OUT <span class="string">&quot;name num_seqs    sum_len min_len avg_len max_len N50 N90\n&quot;</span>;</span><br><span class="line"><span class="keyword">print</span> OUT <span class="string">&quot;$fastq_gz\t&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">my</span> ($len,$total,$num_seqs,$min_len,$max_len)=(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">my</span> @length_list;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(&lt;IN&gt;)&#123;</span><br><span class="line">    <span class="keyword">my</span> $title = $_;</span><br><span class="line">    <span class="keyword">my</span> $seq = &lt;IN&gt;;</span><br><span class="line">    <span class="keyword">my</span> $add = &lt;IN&gt;;</span><br><span class="line">    <span class="keyword">my</span> $quality = &lt;IN&gt;;</span><br><span class="line">    $seq =~ <span class="regexp">s/\r|\n|\r\n//mg</span>;</span><br><span class="line">    $len = <span class="keyword">length</span>($seq);</span><br><span class="line">    <span class="keyword">if</span>($len&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        $total += $len;</span><br><span class="line">        <span class="keyword">push</span> @length_list,$len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>($min_len == <span class="number">0</span>)&#123;$min_len = $len;&#125;<span class="keyword">elsif</span>($min_len &gt; $len)&#123;$min_len = $len;&#125;</span><br><span class="line">    <span class="keyword">if</span>($max_len == <span class="number">0</span>)&#123;$max_len = $len;&#125;<span class="keyword">elsif</span>($max_len &lt; $len)&#123;$max_len = $len;&#125; </span><br><span class="line">    $len=<span class="number">0</span>;</span><br><span class="line">    $num_seqs++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">my</span> $avg_len = $total/$num_seqs;</span><br><span class="line"><span class="keyword">print</span> OUT <span class="string">&quot;$num_seqs\t&quot;</span>;</span><br><span class="line"><span class="keyword">print</span> OUT <span class="string">&quot;$total\t&quot;</span>;</span><br><span class="line"><span class="keyword">print</span> OUT <span class="string">&quot;$min_len\t&quot;</span>;</span><br><span class="line"><span class="keyword">print</span> OUT <span class="string">&quot;$avg_len\t&quot;</span>;</span><br><span class="line"><span class="keyword">print</span> OUT <span class="string">&quot;$max_len\t&quot;</span>;</span><br><span class="line"></span><br><span class="line">@length_list=<span class="keyword">sort</span>&#123;$b&lt;=&gt;$a&#125; @length_list;</span><br><span class="line"></span><br><span class="line"><span class="keyword">my</span> ($count,$half)=(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">my</span> $j=<span class="number">0</span>;$j&lt;@length_list;$j++)&#123;</span><br><span class="line">    $count+=$length_list[$j];</span><br><span class="line">    <span class="keyword">if</span> (($count&gt;=$total/<span class="number">2</span>)&amp;&amp;($half==<span class="number">0</span>))&#123;</span><br><span class="line">        <span class="keyword">print</span> OUT <span class="string">&quot;$length_list[$j]\t&quot;</span>;</span><br><span class="line">        $half=$length_list[$j]</span><br><span class="line">    &#125;<span class="keyword">elsif</span> ($count&gt;=$total*<span class="number">0</span>.<span class="number">9</span>)&#123;</span><br><span class="line">        <span class="keyword">print</span> OUT <span class="string">&quot;$length_list[$j]\t\n&quot;</span>;</span><br><span class="line">        <span class="keyword">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="filtlong过滤数据"><a href="#filtlong过滤数据" class="headerlink" title="filtlong过滤数据"></a>filtlong过滤数据</h3><p>前面说过，二代测序是双端测序，三代测序是单端测序，两者过滤数据的要求不同。三代测序主要是过滤<strong>长度过短的序列和测序质量较低的序列</strong>。在basecalling中我们过滤了Q值小于7的序列，现在还要过滤read长度小于1000bp的序列。过滤后的序列可以直接用于后续的组装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装filtlong软件</span></span><br><span class="line">conda install -y filtlong</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置序列最短为1000bp，压缩结果文件到新文件中</span></span><br><span class="line">filtlong --min_length 1000 pass.fq.gz | gzip &gt; clean_filter.fq.gz</span><br></pre></td></tr></table></figure><p><img src="https://www.shelven.com/tuchuang/20220617/6.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220617/6.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>可以看到过滤了一部分数据，用过滤后的数据再跑一次NanoPlot</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NanoPlot -t 4 --fastq clean_filter.fq.gz --plots hex dot -o filt_nanoplot_out</span><br></pre></td></tr></table></figure><p>测序数据读长分布如下，可以看到已经没有1kb以下的reads了：</p><p><img src="https://www.shelven.com/tuchuang/20220617/8.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220617/8.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><a href="https://www.shelven.com/tuchuang/20220617/NanoPlot-report2.html">点击这里查看过滤后的质控报告</a></p><p>至此质控过滤流程结束，我们可以做一个下机数据质控统计表：</p><table><thead><tr><th>Type</th><th>Bases(bp)</th><th>Reads Number</th><th>Reads mean length(bp)</th><th>Reads N50 length(bp)</th></tr></thead><tbody><tr><td>Raw Reads</td><td>25,584,046,180.0</td><td>1,933,526.0</td><td>13,231.8</td><td>28,127.0</td></tr><tr><td>Filtered Reads</td><td>25,531,304,191.0</td><td>1,834,925.0</td><td>13,914.1</td><td>28,184.0</td></tr></tbody></table></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近拿到一个植物基因组的三代和二代测序数据，想通过以三代测序数据为主，二代测序数据为辅的方式学习一下如何拼接组装一个基因组。但是三代测序数据刚到手就懵了，与之前学习的转录组分析不一样，三代测序返回的几个文件不是单纯的fq文件，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;h</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="基因组三代测序分析" scheme="http://www.shelven.com/categories/%E5%9F%BA%E5%9B%A0%E7%BB%84%E4%B8%89%E4%BB%A3%E6%B5%8B%E5%BA%8F%E5%88%86%E6%9E%90/"/>
    
    
    <category term="nanoplot" scheme="http://www.shelven.com/tags/nanoplot/"/>
    
    <category term="filtlong" scheme="http://www.shelven.com/tags/filtlong/"/>
    
  </entry>
  
  <entry>
    <title>NCBI的BLAST+工具本地安装，本地建库和BLAST比对</title>
    <link href="http://www.shelven.com/2022/06/17/a.html"/>
    <id>http://www.shelven.com/2022/06/17/a.html</id>
    <published>2022-06-16T18:33:56.000Z</published>
    <updated>2022-06-17T15:33:13.270Z</updated>
    
    <content type="html"><![CDATA[<p>接触过生物学的小伙伴对<a href="https://blast.ncbi.nlm.nih.gov/Blast.cgi">NCBI在线BLAST网页</a>一定不陌生，简单介绍一下这个网页的5种比对工具：</p><ul><li>blastn    用核苷酸序列检索核苷酸数据库</li><li>blastp    用蛋白质序列检索蛋白质数据库</li><li>blastx    核苷酸序列通过6种阅读框翻译不同蛋白序列后，检索蛋白数据库</li><li>tblastn    蛋白序列比对核酸库，核酸数据库通过6种开放阅读框翻译不同蛋白质</li><li>tblastx    核酸序列和核酸数据库都通过6种开放阅读框翻译后比对</li></ul><p>平常我们用的最多的就是blastn和blastp，进入网页，选择blast方式，然后贴上自己的quary序列，选择数据库，选择比对的物种，设置参数如E值，wordlength长度等等。但是NCBI网站的BLAST在线工具有个让人特别无语的缺点：<strong>国内访问速度巨慢</strong>！不仅仅是比对过程慢，一条序列还好，大批量数据比对就不要想了，有的时候网页都打不开一直转圈圈。因此本地化blast工具还是很有必要的。</p><p>好在NCBI很贴心地提供了blast+工具，我们安装好blast+工具和下载好数据库以后，就可以不依赖网页和NCBI地服务器，在本地服务器上运行了。</p><h2 id="1-安装blast"><a href="#1-安装blast" class="headerlink" title="1 安装blast+"></a>1 安装blast+</h2><div class="story post-story"><p>最新版blast+工具可以通过ftp方式获得，<a href="https://ftp.ncbi.nlm.nih.gov/blast/executables/blast+/LATEST/">点击这里</a></p><p>我是在集群账户下安装，集群机器都是linux操作系统的，因此我选择的最新linux版本</p><p><img src="https://www.shelven.com/tuchuang/20220616/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220616/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><strong>别忘了要连md5校验文件一起下载</strong>，谁都不知道下载过程中是否会出错，因此大的文件下载完以后都是需要验证文件完整性的！</p><p>将上面的ftp地址拼凑一下，网速好的话可以直接用wget下载，但是我这边服务器连NCBI网速实在太慢了，wget只有10Kb&#x2F;s的速度，甚至还会断开重连。看的我高血压都要犯了，无奈之下挂了个梯子，在自己电脑上下载好这两份文件，通过xftp传到了服务器上。</p><p>在服务器上首先校验文件完整性:</p><p><code>md5sum -c ncbi-blast-2.13.0+-x64-linux.tar.gz.md5</code></p><p>显示结果OK后，解压：</p><p><code>tar -zxvf ncbi-blast-2.13.0+-x64-linux.tar.gz</code></p><p>名字太长了，不方便以后找，顺便改个名就叫blast：</p><p><code>mv ncbi-blast-2.13.0+-x64-linux.tar.gz blast</code></p><p>然后是配置环境变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc       # 编辑环境变量文件</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在.bashrc文件最后一行加入如下内容（根据自己路径修改）</span></span><br><span class="line">export PATH=&quot;/public/home/wlxie/blast/bin:$PATH&quot;</span><br></pre></td></tr></table></figure><p>保存退出后重新source一下.bashrc文件，blast+工具就安装好了。</p></div><h2 id="2-下载nr-x2F-nt数据库"><a href="#2-下载nr-x2F-nt数据库" class="headerlink" title="2 下载nr&#x2F;nt数据库"></a>2 下载nr&#x2F;nt数据库</h2><div class="story post-story"><p>我们比对一般用的是NCBI的非冗余蛋白&#x2F;核酸数据库，有两种方法下载nr&#x2F;nt数据库：</p><ul><li><p>1.通过blast+工具自带的更新程序下载</p></li><li><p>2.通过aspera工具下载</p></li></ul><p>同样是网速的问题，如果用第一种方法下载，我们可以在~&#x2F;blast&#x2F;bin目录下找到如下的perl程序</p><p><img src="https://www.shelven.com/tuchuang/20220616/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220616/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>直接运行命令 <code>perl update_blastdb.pl nt</code></p><p>但是10几kb&#x2F;s的速度真的让人抓狂，所以我推荐第二种方法：用IBM公司开发的快速下载神器——aspera</p><h3 id="安装aspera"><a href="#安装aspera" class="headerlink" title="安装aspera"></a>安装aspera</h3><p>在我之前写的一篇博客里推荐过sra-tools工具中的prefetch，用来下载SRA数据中存放的高通量测序原始数据。prefetch软件就是默认通过aspera工具进行下载的。</p><p>如果之前没有安装过aspera，可以用conda直接安装，命令如下：</p><p><code>conda install -c hcc aspera-cli</code></p><p>这里注意下aspera-cli是aspera的命令行版本，各种不同版本的本质上下载都是调用ascp程序，并且需要<strong>openssh公钥认证</strong>，不同版本的aspera公钥文件存放的位置不同。因为我们是通过conda安装的aspera，aspera-cli公钥文件的位置在<strong>你的conda环境目录下的etc文件夹中</strong>，比如我的aspera-cli公钥文件在&#x2F;public&#x2F;home&#x2F;wlxie&#x2F;miniconda3&#x2F;envs&#x2F;biosoft&#x2F;etc</p><p>而且因为是conda安装的，我们不需要修改什么配置文件和依赖关系，还是挺省事的。</p><h3 id="用aspera下载数据库nr-x2F-nt"><a href="#用aspera下载数据库nr-x2F-nt" class="headerlink" title="用aspera下载数据库nr&#x2F;nt"></a>用aspera下载数据库nr&#x2F;nt</h3><p>nr&#x2F;nt数据库也可以通过ftp方式获得，<a href="https://ftp.ncbi.nlm.nih.gov/blast/db/FASTA/">点击这里查看ftp网址</a></p><p>为了方便找到下载到本地的数据库，先在家目录新建db&#x2F;blast文件夹，进入这个文件夹后，在当前目录下运行如下命令：</p><p><code>ascp -QT -i /public/home/wlxie/miniconda3/envs/biosoft/etc/asperaweb_id_dsa.openssh -k1 -l 500m anonftp@ftp.ncbi.nlm.nih.gov:/blast/db/FASTA/nt.gz ./</code></p><p>这里是其中一个nt数据库，nr数据库只要改一个字母就行了，两个数据库都要下载。</p><p>稍微解释下各参数的含义：</p><ul><li>-Q 用于自适应流量控制，磁盘限制所需；-T 是取消加密，否则有时候数据下载不了。两个参数是搭配一起使用的</li><li>-i 输入私钥文件，注意下载的ascp版本不一样文件位置也不一样</li><li>-k1 这里是加上了断点传续功能</li><li>-l 限制最大下载速度</li><li>后面一串是账户@ftp地址:路径。<strong>注意@和冒号</strong>。NCBI公共账号是<strong>anonftp</strong>，也就是你下载SRA数据库数据也可以用这个账号；EBI公共账号是<strong>era-fasp</strong></li><li>最后指定下载文件的路径，我用了当前路径</li></ul><p><img src="https://www.shelven.com/tuchuang/20220616/3.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220616/3.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>可以看到下载速度杠杠的，提升了不知道多少倍…下载大数据都可以用ascp命令。</p><p><strong>下载好之后同样别忘了校验md5文件，校验后gunzip直接解压到当前文件夹。</strong></p></div><h2 id="3-本地建库"><a href="#3-本地建库" class="headerlink" title="3 本地建库"></a>3 本地建库</h2><div class="story post-story"><p>解压完成以后我们可以看到这两个数据库总大小在980G</p><p><img src="https://www.shelven.com/tuchuang/20220616/5.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220616/5.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>现在还不能用这两个数据库，需要对这两个超大的数据文件建索引，也就是本地建库。</p><p>使用如下命令：</p><p><code>makeblastdb -in nt -dbtype nucl -input_type fasta -out nt</code></p><p><code>makeblastdb -in nr -dbtype prot -input_type fasta -out nr</code></p><ul><li>-in: 待格式化的序列文件</li><li>-dbtype: 数据类型，prot为蛋白序列，nucl为核酸序列</li><li>-input_type: 输入数据的类型，默认为fasta格式</li><li>-out: 自定义的数据库名称</li></ul><p><img src="https://www.shelven.com/tuchuang/20220616/7.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220616/7.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><img src="https://www.shelven.com/tuchuang/20220616/8.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220616/8.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>这一步需要非常长时间，在目录下能看到有文件生成并且没有报错就行了，同样的操作方法可以用<strong>自己的基因组数据建库</strong>。</p><p>这里有两条核苷酸序列可能有问题，序列录到了开头第一行，不过就只有两条序列应该不影响。nt库录入了0.8亿条序列，nr库录入了4.8亿条序列。</p></div><h2 id="4-创建blast全局配置文件"><a href="#4-创建blast全局配置文件" class="headerlink" title="4 创建blast全局配置文件"></a>4 创建blast全局配置文件</h2><div class="story post-story"><p>在家目录下创建blast全局配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">vim .ncbirc        <span class="comment"># 家目录下创建一个新文件.ncbirc，输入如下内容</span></span></span><br><span class="line"></span><br><span class="line">; Start the section for BLAST configuration</span><br><span class="line"></span><br><span class="line">[BLAST]</span><br><span class="line"></span><br><span class="line">; Specifies the path where BLAST databases are installed</span><br><span class="line"></span><br><span class="line">BLASTDB=/public/home/wlxie/db/blast</span><br><span class="line"></span><br><span class="line">; Specifies the data sources to use for automatic resolution</span><br><span class="line"></span><br><span class="line">; for sequence identifiers</span><br><span class="line"></span><br><span class="line">DATA_LOADERS=blastdb</span><br><span class="line"></span><br><span class="line">; Specifies the BLAST database to use resolve protein sequences</span><br><span class="line"></span><br><span class="line">BLASTDB_PROT_DATA_LOADER=/public/home/wlxie/db/blast/nr</span><br><span class="line"></span><br><span class="line">; Specifies the BLAST database to use resolve protein sequences</span><br><span class="line"></span><br><span class="line">BLASTDB_NUCL_DATA_LOADER=/public/home/wlxie/db/blast/nt</span><br><span class="line"></span><br><span class="line">BATCH_SIZE=10G</span><br><span class="line"></span><br><span class="line">; Windowmasker settings</span><br><span class="line"></span><br><span class="line">[WINDOW_MASKER]</span><br><span class="line"></span><br><span class="line">WINDOW_MASKER_PATH=/public/home/wlxie/db/blast/windowmasker</span><br><span class="line"></span><br><span class="line">; end of file</span><br></pre></td></tr></table></figure><p>以上设置中定义了blastn和blastp默认的地址，这样我们在比对数据库的时候可以直接输入数据库的名称而不用给出绝对路径，方便一点（这步不是必须的，可选）。</p></div><h2 id="5-运行blast程序"><a href="#5-运行blast程序" class="headerlink" title="5 运行blast程序"></a>5 运行blast程序</h2><div class="story post-story"><p>以上准备工作完成后，准备一段query序列试一下，我的query序列名称是gene.fna</p><p>运行blastn程序：</p><p><code>blastn -query gene.fna -out gene_blastn_nr.out -db nt -outfmt 6 -evalue 1e-5 -num_threads 10</code></p><ul><li>-query: 用来查询的输入序列</li><li>-db: 指定的数据库名称</li><li>-out: 自定义输出的结果文件，最好统一格式。我是基因名_比对方法_数据库.out，这样比较直观知道比对了什么，怎么比对的</li><li>-outfmt: blast结果的呈现形式，<strong>一般用6比较多</strong>，也就是m8格式，以制表符为分隔符，有部分信息会缺失。5是XML格式比较适合解析，7在6基础上加了表头。</li><li>-evalue: 限定E值</li><li>-num_threads: 指定多少个核运行blast程序</li></ul><p>还有其他参数比如就不一一介绍了，说明一下，一个序列的blast可以用上面的命令，多个序列的blast同样适用，把多个fasta格式的序列放进去即可。</p><p>当然，批量blast的结果需要限定匹配的结果数量，毕竟我们不可能几百上千个序列一一查看，可以指定参数-max_target_seqs 5限制每个序列的最大匹配数量，这个数值推荐是在5以上，5以下会有警告信息。</p><p>blast结果m8格式如下：</p><p><img src="https://www.shelven.com/tuchuang/20220616/9.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220616/9.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>一共12列，分别能获得如下信息：</p><blockquote><p>1、Query id：查询序列ID标识</p><p>2、Subject id：比对上的目标序列ID标识</p><p>3、% identity：序列比对的<strong>一致性</strong>百分比</p><p>4、alignment length：符合比对的比对区域的长度</p><p>5、mismatches：比对区域的错配数</p><p>6、gap openings：比对区域的gap数目</p><p>7、q. start：比对区域在查询序列(Query id)上的起始位点</p><p>8、q. end：比对区域在查询序列(Query id)上的终止位点</p><p>9、s. start：比对区域在目标序列(Subject id)上的起始位点</p><p>10、s. end：比对区域在目标序列(Subject id)上的终止位点</p><p>11、e-value：比对结果的期望值，解释是大概多少次随即比对才能出现一次这个score，Evalue越小，表明这种情况从概率上越不可能发生，那么发生了即说明这更有可能是真实的相似序列</p><p>12、bit score：比对结果的bit score值，越高越好</p></blockquote></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;接触过生物学的小伙伴对&lt;a href=&quot;https://blast.ncbi.nlm.nih.gov/Blast.cgi&quot;&gt;NCBI在线BLAST网页&lt;/a&gt;一定不陌生，简单介绍一下这个网页的5种比对工具：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;blastn    用核苷酸序列检索核苷</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="基因组三代测序分析" scheme="http://www.shelven.com/categories/%E5%9F%BA%E5%9B%A0%E7%BB%84%E4%B8%89%E4%BB%A3%E6%B5%8B%E5%BA%8F%E5%88%86%E6%9E%90/"/>
    
    
    <category term="BLAST+" scheme="http://www.shelven.com/tags/BLAST/"/>
    
    <category term="aspera" scheme="http://www.shelven.com/tags/aspera/"/>
    
  </entry>
  
  <entry>
    <title>perl语言学习笔记（1）</title>
    <link href="http://www.shelven.com/2022/06/16/a.html"/>
    <id>http://www.shelven.com/2022/06/16/a.html</id>
    <published>2022-06-15T16:07:31.000Z</published>
    <updated>2022-06-15T16:10:16.104Z</updated>
    
    <content type="html"><![CDATA[<p>最近在处理三代测序的下机数据，用到了一些挺好用的perl脚本，但是苦于没接触这种类型的编程语言，想根据情况改一些代码却看不懂实现方式**&#x3D; &#x3D;**</p><p>前面说学习perl可以只学怎么调用模块，马上啪啪打脸了，这货和python还是有点不一样的，还是抽空补补基础吧~现在做生信用的最多的就是R、python和perl，多掌握一门编程语言还是挺有必要的。记录一下自学的过程和笔记，自学视频来源是b站up主<a href="https://space.bilibili.com/338686099?spm_id_from=333.337.0.0">生信技能树-jimmy</a></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><div class="story post-story"><p>首先了解一下perl脚本的结构，以blast结果过滤的perl脚本为例，输入文件blast_m8.out是一个12列，分隔符为空格的文件：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/perl -w      # 选择解释器类型为perl，-w是运行错误时提供警告信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> IN,<span class="string">&quot;blast_m8.out&quot;</span>;     <span class="comment"># 打开文件，m8格式输出的blastout文件。每次只读一行</span></span><br><span class="line"><span class="keyword">while</span> (&lt;IN&gt;) &#123;      <span class="comment"># 大括号为程序块，每个程序块是一个独立的部分，执行相对独立的功能</span></span><br><span class="line">    <span class="keyword">chomp</span>;      <span class="comment"># 去掉读进来数据结尾的换行符\n（没有换行符则不起作用）</span></span><br><span class="line">    <span class="keyword">my</span> @line=<span class="keyword">split</span> <span class="regexp">/\s+/</span>,$_;        <span class="comment"># 以空白分割(\s是匹配任何空白符，+表示匹配任意多个),存入数组中</span></span><br><span class="line">    <span class="keyword">if</span> ($line[<span class="number">2</span>] &gt;=<span class="number">50</span> &amp;&amp; $line[<span class="number">3</span>] &gt;=<span class="number">100</span>) &#123;</span><br><span class="line">        <span class="keyword">print</span> <span class="string">&quot;$_\n&quot;</span>;       <span class="comment"># 将第三列identity值大于50，第四列序列长度大于100的blast结果输出</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">next</span>;       <span class="comment"># 否则进入下一个循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">close</span> IN;</span><br><span class="line"><span class="comment"># 这个脚本第四行的my也要注意下，一般是需要申明use strict;也就是使用严谨的方式，在这种方式下，任何变量都必须先定义，不使用my的话定义第一次出现的$和@运行会报错。初学可以不使用use strict。</span></span><br><span class="line"><span class="comment"># $_这个变量是使用非常多的，如果没有定义变量名称，则默认使用$_</span></span><br></pre></td></tr></table></figure><p>OK，格式与python不一样，以<strong>分号</strong>作为每一行结尾，基础语法类似但不完全一样，先从基础学起。</p></div><h2 id="1-标量数据"><a href="#1-标量数据" class="headerlink" title="1 标量数据"></a>1 标量数据</h2><div class="story post-story"><h3 id="标量数据特点"><a href="#标量数据特点" class="headerlink" title="标量数据特点"></a>标量数据特点</h3><ul><li>perl中最基本的数据类型</li><li>可以是数字、字母</li><li>无需定义类型（所有perl语言的数据都是双精度浮点型，<strong>不需要对数据类型进行定义</strong>，代价是消耗内存）</li><li>“单数为标量”</li></ul><h3 id="字符串运算"><a href="#字符串运算" class="headerlink" title="字符串运算"></a>字符串运算</h3><ul><li>字符串就是一连串字符组合，可以是字母数字标点等</li><li>对DNA序列处理本质上就是处理字符串</li><li>字符串可以为空</li><li>需要“引号”，尽量使用双引号</li><li>字符串连接“.”或者“x”  如 “hello” . “world”</li></ul><h3 id="标量变量"><a href="#标量变量" class="headerlink" title="标量变量"></a>标量变量</h3><p>标量变量用来动态存储标量值，以美元符号$表示（定义数组用@符号），<strong>和linux一样不能以数字开头</strong></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一个=表示赋值，两个==表示判断，这里和python是一样的</span></span><br><span class="line">$gene_num=<span class="number">3</span></span><br><span class="line">$gene_num=$gene_num+<span class="number">4</span></span><br><span class="line">$gene_num+=<span class="number">4</span>        <span class="comment"># 双目运算符，运算所需变量为两个运算符，这个简写是非常常用的</span></span><br><span class="line">$dna=<span class="string">&quot;ATCGGGTATCG&quot;</span></span><br><span class="line">$dna.=<span class="string">&quot;ATCGGGTCG&quot;</span>       <span class="comment"># 双目运算符同样可以用于字符串操作，得到标量变量为连接的字符串</span></span><br></pre></td></tr></table></figure></div><h2 id="2-数组和列表"><a href="#2-数组和列表" class="headerlink" title="2 数组和列表"></a>2 数组和列表</h2><div class="story post-story"><h3 id="数组构建"><a href="#数组构建" class="headerlink" title="数组构建"></a>数组构建</h3><p>列表（list）指标量的有序集合，数组（array）则是存储列表的变量</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@array=（<span class="number">1</span>,<span class="string">&quot;hello&quot;</span>,<span class="keyword">undef</span>,$dna,<span class="number">5</span>）;      <span class="comment"># 左边为数组，右边为列表，构建列表中间用逗号隔开</span></span><br><span class="line">$array[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">$array[<span class="number">1</span>]=<span class="string">&quot;hello&quot;</span>       <span class="comment"># 注意下标数字从0开始，0表示第一个元素</span></span><br><span class="line">数组的最后一个元素角标$#array，因此数组元素个数=$#array+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">@number=(<span class="number">1</span>..<span class="number">100</span>)        <span class="comment"># 范围操作符(..)每次加一</span></span><br><span class="line">@string=<span class="string">qw (fred barney betty wilma dino)</span>       <span class="comment"># qw操作符可以省略逗号</span></span><br></pre></td></tr></table></figure><h3 id="split和join函数"><a href="#split和join函数" class="headerlink" title="split和join函数"></a>split和join函数</h3><ul><li>split将字符串根据固定的分隔符进行切割，切割后得到一个数组</li><li>join与split相反，将数组连接成一个标量</li></ul><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/perl</span></span><br><span class="line"></span><br><span class="line">$scalar=<span class="string">&quot;a:bcd:123:de&quot;</span>;</span><br><span class="line">@array=<span class="keyword">split</span> <span class="regexp">/:/</span>,$scalar;       <span class="comment"># 以冒号作为分隔符分割</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;@array\n&quot;</span></span><br><span class="line"></span><br><span class="line">$new_scalar=<span class="keyword">join</span> <span class="string">&quot;\t&quot;</span>,@array;       <span class="comment"># 以制表符作为分割符，好处是excel里打开每个元素在不同单元格</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;$new_scalar\n&quot;</span></span><br></pre></td></tr></table></figure><h3 id="pop和push函数"><a href="#pop和push函数" class="headerlink" title="pop和push函数"></a>pop和push函数</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/perl</span></span><br><span class="line">@number=(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">$value=<span class="keyword">pop</span> @number;     <span class="comment"># pop提取数组的最后一个元素</span></span><br><span class="line"><span class="keyword">push</span> @number,<span class="number">6</span>;     <span class="comment"># push添加一个元素到数组的末尾</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;$value\n@number\n&quot;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://www.shelven.com/tuchuang/20220615/01.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220615/01.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="shift和unshift函数"><a href="#shift和unshift函数" class="headerlink" title="shift和unshift函数"></a>shift和unshift函数</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/perl</span></span><br><span class="line">@number=(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">$value=<span class="keyword">shift</span> @number;       <span class="comment"># shift提取数组第一个元素</span></span><br><span class="line"><span class="keyword">unshift</span> @number,<span class="number">10</span>;     <span class="comment"># unshift添加一个元素到数组的开头</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;$value\n@number\n&quot;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://www.shelven.com/tuchuang/20220615/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220615/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>一般来说pop和shift用的比较多，一个提取数组末尾元素，一个提取数组开头元素。</p><p>因为我们用perl处理的往往是矩阵文件，第一行是ID信息，我们往往是读入一行数据，去掉换行符，存储为标量，分割数组。这个时候就要用shift函数，将ID提取出来，这样呢后面都是<strong>同一种类型的数据</strong>，方便我们操作，也就是底下这个框架：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/perl</span></span><br><span class="line"><span class="keyword">while</span> (&lt;IN&gt;) &#123;</span><br><span class="line">    <span class="keyword">chomp</span>;</span><br><span class="line">    <span class="keyword">my</span> @line=<span class="keyword">split</span> <span class="regexp">/\s+/</span>,$_;</span><br><span class="line">    <span class="keyword">my</span> @id=<span class="keyword">shift</span> @line；</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot;$id\n&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sort和reverse函数"><a href="#sort和reverse函数" class="headerlink" title="sort和reverse函数"></a>sort和reverse函数</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/perl</span></span><br><span class="line">@number=(<span class="number">1</span>..<span class="number">10</span>);</span><br><span class="line">@number_sort=<span class="keyword">sort</span> @number;      <span class="comment"># sort函数使数组按照ASCII码大小排序</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;@number_sort\n&quot;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://www.shelven.com/tuchuang/20220615/3.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220615/3.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>可以看到10在1的后面，因为sort函数是以<strong>ASCII码大小</strong>进行排序的。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/perl</span></span><br><span class="line">$dna=<span class="string">&quot;ATCGCGTAGCATCGATGCTGATCATGC&quot;</span>;</span><br><span class="line">$dna_reverse=<span class="keyword">reverse</span> $dna;      <span class="comment"># reverse函数可以使数组或者字符串反转</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;$dna_reverse\n&quot;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://www.shelven.com/tuchuang/20220615/4.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220615/4.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>reverse函数在做DNA反向互补配对的时候能用到。</p><h3 id="foreach遍历数组"><a href="#foreach遍历数组" class="headerlink" title="foreach遍历数组"></a>foreach遍历数组</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/perl</span></span><br><span class="line">@number=(<span class="number">1</span>..<span class="number">10</span>);</span><br><span class="line"><span class="keyword">foreach</span> $num (@number) &#123;        <span class="comment"># 遍历数组中的值依迭代</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot;$num\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以省略一部分内容</span></span><br><span class="line"><span class="comment">#!/bin/perl</span></span><br><span class="line">@number=(<span class="number">1</span>..<span class="number">10</span>);</span><br><span class="line"><span class="keyword">foreach</span> (@number) &#123;     <span class="comment"># 省略了$num，存储到默认的$_中</span></span><br><span class="line">    <span class="keyword">print</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在处理三代测序的下机数据，用到了一些挺好用的perl脚本，但是苦于没接触这种类型的编程语言，想根据情况改一些代码却看不懂实现方式**&amp;#x3D; &amp;#x3D;**&lt;/p&gt;
&lt;p&gt;前面说学习perl可以只学怎么调用模块，马上啪啪打脸了，这货和python还是有点不一样的，</summary>
      
    
    
    
    <category term="编程自学" scheme="http://www.shelven.com/categories/%E7%BC%96%E7%A8%8B%E8%87%AA%E5%AD%A6/"/>
    
    
    <category term="perl" scheme="http://www.shelven.com/tags/perl/"/>
    
  </entry>
  
  <entry>
    <title>基因组注释文件gbff格式转换gff3格式</title>
    <link href="http://www.shelven.com/2022/06/14/a.html"/>
    <id>http://www.shelven.com/2022/06/14/a.html</id>
    <published>2022-06-13T17:09:45.000Z</published>
    <updated>2022-06-13T17:24:07.097Z</updated>
    
    <content type="html"><![CDATA[<p>前几天老师布置了一个任务，寻找夹竹桃科Apocynaceae分类下的物种参考基因组，我在plaBiPD网站和NCBI的genome数据库中只找到包括罗布麻在内的5个已发表物种参考基因组，且都是<strong>gbff</strong>格式的。提交之后被告知需要<strong>gff</strong>格式的，因为gbf格式中没有基因相关结构的位置信息。</p><p>emmmmm….其实不是很理解，因为gbff格式和gff格式是可以相互转换的，如果gbff注释文件中有信息缺失，那么gff格式也同样没有相关信息….不管怎么样先转换个格式交差，网上搜了下有前人写的<strong>perl脚本</strong>可以用，但是我以前没接触过perl语言，这里做个笔记写一下自己瞎捣鼓的过程。</p><h2 id="1-perl语言和CPAN模块库"><a href="#1-perl语言和CPAN模块库" class="headerlink" title="1. perl语言和CPAN模块库"></a>1. perl语言和CPAN模块库</h2><div class="story post-story"><p>从<a href="https://baike.baidu.com/item/perl/851577?fr=aladdin">百度百科</a>中引用对perl语言的一段描述：</p><blockquote><p>Perl是一种功能丰富的计算机程序语言，易于使用、高效、完整，而不是美观（小巧，优雅，简约）。同时支持过程和面向对象编程，对文本处理具有强大的内置支持，并且拥有第三方模块集合之一。 Perl借取了C、sed、awk、shell脚本语言以及很多其他程序语言的特性，其中最重要的特性是它内部集成了正则表达式的功能，以及巨大的第三方代码库CPAN。</p></blockquote><p>看到这个简介，个人的理解就是perl语言就像python一样，自己有丰富的第三方库可以调用。同样，我们不需要具体了解每个模块的实现方式和底层代码，只要知道会调用相关的模块实现自己的目标即可。</p><p>CPAN是perl的一个第三方源码模块库，里面有上百万的perl模块，用于支撑perl的各种功能。为了方便安装perl的各种模块，前人做了一个CPAN模块，用cpan命令来安装perl的各个模块。也可以通过cpan命令来安装bioperl模块，里面有非常多的有关生信分析的perl脚本。</p></div><h2 id="2-安装和配置bioperl"><a href="#2-安装和配置bioperl" class="headerlink" title="2. 安装和配置bioperl"></a>2. 安装和配置bioperl</h2><div class="story post-story"><p>运行gbff转换gff3的perl脚本需要调用bioperl的一些模块，因此第一步需要安装bioperl，以及配置相应的环境。</p><p>登录学校集群，发现系统自带安装了perl程序和CPAN模块，我们可以用CPAN来安装bioperl。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在命令行进入CPAN交互式界面</span></span><br><span class="line">perl -MCPAN -e shell</span><br></pre></td></tr></table></figure><p>进入CPAN交互式界面如下：</p><p><img src="https://www.shelven.com/tuchuang/20220613/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220613/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在线寻找bioperl安装包</span></span><br><span class="line">cpan&gt;d /bioperl/</span><br><span class="line"><span class="comment"># 安装对应版本的bioperl，注意目录和版本号根据搜出来的结果不同而不同</span></span><br><span class="line">cpan&gt;install S/SE/SENDU/bioperl-<span class="number">1.5</span>.<span class="number">2_100</span>.tar.gz </span><br></pre></td></tr></table></figure><p>之后就是漫长的安装过程了，所有依赖关系也会一并安装，安装的时间较长，大概需要半个小时。</p><p>安装完成之后是配置环境变量，不配置的话即使安装了bioperl，也会找不到对应的模块。我的bioperl安装路径是&#x2F;public&#x2F;home&#x2F;wlxie&#x2F;miniconda3&#x2F;envs&#x2F;biosoft&#x2F;lib&#x2F;perl5&#x2F;site_perl&#x2F;5.22.0&#x2F;Bio&#x2F;，可以通过<code>echo $PERL5LIB</code>来查看当前perl模块的调用路径，然后在家目录的.bashrc环境变量文件中将bioperl的模块路径加到perl模块调用的路径当中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在。bashrc文件最后一行加入bioperl模块调用路径</span></span><br><span class="line">export PERL5LIB=&quot;/public/home/wlxie/miniconda3/envs/biosoft/lib/perl5/site_perl/5.22.0/:$PERL5LIB&quot;</span><br></pre></td></tr></table></figure><p>这样所有的配置就完成了。</p></div><h2 id="3-gbff格式转换gff3"><a href="#3-gbff格式转换gff3" class="headerlink" title="3. gbff格式转换gff3"></a>3. gbff格式转换gff3</h2><div class="story post-story"><p>github上有许多gbff格式转gff3格式的脚本代码，有用biopython做的，也有bioperl做的，可能是我配置的问题，试了几个脚本后只有一个可以顺利转换。本来想研究一下脚本的实现方式，可是源代码2000多行看的我实在不知从何下手，这里只记录一下使用方法和备份脚本文件。</p><p>源代码的出处已经找不到了…<a href="https://www.shelven.com/script_backup/bp_genbank2gff3.pl">点击这里查看源代码在本站的备份</a></p><p>使用方法：</p><p>将脚本文件bp_genbank2gff3.pl放在要转换格式的gbff文件<strong>同一个目录下</strong>，运行命令</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># perl bp_genbank2gff3.pl gbff文件名</span></span><br><span class="line">perl bp_genbank2gff3.pl Asclepias_syriaca-GCA_002018285.<span class="number">1_</span>ASM201828v1_genomic.gbff</span><br></pre></td></tr></table></figure><p>脚本自动运行，结束后会在当前目录生成<strong>同名的gff3文件</strong></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前几天老师布置了一个任务，寻找夹竹桃科Apocynaceae分类下的物种参考基因组，我在plaBiPD网站和NCBI的genome数据库中只找到包括罗布麻在内的5个已发表物种参考基因组，且都是&lt;strong&gt;gbff&lt;/strong&gt;格式的。提交之后被告知需要&lt;strong</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="bioperl" scheme="http://www.shelven.com/tags/bioperl/"/>
    
    <category term="perl" scheme="http://www.shelven.com/tags/perl/"/>
    
  </entry>
  
  <entry>
    <title>集群和slurm调度系统使用心得</title>
    <link href="http://www.shelven.com/2022/05/25/a.html"/>
    <id>http://www.shelven.com/2022/05/25/a.html</id>
    <published>2022-05-24T18:05:26.000Z</published>
    <updated>2022-06-21T11:27:33.293Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><div class="story post-story"><p>随着各种组学技术和生物信息学技术的发展，高通量测序现在已经广泛应用到生命科学的多个领域，这些测序数据动辄几个G甚至几十上百G（主要看物种和测序深度），个人电脑对这些大量的数据处理时有些力不从心。</p><p>比如我的小破电脑，4核，2G运行内存，在对16个10X测序深度的拟南芥转录组数据进行回帖参考基因组时，cpu满载的情况下跑了整整一个晚上，拟南芥的参考基因组还是比较小的（只有116M大小）。因此在需要做大量数据处理的时候我们往往都会用到<strong>计算机集群</strong>。</p></div><h2 id="1-计算机集群介绍"><a href="#1-计算机集群介绍" class="headerlink" title="1. 计算机集群介绍"></a>1. 计算机集群介绍</h2><div class="story post-story"><p>先上一段<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%9B%86%E7%BE%A4/1728905?fr=aladdin">百度百科</a>的介绍</p><blockquote><p><strong>计算机集群</strong>简称<strong>集群，</strong>是一种计算机系统， 它通过一组松散集成的计算机软件或硬件连接起来高度紧密地协作完成计算工作。在某种意义上，他们可以被看作是一台计算机。</p><p>集群系统中的单个计算机通常称为节点，通常通过局域网连接，但也有其它的可能连接方式。集群计算机通常用来改进单个计算机的计算速度和&#x2F;或可靠性。一般情况下集群计算机比单个计算机，比如工作站或超级计算机性能价格比要高得多。</p></blockquote><p>简单来说集群就是一群电脑连接在一起完成同一个工作，自然是比单个电脑工作效率高得多。</p><p>塔大有着南疆最大的超算中心，我用测试账号登录大致看了下节点配置信息和存储规模：</p><p><img src="https://www.shelven.com/tuchuang/20220524/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220524/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><img src="https://www.shelven.com/tuchuang/20220524/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220524/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>可以看到塔大集群有三个分区：debug、normal和operation，其中debug是默认分区。</p><p>每个分区下都有admin91、admin92和computer1-6共计8个节点，从状态栏可以看到admin91节点处于down状态，一般来说只有故障节点才会显示状态down，但是我看了下登录节点的hostname就是admin91（<strong>admin91是登录节点</strong>），可能就是这样设置的，防止用户申请到登录节点资源（学校规定禁止在登录节点运行脚本程序，为了防止用户占用太多登录节点资源）。<strong>computer1-6都是计算节点</strong>，可以看到状态栏是idle也就是空闲的。<strong>admin92是个胖节点</strong>，状态却是drain也就是不能分配，这个我不理解，如果要运行并行命令就要用到胖节点。</p><p>裸储存容量算个大概<strong>450TB</strong>左右，不算大不算小，够用就行。</p><p>顺便看一下各个节点的性能：</p><p><img src="https://www.shelven.com/tuchuang/20220524/3.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220524/3.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><img src="https://www.shelven.com/tuchuang/20220524/4.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220524/4.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><img src="https://www.shelven.com/tuchuang/20220524/5.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220524/5.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>稍微计算一下可以发现，计算节点computer1-6每个节点有128个核，每个核2G运行内存；登录节点admin91有64个核，每个核4G运行内存<del>（不是很理解登录节点为什么要这么豪华……）</del>；胖节点admin92有256个核，每个核4G运行内存。总的来说，放在内地比可能确实不怎么样，但是在新疆可以说是奢华顶配了……</p></div><h2 id="2-slurm调度系统介绍"><a href="#2-slurm调度系统介绍" class="headerlink" title="2. slurm调度系统介绍"></a>2. slurm调度系统介绍</h2><div class="story post-story"><p>塔大集群用的是slurm调度系统，简单来说就是借助slurm这个资源管理系统，将超算中心的集群计算机统一管理。slurm是个开源分布式资源管理软件，管理这种大型的计算机集群还是比较高效的，比如天河二号上就使用了 该资源管理系统。集群操作和个人电脑操作不一样的地方是，<strong>我们需要申请计算节点然后才能运行计算的命令</strong>，需要了解一下slurm的作业调度系统。</p><p>了解一下基本概念：一个分区（partition）就是节点的逻辑分组，可以有不同的节点（node）；可以调用几个节点的资源创建作业步（job step），一个作业（job）就是一次资源分配，可以有多个作业步并且可以并发运行。</p><p><img src="https://www.shelven.com/tuchuang/20220524/7.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220524/7.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>再来看一下slurm调度系统的组成成分：</p><p><img src="https://www.shelven.com/tuchuang/20220524/6.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220524/6.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>主要有控制进程slurmcld，记账存储进程Slurmdbd（有的集群是收费的），节点监控进程slurmd，作业管理进程slurmstepd和用户命令工具组成，我们可以不用了解这些进程之间的相互关系，熟悉用户命令比如创建作业，提交作业和查看作业状态即可。</p><h3 id="2-1-创建和提交作业"><a href="#2-1-创建和提交作业" class="headerlink" title="2.1 创建和提交作业"></a>2.1 创建和提交作业</h3><p>slurm作业调度系统有三种模式创建和提交作业：<strong>交互模式——srun</strong>，<strong>批处理模式——sbatch</strong>和<strong>分配模式——salloc</strong>，分别介绍一下~还是再次强调一下，学校集群禁止在登录界面直接运行计算命令，第一次发现会强制终止进程，第二次管理员会注销用户账号。</p><h4 id="2-1-1-交互模式——srun"><a href="#2-1-1-交互模式——srun" class="headerlink" title="2.1.1 交互模式——srun"></a>2.1.1 交互模式——srun</h4><p>交互模式说白了就是我们通过命令行与集群产生可以互动的“交流”，具体过程如下：</p><ul><li>通过终端提交资源分配请求，指定资源数目和限制</li><li>等待资源分配</li><li>获得资源后，自动加载计算任务</li><li>运行中，任务I&#x2F;O传递终端，可与任务进行交互</li><li>任务结束后，资源被释放</li></ul><p>一次执行srun生成一个作业步，也就是一次任务加载，执行一次最简单的hostname命令如下：</p><p><img src="https://www.shelven.com/tuchuang/20220524/9.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220524/9.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>-n 参数指定核数，-w参数指定节点，因此显示的hostname就是computer3。<strong>运行结束后直接释放资源</strong>。</p><p>上面的例子可能没有体现出交互的意义，因为程序比较简单。有些程序在运行的过程中需要人为调整，srun才能体现出优势。</p><h4 id="2-1-2-批处理模式——sbatch"><a href="#2-1-2-批处理模式——sbatch" class="headerlink" title="2.1.2 批处理模式——sbatch"></a>2.1.2 批处理模式——sbatch</h4><p>批处理模式顾名思义特点在于需要自己写批处理脚本，具体过程如下：</p><ul><li>编写作业脚本，指定资源数目和限制</li><li>sbatch提交作业</li><li>作业排队等待资源分配</li><li>分配到资源后在首节点加载执行作业脚本</li><li>任务结束释放资源</li><li>运行结果定向到指定文件夹</li></ul><p>这个模式也是用的最多的，登录塔大集群可以在用户家目录下找到job_example文件夹，里面有不同的slurm脚本提供参考，举个最简单的例子sleep.slurm，我们cat一下看看脚本内容：</p><p><img src="https://www.shelven.com/tuchuang/20220524/8.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220524/8.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>第一行#! 指定解释器类型，和其他脚本都一样；</p><p>第二行开始后面几行的#SBATCH都被识别为sbatch命令，因此后面都加上了对应参数，这里只有sbatch这一行会被识别成命令，注意不是被注释了。如果脚本里写了对应参数内容，命令运行脚本的时候就可以不用加入这些参数。</p><p>第六行开始也就是#以后的部分，才是我们编写脚本要运行的命令。</p><p>参考这个格式，我写了如下一个建立拟南芥参考基因组索引文件的hisat2.slurm脚本：</p><p><img src="https://www.shelven.com/tuchuang/20220524/10.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220524/10.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>申请了job名为job1，一个节点，一个核，显示队列，显示程序运行开始时间，运行程序，显示结束时间。</p><p>提交直接用<code>sbatch hisat2.slurm</code>，很快就获得资源跑完了程序，当前目录下生成了索引文件和默认输出文件slurm-job号.out</p><p><img src="https://www.shelven.com/tuchuang/20220524/11.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220524/11.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>因为输出结果在结果文件里，所以我们屏幕上是看不到运行过程的，要想监控运行过程只能在运行时输入squeue查看，后面会说。<strong>运行结束后同样会自动释放资源。</strong></p><h4 id="2-1-3-分配模式——salloc"><a href="#2-1-3-分配模式——salloc" class="headerlink" title="2.1.3 分配模式——salloc"></a>2.1.3 分配模式——salloc</h4><p>分配模式相比前面两个模式更灵活一些，简单来说就是申请资源，执行运算任务后<strong>手动释放资源</strong>，可以用来在正式提交sbatch前做程序测试，检查代码正确后再写成脚本提交（不过也可以直接提交，不用sbatch）。流程如下：</p><ul><li>提交资源分配请求</li><li>排队等待资源分配</li><li>命令行执行指定的命令</li><li>命令执行结束，exit手动释放资源</li></ul><p>这个比较简单，直接salloc后面接参数申请指定的资源就行，最后一定要exit手动释放资源。</p><p>申请后可以用hostname命令看看申请的是哪个节点，确认是计算节点后再运行计算命令。</p><h4 id="2-1-4-作业提交参数"><a href="#2-1-4-作业提交参数" class="headerlink" title="2.1.4 作业提交参数"></a>2.1.4 作业提交参数</h4><p>知道了三个模式的具体用法，只需要添加对应的参数就行了。没有人会具体记住所有参数，上面只有常用的几个需要记一下。这里记录一下其他常用提交参数：</p><table><thead><tr><th>参数</th><th>含义</th><th>类型</th><th>示例</th></tr></thead><tbody><tr><td>-J</td><td>作业名，squeue看到的作业名</td><td>字符串</td><td>-J wrf；表示作业名称为“wrf”</td></tr><tr><td>-n</td><td>作业申请的总cpu核心数</td><td>数值</td><td>-n 4；表示作业申请4个cpu核心</td></tr><tr><td>-N</td><td>作业申请的节点数</td><td>数值</td><td>-N 1 表示作业申请1个计算节点</td></tr><tr><td>-p</td><td>指定作业提交的分区</td><td>字符串</td><td>-psilicon表示将作业提交到silicon分区</td></tr><tr><td>-t</td><td>指定作业的执行时间</td><td>数值</td><td>-t 30 表示作业的执行时间不超过30分钟</td></tr><tr><td>-o</td><td>指定作业标准输出文件的名称</td><td>字符串</td><td>-o %j，表示使用作业号作为作业标准输出文件的名称</td></tr><tr><td>-e</td><td>指定作业标准错误输出文件名称</td><td>字符串</td><td>-e %j，表示使用作业号作为作业标准错误输出文件名</td></tr><tr><td>-w</td><td>指定分配特定的计算节点</td><td>字符串</td><td>-w computer3 表示使用computer3节点</td></tr><tr><td>-d</td><td>作业依赖关系设置</td><td>字符串</td><td>-d after:123 表示本作业须待作业123开始以后再执行</td></tr></tbody></table><p>顺便最后再提一下交互模式和批处理模式是可以相互结合的，脚本中可以加入srun命令，可以自行尝试。</p><p><img src="https://www.shelven.com/tuchuang/20220524/12.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220524/12.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>如上，可以用sbatch一次性创建100个job，每个job运行一次srun后面的内容，也就是提交并行的100个计算作业。也可以不加–array这个参数，srun最后加上符号&amp;在后台挂起，下一行继续用srun命令，以此来实现并行计算，不过要注意最后一行命令用<strong>wait</strong>等待所有命令运行结束后一起结束，否则读完sbatch就结束了。</p><h3 id="2-2-其他用户命令"><a href="#2-2-其他用户命令" class="headerlink" title="2.2 其他用户命令"></a>2.2 其他用户命令</h3><p>这里再简单列举记录一些常用的用户命令和参数，方便自己后续用到时查阅~</p><h4 id="2-2-1-sinfo-查询信息"><a href="#2-2-1-sinfo-查询信息" class="headerlink" title="2.2.1 sinfo 查询信息"></a>2.2.1 sinfo 查询信息</h4><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-a</td><td>查看所有分区信息（含隐藏分区）</td></tr><tr><td>-d</td><td>查看dead状态（通信异常）的节点和分区的信息，与-r参数对应</td></tr><tr><td>-l</td><td>打印分区（或节点）的详细信息</td></tr><tr><td>-n</td><td>查看指定节点的信息</td></tr><tr><td>-p</td><td>查看指定分区的状态</td></tr><tr><td>-r</td><td>查看计算节点（内部通信）正常的节点和分区的状态，与-d参数对应</td></tr><tr><td>-R</td><td>查看节点不可用的原因，包括管理操作设置的异常</td></tr><tr><td>-t</td><td>查询指定节点状态的分区或节点的信息</td></tr><tr><td>–federation</td><td>显示所有集群的分区（或节点）的信息</td></tr><tr><td>–local</td><td>仅显示当前集群的分区（或节点）的信息</td></tr></tbody></table><h4 id="2-2-2-squeue-查询作业"><a href="#2-2-2-squeue-查询作业" class="headerlink" title="2.2.2 squeue 查询作业"></a>2.2.2 squeue 查询作业</h4><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-A</td><td>查看指定账号的作业</td></tr><tr><td>-a</td><td>显示所有分区（包含隐藏）下的作业和作业步</td></tr><tr><td>-r</td><td>按行显示作业组的每一个作业</td></tr><tr><td>–hide</td><td>不显示隐藏分区或者无权访问的分区中的作业</td></tr><tr><td>-j</td><td>根据指定的作业号查询作业信息</td></tr><tr><td>-l</td><td>长格式显示作业信息</td></tr><tr><td>–federation</td><td>显示所有集群下的作业</td></tr><tr><td>–local</td><td>仅仅查看当前集群的作业</td></tr><tr><td>-n</td><td>按作业名查询作业或作业步</td></tr><tr><td>-p</td><td>按分区查询作业</td></tr><tr><td>-s</td><td>查询作业步</td></tr><tr><td>-t</td><td>指定要显示的作业的状态</td></tr></tbody></table><h4 id="2-2-3-scancel-删除作业"><a href="#2-2-3-scancel-删除作业" class="headerlink" title="2.2.3 scancel 删除作业"></a>2.2.3 scancel 删除作业</h4><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>&lt;job id&gt;</td><td>删除指定job id作业</td></tr><tr><td>–t</td><td>删除指定状态的作业</td></tr><tr><td>–account&#x3D;</td><td>删除指定账号的作业</td></tr><tr><td>–name&#x3D;</td><td>删除指定名称的作业</td></tr><tr><td>–partition&#x3D;</td><td>删除指定分区的作业</td></tr><tr><td>–reservation&#x3D;</td><td>删除指定预约名称的作业</td></tr><tr><td>–user&#x3D;</td><td>删除指定用户的作业</td></tr><tr><td>–nodelist&#x3D;</td><td>删除指定节点的作业</td></tr></tbody></table><h4 id="2-2-4-scontrol-查询详细信息"><a href="#2-2-4-scontrol-查询详细信息" class="headerlink" title="2.2.4 scontrol 查询详细信息"></a>2.2.4 scontrol 查询详细信息</h4><p>这个命令和sinfo相比更为详细，主要能获得4个方面的详细信息</p><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>scontrol show node &lt;name&gt;</td><td>查询指定节点信息</td></tr><tr><td>scontrol show partition &lt;name&gt;</td><td>查询指定分区信息</td></tr><tr><td>scontrol show job</td><td>查询job信息，注意是所有的</td></tr><tr><td>scontrol show config</td><td>查询配置信息，也是所有的</td></tr></tbody></table></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;div class=&quot;story post-story&quot;&gt;&lt;p&gt;随着各种组学技术和生物信息学技术的发展，高通量测序现在已经广泛应用到生命科学的多</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="集群" scheme="http://www.shelven.com/tags/%E9%9B%86%E7%BE%A4/"/>
    
    <category term="slurm" scheme="http://www.shelven.com/tags/slurm/"/>
    
  </entry>
  
  <entry>
    <title>转录组数据分析笔记（10）——初识GO/KEGG富集分析</title>
    <link href="http://www.shelven.com/2022/05/16/a.html"/>
    <id>http://www.shelven.com/2022/05/16/a.html</id>
    <published>2022-05-15T19:47:39.000Z</published>
    <updated>2022-05-15T20:04:18.802Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><div class="story post-story"><p>前面介绍了如何找到差异基因，我们通过R包DESeq2获得了差异表达基因，在此基础上做了更为直观的火山图和差异表达基因热图。但是仅仅知道差异表达基因的名字还不够，我们还要知道它到底有哪些功能和特征，就比如我看到一个很养眼的动漫角色，我就要去查查出自哪部番，是怎么样的人设和背景故事，一样的道理。</p><p>一个基因没有注释信息，那就只是一段核苷酸序列，有了注释信息我们才能知道这个基因在染色体上的定位，在具体的某个代谢途径上发挥什么功能等等。网上能找到很多注释信息的数据库，比如模式生物拟南芥TAIR，人类基因组hg19等等，Bioconductor有一个专门用来搜集注释信息数据库的工具包——AnnotationHub。</p></div><h2 id="1-AnnotationHub注释数据库搜索工具"><a href="#1-AnnotationHub注释数据库搜索工具" class="headerlink" title="1. AnnotationHub注释数据库搜索工具"></a>1. AnnotationHub注释数据库搜索工具</h2><div class="story post-story"><p>用bioconductor下载Annotationhub包，载入（<strong>注：为演示结果，以下命令均在Rstudio终端输入</strong>）</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> library<span class="punctuation">(</span><span class="string">&quot;Annotationhub&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> hub <span class="operator">&lt;-</span> AnnotationHub<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line">C<span class="operator">:</span><span class="punctuation">\</span>Users<span class="punctuation">\</span>HUAWEI<span class="punctuation">\</span>AppData<span class="punctuation">\</span>Local<span class="operator">/</span>R<span class="operator">/</span>cache<span class="operator">/</span>R<span class="operator">/</span>AnnotationHub</span><br><span class="line">  does not exist<span class="punctuation">,</span> create directory<span class="operator">?</span> <span class="punctuation">(</span>yes<span class="operator">/</span>no<span class="punctuation">)</span><span class="operator">:</span> yes</span><br><span class="line">  <span class="operator">|</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">=</span><span class="operator">|</span> <span class="number">100</span>%</span><br><span class="line"></span><br><span class="line">snapshotDate<span class="punctuation">(</span><span class="punctuation">)</span><span class="operator">:</span> <span class="number">2021</span><span class="operator">-</span><span class="number">10</span><span class="operator">-</span><span class="number">20</span></span><br><span class="line"><span class="operator">&gt;</span> hub</span><br><span class="line">AnnotationHub with <span class="number">62386</span> records</span><br><span class="line"><span class="comment"># snapshotDate(): 2021-10-20</span></span><br><span class="line"><span class="comment"># $dataprovider: Ensembl, BroadInstitute, UCSC, ftp://ftp...</span></span><br><span class="line"><span class="comment"># $species: Homo sapiens, Mus musculus, Drosophila melano...</span></span><br><span class="line"><span class="comment"># $rdataclass: GRanges, TwoBitFile, BigWigFile, EnsDb, Rl...</span></span><br><span class="line"><span class="comment"># additional mcols(): taxonomyid, genome,</span></span><br><span class="line"><span class="comment">#   description, coordinate_1_based, maintainer,</span></span><br><span class="line"><span class="comment">#   rdatadateadded, preparerclass, tags, rdatapath,</span></span><br><span class="line"><span class="comment">#   sourceurl, sourcetype </span></span><br><span class="line"><span class="comment"># retrieve records with, e.g., &#x27;object[[&quot;AH5012&quot;]]&#x27; </span></span><br></pre></td></tr></table></figure><p>第一次使用AnnotationHub需要创建一个AnnotationHub对象。为了更直观地使用，我们将AnnotationHub对象赋值给hub变量。查看这个变量，我们可以得到如下的信息。</p><ul><li>数据库版本是2021-10-20，目前有62386条记录</li><li>可以用$dataprovider 方式查看数据来源，比如数据来自于Ensembl，UCSC等等</li><li>可以用$species 方式查看数据库有哪些物种，比如人类、小鼠等等</li><li>可以用$rdataclass 方式查看数据类型</li><li>可以通过函数<code>mcols()</code>查看更多信息</li><li>获取数据的方式是<code>object[[&quot;AH5012&quot;]]</code> object指你命名的变量名</li></ul><p>以上就是AnnotationHub的标准用法，比如我想获得拟南芥的注释数据库，我就输入以下命令查找：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> query<span class="punctuation">(</span>hub<span class="punctuation">,</span> <span class="string">&quot;Arabidopsis thaliana&quot;</span><span class="punctuation">)</span></span><br><span class="line">AnnotationHub with <span class="number">13</span> records</span><br><span class="line"><span class="comment"># snapshotDate(): 2021-10-20</span></span><br><span class="line"><span class="comment"># $dataprovider: UCSC, PathBank, NCBI,DBCLS, FANTOM5,DLRP...</span></span><br><span class="line"><span class="comment"># $species: Arabidopsis thaliana</span></span><br><span class="line"><span class="comment"># $rdataclass: SQLiteFile, TxDb, Tibble, list, OrgDb, Inp...</span></span><br><span class="line"><span class="comment"># additional mcols(): taxonomyid, genome,</span></span><br><span class="line"><span class="comment">#   description, coordinate_1_based, maintainer,</span></span><br><span class="line"><span class="comment">#   rdatadateadded, preparerclass, tags, rdatapath,</span></span><br><span class="line"><span class="comment">#   sourceurl, sourcetype </span></span><br><span class="line"><span class="comment"># retrieve records with, e.g., &#x27;object[[&quot;AH10456&quot;]]&#x27; </span></span><br><span class="line"></span><br><span class="line">            title                                           </span><br><span class="line">  AH10456 <span class="operator">|</span> hom.Arabidopsis_thaliana.inp8.sqlite            </span><br><span class="line">  AH52245 <span class="operator">|</span> TxDb.Athaliana.BioMart.plantsmart22.sqlite      </span><br><span class="line">  AH52246 <span class="operator">|</span> TxDb.Athaliana.BioMart.plantsmart25.sqlite      </span><br><span class="line">  AH52247 <span class="operator">|</span> TxDb.Athaliana.BioMart.plantsmart28.sqlite      </span><br><span class="line">  AH87070 <span class="operator">|</span> pathbank_Arabidopsis_thaliana_metabolites.rda   </span><br><span class="line">  ...       ...                                             </span><br><span class="line">  AH91794 <span class="operator">|</span> wikipathways_Arabidopsis_thaliana_metabolites...</span><br><span class="line">  AH95585 <span class="operator">|</span> Alternative Splicing Annotation <span class="keyword">for</span> Arabidops...</span><br><span class="line">  AH95951 <span class="operator">|</span> org.At.tair.db.sqlite                           </span><br><span class="line">  AH97723 <span class="operator">|</span> LRBaseDb <span class="keyword">for</span> Arabidopsis thaliana <span class="punctuation">(</span>Thale cres...</span><br><span class="line">  AH97844 <span class="operator">|</span> MeSHDb <span class="keyword">for</span> Arabidopsis thaliana <span class="punctuation">(</span>Thale cress<span class="punctuation">,</span>...</span><br></pre></td></tr></table></figure><p><code>query()</code>函数查找，输入拟南芥的学名Arabidopsis thaliana我们可以看到一共找出了13个数据库。可以看到AH95951这个编号的数据库来源就是最大的拟南芥数据库TAIR（OrgDb，<strong>存储不同数据库基因ID之间对应关系，以及基因与GO等注释的对应关系</strong>，后面ID转换和GO分析要用到），我们就用这个数据库的注释资源。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> hub<span class="punctuation">[[</span><span class="string">&quot;AH95951&quot;</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line">downloading <span class="number">1</span> resources</span><br><span class="line">retrieving <span class="number">1</span> resource</span><br><span class="line">  <span class="operator">|</span>                                                   <span class="operator">|</span>   <span class="number">0</span>%</span><br></pre></td></tr></table></figure><p>前面说过<code>object[[&quot;AH5012&quot;]]</code>是获取数据的方式。以上，就可以挂后台自动下载了。我这里因为网速的原因不下了，从前面的基因名也能看出来，我筛选的差异基因都是AT开头的，而且之前的基因组注释文件也是TAIR下载的，我可以<strong>直接用bioconductor安装org.At.tair.db包</strong>，这里用AnnotationHub只是提供一个找注释数据库的思路。</p></div><h2 id="2-GO-x2F-KEGG富集分析"><a href="#2-GO-x2F-KEGG富集分析" class="headerlink" title="2. GO&#x2F;KEGG富集分析"></a>2. GO&#x2F;KEGG富集分析</h2><div class="story post-story"><h3 id="2-1-基因ID转换"><a href="#2-1-基因ID转换" class="headerlink" title="2.1 基因ID转换"></a>2.1 基因ID转换</h3><p>找到和下载注释数据库只是第一步，接下来GO&#x2F;KEGG富集分析需要用到R包<strong>clusterProfiler和org.At.tair.db</strong></p><p>先来看一下我们基因名是什么格式的：</p><p><img src="https://www.shelven.com/tuchuang/20220515/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220515/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>很明显，我们的基因ID是TAIR类型<del>（废话，我从TAIR下的）</del>，org.At.tair.db包可以转换基因ID类型</p><p>可以用<code>keytypes(org.At.tair.db)</code>或者<code>columns(org.At.tair.db)</code>查看可以转换的基因ID类型</p><p><img src="https://www.shelven.com/tuchuang/20220515/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220515/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>转换基因ID代码如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">library<span class="punctuation">(</span><span class="string">&quot;org.At.tair.db&quot;</span><span class="punctuation">)</span></span><br><span class="line">columns<span class="punctuation">(</span>org.At.tair.db<span class="punctuation">)</span>     <span class="comment"># 查看能转换基因的ID类型</span></span><br><span class="line">diffgen <span class="operator">&lt;-</span> nDEGs<span class="punctuation">[</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">]</span>       <span class="comment"># 注意只需要基因名</span></span><br><span class="line">diff_gen <span class="operator">&lt;-</span> bitr<span class="punctuation">(</span>diffgen<span class="punctuation">,</span></span><br><span class="line">                 fromType <span class="operator">=</span> <span class="string">&quot;TAIR&quot;</span><span class="punctuation">,</span></span><br><span class="line">                 toType <span class="operator">=</span> <span class="string">&quot;ENTREZID&quot;</span><span class="punctuation">,</span>   <span class="comment"># 基因ID类型TAIR转换为ENTREZID</span></span><br><span class="line">                 OrgDb <span class="operator">=</span> <span class="string">&quot;org.At.tair.db&quot;</span><span class="punctuation">)</span>      <span class="comment"># 该函数是基于org.At.tair.db包的</span></span><br><span class="line">diff_gen</span><br></pre></td></tr></table></figure><p>这一步我的基因ID转换率<strong>只有60%左右</strong>，有<strong>将近一半</strong>的TAIR基因ID不能成功转换成ENTREZID，可能是Gene ID的版本问题，同一个基因在不同版本genecode中结果不一样，下载的注释文件原始版本我这里找不到了…暂时无法解决这个问题。只能不转换基因ID先跑一遍GO&#x2F;KEGG富集分析。</p><p>看了很多教程都说clusterProfiler需要的ID类型是ENTREZID，<strong>这里我持怀疑态度</strong>，不转换后续也能得到结果，我看了函数<code>enrichGO()</code>默认的基因ID是ENTREZID并不代表不能改变，有可能是误传。<a href="http://www.360doc.com/content/17/0919/14/19913717_688385068.shtml">查阅了一些资料</a>，简单来说Entrez ID是来自于NCBI旗下Entrez gene数据库的编号系统，基因编号系统之间是可以相互转换的，这些ID可以在对应的数据库找到基因注释信息，就是说也可以在网页上手动注释。</p><h3 id="2-2-GO-x2F-KEGG分析"><a href="#2-2-GO-x2F-KEGG分析" class="headerlink" title="2.2 GO&#x2F;KEGG分析"></a>2.2 GO&#x2F;KEGG分析</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">library<span class="punctuation">(</span><span class="string">&quot;clusterProfiler&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># GO富集分析</span></span><br><span class="line">enrich_GO <span class="operator">&lt;-</span> enrichGO<span class="punctuation">(</span>gene <span class="operator">=</span> diffgen<span class="punctuation">,</span>   <span class="comment"># 基因名列表</span></span><br><span class="line">                      OrgDb <span class="operator">=</span> <span class="string">&#x27;org.At.tair.db&#x27;</span><span class="punctuation">,</span> <span class="comment"># 输入OrgDb数据库（注释对象信息）</span></span><br><span class="line">                      keyType <span class="operator">=</span> <span class="string">&#x27;TAIR&#x27;</span><span class="punctuation">,</span>     <span class="comment"># 输入的基因名ID类型</span></span><br><span class="line">                      ont <span class="operator">=</span> <span class="string">&#x27;ALL&#x27;</span><span class="punctuation">,</span>      <span class="comment"># 输出的GO分类</span></span><br><span class="line">                      pAdjustMethod <span class="operator">=</span> <span class="string">&#x27;fdr&#x27;</span><span class="punctuation">,</span></span><br><span class="line">                      pvalueCutoff <span class="operator">=</span> <span class="number">0.05</span><span class="punctuation">,</span></span><br><span class="line">                      qvalueCutoff <span class="operator">=</span> <span class="number">0.2</span><span class="punctuation">,</span></span><br><span class="line">                      readable <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line">GO_result <span class="operator">&lt;-</span> enrich_GO<span class="operator">@</span>result</span><br><span class="line">write.table<span class="punctuation">(</span>GO_result<span class="punctuation">,</span> <span class="string">&#x27;GO_result.csv&#x27;</span><span class="punctuation">,</span> sep <span class="operator">=</span> <span class="string">&#x27;,&#x27;</span><span class="punctuation">,</span> <span class="built_in">quote</span> <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span> row.names <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># KEGG富集分析</span></span><br><span class="line">enrich_KEGG <span class="operator">&lt;-</span> enrichKEGG<span class="punctuation">(</span>gene <span class="operator">=</span> diffgen<span class="punctuation">,</span></span><br><span class="line">                        keyType <span class="operator">=</span> <span class="string">&quot;kegg&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        organism <span class="operator">=</span> <span class="string">&quot;ath&quot;</span><span class="punctuation">,</span>   <span class="comment"># 输入的物种名</span></span><br><span class="line">                        pvalueCutoff <span class="operator">=</span> <span class="number">0.05</span><span class="punctuation">,</span></span><br><span class="line">                        qvalueCutoff <span class="operator">=</span> <span class="number">0.2</span><span class="punctuation">)</span></span><br><span class="line">KEGG_result <span class="operator">&lt;-</span> enrich_KEGG<span class="operator">@</span>result</span><br><span class="line">write.table<span class="punctuation">(</span>KEGG_result<span class="punctuation">,</span> <span class="string">&#x27;KEGG_result.csv&#x27;</span><span class="punctuation">,</span> sep <span class="operator">=</span> <span class="string">&#x27;,&#x27;</span><span class="punctuation">,</span> <span class="built_in">quote</span> <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span> row.names <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>clusterProfiler这个包进行GO和KEGG富集分析就这两个函数</p><p>这里我的GO只富集到两条细胞组分的内容：</p><p><img src="https://www.shelven.com/tuchuang/20220515/3.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220515/3.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>说一下各列代表的意思：</p><ul><li>ONTOLOGY GO分类BP（生物学过程）、CC（细胞组分）或MF（分子功能）</li><li>ID 富集到的GO id号</li><li>Description 富集到的GO描述</li><li>GeneRatio和BgRatio 分别为富集到该GO条目中的基因数目&#x2F;给定基因的总数目，以及该条目中背景基因总数目&#x2F;该物种所有已知的GO功能基因数目</li><li>pvalue、p.adjust和qvalue p值、校正后p值和q值信息</li><li>geneID和Count，富集到该GO条目中的基因名称和数目</li></ul><p>KEGG富集分析结果表如下：</p><p><img src="https://www.shelven.com/tuchuang/20220515/5.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220515/5.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><ul><li>ID和Description 分别代表富集到KEGG的ID和描述，其他和GO富集都类似</li></ul><p>KEGG富集分析的时候有一点需要注意，输入的organism名称需要在<strong>官网的KEGG Organisms列表中能找到</strong>，否则是不能进行分析的！<a href="https://www.genome.jp/kegg/catalog/org_list.html">点击这里进入KEGG Organisms: Complete Genomes</a></p><p>还发现一个很奇怪的问题，我在官网的Organisms列表能找到拟南芥Arabidopsis thaliana，但是在上面的函数中对参数赋值<code>organism = &quot;Arabidopsis thaliana&quot;</code>会显示HTTP 400错误，也就是发出的url请求有问题，但是输入<code>organism = &quot;ath&quot;</code>程序可以正常运行，以后注意写缩写吧（<strong>应该是只有缩写才行</strong>，会通过联网自动获取该物种的pathway注释信息）。</p></div><h2 id="3-可视化"><a href="#3-可视化" class="headerlink" title="3. 可视化"></a>3. 可视化</h2><div class="story post-story"><p>clusterProfiler包还提供了GO&#x2F;KEGG富集结果的可视化方案，此处代码参考<a href="https://blog.csdn.net/qq_50898257/article/details/120588222">CSDN，作者：Tian問</a></p><p>这里因为我的GO结果不好，只简单写一下流程，详细作图函数参数使用方法和效果同样可以参考上面的链接~</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## GO富集分析可视化</span></span><br><span class="line"><span class="comment">#barplot</span></span><br><span class="line">barplot<span class="punctuation">(</span>enrich_GO<span class="punctuation">,</span> showCategory <span class="operator">=</span> <span class="number">10</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#dotplot</span></span><br><span class="line">dotplot<span class="punctuation">(</span>enrich_GO<span class="punctuation">,</span> showCategory <span class="operator">=</span> <span class="number">10</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#DAG有向无环图</span></span><br><span class="line">plotGOgraph<span class="punctuation">(</span>enrich_GO<span class="punctuation">)</span>  <span class="comment">#矩形代表富集到的top10个GO terms, 颜色从黄色过滤到红色，对应p值从大到小。</span></span><br><span class="line"><span class="comment">#igraph布局的DAG</span></span><br><span class="line">goplot<span class="punctuation">(</span>enrich_GO<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#GO terms关系网络图（通过差异基因关联）</span></span><br><span class="line">emapplot<span class="punctuation">(</span>enrich_GO<span class="punctuation">,</span> showCategory <span class="operator">=</span> <span class="number">30</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#GO term与差异基因关系网络图</span></span><br><span class="line">cnetplot<span class="punctuation">(</span>enrich_GO<span class="punctuation">,</span> showCategory <span class="operator">=</span> <span class="number">5</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## KEGG富集分析可视化</span></span><br><span class="line"><span class="comment">#barplot</span></span><br><span class="line">barplot<span class="punctuation">(</span>enrich_KEGG<span class="punctuation">,</span> showCategory <span class="operator">=</span> <span class="number">10</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#dotplot</span></span><br><span class="line">dotplot<span class="punctuation">(</span>enrich_KEGG<span class="punctuation">,</span> showCategory <span class="operator">=</span> <span class="number">10</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#pathway关系网络图（通过差异基因关联）</span></span><br><span class="line">emapplot<span class="punctuation">(</span>enrich_KEGG<span class="punctuation">,</span>  showCategory <span class="operator">=</span> <span class="number">30</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#pathway与差异基因关系网络图</span></span><br><span class="line">cnetplot<span class="punctuation">(</span>enrich_KEGG<span class="punctuation">,</span> showCategory <span class="operator">=</span> <span class="number">5</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#pathway映射</span></span><br><span class="line">browseKEGG<span class="punctuation">(</span>enrich_KEGG<span class="punctuation">,</span> <span class="string">&quot;ath03060&quot;</span><span class="punctuation">)</span> <span class="comment">#在pathway通路图上标记富集到的基因，会弹出页面链接到KEGG官网</span></span><br></pre></td></tr></table></figure><p>关于GO&#x2F;KEGG富集分析，还有非常多的操作和应用，我只是简单做个最基础的富集分析的学习，没有涉及到手动注释，构建orgdb等等更多操作。电脑快没电了，这篇笔记先暂时记这些，以后需要用到再补充~</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;div class=&quot;story post-story&quot;&gt;&lt;p&gt;前面介绍了如何找到差异基因，我们通过R包DESeq2获得了差异表达基因，在此基础</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="转录组数据分析" scheme="http://www.shelven.com/categories/%E8%BD%AC%E5%BD%95%E7%BB%84%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
    <category term="AnnotationHub" scheme="http://www.shelven.com/tags/AnnotationHub/"/>
    
    <category term="GO/KEGG" scheme="http://www.shelven.com/tags/GO-KEGG/"/>
    
    <category term="org.At.tair.db" scheme="http://www.shelven.com/tags/org-At-tair-db/"/>
    
  </entry>
  
  <entry>
    <title>视频一键转字符动画——python函数封装和调用练习</title>
    <link href="http://www.shelven.com/2022/05/08/a.html"/>
    <id>http://www.shelven.com/2022/05/08/a.html</id>
    <published>2022-05-07T17:43:17.000Z</published>
    <updated>2022-05-07T18:35:00.862Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><div class="story post-story"><p>捣鼓了几天python代码，我现在也越来越发现python的魅力所在，它的强大之处在于有非常多的第三方库可以随意调用。我不需要知道这些第三方库各种函数的实现方式，只要知道这些函数有什么作用，能得到什么结果。只要构思好自己的想法，找到对应的库就可以一步步按照我的思路编写程序，实现我想要的结果，整个构思到实现的过程让我非常愉悦~</p><p>写这篇博客纯粹是个人爱好，也是一个巧合~</p><p>前几天刷b站看到有人做了个剪影的字符动画，我就很好奇python是否可以实现。参考了一下github上大佬们的图片转字符画的代码，对这些代码做了点深入研究，总算搞明白了其实现方式，并且自己动手修改代码，在原有基础上改了几个bug，新增几个模块的调用，最后一步封装写成了下面这个脚本。这个脚本的功能是<strong>只要输入视频文件和你想要的视频帧率，就可以自动将视频转化为字符动画</strong>。</p><p>可以先看一下视频效果~ <a href="https://www.bilibili.com/video/BV14S4y187Az?spm_id_from=333.999.0.0">或者点击这里进入b站观看</a></p><div class="video"><video controls preload><source src='https://www.shelven.com/tuchuang/20220508/590001100-1-112.mov' type='video/mp4'>Your browser does not support the video tag.</video></div></div><h2 id="2-实现思路"><a href="#2-实现思路" class="headerlink" title="2. 实现思路"></a>2. 实现思路</h2><div class="story post-story"><ul><li>调用ffmpeg根据帧率将视频切割成图片</li><li>调用pillow库作图，每张图片转换字符画</li><li>调用ffmpeg合并字符画并输出动画</li></ul></div><h2 id="3-脚本代码及详解"><a href="#3-脚本代码及详解" class="headerlink" title="3. 脚本代码及详解"></a>3. 脚本代码及详解</h2><div class="story post-story"><p>思路很清晰，接下来是写代码实现的过程，细节方面需要调用其他库</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageDraw, ImageFont <span class="comment"># pillow库作图</span></span><br><span class="line"><span class="keyword">import</span> subprocess   <span class="comment"># 执行命令行命令，为了调用ffmpeg</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os   <span class="comment"># 操作目录用</span></span><br><span class="line"><span class="keyword">import</span> shutil   <span class="comment"># 删除目录用</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  <span class="comment"># 转化numpy数组</span></span><br><span class="line"><span class="keyword">import</span> gc   <span class="comment"># 优化运行内存用到</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义输入值，这个脚本需要两个输入值：file_input和FPS</span></span><br><span class="line">file_input = sys.argv[<span class="number">1</span>]</span><br><span class="line">FPS = sys.argv[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">do_turn</span>(<span class="params">file_input, FPS</span>):</span><br><span class="line">    <span class="comment"># 调用ffmpeg切割视频</span></span><br><span class="line">    os.makedirs(<span class="string">&quot;tempfile/cut/&quot;</span>)    <span class="comment"># 当前目录新建存放切割图片的临时文件夹</span></span><br><span class="line">    shell_vedio = <span class="string">&quot;ffmpeg -i &quot;</span> + file_input + <span class="string">&quot; -r &quot;</span> + FPS + <span class="string">&quot; -qscale:v 2 ./tempfile/cut/%05d.jpg&quot;</span>     <span class="comment"># 按照XXXXX序号切割</span></span><br><span class="line">    shell_voice = <span class="string">&quot;ffmpeg -i &quot;</span> + file_input + <span class="string">&quot; ./tempfile/out.mp3&quot;</span></span><br><span class="line">    subprocess.call(shell_vedio, shell=<span class="literal">True</span>)    <span class="comment"># 切割视频</span></span><br><span class="line">    subprocess.call(shell_voice, shell=<span class="literal">True</span>)    <span class="comment"># 分离音频</span></span><br><span class="line">    count =<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> os.listdir(<span class="string">&quot;./tempfile/cut/&quot;</span>):</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;成功分离音频，截图开始转换字符画......&quot;</span> + <span class="string">&quot;共计&quot;</span> + <span class="built_in">str</span>(count) + <span class="string">&quot;张&quot;</span>)    <span class="comment"># 统计切割图张数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 图片转换字符画</span></span><br><span class="line">    list_p = os.listdir(<span class="string">&quot;./tempfile/cut/&quot;</span>)  </span><br><span class="line">    cwd = os.getcwd()</span><br><span class="line">    os.mkdir(<span class="string">&quot;./tempfile/new/&quot;</span>)     <span class="comment"># 新建存放字符画的临时文件夹</span></span><br><span class="line">    process = <span class="number">1</span>     <span class="comment"># 统计完成转换的字符画数量</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">id</span> <span class="keyword">in</span> list_p:   <span class="comment"># 遍历cut文件夹所有切割后的图片做字符画转换</span></span><br><span class="line">        address = <span class="built_in">str</span>(<span class="string">&quot;&quot;</span>.join(cwd + <span class="string">&#x27;/tempfile/cut/&#x27;</span> + <span class="built_in">id</span>)) <span class="comment"># 拼接文件的绝对路径</span></span><br><span class="line">        im = Image.<span class="built_in">open</span>(address)    <span class="comment"># 调用image打开图片</span></span><br><span class="line">        font = ImageFont.truetype(<span class="string">&quot;DejaVuSans-Bold&quot;</span>, size=<span class="number">20</span>)      <span class="comment"># 字体模式，可更改</span></span><br><span class="line">        rate = <span class="number">0.1</span>    <span class="comment"># 缩放比（不调整的话像素点过多，这里统一调整）</span></span><br><span class="line">        aspect_ratio = font.getsize(<span class="string">&quot;x&quot;</span>)[<span class="number">0</span>] / font.getsize(<span class="string">&quot;x&quot;</span>)[<span class="number">1</span>]  <span class="comment"># 获得字符长宽比 </span></span><br><span class="line">        new_im_size = np.array([im.size[<span class="number">0</span>] * rate, im.size[<span class="number">1</span>] * rate * aspect_ratio]).astype(<span class="built_in">int</span>)    <span class="comment"># 转换numpy数组，调整大小</span></span><br><span class="line">        im = im.resize(new_im_size)   </span><br><span class="line">        im = np.array(im.convert(<span class="string">&quot;L&quot;</span>))       <span class="comment"># 转换灰阶图，生成numpy数组</span></span><br><span class="line">        </span><br><span class="line">        symbols = np.array(<span class="built_in">list</span>(<span class="string">&quot; .-vM@&quot;</span>))  <span class="comment"># 建立字符索引，注意要按照亮度手动排序</span></span><br><span class="line">        <span class="keyword">if</span> im.<span class="built_in">max</span>() == im.<span class="built_in">min</span>():      <span class="comment"># 全黑和全是一种颜色进行区分</span></span><br><span class="line">            <span class="keyword">if</span> im.<span class="built_in">max</span>() &gt; <span class="number">0</span>:    <span class="comment"># 全是一种颜色，亮度值大于0，则全部用最亮的字符数值</span></span><br><span class="line">                im = (im / im) * (symbols.size - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                im[np.isnan(im)] = <span class="number">0</span>    <span class="comment"># 全黑时亮度值为NaN(非数值)，则全部用最暗字符的字符数值，也就是全黑</span></span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            im = (im - im.<span class="built_in">min</span>()) / (im.<span class="built_in">max</span>() - im.<span class="built_in">min</span>()) * (symbols.size - <span class="number">1</span>) <span class="comment"># 根据索引赋予相应像素点相应的数值</span></span><br><span class="line">        <span class="built_in">ascii</span> = symbols[im.astype(<span class="built_in">int</span>)]    </span><br><span class="line">        letter_size = font.getsize(<span class="string">&quot;x&quot;</span>)   <span class="comment"># 获取字符大小，与前面一定要对应</span></span><br><span class="line">        im_out_size = new_im_size * letter_size    <span class="comment"># 这里乘以字符长宽，否则字符只有一个像素点大小</span></span><br><span class="line">        im_out = Image.new(<span class="string">&quot;RGB&quot;</span>, <span class="built_in">tuple</span>(im_out_size), <span class="string">&quot;black&quot;</span>)  <span class="comment"># 设置输出图片，背景</span></span><br><span class="line">        draw = ImageDraw.Draw(im_out)   </span><br><span class="line">        </span><br><span class="line">        y = <span class="number">0</span>   <span class="comment"># 两个循环穷举赋值，做字符画图片</span></span><br><span class="line">        <span class="keyword">for</span> i, m <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">ascii</span>):</span><br><span class="line">            <span class="keyword">for</span> j, n <span class="keyword">in</span> <span class="built_in">enumerate</span>(m): </span><br><span class="line">                draw.text((letter_size[<span class="number">0</span>] * j, y), n, font=font) </span><br><span class="line">            y += letter_size[<span class="number">1</span>]     <span class="comment"># 注意+=，这里赋值字符宽度给y值</span></span><br><span class="line">        im_out.save(<span class="string">&quot;./tempfile/new/&quot;</span> + <span class="built_in">id</span> + <span class="string">&quot;.png&quot;</span>)  <span class="comment"># 定义输出位置和图片格式</span></span><br><span class="line">        <span class="built_in">print</span>(address + <span class="string">&quot;转换成功！当前进度：&quot;</span> + <span class="built_in">str</span>(process) + <span class="string">&quot;/&quot;</span> + <span class="built_in">str</span>(count))       <span class="comment"># 显示进度</span></span><br><span class="line">        process += <span class="number">1</span></span><br><span class="line">        gc.collect()    <span class="comment"># 重要！每次循环结束释放一次内存，否则容易内存溢出</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;转换成功！开始生成视频，请稍候......&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 调用ffmpeg合并字符画为视频，并且合并分离的音频</span></span><br><span class="line">    outvedio = <span class="string">&quot;ffmpeg -r &quot;</span> + FPS + <span class="string">&quot; -i ./tempfile/new/%05d.jpg.png ./tempfile/out.mp4&quot;</span></span><br><span class="line">    subprocess.call(outvedio, shell=<span class="literal">True</span>)</span><br><span class="line">    final_vedio = <span class="string">&quot;ffmpeg -i ./tempfile/out.mp4 -i ./tempfile/out.mp3 final.mp4&quot;</span></span><br><span class="line">    subprocess.call(final_vedio, shell=<span class="literal">True</span>)</span><br><span class="line">    shutil.rmtree(<span class="string">&quot;./tempfile&quot;</span>)     <span class="comment"># 删除临时文件夹</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;字符动画final.mp4已生成!已移除临时文件夹&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入格式错误则显示该条用法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">usage</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;usage:&quot;</span>, sys.argv[<span class="number">0</span>], <span class="string">&quot;&lt;file_input&gt; &lt;FPS&gt;&quot;</span>) </span><br><span class="line">    exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:  <span class="comment"># 封装，只有在文件作为脚本直接执行时后面的语句才会被执行，而 import 到其他脚本中后面的语句是不会被执行的</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) != <span class="number">3</span>:  <span class="comment"># 判断输入的值是否为两个，没错，是判断两个</span></span><br><span class="line">        usage()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        do_turn(file_input, FPS)</span><br></pre></td></tr></table></figure></div><h2 id="4-注意要点"><a href="#4-注意要点" class="headerlink" title="4. 注意要点"></a>4. 注意要点</h2><div class="story post-story"><p>调用numpy模块生成数组，是因为python本身虽然可以建立多维度的数组，但是书写起来非常麻烦。numpy可以很好地解决这个问题，可以理解为能构建一个更好用的数组。在对数组进行遍历穷举，要注意两次穷举分别生成两个<strong>数组</strong>，第二次生成的数组只有一个数，所以下面draw.text第二个参数text可以用n，也可以用n[0]列举第一个数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">y = <span class="number">0</span>   </span><br><span class="line"><span class="keyword">for</span> i, m <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">ascii</span>):   <span class="comment"># 这里i是用不到的</span></span><br><span class="line">    <span class="keyword">for</span> j, n <span class="keyword">in</span> <span class="built_in">enumerate</span>(m): </span><br><span class="line">        draw.text((letter_size[<span class="number">0</span>] * j, y), n, font=font)  <span class="comment"># 第一个参数是确定坐标</span></span><br><span class="line">    y += letter_size[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>字符大小，字符格式，以什么字符为参照，都是可以调整的。只要注意一点，我们是按照像素点的亮度来赋于这个像素点用什么字符的，所以索引列比较重要，要自己按照字符亮度排序，添加字符注意改值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">symbols = np.array(<span class="built_in">list</span>(<span class="string">&quot; .-vM@&quot;</span>))      <span class="comment"># 可以改成自己想要用的字符，注意按照亮度升序</span></span><br></pre></td></tr></table></figure><p>还有，在计算亮度和赋予索引值的时候，我们是按照相对亮度来计算的。因此，当图片所有像素点都是一种颜色的时候，im.max() 和 im.min()值是相等的，相对亮度会出现0&#x2F;0的值，导致报错。所以我加了以下判断条件：纯色黑色和其他颜色属于两种不同情况，黑色时numpy数组亮度是非数值NaN，需要将数组全部值进行替换为亮度最小的字符的值；因为是RGB取值，其他颜色值固定在0-255之间，颜色均一，相对亮度就没有意义了，因此全部调整为最亮字符的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> im.<span class="built_in">max</span>() == im.<span class="built_in">min</span>():</span><br><span class="line">    <span class="keyword">if</span> im.<span class="built_in">max</span>() &gt; <span class="number">0</span>:</span><br><span class="line">        im = (im / im) * (symbols.size - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        im[np.isnan(im)] = <span class="number">0</span></span><br><span class="line"><span class="keyword">else</span>: </span><br><span class="line">    im = (im - im.<span class="built_in">min</span>()) / (im.<span class="built_in">max</span>() - im.<span class="built_in">min</span>()) * (symbols.size - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>顺便再说一个很有意思的模块subprocess，subprocess.call()函数可以执行命令行的命令，并且这个命令是在子进程实行的，只有子程序结束才会继续执行其他命令，使用起来真的特别方便！比如有些程序我的python库里没有但是我的linux里有，在python脚本的某一步我需要用到linux里的软件去处理，这个时候就可以调用subprocess.call()函数去执行linux命令行的命令了。</p><p><strong>还有一个函数虽然不显眼，但是起着至关重要的作用</strong> <code>gc.collect()</code></p><p>没有这个函数部分运行内存不够的电脑会崩……我在这里踩了个大坑……</p><p>在对程序进行简化以后，我以为优化地差不多了，然后发现有的时候程序会被莫名其妙killed……</p><p><code>vi /var/log/messages</code> 查看运行日志，好家伙，内存溢出了</p><p><img src="https://www.shelven.com/tuchuang/20220508/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220508/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>经过一番度娘，我检查了一下自己也没有用到循环引用的变量啊，那么真相只有一个了：转换字符画部分程序有3个for循环嵌套，<strong>可能是for循环引用的对象没有及时回收导致内存不断增长，最后被系统kill掉（个人猜测）</strong>。虽然python本身有垃圾回收功能，而在程序运行的时候清理地并不是很及时，引入的gc模块是python的垃圾收集器模块，与默认的回收方式算法不同，<code>gc.collect()</code>函数可以强制进行垃圾回收。因此我在每个转化字符画的for循环执行一次结束后强制回收内存，如下：</p><p><img src="https://www.shelven.com/tuchuang/20220508/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220508/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>效果是立竿见影的，内存占用再也没超过5%了，非常的稳定！</p></div><h2 id="5-食用方法"><a href="#5-食用方法" class="headerlink" title="5. 食用方法"></a>5. 食用方法</h2><div class="story post-story"><p>缺什么第三方库就装什么，主要是pillow库、numpy库和ffmpeg，用conda可以直接安装。上面那段脚本代码复制粘贴，保存为ascii.py，运行命令：</p><p><code>python ascii.py &lt;视频文件&gt; &lt;你想要的视频帧率&gt;</code></p><p>回车，OK，静静等屏幕上的提示就好了。视频文件不在当前文件夹的话自行加上绝对路径，完成以后只会在<strong>当前目录</strong>生成一个out.mp4的输出文件。</p><p>源代码将同步上传<a href="https://github.com/Phantom-Aria/ascii/blob/main/ascii.py">我的github</a>。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h2&gt;&lt;div class=&quot;story post-story&quot;&gt;&lt;p&gt;捣鼓了几天python代码，我现在也越来越发现python的</summary>
      
    
    
    
    <category term="编程自学" scheme="http://www.shelven.com/categories/%E7%BC%96%E7%A8%8B%E8%87%AA%E5%AD%A6/"/>
    
    
    <category term="python" scheme="http://www.shelven.com/tags/python/"/>
    
    <category term="ffmpeg" scheme="http://www.shelven.com/tags/ffmpeg/"/>
    
    <category term="numpy" scheme="http://www.shelven.com/tags/numpy/"/>
    
    <category term="pillow" scheme="http://www.shelven.com/tags/pillow/"/>
    
  </entry>
  
</feed>
