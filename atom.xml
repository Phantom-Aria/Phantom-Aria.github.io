<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>我的小破站</title>
  
  
  <link href="http://www.shelven.com/atom.xml" rel="self"/>
  
  <link href="http://www.shelven.com/"/>
  <updated>2022-04-20T16:00:26.321Z</updated>
  <id>http://www.shelven.com/</id>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>linux操作指令总结整理</title>
    <link href="http://www.shelven.com/2022/04/20/b.html"/>
    <id>http://www.shelven.com/2022/04/20/b.html</id>
    <published>2022-04-20T15:44:49.000Z</published>
    <updated>2022-04-20T16:00:26.321Z</updated>
    
    <content type="html"><![CDATA[<p>该篇内容非常之多，主要记录自己能用的上的linux操作指令和自己的一些理解，想要用的时候方便站内搜索直接查找</p><h2 id="1-linux常用命令"><a href="#1-linux常用命令" class="headerlink" title="1. linux常用命令"></a>1. linux常用命令</h2><div class="story post-story"><p><strong>cd</strong><br>cd：Change directory<br>修改（进入）工作目录，只对目录文件有效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /    进入根(root)目录</span><br><span class="line">cd -    返回上次的目录</span><br><span class="line">cd      返回家(home)目录</span><br><span class="line">cd ~    返回家目录</span><br><span class="line">cd ..   返回上一级目录</span><br></pre></td></tr></table></figure><hr><p><strong>ls</strong></p><p>ls：List files<br>ls计算不了目录内文件大小，所以显示的目录大小不是实际的，要看目录实际大小用du命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-a  列出包括.a开头的隐藏文件的所有文件</span><br><span class="line">-A  通-a，但不列出&quot;.&quot;和&quot;..&quot;</span><br><span class="line">-l  列出文件的详细信息</span><br><span class="line">-c  根据ctime排序显示</span><br><span class="line">-t  根据文件修改时间排序</span><br><span class="line">-h  将文件大小按照易于读懂的方式显示（多少M，多少G）</span><br></pre></td></tr></table></figure><p>ll和ls-l是同样的用法，linux可用，mac中不能用，可以改环境变量文件自定义ll用法</p><hr><p><strong>pwd</strong><br>pwd：print working directory，打印当前所在目录</p><hr><p><strong>cp</strong><br>cp: Copy file<br>拷贝并粘贴文件，并且可以重命名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-b  覆盖前做备份</span><br><span class="line">-f  如存在不询问而强制覆盖</span><br><span class="line">-i  如存在则询问是否覆盖</span><br><span class="line">-u  较新才覆盖</span><br><span class="line">-t  将多个源文件移动到统一目录下，目录参数在前，文件参数在后</span><br></pre></td></tr></table></figure><p><code>cp ../data/xist.fa xist_seq.fa         # 复制上一个目录data目录下的xist.fa到当前目录，并重命名为xist_seq.fa</code><br><code>cp -r 003/ 007         # 递归的方式，复制003目录到007目录，目录复制到目录要用递归</code></p><hr><p><strong>mv</strong><br>mv: Move file<br>移动文件，相当于windows下的剪切粘贴，如果剪切粘贴到同一目录下，则为重命名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-b  覆盖前做备份</span><br><span class="line">-f  如存在不询问而强制覆盖</span><br><span class="line">-i  如存在则询问是否覆盖</span><br><span class="line">-u  较新才覆盖</span><br><span class="line">-t  将多个源文件移动到统一目录下，目录参数在前，文件参数在后</span><br></pre></td></tr></table></figure><p><code>mv a1.index.sh ../         # 移动到上一目录</code><br><code>mv a1.index.sh a2.index.sh     # 重命名为a2.index.sh</code><br><code>rename txt doc *    # 把所有txt改成doc，批量文件重命名可以用rename</code></p><hr><p><strong>rm</strong><br>rm: Remove file<br>删除文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-r  删除文件夹（就是删除目录）</span><br><span class="line">-f  删除不提示</span><br><span class="line">-i  删除提示</span><br><span class="line">-v  详细显示进行步骤</span><br></pre></td></tr></table></figure><p>一定要慎重使用，命令行模式下删除文件不可恢复<br><code>rm -rf *.fna  #删除目录下所有以.fna结尾的文件</code></p><hr><p><strong>ln</strong><br>ln: Link files<br>创建连接文件，包括软连接和硬链接，一般软连接比较常用，相当于windows下的快捷方式；硬链接相当于重要文件的备份，默认硬链接<br><strong>删除原文件，硬链接文件不受影响，软连接文件则无效</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-s  建立软连接  </span><br><span class="line">-v  显示详细的处理过程</span><br></pre></td></tr></table></figure><hr><p><strong>mkdir</strong><br>mkdir：Make directory<br>创建文件夹(目录)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-p  递归创建目录，若父目录不存在则依次创建</span><br><span class="line">-m  自定义创建目录的权限</span><br><span class="line">-v  显示创建目录的详细信息</span><br></pre></td></tr></table></figure><p><code>mkdir rnaseq   #创建一个名为rnaseq的目录</code></p><hr><p><strong>touch</strong><br>建新的空文件(可写入的文件)<br><code>touch 1.txt 2.txt 3.txt    # 同时新建三个文件，一个文件可以直接vim建立</code></p><hr><p><strong>cat</strong><br>cat: concatenate 连接<br>cat的一个作用是查看文件，一般是比较小的文件，行数小于一个屏幕，最多不要超过两个屏幕，否则会刷屏（屏幕输出的方式）<br>cat另一个作用是合并多个文件，一般配合重定向合并为一个新文件或者将一个文件内容追加到另一个文件结尾<br><code>cat a1.txt a2.txt &gt;all.txt     # 合并文件，并不会删除原文件，覆盖新文件内容，新文件为all.txt</code><br><code>cat a1.txt &gt;&gt;a2.txt    # 同样是合并，a1重定向到a2结尾</code><br><code>cat &gt;id.txt        # 回车输入内容，可新建id.txt文件，ctrl+c退出  echo不可以这样新建，只能echo &quot;内容&quot;&gt;id.txt</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-A  显示文件内的空白信息</span><br></pre></td></tr></table></figure><p><strong>linux系统下是换行\n；mac系统下是回车\r；windows系统下回车加换行两个字符\r\n</strong> 三者都是空白，用less无法看出区别，只能在cat -A下看到不同操作系统的换行符信息</p><hr><p><strong>less &#x2F; more</strong><br>less和more都是文件查看工具，但是less功能更多一些，在windows系统下打开一个10G的文件比较困难，但是在Linux下非常方便，less可以打开非常大的文件，压缩格式也可以直接打开。注意后面接文件，不能接目录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-m  显示类似于more命令的百分比</span><br><span class="line">-N  显示行号</span><br></pre></td></tr></table></figure><p>more：q退出，space向下翻一页，enter向下滚动一行，b往前翻一页，会加载全部显示浏览到百分之几，退出后会加载显示的所有内容<br>less：类似，还可以用pageup和pagedown，不会加载全部，退出后不会加载文件内容显示到当前界面<br>less下按h进入帮助界面；按&#x2F;向下搜索字符串，按？向上搜索字符串，搜索状态下n和p前后跳转；按v进入编辑</p><hr><p><strong>head &#x2F; tail</strong><br>这两个命令比较简单，只是取一个文件的头部和尾部多少行，默认10行，可以加-n进行设置，利用管道可以取文件中间行<br><code>head -40 a.txt | tail -20  #取文件第21~40行</code><br><code>tail -n +20 notes.log  #取文件的第20行到文件末尾</code></p><hr><p><strong>g(un)zip&#x2F; b(un)zip2</strong><br>gzip和bzip2是文件压缩工具，默认直接对源文件进行处理，压缩比率在2&#x2F;3左右，都可以进行设置<br>加上un，为unpack的意思，表示解压缩<br>linux压缩文件格式是.gz和.bz2<br>windows压缩文件有.rar文件，可以下载rarlinux工具解压缩；.zip文件可以通过unzip命令解压<br>bzip2压缩比更高（尽量下载bz2压缩文件），但是占用更多CPU<br><code>gzip a.txt     # 压缩a.txt文件</code><br><code>gunzip a.txt.gz    # 解压a.txt.gz文件</code><br>压缩的文件可以用<strong>less</strong>或者<strong>zcat</strong>打开文件</p><hr><p><strong>tar</strong>（很多生物软件是打包并压缩的）<br>tar：Tape archive （磁带档案）<br>tar主要用于打包，由于tar能调用gzip或者bzip2进行压缩，而打包和压缩经常如windows系统一样合并为一个过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-c  建立打包档案，可搭配 -v 来察看过程中被打包的档名(filename)</span><br><span class="line">-t  察看打包档案的内容含有哪些档名，重点在察看文档名就是了（同less功能）</span><br><span class="line">-x  解打包或解压缩的功能，可以搭配 -C (大写) 在特定目录解开</span><br></pre></td></tr></table></figure><p><strong>以上三个命令不能同时使用，只能三选一</strong><br>辅选项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-j  透过 bzip2 的支持进行压缩/解压缩：此时档名最好为 *.tar.bz2</span><br><span class="line">-z  透过 gzip 的支持进行压缩/解压缩：此时档名最好为 *.tar.gz</span><br><span class="line">-v  在压缩/解压缩的过程中，将正在处理的文件名显示出来！</span><br><span class="line">-f  filename -f 后面要立刻接要被处理的档名！f很重要，每次执行tar命令都要加上</span><br></pre></td></tr></table></figure><p>对于初学者，记住<strong>c是creat，创建，x是解包，z对应gzip，j对应bzip2</strong>即可，所以常用的命令如下：<br><code>$ tar -jcvf filename.tar.bz2 A B C     #打包压缩为bz2结尾文件</code><br><code>$ tar -jxvf filename.tar.bz2       # 解压缩.tar.bz2结尾文件</code><br><code>$ tar -zcvf filename.tar.gz A B C  #打包压缩为gz结尾文件</code><br><code>$ tar -zxvf filename.tar.gz        # 解压缩.tar.gz 结尾文件</code><br><code>$ tar -jxvf filename.tar.bz2 -C 目录名     #解压缩到指定目录，注意是大写C</code><br>less命令可以不解压只查看（真的强大），tar -tf filename同样<br>如果只需解压其中一个文档，可以先通过-t查看文档名并复制，再在前面解压缩的命令基础上加空格和文档名</p><hr><p><strong>wc</strong><br>wc &#x3D; Word Count<br>统计一个文件中，行数，单词数（有空格或者换行符的字符串），字符数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-l  filename 报告行数</span><br><span class="line">-c  filename 报告字节数</span><br><span class="line">-m  filename 报告字符数</span><br><span class="line">-w  filename 报告单词数</span><br></pre></td></tr></table></figure><p>统计当前目录下有多少文件<br><code>$ ll | wc    # 注意显示行数比实际多两行，因为还有隐藏的当前目录.和上一层目录.. 可通过ls -a查看</code></p><hr><p><strong>sort</strong><br>排序，默认按第一列排序，可以通过-k进行设置；默认排序规则为按ASCII码排序，可以通过-n进行修改；-r取相反方向；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-n  依照数值的大小排序。</span><br><span class="line">-o  将排序后的结果存入指定的文件。</span><br><span class="line">-r  以相反的顺序来排序。</span><br><span class="line">-t  指定排序时所用的栏位分隔字符。</span><br><span class="line">-k  选择以哪个区间进行排序。</span><br></pre></td></tr></table></figure><p><code>$ sort -nk2 -k1 01.txt | less      # 在01.txt文件中，根据第二列数字大小进行排序，数字一样的比较第一列并排序</code></p><hr><p><strong>uniq</strong><br>用于检查及删除文本文件中重复出现的行列，一般与 sort 命令结合使用，排序之后使用uniq</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-u  显示未重复的行</span><br><span class="line">-c  统计重复行的数量（在行首标注）</span><br><span class="line">-ci 忽略大小写统计重复行</span><br><span class="line">-d  显示重复出现的行</span><br></pre></td></tr></table></figure><p><code># cut -f 1 blast.out | sort -t &quot;|&quot; -nk2 | uniq | wc -l    #从blast.out文件中提取第一列（f代表字段），第一列字段以“|”分割并比较第二段的数字大小进行排序，去除重复行，并记录行数   即记录有多少条比对上的基因</code></p><hr><p><strong>df</strong><br>df: disk free<br>df用于查看磁盘消耗，显示磁盘可用空间数目信息及空间结点信息。一般加一个-h选项，然后接要查看的磁盘，默认所有磁盘。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-a  显示全部文件系统</span><br><span class="line">-h  文件大小友好显示</span><br><span class="line">-l  只显示本地文件系统</span><br><span class="line">-i  显示inode信息</span><br><span class="line">-T  显示文件系统类型</span><br></pre></td></tr></table></figure><hr><p><strong>du</strong><br>du: Disk usage<br>df用于查看磁盘使用情况，du用于查看目录所占磁盘大小，一般也加-h选项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-h  方便阅读的方式（显示带单位）</span><br><span class="line">-s  只显示总和的大小</span><br></pre></td></tr></table></figure><hr><p><strong>find</strong><br>find顾名思义，主要用于查找文件。因为当文件越来越多的时候，由于Linux是文本界面，不方便可视化文件，这个时候就可以利用find快速找到需要的文件。find支持多种搜索方式<br>主要用的搜索方式：<code>find 目录 Expression 条件</code><br><code>$ find /media/ -name *.fna    #查找media目录下所有.fna结尾的文件</code><br><code>$ find /media/ -size 100M    #查找media目录下所有大于100M的文件</code></p><hr><p><strong>which</strong><br><code>$ which filename # 查看可执行文件的位置，在PATH变量指定的路径中查看系统命令是否存在及其位置</code></p><hr><p><strong>whereis</strong><br>该指令只能用于查找二进制文件、源代码文件和man手册页，一般文件的定位需使用locate命令</p><hr><p><strong>locate</strong><br>是find -name的另一种写法，但是要比后者快得多，原因在于它不搜索具体目录，而是搜索一个数据库&#x2F;var&#x2F;lib&#x2F;locatedb，这个数据库中含有本地所有文件信息。Linux系统自动创建这个数据库，并且每天自动更新一次，所以使用locate命令查不到最新变动过的文件。为了避免这种情况，<strong>可以在使用locate之前，先使用updatedb命令，手动更新数据库</strong></p><hr><p><strong>top</strong><br>top可以动态显示（3s一次）系统进程使用情况，类似于windows系统的任务管理器。可以显示当前系统正在执行的进程的相关信息，包括进程ID、内存占用率、CPU占用率等。</p><hr><p><strong>ps</strong><br>ps: process status<br>ps也是系统进程管理工具，与top不同的是，top可以动态显示，而ps则是静态显示，是某一时刻的快照，静态显示的好处是便于其他程序捕获结果，进行处理。</p><hr><p><strong>kill</strong><br>kill的作用是杀死进程，给定一个任务的PID号，可以通过top或者ps命令获得，例如当前有一个sleep进程，pid号为12000；通过kill -9可以强制杀死<br><code>$ kill -9 12000</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1   终端断线</span><br><span class="line">2   中断，相当于ctrl+c</span><br><span class="line">2   退出，同ctrl+\</span><br><span class="line">9   强制终止</span><br><span class="line">15  终止进程，默认为15</span><br><span class="line">18  继续，与STOP相反，fg/bg命令</span><br><span class="line">19  暂停，同ctrl+z</span><br></pre></td></tr></table></figure><hr><p><strong>chmod</strong><br>chmod: Change mode<br>用于修改文件权限，Linux基础权限可以包括ugo模式（文字设定法）以及421模式（数字设定法），可以用通配符一次修改所有类型的文件<br>文字设定法：<br>u表示属主(user)，g表示同组群用户(group)，o表示其他用户(other)，a表示所有用户(all)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+  添加权限</span><br><span class="line">-  删除权限</span><br><span class="line">=  赋予给定权限，并取消其他所有权限</span><br><span class="line">r  可读(read)</span><br><span class="line">w  可写(write)</span><br><span class="line">x  可执行(execute)</span><br></pre></td></tr></table></figure><p>数字设定法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0表示没有权限，1表示可执行权限，2表示可写权限，4表示可读权限</span><br><span class="line">7：可读可写可执行 4+2+1</span><br><span class="line">6：可读可写 4+2</span><br><span class="line">5：可读可执行4+1</span><br></pre></td></tr></table></figure><p><code>$ chmod 721 a1.index.sh    # 421模式修改</code><br>与之类似的还有chown与chgrp，这两个权限更大，需要root权限；<br><strong>chown</strong>: Change owner<br><code>$ chown 用户名 目录名/     # 修改目录的属主</code><br><strong>chgrp</strong>: Change group<br><code>$ chgrp 组名 目录名/       # 修改目录的组名</code></p><hr><p><strong>exit</strong><br>退出登录，exit是正确退出，最好不要直接点windows关闭窗口按钮退出，也不要使用ctrl+D给定退出信号退出。</p><hr><p><strong>man</strong><br>详细解释命令，系统命令可以用这个找，下载的程序往往是–help</p><hr><p><strong>wget</strong><br>后面接下载网址，可以直接由地址获取下载文件</p><hr><p><strong>su</strong>：super user<br>获得超级管理员权限，root权限，需要输入密码<br><strong>sudo</strong>：super user do<br>暂时取得root权限，配置系统经常能看到sudo yum</p><hr><p><strong>echo</strong><br>在标准输出（屏幕）上显示文字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-n  输出之后不换行，去除结尾的换行符。注意默认一行后有一个换行符</span><br><span class="line">-e  转义字符按照对应方式处理</span><br></pre></td></tr></table></figure><hr><p><strong>yum</strong>（centos是yum，ubuntu是apt）</p><p>Yellow dog Updater Modified是一个软件包管理器，能够从指定的服务器自动下载rpm包进行安装并且自动处理依赖性关系，yum优点提供了查找、安装、删除某一个、一组甚至全部软件包的命令，并且命令简洁便于使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">yum clean all               # 清除原有yum缓存</span><br><span class="line">yum repolist                # 列出仓库信息</span><br><span class="line">yum install software        # 安装</span><br><span class="line">yum update                  # 更新</span><br><span class="line">yum list software           # 查看软件</span><br><span class="line">yum list all                # 查看所有软件</span><br><span class="line">yum list installed          # 列出已安装软件</span><br><span class="line">yum list available          # 列出可安装软件</span><br><span class="line">yum reinstall software      # 重新安装</span><br><span class="line">yum remove software         # 卸载</span><br><span class="line">yum info software           # 查看软件信息</span><br><span class="line">yum search software         # 根据软件信息查找软件</span><br><span class="line">yum whatprovides file       # 根据文件找出包含此文件的软件</span><br><span class="line">yum history                 # 查看系统中软件管理信息</span><br><span class="line">yum history info 数字        # 对该数字为id的信息进行显示</span><br><span class="line">yum groups list             # 列出软件组 </span><br><span class="line">yum groups info             # 查看软件组的信息</span><br><span class="line">yum groups install sfgroup  # 安装软甲组</span><br><span class="line">yum groups remove sfgroup   # 卸载软件组</span><br><span class="line">yum repolist                # 查看yum源信息</span><br></pre></td></tr></table></figure><hr><p><strong>cut</strong><br>命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段写至标准输出<br>如果不指定 File 参数，cut 命令将读取标准输入。必须指定 -b、-c 或 -f 标志之一</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-b  以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了 -n 标志</span><br><span class="line">-c  以字符为单位进行分割</span><br><span class="line">-d  自定义分隔符，默认为制表符</span><br><span class="line">-f  与-d一起使用，指定显示哪个区域</span><br></pre></td></tr></table></figure><hr><p><strong>xargs</strong><br>与管道不同，xargs可以给下个命令传递参数。<br><code>$ ls *.gz | head   #只可以输出前10个文件名</code><br><code>$ ls *.gz | xargs head     #输出.gz结尾的所有文件前10行</code><br>这里要注意下其实命令是有省略的，完整应该是<code>ls *.gz | xargs -i head&#123;&#125;    #传递参数到head的花括号中</code></p><hr><p><strong>jobs</strong><br>查看当前在后台执行的命令，可查看命令进程号码</p><hr><p><strong>&amp;</strong><br>运行命令时，在命令末尾加上&amp;可让命令在后台执行</p><hr><p><strong>nohup</strong><br>命令可以使命令永久的执行下去，和终端没有关系，退出终端也不会影响程序的运行； &amp; 是后台运行的意思，但当用户退出的时候，命令自动也跟着退出。 那么，把两个结合起来nohup 命令 &amp;这样就能使命令永久的在后台执行</p><hr><p><strong>fg N</strong><br>将命令进程号码为N的命令进程放到前台执行，同%N  #注意是进程号不是PID！kill程序需要PID</p><p><strong>bg N</strong><br>将命令进程号码为N的命令进程放到后台执行</p><p><strong>cal</strong> 显示日历</p><p><strong>date</strong>    显示时间</p></div><h2 id="2-基本操作"><a href="#2-基本操作" class="headerlink" title="2. 基本操作"></a>2. 基本操作</h2><div class="story post-story"><p><strong>源码编译</strong><br>安装软件都有Readme文件或者install文件说明安装方式，一般是以下步骤：<br>1、运行configue脚本 #检查系统环境配置情况，缺少哪些东西，缺少的可以yum下载安装<br>2、运行make check命令（可选）<br>3、敲make命令进行编译<br>4、make install命令安装，出现可执行程序</p><hr><p><strong>文件校验</strong><br>下载大的文件会附带.md5文件<br>任意长度信息逐位计算，产生128位hash值，不可逆。也就是说MD5算法可以位任何文件产生一个独一无二的数据指纹，通过校验下载前后的MD5值是否发生改变，就可以知道源文件是否被改动<br><code>$ md5sum filename &gt; data.md5   # 对文件（可多个文件）生成md5校验码（32位，16进制），并命名为data.md5</code><br><code>$ md5sum -c data.md5       # 校验文件，如果校验码相同则显示OK</code></p><hr><p><strong>重定向</strong><br>本质是将输出到屏幕的内容重定向到一个新的文件夹中，大于号和小于号都是代表数据的流向<br><code>$ echo “想要的内容”&gt; 文件名  #覆盖原文件的内容</code><br><code>$ echo “想要的内容”&gt;&gt; 文件名  #想要的内容追加到文件后，原文件内容不修改</code><br>一个&gt;是覆盖，两个&gt;&gt;是追加</p><hr><p><strong>Ctrl+C</strong><br><strong>终止</strong>并退出前台命令的执行，回到SHELL</p><p><strong>Ctrl+Z</strong><br><strong>暂停</strong>前台命令的执行，将该进程放入后台，回到SHELL</p><hr></div><h2 id="3-vim"><a href="#3-vim" class="headerlink" title="3. vim"></a>3. vim</h2><div class="story post-story"><p>vim（主要用来写脚本，编辑文件）<br>vim是Linux系统自带的文本编辑器，可以理解成为windows系统下的word软件，适合编辑小文件，会一次加载全部内容到内存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:w filename 将文件以指定的文件名保存起来  </span><br><span class="line">:wq         保存并退出</span><br><span class="line">:q!         不保存而强制退出</span><br></pre></td></tr></table></figure><p>注意vim是vi的拓展，有些自定义设置要在vim下生效，最好是用vim<br>用户设置优先级高于全局设置，设置文件都在家目录~下设置，且均为点开头的隐藏文件，如下<br>~&#x2F;.vimrc<br>~&#x2F;.bashrc</p><h3 id="3-1-命令行模式功能键："><a href="#3-1-命令行模式功能键：" class="headerlink" title="3.1 命令行模式功能键："></a>3.1 命令行模式功能键：</h3><p><strong>1）插入模式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i   切换进入插入模式 insert mode ，按&quot;i&quot;进入插入模式后是从光标当前位置开始输入文件</span><br><span class="line">a   进入插入模式后，是从目前光标所在位置的下一个位置开始输入文字</span><br><span class="line">o   进入插入模式后，是插入新的一行，从行首开始输入文字</span><br></pre></td></tr></table></figure><p><strong>2）从插入模式切换为命令行模式</strong><br>按 ESC 键<br><strong>3）移动光标</strong><br>直接用键盘上的光标来上下左右移动，也可以用小写英文字母h、j、k、l，分别控制光标左、下、上、右移一格。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">G   移动到文件末尾，15G移动光标至文章的第15行行首</span><br><span class="line">gg  移动到文件开头</span><br><span class="line">$   移动到光标所在行的行尾</span><br><span class="line">^   移动到光标所在行的行首</span><br><span class="line">H   光标移动到这个屏幕的最上方那一行的第一个字符</span><br><span class="line">M   光标移动到这个屏幕的中央那一行的第一个字符</span><br><span class="line">L   光标移动到这个屏幕的最下方那一行的第一个字符</span><br></pre></td></tr></table></figure><p><strong>4）删除文字</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x   每按一次，删除光标所在位置的后面一个字符</span><br><span class="line">X   大写的X，每按一次，删除光标所在位置的前面一个字符</span><br><span class="line">dd  删除光标所在行 1,6d删除1到6行</span><br></pre></td></tr></table></figure><p><strong>5）回复上一次操作</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u   如果误执行一个命令，可以回到上一个操作。按多次u可以执行多次回复</span><br></pre></td></tr></table></figure><p><strong>6）继续下一个操作</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n或. 比如查找一个字符串以后，继续寻找下一个字符串，按多次n执行多次操作</span><br><span class="line">N    与 n 刚好相反，为反向进行前一个搜寻动作</span><br></pre></td></tr></table></figure><h3 id="3-2-底线命令模式"><a href="#3-2-底线命令模式" class="headerlink" title="3.2 底线命令模式"></a>3.2 底线命令模式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">:/word          # 查找word字符串</span><br><span class="line">:%s/x/y/gc      # 所有x被y替换 g代表全局，c代表交互模式（每次替代会提示）</span><br><span class="line">:!命令             # 命令先执行，vim被挂起。执行后按enter回到vim</span><br><span class="line">:split          # 横屏分屏显示 ctrl+ww切换上下屏</span><br><span class="line">:vsplit         # 纵向分屏</span><br><span class="line">:only           # 取消分屏</span><br><span class="line">:n1,n2s/word1/word2/g   # 在第n1与n2行之间寻找word1这个字符串，并将该字符串取代为word2</span><br></pre></td></tr></table></figure><p>vim还有专门的键盘图。。。放一个简略版的</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/%E5%9C%A3%E5%85%AC%E4%BC%9A%E5%A8%81%E5%A8%81.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/%E5%9C%A3%E5%85%AC%E4%BC%9A%E5%A8%81%E5%A8%81.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div><h2 id="4-基础命令三剑客"><a href="#4-基础命令三剑客" class="headerlink" title="4. 基础命令三剑客"></a>4. 基础命令三剑客</h2><div class="story post-story"><p>三剑客的命令非常之多，完全可以出一本书，这里只放一些简单的和我能用得到的</p><h3 id="4-1-三剑客之grep"><a href="#4-1-三剑客之grep" class="headerlink" title="4.1 三剑客之grep"></a>4.1 三剑客之grep</h3><p>grep（找基因信息比较方便）<br>Global Regular Expression Print，全局正则表达式版本<br>文本搜索工具，类似于正则表达式搜索，可以在一个大的文件中快速搜索到满足一定规则的内容。</p><p><code>$ grep &quot;&gt;&quot;  gene.fna | wc -l   # 统计gene.fna文件中序列的条数</code><br><code>$ grep -A 2 &quot;3 gi 29732 34486&quot; lastz.axt  #将满足条件的行和下面两行显示出来</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grep -E         # grep的拓展模式</span><br><span class="line">grep -P         # 适应perl语言的正则表达式</span><br></pre></td></tr></table></figure><p>区分一下：find是搜索目录下满足条件的文件，grep是搜索文件内满足条件的内容</p><h3 id="4-2-三剑客之sed"><a href="#4-2-三剑客之sed" class="headerlink" title="4.2 三剑客之sed"></a>4.2 三剑客之sed</h3><p>sed<br>sed &#x3D; Stream Editor<br>流处理器，数据流过这个工具，格式化成固定的格式<br><code>sed + 选项参数 + &#39;模式&#39; + 文本或文件</code></p><p><strong>选项参数</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-e  替换，并输出到屏幕（搭配重定向）</span><br><span class="line">-i  原文件修改</span><br><span class="line">-f  根据模式替换</span><br><span class="line">-r  拓展的正则表达式</span><br><span class="line">-n  输出</span><br></pre></td></tr></table></figure><p><strong>模式：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g   全局</span><br><span class="line">s   替换，一个字符替换另一个</span><br><span class="line">d   删除</span><br><span class="line">p   打印</span><br></pre></td></tr></table></figure><p><strong>输出固定的行</strong><br><code>$ sed -n &#39;1307p&#39;  seq.fna      # 输出文件第1307行；</code><br><code>$ sed -n &#39;100,200p&#39; seq.fna    # 输出文件第100到200行；</code></p><p><strong>替换操作</strong><br><code>$ sed -e &#39;s/gi/GI/&#39; seq.fna    # 将文件中gi全部替换为大写GI；s为替换</code><br><code>$ sed -i &#39;s/gi/GI/g&#39; seq.fna       # 在原文件上进行替换，并且进行全部替换，g为全局（默认只进行一次替换）</code></p><p><strong>删除操作</strong><br><code>$ sed -e &#39;/^\s$/d&#39;  seq.fna    # 删除文件中的空白行，命令d为删除符合条件的行。\s为空白；^行首，$行尾</code><br><code>$ sed -e &#39;/&gt;/d&#39; seq.fna        # 删除包含ref的行，每个ref行都有&gt;</code><br><code>$ sed -e &#39;s/:.*//g&#39; seq.fna    # 删除冒号之后的所有内容</code></p><h3 id="4-3-三剑客之awk"><a href="#4-3-三剑客之awk" class="headerlink" title="4.3 三剑客之awk"></a>4.3 三剑客之awk</h3><p>awk也是非常强大的文本处理工具，awk本身也是一门编程语言<br><strong>输出一个列表任意列</strong><br><code>$ awk &#39;&#123;print $1,$NF&#125;&#39; 1.txt   # 输出1.txt的第一列和最后一列</code></p><p><strong>过滤文件结果</strong><br><code>$ awk &#39;&#123;if ($3&gt;=80 &amp;&amp; $4&gt;=100) print $0&#125;&#39;  blast_m8.out  # 过滤文件比对结果，将第三列值大于80，并且第四列值大于100的所有结果输出</code></p><p><strong>比较</strong><br><code>$ awk &#39;$8&gt;$10&#39; input.txt   # 输出第8列数值大于第10列数值的行</code></p><p><strong>输出固定行内容</strong><br><code>$ awk &#39;NR&gt;=20&amp;&amp;NR&lt;=80&#39; input.txt  #输出第20到第80行内容</code></p></div><h2 id="5-正则表达式"><a href="#5-正则表达式" class="headerlink" title="5. 正则表达式"></a>5. 正则表达式</h2><div class="story post-story"><p>正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">^   匹配输入字行首      ^eat,识别eat开头的字符串</span><br><span class="line">$   匹配输入行尾    eat$,识别eat结尾的字符串 </span><br><span class="line">\b  单词锚定符          \beat\b ,只识别eat字符串</span><br><span class="line">.   匹配除“\n”和&quot;\r&quot;之外的任何单个字符</span><br><span class="line">\   转译字符         比如匹配. 则\.</span><br><span class="line">*   匹配前面的子表达式任意次</span><br><span class="line">+   匹配前面的子表达式一次或多次(大于等于1次，例如“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”）# 需要grep -E支持（拓展）</span><br><span class="line">?   匹配前面的子表达式零次或一次  # 需要grep -E支持（拓展）</span><br><span class="line">[xyz]   字符集合。匹配所包含的任意一个字符</span><br><span class="line">x|y     匹配x或y。“z|food”能匹配“z”或“food”。“[z|f]ood”则匹配“zood”或“food”，择译匹配</span><br><span class="line">[a-z]   字符范围</span><br><span class="line">\d  匹配所有数字，等同[0-9]</span><br><span class="line">\s  空白，是字符集换页、制表、换行、回车以及空格的简写[\f\t\n\r]</span><br><span class="line">\w  [A-Za-z0-9_]单词包括大小写字母、数字和下划线</span><br><span class="line">^   负值字符范围。匹配任何不在指定范围内的任意字符。（倒三角）</span><br><span class="line">\D  非数字</span><br><span class="line">\W  非字符</span><br><span class="line">\S  非空白字符</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;该篇内容非常之多，主要记录自己能用的上的linux操作指令和自己的一些理解，想要用的时候方便站内搜索直接查找&lt;/p&gt;
&lt;h2 id=&quot;1-linux常用命令&quot;&gt;&lt;a href=&quot;#1-linux常用命令&quot; class=&quot;headerlink&quot; title=&quot;1. linux</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="linux指令" scheme="http://www.shelven.com/tags/linux%E6%8C%87%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>shell脚本基本语法总结</title>
    <link href="http://www.shelven.com/2022/04/20/a.html"/>
    <id>http://www.shelven.com/2022/04/20/a.html</id>
    <published>2022-04-19T19:55:58.000Z</published>
    <updated>2022-04-20T05:03:08.389Z</updated>
    
    <content type="html"><![CDATA[<p>简单记录下shell脚本语言的学习</p><h2 id="shell脚本运行方式"><a href="#shell脚本运行方式" class="headerlink" title="shell脚本运行方式"></a>shell脚本运行方式</h2><div class="story post-story"><p>首先要了解什么是脚本，脚本本质上是一个可运行的文件，使用特定格式的指令让系统通过脚本解析器解析并执行你的指令。系统提供的shell命令解析器有sh、bash和ash。可以通过<code>echo $SHELL</code>查看自己linux系统的默认解析方式</p><p>shell脚本文件的开头：<code>#!/bin/bash</code></p><p>#! 是特殊的用来声明脚本由什么shell解释，否则使用默认shell</p><p>sh文件有三种执行方式<code>./xxx.sh</code> <code>bash xxx.sh</code> <code>. xxx.sh</code></p><p><code>./xxx.sh</code>  先按照 文件中#!指定的解析器解析，如果#！指定指定的解析器不存在才会使用系统默认的解析器</p><p><code>bash xxx.sh</code>   指明先用bash解析器解析，如果bash不存在才会使用默认解析器</p><p><code>. xxx.sh</code>  直接使用默认解析器解析</p></div><h2 id="各种引号的区别"><a href="#各种引号的区别" class="headerlink" title="各种引号的区别"></a>各种引号的区别</h2><div class="story post-story"><p>vim创建脚本文件1111.sh：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo &quot;Phantom的SHELL练习&quot;</span><br><span class="line">num=123</span><br><span class="line">echo &quot;预设数字=$num&quot;</span><br><span class="line">read -p &quot;输入数字&quot; sum      # read可以识别标准输入（键盘输入），-p参数设置提示语</span><br><span class="line">echo &quot;输出结果=$sum+$num&quot;</span><br><span class="line">echo &quot;$sum&quot;     # &quot;&quot;解析变量值</span><br><span class="line">echo &#x27;$sum&#x27;     # &#x27;&#x27;不能解析变量值</span><br><span class="line">echo &quot;今天日期`date`&quot;       # ``识别为系统命令</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220420011514.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220420011514.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>变量名不能以数字开头</p><p>在变量赋值的过程中，等号两边不能接空格，若要接空格，则整个字符串都要用引号括起来</p><div class="note "><p><strong>各种引号区别</strong></p><p>双引号“”可以解析变量的值<br>单引号‘’不能解析变量的值，包含的变量会被当做字符串<br>反引号`` 反引号的内容作为系统命令并执行 如`date`</p></div></div><h2 id="各种括号的区别"><a href="#各种括号的区别" class="headerlink" title="各种括号的区别"></a>各种括号的区别</h2><div class="story post-story"><p>vim创建脚本文件xxx.sh：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">Num=1000</span><br><span class="line">&#123;                                       # 花括号表示在当前shell完成，会影响当前变量</span><br><span class="line">    Num=1234</span><br><span class="line">    echo &quot;()里面的数字是=$Num&quot;</span><br><span class="line">&#125;</span><br><span class="line">echo &quot;显示当前shell数字=$Num&quot;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220420012607.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220420012607.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>vim创建脚本文件xxxx.sh：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">Num=1000</span><br><span class="line">(                                       # 小括号表示在当前shell完成，不会影响当前变量</span><br><span class="line">    Num=1234</span><br><span class="line">    echo &quot;()里面的数字是=$Num&quot;</span><br><span class="line">)</span><br><span class="line">echo &quot;显示当前shell数字=$Num&quot;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220420013440.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220420013440.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><div class="note "><p><strong></strong></p><p>{命令序列} 在当前shell中执行，直接影响当前变量<br>(命令序列) 由子shell完成，不影响当前shell的变量<br>[判断条件]中括号是判断条件，进行数值判断。下面会说明</p></div></div><h2 id="数值判断"><a href="#数值判断" class="headerlink" title="数值判断"></a>数值判断</h2><div class="story post-story"><p>vim建立脚本文件xxxxx.sh：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">read -p &quot;请输入第一个数字&quot; m</span><br><span class="line">read -p &quot;请输入第二个数字&quot; n</span><br><span class="line">if [ $m -eq $n ]; then          # -eq 判断两个参数是否相等</span><br><span class="line">    echo &quot;输入的两个数字相等&quot;</span><br><span class="line">elif [ $m -lt $n ]; then        # -lt 判断左边参数是否小于右边参数</span><br><span class="line">    echo &quot;第一个数字小于第二个数字&quot;</span><br><span class="line">elif [ $m -gt $n ]; then        # -gt 判断左边参数是否大于右边参数</span><br><span class="line">    echo &quot;第一个数字大于第二个数字&quot;</span><br><span class="line">fi      # if控制语句格式：if elif else fi </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220420015758.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220420015758.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="> </p><div class="note "><p><strong>数值判断参数详解</strong></p><p>-eq  比较两个参数是否相等<br>-ne  比较两个参数是否不相等<br>-lt  左边参数是否小于右边参数<br>-le  左边参数是否小于等于右边参数<br>-gt  左边参数是否大于右边参数<br>-ge  左边参数是否大于等于右边参数</p></div></div><h2 id="字符串提取和替换"><a href="#字符串提取和替换" class="headerlink" title="字符串提取和替换"></a>字符串提取和替换</h2><div class="story post-story"><p>vim新建脚本文件1234.sh：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">ll=&quot;Phantom Aria f r u i t l e s s l o v e&quot;     # 定义字符串变量</span><br><span class="line">echo &quot;长度为:$&#123;#ll&#125;&quot;        # 字符串长度(包括空格)</span><br><span class="line">echo &quot;$&#123;ll:3&#125;&quot;          # 从第3个字符往后提取</span><br><span class="line">echo &quot;$&#123;ll:3:11&#125;&quot;       # 从第3个字符往后提取11个字符</span><br><span class="line">echo &quot;$&#123;ll/ /&#125;&quot;         # 字符串从左往右删除第一个空格（相当于替换的方式）</span><br><span class="line">echo &quot;$&#123;ll// /&#125;&quot;        # 删除字符串中所有空格（相当于全局替换的方式）</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220420024742.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220420024742.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div><h2 id="字符串匹配和删除"><a href="#字符串匹配和删除" class="headerlink" title="字符串匹配和删除"></a>字符串匹配和删除</h2><div class="story post-story"><p>vim新建脚本文件match.sh：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">ll=&quot;Phantom Aria fruitless love&quot;</span><br><span class="line">echo $&#123;ll% *&#125;   # 从右往左匹配第一个空格，删除右边所有字符串</span><br><span class="line">echo $&#123;ll%% *&#125;  # 从右往左匹配所有空格，删除右边所有字符串</span><br><span class="line">echo $&#123;ll#* &#125;   # 从左往右匹配第一个空格，删除左边所有字符串</span><br><span class="line">echo $&#123;ll##* &#125;  # 从左往右匹配所有空格，删除左边所有字符串</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220420031440.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220420031440.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><div class="note "><p><strong></strong></p><p>*号是通配符，可以是匹配的任意长度任意字符串<br>%和%%匹配原则：都是从右到左匹配，删除右边，%%称为<strong>贪婪匹配</strong><br>#和##匹配原则：都是从左往右匹配，删除左边，##同样称为贪婪匹配，<strong>注意通配符位置</strong></p></div></div><h2 id="for循环语句"><a href="#for循环语句" class="headerlink" title="for循环语句"></a>for循环语句</h2><div class="story post-story"><p>for循环语句两种写法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for （(初始值；限制值；执行步阶)）    #注意两个小括号，少一个都不行</span><br><span class="line">do</span><br><span class="line">    程序段</span><br><span class="line">done</span><br><span class="line">或</span><br><span class="line">for 变量 in 1 2 3 4 5 6 7 8 9 10    #等价于`seq 1 10`</span><br><span class="line">do</span><br><span class="line">    程序段</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>vim建立脚本文件for_example.sh：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">declare -i sum=0        # 强制定义sum为整数型变量（不定义会变成一串字符串）</span><br><span class="line">read -p &quot;请输入整数&quot; n      # 标准输入定义变量n</span><br><span class="line">for (( i=0; i&lt;=$n; i++ ))   # 等同于for i in `seq 0 $n`，不赘述</span><br><span class="line">do</span><br><span class="line">    sum=$sum+$i     # 计算0到n之和</span><br><span class="line">done</span><br><span class="line">echo &quot;0到这个数的整数之和=$sum&quot;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220420022902.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220420022902.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div><h2 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h2><div class="story post-story"><p>vim建立脚本文件12345.sh：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">function formax()</span><br><span class="line">&#123;</span><br><span class="line">    if [ $n -gt $m ]; then</span><br><span class="line">        return $n</span><br><span class="line">    else</span><br><span class="line">        return $m</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line">read -p &quot;输入数值1：&quot; n</span><br><span class="line">read -p &quot;输入数值2：&quot; m</span><br><span class="line">formax $n $m</span><br><span class="line">echo &quot;输入的最大值为$?&quot; # $?表示上个指令的返回值</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220420034507.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220420034507.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>自定义了一个formax函数判断输入的两个数值大小，可以看出shell脚本中是一行一行读取指令的。自定义函数可以被引用，保存上述{}内的指令至原文件名12345.sh，在下一个脚本文件中，将函数放在脚本开始处， shell解释器发现它才可以进行调用（如下所示）</p><p>vim建立脚本文件test.sh：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">source 12345.sh</span><br><span class="line">read -p &quot;输入数值1：&quot; n</span><br><span class="line">read -p &quot;输入数值2：&quot; m</span><br><span class="line">formax $n $m</span><br><span class="line">echo &quot;输入的最大值为$?&quot;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220420035345.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220420035345.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>自定义函数被成功调用</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;简单记录下shell脚本语言的学习&lt;/p&gt;
&lt;h2 id=&quot;shell脚本运行方式&quot;&gt;&lt;a href=&quot;#shell脚本运行方式&quot; class=&quot;headerlink&quot; title=&quot;shell脚本运行方式&quot;&gt;&lt;/a&gt;shell脚本运行方式&lt;/h2&gt;&lt;div class=&quot;</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="shell脚本" scheme="http://www.shelven.com/tags/shell%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>转录组数据分析笔记（7）——DESeq2差异分析</title>
    <link href="http://www.shelven.com/2022/04/18/a.html"/>
    <id>http://www.shelven.com/2022/04/18/a.html</id>
    <published>2022-04-18T07:49:20.000Z</published>
    <updated>2022-04-18T15:32:11.286Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-代码示范"><a href="#1-代码示范" class="headerlink" title="1. 代码示范"></a>1. 代码示范</h2><div class="story post-story"><p>前面处理好raw count定量表达矩阵，建立样本列表矩阵后，我们就可以在rstudio里运行DESeq2包进行差异基因筛选了。代码如下。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">library<span class="punctuation">(</span><span class="string">&quot;DESeq2&quot;</span><span class="punctuation">)</span></span><br><span class="line">mycounts <span class="operator">&lt;-</span> read.csv<span class="punctuation">(</span><span class="string">&quot;transcript_count_matrix.csv&quot;</span><span class="punctuation">,</span>row.names <span class="operator">=</span> <span class="number">1</span><span class="punctuation">)</span></span><br><span class="line">mycounts_1 <span class="operator">&lt;-</span> mycounts<span class="punctuation">[</span>rowSums<span class="punctuation">(</span>mycounts<span class="punctuation">)</span> <span class="operator">!=</span> <span class="number">0</span><span class="punctuation">,</span><span class="punctuation">]</span> <span class="comment"># 重新定义数据集，过滤mapping数为0的基因</span></span><br><span class="line">mymeta <span class="operator">&lt;-</span> read.csv<span class="punctuation">(</span><span class="string">&quot;sample_list.csv&quot;</span><span class="punctuation">,</span>stringsAsFactors <span class="operator">=</span> <span class="built_in">T</span><span class="punctuation">)</span>  <span class="comment"># 载入样本分组文件，遇到字符串将其转化为因子</span></span><br><span class="line">colnames<span class="punctuation">(</span>mycounts_1<span class="punctuation">)</span> <span class="operator">==</span> mymeta<span class="operator">$</span>id   <span class="comment"># 检查导入的两个数据集是否匹配，返回值为F需要重新匹配</span></span><br><span class="line">mymeta<span class="operator">$</span>index <span class="operator">&lt;-</span> factor<span class="punctuation">(</span>mymeta<span class="operator">$</span>index<span class="punctuation">,</span>levels <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;0&quot;</span><span class="punctuation">,</span><span class="string">&quot;1&quot;</span><span class="punctuation">,</span><span class="string">&quot;2&quot;</span><span class="punctuation">,</span><span class="string">&quot;3&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span>    <span class="comment"># 把样本分组文件的分组列转换到因子，不然会报错</span></span><br><span class="line">dds <span class="operator">&lt;-</span> DESeqDataSetFromMatrix<span class="punctuation">(</span>countData <span class="operator">=</span> mycounts_1<span class="punctuation">,</span></span><br><span class="line">                              colData <span class="operator">=</span> mymeta<span class="punctuation">,</span></span><br><span class="line">                              design <span class="operator">=</span> <span class="operator">~</span>index<span class="punctuation">)</span>  <span class="comment">#构造用于差异表达分析的数据集</span></span><br><span class="line">dds <span class="operator">&lt;-</span> DESeq<span class="punctuation">(</span>dds<span class="punctuation">)</span></span><br><span class="line">res <span class="operator">&lt;-</span> results<span class="punctuation">(</span>dds<span class="punctuation">)</span></span><br><span class="line">res_1 <span class="operator">&lt;-</span> data.frame<span class="punctuation">(</span>res<span class="punctuation">)</span>    <span class="comment"># 结果res不是常规的数据，需要转化成数据框</span></span><br><span class="line">library<span class="punctuation">(</span><span class="string">&quot;dplyr&quot;</span><span class="punctuation">)</span></span><br><span class="line">res_1 <span class="operator">%&gt;%</span>   <span class="comment"># dplyr给数据集增加新列</span></span><br><span class="line">  mutate<span class="punctuation">(</span>group <span class="operator">=</span> case_when<span class="punctuation">(</span></span><br><span class="line">    log2FoldChange <span class="operator">&gt;=</span><span class="number">1</span> <span class="operator">&amp;</span> padj <span class="operator">&lt;=</span><span class="number">0.05</span> <span class="operator">~</span> <span class="string">&quot;UP&quot;</span><span class="punctuation">,</span></span><br><span class="line">    log2FoldChange <span class="operator">&lt;=</span><span class="operator">-</span><span class="number">1</span> <span class="operator">&amp;</span> padj <span class="operator">&lt;=</span><span class="number">0.05</span> <span class="operator">~</span> <span class="string">&quot;DOWN&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="literal">TRUE</span> <span class="operator">~</span> <span class="string">&quot;NOT_CHANGE&quot;</span></span><br><span class="line">  <span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">-&gt;</span> res_2</span><br><span class="line">table<span class="punctuation">(</span>res_2<span class="operator">$</span>group<span class="punctuation">)</span></span><br><span class="line">write.csv<span class="punctuation">(</span>res_2<span class="punctuation">,</span>file <span class="operator">=</span> <span class="string">&quot;all.csv&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="built_in">quote</span> <span class="operator">=</span> <span class="built_in">F</span><span class="punctuation">)</span>    <span class="comment"># 输出文件</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h2 id="2-代码详解"><a href="#2-代码详解" class="headerlink" title="2. 代码详解"></a>2. 代码详解</h2><div class="story post-story"><p>详细解释一下过程：</p><p>在R里运行程序或者写代码，首先要确定好工作目录在哪里，将之前Stringtie转化的定量表达矩阵和样本列表矩阵全都放在工作目录下，这里我的表达量矩阵是transcript_count_matrix.csv，分组列表矩阵是sample_list.csv。<code>getwd()</code>可以查看当前工作目录，在全局设置里可以更改工作目录。</p><p><code>library(&quot;DESeq2&quot;)</code>  # 加载DESeq2这个R包</p><p><code>mycounts &lt;- read.csv(&quot;transcript_count_matrix.csv&quot;,row.names = 1)</code> # 载入raw count矩阵，以第一行数据作为行名，读取的矩阵命名为mycounts</p><p><code>mycounts_1 &lt;- mycounts[rowSums(mycounts) != 0,]</code> # 过滤每一行mapping总数为0的基因，将数据集整理命名为mycounts_1</p><p><code>mymeta &lt;- read.csv(&quot;sample_list.csv&quot;,stringsAsFactors = T)</code> # 载入样品列表，遇到字符串将其转化为一个因子</p><p><code>colnames(mycounts_1) == mymeta$id</code> # 检查raw count矩阵第一行是否与样品列表的id列是否一致（如下）。<strong>这个很重要，不一致跑DESeq2会报错</strong>。如果显示false就要调整</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220418154725.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220418154725.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><code>mymeta$index &lt;- factor(mymeta$index,levels = c(&quot;0&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;))</code> # 这一步同样重要，把样本分组文件的分组列转换到因子，不然会报错。我这里的分组是第0天，第1天，第2天和第3天</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dds <span class="operator">&lt;-</span> DESeqDataSetFromMatrix<span class="punctuation">(</span>countData <span class="operator">=</span> mycounts_1<span class="punctuation">,</span></span><br><span class="line">                              colData <span class="operator">=</span> mymeta<span class="punctuation">,</span></span><br><span class="line">                              design <span class="operator">=</span> <span class="operator">~</span>index<span class="punctuation">)</span> </span><br></pre></td></tr></table></figure><p># 中间那一长串是DESeq2包里的函数，countData是raw count定量矩阵，colData是样品列表，design是分组信息，这步是为了<strong>构造</strong>用于差异表达分析的数据集，并将数据集命名为dds</p><p><code>dds &lt;- DESeq(dds)</code>  # <strong>分析的核心DESeq程序</strong></p><p><code>res &lt;- results(dds)</code> # 将结果输出至res数据集</p><p><code>res_1 &lt;- data.frame(res)</code>  # res不是常规的数据，我们可以用head和class命令查看一下（如下图），需要转化成常规的数据框格式才可以对其进行加减列等操作，转换格式后的数据集名字为res_1</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220418153006.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220418153006.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><code>library(&quot;dplyr&quot;)</code>  # 加载这个包是为了对数据框进行操作，我是要增加新的一列统计差异表达情况</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">res_1 <span class="operator">%&gt;%</span>   </span><br><span class="line">  mutate<span class="punctuation">(</span>group <span class="operator">=</span> case_when<span class="punctuation">(</span></span><br><span class="line">    log2FoldChange <span class="operator">&gt;=</span><span class="number">1</span> <span class="operator">&amp;</span> padj <span class="operator">&lt;=</span><span class="number">0.05</span> <span class="operator">~</span> <span class="string">&quot;UP&quot;</span><span class="punctuation">,</span></span><br><span class="line">    log2FoldChange <span class="operator">&lt;=</span><span class="operator">-</span><span class="number">1</span> <span class="operator">&amp;</span> padj <span class="operator">&lt;=</span><span class="number">0.05</span> <span class="operator">~</span> <span class="string">&quot;DOWN&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="literal">TRUE</span> <span class="operator">~</span> <span class="string">&quot;NOT_CHANGE&quot;</span></span><br><span class="line">  <span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">-&gt;</span> res_2</span><br></pre></td></tr></table></figure><p># 调用dplyr包给数据集增加新的一列group，<strong>log2FoldChange &gt;&#x3D;1，padj &lt;&#x3D;0.05，判断这个基因表达为上调，在log2FoldChange &lt;&#x3D;-1，padj &lt;&#x3D;0.05时判断这个基因表达为下调，其余情况为该基因表达情况不变。</strong>将结果输出到res_2数据集。</p><p>FoldChange表示两样品间表达量比值，是倍数变化，差异表达基因分析里，log2 fold change绝对值大于1为差异基因筛选标准。padj是调整后的p值，在p检验里，p值小于0.05是有显著差异的标志。</p><p><code>table(res_2$group)</code> # 查看差异基因表达的结果，上调基因多少，下调基因有多少，不变的有多少</p><p><code>write.csv(res_2,file = &quot;all.csv&quot;, quote = F)</code> # 输出和生成all.csv文件，即为结果文件</p><p>我分别对转录本和基因都运行了DESeq2包做差异分析，</p><p>转录本差异分析如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220418153406.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220418153406.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>基因差异分析如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220418154154.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220418154154.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>基因差异表达情况可以看到，有173个基因表达下调，259个基因表达上调；转录本差异表达情况可以看到，336个上调表达，458个下调表达，数量不一致的情况是因为一个基因中存在多个转录本。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-代码示范&quot;&gt;&lt;a href=&quot;#1-代码示范&quot; class=&quot;headerlink&quot; title=&quot;1. 代码示范&quot;&gt;&lt;/a&gt;1. 代码示范&lt;/h2&gt;&lt;div class=&quot;story post-story&quot;&gt;&lt;p&gt;前面处理好raw count定量表达矩阵，建</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="转录组数据分析" scheme="http://www.shelven.com/categories/%E8%BD%AC%E5%BD%95%E7%BB%84%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
    <category term="DESeq2" scheme="http://www.shelven.com/tags/DESeq2/"/>
    
  </entry>
  
  <entry>
    <title>转录组数据分析笔记（6）——HTseq计数定量</title>
    <link href="http://www.shelven.com/2022/04/17/b.html"/>
    <id>http://www.shelven.com/2022/04/17/b.html</id>
    <published>2022-04-17T15:49:37.000Z</published>
    <updated>2022-04-19T17:06:13.683Z</updated>
    
    <content type="html"><![CDATA[<p>HTseq也是对有参考基因组转录数据进行表达量分析的，主要用于reads计数。这个软件功能就比较专一，不像stringtie还需要运行prepDE.py脚本进行数据转化，直接一步到位。那为什么我一开始不用HTseq呢？<del>因为我遇到一个bug</del> 主要还是运算速度的问题，我比较了两种定量方式，HTseq定量虽然只有一步，但是速度远不如stringtie，也可能是我的问题，下面会说到。</p><h2 id="1-HTseq定量获得raw-count"><a href="#1-HTseq定量获得raw-count" class="headerlink" title="1. HTseq定量获得raw count"></a>1. HTseq定量获得raw count</h2><div class="story post-story"><p>vim一个新脚本，输入如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">for i in `seq 194 209`</span><br><span class="line">do </span><br><span class="line">    htseq-count -f bam -s no \</span><br><span class="line">    /media/sf_/data/fastq/bam/ERR1698&quot;$i&quot;.bam \     # 输入bam文件</span><br><span class="line">    /media/sf_/data/ref/Arabidopis_thaliana.gtf     # 参考基因组注释文件</span><br><span class="line">    &gt; /media/sf_/data/fastq/count/ERR1698&quot;$i&quot;.count     # 自定义输出文件</span><br><span class="line">done</span><br></pre></td></tr></table></figure><div class="note "><p><strong>参数详解</strong></p><p>-f  # 设置输入文件格式，可以是bam或者sam<br>-s  # 设置是否是链特异性测序，设置no每一条reads都会和正义链和反义链进行比较</p></div><p>保存运行以后发现这个程序只能分配一个线程（也可能是我没找到分线程的方法），所以可以根据电脑内核数分几个批处理一起运行会快很多（不然就等着干瞪眼&#x3D; &#x3D;）。</p><p>还有一点非常重要！<strong>bam文件需要提前按照名称排序</strong>，不然会出现绝大部分reads mapping不到参考基因组，这种情况会在屏幕上输出提示信息，但是程序还是会继续跑……这时候就别犹豫了赶紧kill这个程序，就算跑完了数据都不能用。可以用<strong>samtools sort -n</strong>对bam文件进行名称排序，但是排序之后<strong>无法再用samtools index建立索引文件</strong>，这会导致HTseq运行速度比蜗牛还慢。暂时没找到更好的办法 <del>摊手</del>。</p><p>经过漫长长长长长的时间等待，我们可以看看结果文件的head和tail（这里就放一张图吧）：</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220417235405.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220417235405.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>前面记录了基因名称和mapping上的reads数，最后5行对应不同的mapping情况，在不同的模式下意义不同，官网给出的区别如下图，默认是union模式：</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220417235652.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220417235652.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>计数结果也可以用multiqc合并，生成在线报告，这里可以直观地看到每个样品比对上的reads数百分比，这里16个样品的比对率都超过<emp>80%</emp>，说明计数结果都还不错。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220418005645.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220418005645.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div><h2 id="2-HTseq结果文件处理"><a href="#2-HTseq结果文件处理" class="headerlink" title="2. HTseq结果文件处理"></a>2. HTseq结果文件处理</h2><div class="story post-story"><p>HTseq计数定量后得到的是每一个样品的每个基因reads数，我们需要合并每个样品定量数据，<strong>手动修改成DESeq2能识别的raw count表达矩阵，还需要再准备一个样本列表矩阵</strong>，才能进行后续的DESeq分析。参考一下stringtie最后生成的表达量矩阵文件，我们也需要将HTseq定量结果整理成csv格式（逗号作为分隔符），第一列是基因名，后面是按照样品序列的排序，中间是表达矩阵。</p><p>再来看一看HTseq定量生成的文件详情，同样第一列是基因名，后面是raw count数量，^I 表示两列数据是以制表符tab键分隔的，$为换行符。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220418013441.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220418013441.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>我的方法比较笨比，除第一个ERR1698194.count文件保留外，其他所有count文件第一列删去并命名为cut.count，然后合并ERR1698194.count和其他所有cut.count文件，再将所有的制表符替换为逗号，最后加上第一行行名和改文件名。</p><p>用awk命令删除第一列，写入到新的cut.count文件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for i in `seq 195 209`</span><br><span class="line">do </span><br><span class="line">    cat ERR1698&quot;$i&quot;.count | awk &#x27;&#123;$1 = &quot;&quot;; print $0&#125;&#x27; &gt; ERR1698&quot;$i&quot;cut.count</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>paste组合ERR1698194样品和其他cut.count文件到alldata.count:</p><p><code>$ paste ERR1698194.count *cut.count &gt; alldata.count</code></p><p>看看alldata.count的数据格式，列数没有问题，但是awk删除列产生了空格：</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220418014618.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220418014618.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>用sed命令删除所有空格，替换所有制表符为逗号（两步可以合一步）：</p><p><code>$ sed &#39;s/ //g&#39; alldata.count &gt; alldata1.count</code></p><p><code>$ sed &#39;s/\t/,/g&#39; alldata1.count &gt; alldata2.count</code></p><p>这样就手动生成符合csv格式的文件了，只需加上第一行：</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220418014916.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220418014916.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>这里样本量比较少，我直接vim复制粘贴的方法加了第一行，重命名一下文件就完成了表达矩阵的制作，可以用于DESeq2分析了！</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220418014948.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220418014948.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>因为本人比较小白，上面处理过程就有些啰嗦了，总的思路就是改成csv格式文件的样式就可以。</p><p>样本列表矩阵的制作过程和stringtie一模一样，<a href="https://www.shelven.com/2022/04/17/a.html">点击这里查看</a>，本篇不再赘述。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;HTseq也是对有参考基因组转录数据进行表达量分析的，主要用于reads计数。这个软件功能就比较专一，不像stringtie还需要运行prepDE.py脚本进行数据转化，直接一步到位。那为什么我一开始不用HTseq呢？&lt;del&gt;因为我遇到一个bug&lt;/del&gt; 主要还是运算</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="转录组数据分析" scheme="http://www.shelven.com/categories/%E8%BD%AC%E5%BD%95%E7%BB%84%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
    <category term="HTseq" scheme="http://www.shelven.com/tags/HTseq/"/>
    
  </entry>
  
  <entry>
    <title>转录组数据分析笔记（5）——stringtie转录本组装和定量</title>
    <link href="http://www.shelven.com/2022/04/17/a.html"/>
    <id>http://www.shelven.com/2022/04/17/a.html</id>
    <published>2022-04-17T15:14:21.000Z</published>
    <updated>2022-04-19T17:05:56.688Z</updated>
    
    <content type="html"><![CDATA[<h2 id="stringtie转录本组装和定量"><a href="#stringtie转录本组装和定量" class="headerlink" title="stringtie转录本组装和定量"></a>stringtie转录本组装和定量</h2><div class="story post-story"><h3 id="1-转录本组装"><a href="#1-转录本组装" class="headerlink" title="1 转录本组装"></a>1 转录本组装</h3><p>Stringtie是一个基因和转录本组装定量的软件，stringtie的输入文件有两个，一个是经过<strong>排序</strong>的bam文件，排序可以用前面说到的samtools sort命令完成，还有一个是参考基因组的注释文件（gff或gtf格式）。</p><p>在使用Stringtie进行基因或者转录本组装定量的过程中，有一个非常重要的参数 <strong>- e</strong>，我之前跑了一遍流程没有加参数-e，结果组装的结果非常差，还有大量的未注释的基因。我请教了度娘，网上的教程攻略也都是抄来抄去的没解决什么问题，官网只有这么一句解释：</p><blockquote><p>-e    this option directs StringTie to operate in expression estimation mode; this limits the processing of read alignments to estimating the coverage of the transcripts given with the <code>-G</code> option (hence this option requires <code>-G</code>).</p></blockquote><p>对于加了参数-e之后如何做的比对和组装处理还是不明了，不知道表达评估模式的原理是什么，只能自己做个大概的总结（不知正确与否）：</p><div class="note "><p><strong></strong></p><ol><li>如果我们研究的样本没有很好的注释信息，研究的人少，现有的注释信息都不完善，那么我们就需要重建转录本进行注释，这个时候就不需要加参数-e。</li><li>如果样品的注释信息非常完整，比如拟南芥这种模式生物，我们不需要重建新的转录本进行注释，只对现有的参考基因组注释文件就足够了，那就要用-e参数，不需要预测新的转录本。</div></li></ol><p>-e参数还有个比较重要的地方，<strong>只有用了-e参数后，才可以运行prepDE.py3脚本得到read count矩阵</strong>（也就是进行定量），这个脚本后面会说。</p><hr><p>我们首先创建一个shell脚本进行转录本组装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">for i in `seq 194 209`</span><br><span class="line">do</span><br><span class="line">    stringtie -p 4 -e \</span><br><span class="line">    -G /media/sf_/data/ref/Arabidopis_thaliana.gtf \    # 参考基因组注释文件</span><br><span class="line">    -o /media/sf_/data/fastq/gtf/ERR1698&quot;$i&quot;.gtf \      # 自定义输出文件</span><br><span class="line">    /media/sf_/data/fastq/bam/ERR1698&quot;$i&quot;.bam   # 输入的bam文件</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>保存，运行，我们可以得到.gtf格式文件，less一下查看里面的内容：</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/QQ%E6%88%AA%E5%9B%BE20220417215153.jpg" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/QQ%E6%88%AA%E5%9B%BE20220417215153.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>我们这里因为加了参数-e，不会有新的基因和转录本，可以看到每个read比对上的基因的信息。（不加参数-e会组装<strong>新基因和转录本</strong>，默认采用STRG加数字编号进行区分）。每行数据会给出<strong>coverage</strong>，<strong>FPKM</strong>和<strong>TPM</strong>三个信息，后两者都可以用来定量。FPKM和TPM都是对read counts数目进行的标准化，如果是单端测序数据可以用RPKM进行标准化，不进行数据标准化的比较是没有意义的。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/ethwtjyj.jpg" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/ethwtjyj.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/%E6%96%87gnwn%E5%8C%96%E4%B8%BA.jpg" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/%E6%96%87gnwn%E5%8C%96%E4%B8%BA.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/%E6%B8%B8%E5%AE%A2%E4%BD%93sfns%E9%AA%8C%E7%9C%8B%E5%9B%BE.jpg" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/%E6%B8%B8%E5%AE%A2%E4%BD%93sfns%E9%AA%8C%E7%9C%8B%E5%9B%BE.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><hr><h3 id="2-合并转录本-重构转录本才需要"><a href="#2-合并转录本-重构转录本才需要" class="headerlink" title="2 合并转录本(重构转录本才需要)"></a>2 合并转录本(重构转录本才需要)</h3><p>这一步要注意下，如果需要重构转录本才需要<strong>合并</strong>所有的转录本的组装结果，得到一个非冗余的转录本合集，也就是获得跨多个RNA-seq样品的全局的转录本。这里需要分两步：</p><p><code>$ ls *.gtf &gt; mergelist.txt     # 将所有组装的转录本文件名合并到一个文件</code></p><p><code>$ stringtie --merge -p 4 -G /media/sf_/data/ref/Arabidopis_thaliana.gtf -o merge.gtf ./mergelist.txt   #这一步是用--merge指令将所有转录本合并输出到merge.gtf文件中</code></p><p>我们最后得到的merge.gtf就是全局的转录本。这里只是记录一下这步操作，我们只关注参考基因组的注释结果就不需要merge。</p><hr><h3 id="3-获得定量表达矩阵"><a href="#3-获得定量表达矩阵" class="headerlink" title="3 获得定量表达矩阵"></a>3 获得定量表达矩阵</h3><p>DESeq2要求输入的定量结果为raw count形式，raw count是根据mapping到基因或转录本的reads数计算得到，而stringtie只提供了转录本水平的表达量，定量方式包括TPM和FPKM值两种。为了进行raw count定量，stringtie官方提供了prepDE.py脚本（两个版本，我选择的python 3版本，在我base环境下不会冲突），可以计算出raw count的表达量。</p><p>下载这个python脚本，如果你用的是windows浏览器，在官网找到脚本直接右键复制链接，用wget直接下到linux系统里，<strong>千万不要在windows上直接复制粘贴代码过去</strong>。因为windows的换行符和linux的不一样，两个系统间直接粘贴代码会出现错行和莫名其妙的缩进导致程序报错（可以用cat -A看两个系统换行符的区别，血的教训，排查了老半天才发现）推荐用prepDE.py3，不用再切python 2 的环境了。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/stjssjrsjjjjs.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/stjssjrsjjjjs.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>官方给出的prepDE.py脚本有两种运行方式（如下图所示），一种是建立Ballgown能识别的目录结构，一种是建立sample_lst文件并指定所有样品数据的路径。两种方法都可行，Ballgown现在用的比较少，比较主流的还是Stringtie+DESeq2的分析方法。演示一下如何创建sample_lst和解释一下这个文件要求的格式。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/46uij.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/46uij.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="3-1-sample-lst文件准备"><a href="#3-1-sample-lst文件准备" class="headerlink" title="3.1 sample_lst文件准备"></a>3.1 sample_lst文件准备</h4><p>简单来说，sample_lst.txt要求第一列为样品编号，第二列为对应编号的样品gtf文件所在路径，中间用<strong>制表符tab</strong>隔开，如下图（命名不一定要完全一样，注意格式，后面要导入prepDE脚本，能找到就行）：</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220418211607.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220418211607.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>这个文件准备工作比较简单，不再赘述</p><h4 id="3-2-运行prepDE-py3"><a href="#3-2-运行prepDE-py3" class="headerlink" title="3.2 运行prepDE.py3"></a>3.2 运行prepDE.py3</h4><p>将prepDE.py3脚本放在上面gtf文件的目录下，运行以下命令：</p><p><code>$ python prepDE.py3 -i sample_lst.txt -g gene_count_matrix.csv -t transcript_count_matrix.csv</code></p><p>解释一下：</p><div class="note "><p><strong>参数含义</strong></p><p>-i  # 输入文件，就是前面做的sample_lst.txt<br>-g  # 自定义基因组表达矩阵名字，默认也是gene_count_matrix.csv<br>-t  # 自定义转录本表达矩阵名字，默认也是transcript_count_matrix.csv</p></div><p>得到的这两个文件就是基因和转录水平的raw count表达量矩阵，我们都可以用于后面的DESeq2分析。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220417225037.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220417225037.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><hr></div><h2 id="4-制作样本列表矩阵"><a href="#4-制作样本列表矩阵" class="headerlink" title="4. 制作样本列表矩阵"></a>4. 制作样本列表矩阵</h2><div class="story post-story"><p>这里需要和前面为了运行prepDE.py脚本而制作的sample_lst文件区分开，要做下一步DESeq2差异基因分析，我们需要自己手动创建一个DESeq2能识别的样本列表矩阵，包含两列信息：一列是样本名称，一列是样本分组。样本分组信息我们可以直接从下载样本数据的地方（EBI官网）得到，只需要自己改一下格式。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220417225800.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220417225800.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>下载之后发现第一行标题特别长，稍微处理下制表符替换成换行符，将第一行标题拆分成每个字段一行的格式，找一下不同天数处理的分组信息关键字“time”，发现我们要的分组信息在第36行（也就是原来文件的第36列）：</p><p><code>$ head -n1 E-MTAB-5130.sdrf.txt | tr &#39;\t&#39; &#39;\n&#39; | nl | grep &quot;time&quot;</code></p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220417225856.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220417225856.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>同样的方法找样本信息所在列是32列：</p><p><code>$ head -n1 E-MTAB-5130.sdrf.txt | tr &#39;\t&#39; &#39;\n&#39; | nl | grep &quot;ENA&quot;</code></p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220417225952.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220417225952.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>所以我们需要提取第32列和第36列，用cut命令切割并重定向到新的文件sample_list:</p><p><code>$ cut -f 32,36 E-MTAB-5130.sdrf.txt &gt; sample_list.csv</code></p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220417230231.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220417230231.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>发现相邻数据有重复，uniq删除重复行，再用sed替换制表符为逗号（因为csv文件就是以逗号作为分隔符），将原来的sample_list.csv覆盖，vim手动修改一下第一行名字，完成后就可以用于DESeq2分析了！</p><p><code>$ uniq sample_list.csv &gt; sample_list1.csv  # uniq删除重复行</code></p><p><code>$ sed &#39;s/\t/,/g&#39; sample_list1.csv &gt; sample_list .csv   # 替换制表符为逗号</code></p><p>手动修改sample_list .csv第一行内容，修改之后如下即可</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220417231146.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/20220417231146.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;stringtie转录本组装和定量&quot;&gt;&lt;a href=&quot;#stringtie转录本组装和定量&quot; class=&quot;headerlink&quot; title=&quot;stringtie转录本组装和定量&quot;&gt;&lt;/a&gt;stringtie转录本组装和定量&lt;/h2&gt;&lt;div class=&quot;s</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="转录组数据分析" scheme="http://www.shelven.com/categories/%E8%BD%AC%E5%BD%95%E7%BB%84%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
    <category term="stringtie" scheme="http://www.shelven.com/tags/stringtie/"/>
    
    <category term="prepDE.py3" scheme="http://www.shelven.com/tags/prepDE-py3/"/>
    
  </entry>
  
  <entry>
    <title>转录组数据分析笔记（4）——IGV基因组浏览器安装和解读</title>
    <link href="http://www.shelven.com/2022/04/16/b.html"/>
    <id>http://www.shelven.com/2022/04/16/b.html</id>
    <published>2022-04-16T11:32:50.000Z</published>
    <updated>2022-04-16T11:37:33.011Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-IGV软件下载"><a href="#1-IGV软件下载" class="headerlink" title="1. IGV软件下载"></a>1. IGV软件下载</h2><div class="story post-story"><p>IGV（Integrative Genomics Viewer）是一个非常方便的比对软件，在使用前只需要将参考基因组和bam文件分别建立索引（即建立fai和bai文件）并载入，就可以对转录组测序数据进行可视化浏览。对比samtools tview功能，这个软件有交互式操作界面，对萌新非常友好。</p><p>直接上百度搜就能找到IGV官网，选择linux版本或者windows版本都行，这里用linux版本为例，IGV只支持JAVA11版本，不用担心这个问题，下载的安装包里直接有JAVA11，解压就可以用，就是国外网站下载有点慢<del>（科学上网）</del>。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/%E7%87%83%E7%83%A7%E5%86%9B%E5%9B%A2%E6%98%AF.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/%E7%87%83%E7%83%A7%E5%86%9B%E5%9B%A2%E6%98%AF.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>直接在虚拟机里解压打开，运行igv.sh，会自动准备好JAVA11的运行环境，成功弹出交互式界面（终于告别了黑漆漆的命令行 <span><img src='https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/tieba/%E6%BB%91%E7%A8%BD.png' style='height:24px'></span>）。</p></div><h2 id="2-导入文件"><a href="#2-导入文件" class="headerlink" title="2. 导入文件"></a>2. 导入文件</h2><div class="story post-story"><p>Genomes菜单栏上传<strong>建立索引</strong>的参考基因组.fa和.fai文件：</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/%E6%96%87%E5%8C%96%E4%B8%BA.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/%E6%96%87%E5%8C%96%E4%B8%BA.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><hr><p>File菜单栏上传<strong>排序并建立索引</strong>的.bam和.bai文件：</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/45645%E5%92%8C.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/45645%E5%92%8C.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><hr><p>如果有参考基因组注释文件，同样可以导入进去，同样导入前需要sort排序和建立index，可以用菜单栏里的igvtools直接sort和index：</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/%E4%BA%BA%E5%BE%88%E5%B0%91.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/%E4%BA%BA%E5%BE%88%E5%B0%91.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div><h2 id="3-界面解读"><a href="#3-界面解读" class="headerlink" title="3. 界面解读"></a>3. 界面解读</h2><div class="story post-story"><p>我导入了5组bam数据，所有文件导入后可以看到如下界面，简单介绍一下各个区域和功能：</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/%E4%BA%8C%E7%BA%A7%E5%90%88%E5%90%8C%E9%87%91%E9%A2%9D%E5%95%8A.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/%E4%BA%8C%E7%BA%A7%E5%90%88%E5%90%8C%E9%87%91%E9%A2%9D%E5%95%8A.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><hr><p>主页面获得的信息有限，我们选取第3条染色体为例，将其放大：</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/35724575.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/35724575.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><hr><p>中间的界面可以通过左右拖动鼠标，或者按左右方向键来浏览染色体上的比对情况。我们在搜索框中直接搜基因名字进行染色体定位，比如CIPK家族中的CIPK7基因，回车后双击最后一栏基因注释文件中的基因名称CIPK7，可以得到详细的CIPK7基因信息<strong>（这里注意下，如果双击弹出来多个可供选择的片段的话，代表这个基因存在可变剪切）</strong>:</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/4362436%E5%85%B67.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/4362436%E5%85%B67.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><hr><p>在基因注释区右键，选择expanded，可以将CIPK7基因的所有转录本显示出来。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/3472572.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/3472572.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><hr><p>放大到一定程度后，我们可以看到基因注释区上方出现了核苷酸序列和氨基酸序列，我们可以点击sequence旁边的箭头，切换到另一条链的序列。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/%E5%91%B5%E5%91%B5%E5%95%8A.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/%E5%91%B5%E5%91%B5%E5%95%8A.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><hr><p>点击核苷酸，会出现三行，分别表示不同起始位点的核苷酸翻译结果，绿色为起始密码子，红色的星号表示终止密码子。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/4365486795.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/4365486795.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><hr><p>再来看看放大后的tracks区域，bam文件在载入后会默认生成两个tracks，一个显示测序深度（<strong>Coverage track</strong>，可以对比下<u>samtools depth</u>），一个显示比对情况（<strong>Alignment track</strong>），我们放大其中一个样本的数据信息。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/11122333.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/11122333.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>Coverage track区域灰色代表质量好，如果reads中某核苷酸与参考序列超过20%不一致的时候，IGV会根据四个碱基的计数对coverage的条形图进行着色。这里可以看到该位点处有20个reads覆盖到，8条reads测的是C核苷酸，12条reads测的是T核苷酸。如果某个位置coverage条形图只有一种颜色，即该位点测的核苷酸和参考序列完全不一样，那说明该位点是<span class='p red'>SNP位点</span>。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/%E7%81%AF%E5%85%89%E8%BE%83%E6%9A%97%E7%9A%84%E6%84%9F%E8%A7%89%E5%95%8A.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/%E7%81%AF%E5%85%89%E8%BE%83%E6%9A%97%E7%9A%84%E6%84%9F%E8%A7%89%E5%95%8A.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><hr><p>Alignment tracks柱形图是和bam文件中的数据一一对应的，举个例子，我在IGV软件的ERR1698206.bam可以看到在第3条染色体位置8173028有3条reads。虚拟机中找到这个bam文件，直接samtools view查看并grep这个位置，可以找到3条定位的reads（还有三条是配对的另一条链）。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/QQ%E6%88%AA%E5%9B%BE20220416192308.jpg" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/QQ%E6%88%AA%E5%9B%BE20220416192308.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><hr><p>如果一条reads中间有缺失，IGV会用黑色横杠表示，中间数字表示缺失几个核苷酸。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/%E5%95%8A%E5%95%8A%E5%95%8A%E5%95%8A%E5%95%8A%E5%95%8A%E5%95%8A%E9%98%BF%E4%B8%89%E5%A3%AB%E5%A4%A7%E5%A4%AB%E5%B1%B1%E8%B1%86%E6%A0%B9.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/%E5%95%8A%E5%95%8A%E5%95%8A%E5%95%8A%E5%95%8A%E5%95%8A%E5%95%8A%E9%98%BF%E4%B8%89%E5%A3%AB%E5%A4%A7%E5%A4%AB%E5%B1%B1%E8%B1%86%E6%A0%B9.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><hr><p>IGV还用不同颜色标记异常的插入片段大小的reads，这里做的是RNA-seq数据比对，不用看reads颜色，有些reads还在质控的时候被裁短了，变成蓝色很正常（<u>因为比预期短，个人理解是这样，有待考证？</u>）。以下是官网的默认着色方案：</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/a1029731a0e61326140cb74b369fc3fb.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/a1029731a0e61326140cb74b369fc3fb.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-IGV软件下载&quot;&gt;&lt;a href=&quot;#1-IGV软件下载&quot; class=&quot;headerlink&quot; title=&quot;1. IGV软件下载&quot;&gt;&lt;/a&gt;1. IGV软件下载&lt;/h2&gt;&lt;div class=&quot;story post-story&quot;&gt;&lt;p&gt;IGV（Integr</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="转录组数据分析" scheme="http://www.shelven.com/categories/%E8%BD%AC%E5%BD%95%E7%BB%84%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
    <category term="IGV" scheme="http://www.shelven.com/tags/IGV/"/>
    
  </entry>
  
  <entry>
    <title>转录组数据分析笔记（3）——samtools用法小结</title>
    <link href="http://www.shelven.com/2022/04/16/a.html"/>
    <id>http://www.shelven.com/2022/04/16/a.html</id>
    <published>2022-04-16T10:41:24.000Z</published>
    <updated>2022-04-20T08:15:24.059Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-sam文件转化bam"><a href="#1-sam文件转化bam" class="headerlink" title="1. sam文件转化bam"></a>1. sam文件转化bam</h2><div class="story post-story"><p>bam文件是二进制文件，占用磁盘空间小，运算速度快，samtools操作是针对bam文件的，所以我们要进行数据转化。samtools sort指令可以将bam文件进行排序，这个指令同时也可以将sam文件转化成bam文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">ls *.sam | while read id</span><br><span class="line">do</span><br><span class="line">    samtools sort -l 0 -@ 5 -o $(basename $id &quot;.sam&quot;).bam $id     # 指定输出文件，改后缀.bam</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>运行脚本，将当前目录的sam文件全转换成bam文件并排序（<strong>这里的排序不是按名称，用HTseq还要再按照read名称排序，使用参数-n）</strong>。</p><div class="note "><p><strong>samtools sort参数</strong></p><p>samtools sort   # 对bam文件进行排序（sam文件排序不会变）<br>-l  # 设置输出文件压缩等级，0-9，0是不压缩,9是最高等级压缩<br>-@  # 设置线程数<br>-o  # 设置排序后输出的文件名<br>最后接输入的bam或者sam格式文件</p></div></div><h2 id="2-构建索引文件"><a href="#2-构建索引文件" class="headerlink" title="2. 构建索引文件"></a>2. 构建索引文件</h2><div class="story post-story"><h3 id="2-1-构建bam文件索引"><a href="#2-1-构建bam文件索引" class="headerlink" title="2.1 构建bam文件索引"></a>2.1 构建bam文件索引</h3><p>在bam文件目录下，<strong>排序后</strong>的bam文件可以建立索引：</p><p><code>$ ls *.bam | xargs -i samtools index &#123;&#125;</code></p><p>注意下xargs -i的用法，和管道不一样，是传递参数给后一个命令的花括号中，后一个命令中不存在歧义的时候可省略参数-i和花括号。</p><p>如图生成的bai文件就是索引文件。其实到了这一步，前面的sam文件就可以删除（节省电脑空间），只留下bam文件就行，bam文件无法直接查看，可以通过samtools view命令查看bam文件。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/QQ%E6%88%AA%E5%9B%BE20220416174957.jpg" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/QQ%E6%88%AA%E5%9B%BE20220416174957.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="2-2-构建参考基因组fa文件索引"><a href="#2-2-构建参考基因组fa文件索引" class="headerlink" title="2.2 构建参考基因组fa文件索引"></a>2.2 构建参考基因组fa文件索引</h3><p>在参考基因组文件目录下，对参考基因组的fa文件建立索引：</p><p><code>$ samtools faidx Arabidopsis_thaliana.dna.genome.fa</code></p><p>参考基因组文件名注意改成自己的，生成的索引文件是.fai结尾的</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/QQ%E6%88%AA%E5%9B%BE20220416180041.jpg" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/QQ%E6%88%AA%E5%9B%BE20220416180041.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div><h2 id="3-bam文件qc质控"><a href="#3-bam文件qc质控" class="headerlink" title="3. bam文件qc质控"></a>3. bam文件qc质控</h2><div class="story post-story"><p>samtools转化生成的bam文件需要进行质控，看看比对情况如何。在bam文件目录下，我们创建一个samtools自带qc质控指令samtools flagstat运行脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">ls *.bam | while read id</span><br><span class="line">do</span><br><span class="line">    samtools flagstat -@ 4 $id &gt; $(basename $id &quot;.bam&quot;).flagstat     # 自定义输出文件</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p><code>$ samtools flagstat bam文件 &gt; 输出文件     # 这种格式，其他参数都一样</code> </p><p>运行脚本文件可以获得16个.flagstat质控文件，和fastqc一样，我们还可以做完后用multiqc命令集合成一个html格式的总的qc报告网页。和fastqc不同之处是，fastqc是做下机数据质控，samtools是做比对参考基因组的质控。如下图所示，可以比较直观地看出大部分reads都是map上的。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/%E5%B7%A5%E5%95%86%E9%87%91%E8%9E%8D%E7%95%8C.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/%E5%B7%A5%E5%95%86%E9%87%91%E8%9E%8D%E7%95%8C.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>生成的每一个flagstat文件我们也可以直接点开。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/QQ%E6%88%AA%E5%9B%BE20220416181848.jpg" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/QQ%E6%88%AA%E5%9B%BE20220416181848.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>每一行统计数据都是以通过QC的reads数量和未通过QC的reads数量组成，以我点开的这个文件为例，主要信息有以下几个：</p><div class="note "><p><strong></strong></p><p>13992629个reads都是合格的<br>12328290个reads只比对到参考基因组一个位置上<br>13988737个reads比对到参考基因组（99.97%）<br>12332182个reads是成对的<br>12201338个reads可以正确配对（98.94%）<br>2846条reads成对但只有一条能比对上参考基因组<br>12398个配对的reads可以比对到别的染色体上</p></div><p>可以自己将所有的flagstat运行结束后的文件放在一个目录下，运用paste命令全部按列粘贴在一起，用cut或者awk提取所需的列数据自己做比对情况表格，这里不再赘述。</p></div><h2 id="4-samtools其他指令"><a href="#4-samtools其他指令" class="headerlink" title="4. samtools其他指令"></a>4. samtools其他指令</h2><div class="story post-story"><p>简单介绍一下：</p><p><code>$ samtools view ERR1698194.bam     #查看bam文件（不能直接cat查看二进制文件）</code></p><p><code>$ samtools tview ERR1698194.bam    #类似于IGV这种基因组浏览器，但是非交互式界面（下图）不直观，我们一般都是用IGV查看基因组</code></p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/QQ%E6%88%AA%E5%9B%BE20220416182944.jpg" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/QQ%E6%88%AA%E5%9B%BE20220416182944.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>其他还有samtools merge（合并所有bam文件到一个文件），samtools depth（得到每个碱基位点或者区域的测序深度,并输出到标准输出）等等，不是特别常用，这里就不介绍了。</p><p>在步骤2中构建的索引文件可以导入IGV中，对转录组每个read mapping情况进行可视化浏览，下个笔记将介绍IGV的用法。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-sam文件转化bam&quot;&gt;&lt;a href=&quot;#1-sam文件转化bam&quot; class=&quot;headerlink&quot; title=&quot;1. sam文件转化bam&quot;&gt;&lt;/a&gt;1. sam文件转化bam&lt;/h2&gt;&lt;div class=&quot;story post-story&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="转录组数据分析" scheme="http://www.shelven.com/categories/%E8%BD%AC%E5%BD%95%E7%BB%84%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
    <category term="samtools" scheme="http://www.shelven.com/tags/samtools/"/>
    
  </entry>
  
  <entry>
    <title>转录组数据分析笔记（2）——使用Hisat2比对参考基因组</title>
    <link href="http://www.shelven.com/2022/04/15/a.html"/>
    <id>http://www.shelven.com/2022/04/15/a.html</id>
    <published>2022-04-15T08:53:41.000Z</published>
    <updated>2022-04-19T17:04:40.287Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-建立参考基因组索引"><a href="#1-建立参考基因组索引" class="headerlink" title="1. 建立参考基因组索引"></a>1. 建立参考基因组索引</h2><div class="story post-story"><p>在进行clean data与参考基因组比对之前，我们需要先建立参考基因组索引。进入下载好参考基因组的文件目录下，运行命令：</p><p><code>$ hisat2-build Arabidopsis_thaliana.dna.genome.fa genome</code></p><div class="note info"><p>-p # 以几个线程运行，与电脑核数或者分配虚拟机的核数有关<br >genome # 命名的索引文件名，可以改成自己能找到的</p></div><p>就可以在当前目录建立参考基因组索引文件，hisat2固定会生成8个以.ht2做后缀名的索引文件，如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/QQ%E6%88%AA%E5%9B%BE2022dhkdk041tweaaeheqhh.jpg" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/QQ%E6%88%AA%E5%9B%BE2022dhkdk041tweaaeheqhh.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>需要注意的一点，比对软件除了hiasat2以外，还有subjunk、bwa、bowtie2等等，<strong>各个比对软件生成的索引文件是不同的</strong>，不能相互混用，命名的时候注意区分各种比对工具。</p></div><h2 id="2-clean-data与参考基因组比对"><a href="#2-clean-data与参考基因组比对" class="headerlink" title="2. clean data与参考基因组比对"></a>2. clean data与参考基因组比对</h2><div class="story post-story"><p>比对的意思是将每一个read与参考基因组序列进行对比，目的是得到每一个read在参考基因组上的位置信息，有了这个基础的位置信息才可以进行后续基因或者转录本的定量，最终由定量结果做差异表达矩阵，分析上调或者下调的基因数量。</p><p>新建一个shell脚本输入下面的代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">for i in `seq 194 209`</span><br><span class="line">do</span><br><span class="line">    hisat2 -p 4 -x /media/sf_example/data/ref/genome \  #索引文件绝对路径</span><br><span class="line">    -1 /media/sf_example/data/clean_data/ERR1698&quot;$i&quot;_1.fq.gz \</span><br><span class="line">    -2 /media/sf_example/data/clean_data/ERR1698&quot;$i&quot;_2.fq.gz \</span><br><span class="line">    -S /media/sf_example/data/hisat2_sam/ERR1698&quot;$i&quot;.sam    #注意大写的S</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>参数解释：</p><div class="note info"><p>-p # 同样是配置线程数<br >-x # 指定索引文件，需要定义索引文件名称，不能加后缀，不能只定义到索引文件所在目录<br >-1 # 第一端测序数据文件<br >-2 # 第二端测序数据文件<br >-S # 指定输出目录和文件，不指定会刷屏，<strong>注意是大写的S</strong></p></div><p>输出到屏幕的结果如下，我们选取其中一个进行解读：</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/QQ%E6%88%AA%E5%9B%BE20220415150423.jpg" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/QQ%E6%88%AA%E5%9B%BE20220415150423.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>共有6166091对测序数据，都是双侧测序数据，其中：</p><div class='checkbox'><input type="checkbox" />            <p>read1 和 read2 没有合理比对上参考基因组序列的有65259对，占1.06%</p>            </div><div class='checkbox'><input type="checkbox" />            <p>read1 和 read2 只有一条比对上参考基因组序列的有5698903对，占92.42%，<strong>这部分reads数需要占测序reads的绝大多数才正常</strong></p>            </div><div class='checkbox'><input type="checkbox" />            <p>read1 和 read2 可以同时比对到多个地方的有401929对，占6.52%</p>            </div><div class='checkbox'><input type="checkbox" />            <p>65259对没有合理比对上的序列中，55871对可以不合理地比对上一次</p>            </div><p>最后一块是对两条链拆开比对的结果，这个一般用不到，本来测序的两条reads就应该比对到同一个染色体同一个基因附近，拆开比对到不同染色体没有意义。我们要看的是最后一句话，总比对率为99.97%，通常比对率大于90%说明比对情况较好，与参考基因组基本吻合。</p></div><h2 id="3-sam文件解读"><a href="#3-sam文件解读" class="headerlink" title="3. sam文件解读"></a>3. sam文件解读</h2><div class="story post-story"><p>比对结果除了有屏幕上输出的总体报告外，还有记录详细比对结果的sam文件。双端测序的比对会将两个测序文件进行整合和比较，最后只生成一个sam文件，因此这个sam文件非常大，hisat2比对生成的sam文件可以直接打开。我们可以选取一部分进行解读。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/QQ%E6%88%AA%E5%9B%BE20220415153505.jpg" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/QQ%E6%88%AA%E5%9B%BE20220415153505.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><div class='checkbox checked'><input type="radio" checked="checked"/>            <p><strong>@HD VN:1.0 SO:unsorted （排序类型）</strong></p>            </div><p>VN是格式版本；SO表示比对排序的类型，有unknown，unsorted，queryname和coordinate几种。samtools软件在进行行排序后不能自动更新sam文件的SO值。</p><div class='checkbox checked'><input type="radio" checked="checked"/>            <p><strong>@SQ SN:1 LN:30427671 （序列ID及长度）</strong></p>            </div><p>参考序列名，这些参考序列决定了比对结果sort的顺序，SN是参考序列名；LN是参考序列长度；每个参考序列为一行。这里表示拟南芥有5条染色体，对应长度都在后面，Mt是线粒体基因，Pt是叶绿体基因。</p><div class='checkbox checked'><input type="radio" checked="checked"/>            <p><strong>@PG ID:hisat2 PN:hisat2 VN:2.2.1 （比对所使用的软件及版本</strong>）</p>            </div><p>这里包括了路径，方法，以及我质控后的序列长度（50-100）等详细信息。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/QQ%E6%88%AA%E5%9B%BE20220415154521.jpg" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/QQ%E6%88%AA%E5%9B%BE20220415154521.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><div class='checkbox checked'><input type="radio" checked="checked"/>            <p><strong>接下来每行都是一长串，显示的是比对结果部分，11个字段（列）</strong></p>            </div><div class='checkbox'><input type="checkbox" />            <p>第一列：QNAME：测序出来的reads序列数据名，ERR1698194.2</p>            </div><div class='checkbox'><input type="checkbox" />            <p>第二列：FLAG：表明比对类型：paring，strand，mate strand等</p>            </div><div class='checkbox'><input type="checkbox" />            <p>第三列：RNAME：参考基因组的染色体名，我这里是第1条染色体</p>            </div><div class='checkbox'><input type="checkbox" />            <p>第四列：POS：比对到这个染色的具体位置，4969</p>            </div><div class='checkbox'><input type="checkbox" />            <p>第五列：MAPQ：比对质量，是一个衡量比对好坏的打分结果，60最好</p>            </div><div class='checkbox'><input type="checkbox" />            <p>第六列：CIGAR：简要比对信息表达式，1S100M是第1个碱基切除，100个匹配</p>            </div><div class='checkbox'><input type="checkbox" />            <p>第七列：RNEXT：另一个序列比对上的参考序列编号，没有另外的片段是*，同一个片段&#x3D;</p>            </div><div class='checkbox'><input type="checkbox" />            <p>第八列：MPOS：另一个序列匹配的染色体具体位置，这里一样也是4969</p>            </div><div class='checkbox'><input type="checkbox" />            <p>第九列：TLEN：配对片段长度，最左边的为正，最右边的为负</p>            </div><div class='checkbox'><input type="checkbox" />            <p>第十列：SEQ：和参考序列在同一个链上比对的序列</p>            </div><div class='checkbox'><input type="checkbox" />            <p>第十一列：QUAL：比对序列的质量和reads碱基质量值</p>            </div><p>后面提供额外的信息，一般不重要，了解一下就行。因为sam文件太大（往往有10G以上），也不适合电脑进行后续处理，所以我们会用到samtools，将sam文件转化为更适合电脑处理的二进制bam文件。这个后面会讲。</p></div><h2 id="4-其他比对软件"><a href="#4-其他比对软件" class="headerlink" title="4. 其他比对软件"></a>4. 其他比对软件</h2><div class="story post-story"><p>以下4种软件均用于序列比对，用法稍有不同，做个记录</p><p><code>$ hisat2 -p 4 -x 索引目录 -1 单端测序数据文件 -2 另一端测序数据文件 -S 输出文件</code></p><p><code>$ subjunk -T 4 -i 索引目录 -r 单端测序数据文件 -R 另一端测序数据文件 -o 输出文件</code></p><p><code>$ bowtie2 -p 4 -x 索引目录 -1 单端测序数据文件 -2 另一端测序数据文件 -S 输出文件</code></p><p><code>$ bwa mem -t 4 -M 索引目录 单端测序数据文件 另一端测序数据文件 &gt; 输出文件</code></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-建立参考基因组索引&quot;&gt;&lt;a href=&quot;#1-建立参考基因组索引&quot; class=&quot;headerlink&quot; title=&quot;1. 建立参考基因组索引&quot;&gt;&lt;/a&gt;1. 建立参考基因组索引&lt;/h2&gt;&lt;div class=&quot;story post-story&quot;&gt;&lt;p&gt;在进</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="转录组数据分析" scheme="http://www.shelven.com/categories/%E8%BD%AC%E5%BD%95%E7%BB%84%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
    <category term="hisat2" scheme="http://www.shelven.com/tags/hisat2/"/>
    
  </entry>
  
  <entry>
    <title>转录组数据分析笔记（1）——如何用fastqc和trim-galore做测序数据质控</title>
    <link href="http://www.shelven.com/2022/04/14/a.html"/>
    <id>http://www.shelven.com/2022/04/14/a.html</id>
    <published>2022-04-14T13:13:35.000Z</published>
    <updated>2022-04-19T17:04:50.761Z</updated>
    
    <content type="html"><![CDATA[<p>本系列学习笔记数据均来自”<strong>Temporal dynamics of gene expression and histone marks at the Arabidopsis shoot meristem during flowering</strong>“，原文用RNA-Seq的方式研究开花阶段，芽分生组织不同时期的基因表达量变化，4个时间段（0, 1, 2, 3），4个重复，共有16个样品。<a href="https://pubmed.ncbi.nlm.nih.gov/28513600/">点击这里获取文献</a></p><hr><h2 id="1-读文章获得RNA-Seq数据"><a href="#1-读文章获得RNA-Seq数据" class="headerlink" title="1. 读文章获得RNA-Seq数据"></a>1. 读文章获得RNA-Seq数据</h2><div class="story post-story"><p>从文章末尾我们可以获得一些测序数据信息：</p><blockquote><p>Data availability. ChIP-seq and RNA-seq data have been deposited with ArrayExpress database (<a href="http://www.ebi.ac.uk/arrayexpress">www.ebi.ac.uk/arrayexpress</a>), accession numbers E-MTAB-4680, E-MTAB-4684 and E-MTAB-5130. </p></blockquote><p>可以看到作者将CHIP-seq和RNA-seq数据上传到<strong>ArrayExpress</strong>这个数据库中，这个数据库是欧洲生物信息研究所（European Bioinformatics Institute, <strong>EBI</strong>）旗下的公共数据库，主要用于存放芯片和高通量测序数据，我们可以直接从该数据库中下载我们需要的RNA-seq数据，自己动手分析。</p><div class="note info"><p>顺便介绍一下，欧洲<a href="https://www.ebi.ac.uk/">EBI</a>旗下的<a href="https://www.ebi.ac.uk/ena/browser/home">ENA</a>数据库，美国<a href="https://www.ncbi.nlm.nih.gov/">NCBI</a>旗下的<a href="https://www.ncbi.nlm.nih.gov/genbank/">GenBank</a>，以及日本的<a href="https://www.ddbj.nig.ac.jp/index-e.html">DDBJ</a>三大巨头组成了国际核酸序列数据库合作联盟（INSDC），这三大数据库收录了世界上报道的所有序列数据。</p></div><p>EBI数据库可以直接下载fastq数据，不需要做SRA数据转换（NCBI数据库中下载sra数据则需要转换，需要用工具fastq-dump），这是EBI数据库下载高通量测序数据的优点，但是这个数据库经常网络连接不稳定，用aspera或者prefetch这种高速下载软件也不一定能稳定下载 <del>最好的方法是科学上网</del>。我们可以从ArrayExpress数据库中输入索引号E-MTAB-5130，直接获得样本信息和测序信息。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/1234.jpg" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/1234.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><hr></div><h2 id="2-测序数据质控"><a href="#2-测序数据质控" class="headerlink" title="2. 测序数据质控"></a>2. 测序数据质控</h2><div class="story post-story"><p>我们可以看到，下载的数据是双端测序产生的。我们不能直接用下载的raw data做后续分析，必须要进行质控查看测序质量如何。</p><hr><h3 id="2-1-使用fastqc对测序数据生成质控报告"><a href="#2-1-使用fastqc对测序数据生成质控报告" class="headerlink" title="2.1 使用fastqc对测序数据生成质控报告"></a>2.1 使用fastqc对测序数据生成质控报告</h3><p>下载好的fastq文件可以直接用fastqc工具做测序数据质控，输入以下命令一次生成所有qc报告：</p><p><code>$ fastqc *.fastq.gz -o ./  #在当前目录下对所有.fastq.gz文件生成qc报告，-o参数定义输出目录</code></p><p>运行结束后我们可以得到.html文件和.zip压缩包，这个就是质控报告。在虚拟机里，我们可以直接点开.html后缀的网页文件查看质控报告（和压缩包的内容是一致的）。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/QQ%E6%88%AA%E5%9B%BE20220414195329.jpg" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/QQ%E6%88%AA%E5%9B%BE20220414195329.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>顺便介绍一个非常好用的工具multiqc，可以通过conda install直接安装，这个工具可以将批量生成的qc报告合并为一个，看起来更加直观。在生成qc报告的当前目录下，运行代码：</p><p><code>$ multiqc ./</code></p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/zfd.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/zfd.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><hr><h3 id="2-2-质控报告解读"><a href="#2-2-质控报告解读" class="headerlink" title="2.2 质控报告解读"></a>2.2 质控报告解读</h3><h4 id="2-2-1-基本信息"><a href="#2-2-1-基本信息" class="headerlink" title="2.2.1 基本信息"></a>2.2.1 基本信息</h4><p>绿色表示通过，黄色表示不太好，红色表示不通过。RNA-seq一般在Sequence Duplication Levels上结果会不好，一个基因可能会大量表达，测到好多遍。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/afhfh.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/afhfh.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="2-2-2-核苷酸测序质量箱式图"><a href="#2-2-2-核苷酸测序质量箱式图" class="headerlink" title="2.2.2 核苷酸测序质量箱式图"></a>2.2.2 核苷酸测序质量箱式图</h4><p>这里测序质量（纵坐标）用Q值表示，p为出错率，Q值计算式为Q&#x3D;-10*lg（p）。每一个核苷酸的测序质量可以从fastq文件第四行一一对应上，这里只是做了统计和可视化。我们可以看到每个位点的核苷酸测序质量Q值都在30以上，意味着每个位点的测序正确率都在99.9%以上，可以认为测序质量比较好。</p><p>箱式图解读：黄色箱子(25%和75%的分数线)，红色线(中位数)，蓝线是平均数，下面和上面的触须分别表示10%和90%的点。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/fagasdga.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/fagasdga.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="2-2-3-测序泳道质量图"><a href="#2-2-3-测序泳道质量图" class="headerlink" title="2.2.3 测序泳道质量图"></a>2.2.3 测序泳道质量图</h4><p>纵坐标为tile编号，这张图代表每次荧光扫描的质量。蓝色背景表明测序质量良好，白色和红色的背景表示测序过程中可能有小气泡或者测序泳道上有污染。直接的体现就是部分测序数据中出现连续的N，也就是不能读取，可能是任何一个核苷酸。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/faheah.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/faheah.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="2-2-4-reads质量得分"><a href="#2-2-4-reads质量得分" class="headerlink" title="2.2.4 reads质量得分"></a>2.2.4 reads质量得分</h4><p>可以看到平均质量在38，质量比较高。如果最高峰所对应的横坐标质量值小于27（错误率0.2%） 则会显示“警告”，如果最高峰的质量值小于20（错误率1%）则会显示“不合格”。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/rtjyrklyl.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/rtjyrklyl.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="2-2-5-每条reads各个测序位点上各碱基出现概率"><a href="#2-2-5-每条reads各个测序位点上各碱基出现概率" class="headerlink" title="2.2.5 每条reads各个测序位点上各碱基出现概率"></a>2.2.5 每条reads各个测序位点上各碱基出现概率</h4><p>图上看得出比较稳定，测序刚开始的时候波动会大一点，这里的GC含量和AT含量不一致。如果任何一个位置上的A和T之间或者G和C之间的比例相差10%以上则报“警告”，任何一个位置上的A和T之间或者G和C之间的比例相差20%以上则报“不合格”。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/srgsrjsryjy.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/srgsrjsryjy.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="2-2-6-GC含量和理论分布"><a href="#2-2-6-GC含量和理论分布" class="headerlink" title="2.2.6 GC含量和理论分布"></a>2.2.6 GC含量和理论分布</h4><p>可以看出GC含量在43%左右，与理论分布（也就是正态分布）比较吻合，中心峰值与所测转录组的GC含量一致。如果有不正常的尖峰，可能是测序文库有污染，接头的污染还会在过表达序列中体现。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/asgarjry67fb.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/asgarjry67fb.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="2-2-7-每条reads的含N碱基数"><a href="#2-2-7-每条reads的含N碱基数" class="headerlink" title="2.2.7 每条reads的含N碱基数"></a>2.2.7 每条reads的含N碱基数</h4><p>不能识别的碱基会被读成N，这里没有N，测序质量非常好。横坐标表示reads的位置，纵坐标表示N的比例。如果任何一个位置N的比例大于5%则报“警告”，大于20%则报“失败”。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/fhdfdzjnf.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/fhdfdzjnf.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="2-2-8-测序长度分布"><a href="#2-2-8-测序长度分布" class="headerlink" title="2.2.8 测序长度分布"></a>2.2.8 测序长度分布</h4><p>这个测序仪一次测量长度是101bp。测序仪出来的原始reads通常是均一长度的，经过质控软件处理过的reads长度则不一样，这里说明测序结果较好。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/dsgnsfgmsfgmdfhms.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/dsgnsfgmsfgmdfhms.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="2-2-9-重复序列水平"><a href="#2-2-9-重复序列水平" class="headerlink" title="2.2.9 重复序列水平"></a>2.2.9 重复序列水平</h4><p>可以看到重复水平较低。图中横轴代表reads的重复次数，大于10次重复后则按不同的重复次数合并显示。纵坐标表示各重复次数下的reads数占总reads的百分比；蓝线展示所有reads的重复情况，红线表示在去掉重复以后，原重复水平下的reads占去重后reads总数的百分比；如果非unique的reads占总reads数的20%以上则报 ”警告“，占总read数的50%以上则报 ”不合格“。<strong>这项变黄是正常的</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/gdmshmdttu.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/gdmshmdttu.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="2-2-10-过表达序列和接头序列"><a href="#2-2-10-过表达序列和接头序列" class="headerlink" title="2.2.10 过表达序列和接头序列"></a>2.2.10 过表达序列和接头序列</h4><p>过表达的序列很可能是一些测序的接头序列，这里两种序列都看不到，说明质量良好。过表达序列是显示同一条reads出现次数超过总测序reads数的0.1%的统计情况，超过0.1%则报“警告”，超过1%则报“不合格”，会列出可能的接头序列。接头序列正常情况下含量接近于0。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/gsgggnsjtttjbbb.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/gsgggnsjtttjbbb.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><hr><h3 id="2-3-trim-galore测序数据质控过滤"><a href="#2-3-trim-galore测序数据质控过滤" class="headerlink" title="2.3 trim-galore测序数据质控过滤"></a>2.3 trim-galore测序数据质控过滤</h3><p>质控的目的使为了除去下机数据raw data中的接头序列和质量比较差的测序数据，Q&lt;20，正确率小于99%，如果这样的核苷酸超过read长度的20%，则考虑将该read丢弃（只是建议，不是强制，根据需要可以自定义过滤条件）。</p><p>trim-galore也可以用conda install安装，非常方便，这是一个自动检测adaptor的软件，可以一个命令自动找出主流的测序接头并去除，还可以设置参数对测序数据质控。简单介绍一下trim-galore的一些参数：</p><div class="note info"><p>-q # 设定Phred quality score阈值，默认为20；<br />-phred33 # 测序平台衡量测序质量的方法，有33和64，不影响；<br />-length # 设定输出reads长度阈值，小于设定值会被抛弃，根据需要设计;<br >-stringency # 设定可以忍受的前后adapter重叠的碱基数，默认为1（非常苛刻）;<br >-paired # 用于分析双端测序数据结果；<br >-o # 输出目录</p></div><p>因为是双端测序，16个样本每个都有_1和_2两个文件，可以写个脚本批量运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">for i in `seq 194 209`</span><br><span class="line">    do </span><br><span class="line">    trim_galore -q 25 -phred33 -length 50 -stringency 3 -paired \</span><br><span class="line">    -0 /media/sf_/example/data/clean_data \</span><br><span class="line">    /media/sf_/example/data/raw_data/ERR1698&quot;$i&quot;_1.fastq.gz \   #一端测序数据</span><br><span class="line">    /media/sf_/example/data/raw_data/ERR1698&quot;$i&quot;_2.fastq.gz     #另一端测序数据</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>保存退出，运行，最后生成的_triming_report.txt文件就是生成的质控报告，_val_1.fq.gz就是过滤后瘦身的<strong>clean data</strong>，我们可以看到大小比原来小了10M左右，这个<strong>clean data才可以用于后续的分析流程</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/dagjsgjsrjsr.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/dagjsgjsrjsr.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>我截取了其中一个数据的质控结果，拉到最底下，可以看到两端测序数据中都有AGATCGGAAGAGC这个序列，在一个样本测序数据中出现240027次经过网上查找，AGATCGGAAGAGC这个序列确实是Illumina公司测序时的接头序列<a href="https://support.illumina.com/content/dam/illumina-support/help/Illumina_DRAGEN_Bio_IT_Platform_v3_7_1000000141465/Content/SW/Informatics/Dragen/FastQC_Adapter_Kmer_files_fDG.htm">（点击这里查看）</a>，可以和上面fastqc质控报告中的测序平台Illumina相互验证。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/wagrwrhe.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/wagrwrhe.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本系列学习笔记数据均来自”&lt;strong&gt;Temporal dynamics of gene expression and histone marks at the Arabidopsis shoot meristem during flowering&lt;/strong&gt;“，</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="转录组数据分析" scheme="http://www.shelven.com/categories/%E8%BD%AC%E5%BD%95%E7%BB%84%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
    <category term="fastqc" scheme="http://www.shelven.com/tags/fastqc/"/>
    
    <category term="multiqc" scheme="http://www.shelven.com/tags/multiqc/"/>
    
    <category term="trim-galore" scheme="http://www.shelven.com/tags/trim-galore/"/>
    
  </entry>
  
  <entry>
    <title>小破站正式对外开放啦！</title>
    <link href="http://www.shelven.com/2022/04/13/a.html"/>
    <id>http://www.shelven.com/2022/04/13/a.html</id>
    <published>2022-04-13T14:29:14.000Z</published>
    <updated>2022-04-18T15:17:02.573Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><div class="story post-story"><p>咳咳，经过10天左右紧张地准备，小站今天正式对外开放啦！作为第一次运行个人网站的小白，看着网站从零开始在自己手上慢慢展现一个个页面，实现一个个功能，这种成就感和激动感，让我感觉这几天的熬夜狂肝还是值得的<del>呜呜呜我的头发</del>。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/QQ%E5%9B%BE%E7%89%8720220414020811.jpg" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/QQ%E5%9B%BE%E7%89%8720220414020811.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div><h2 id="建站过程"><a href="#建站过程" class="headerlink" title="建站过程"></a>建站过程</h2><div class="story post-story"><h4 id="为什么建站"><a href="#为什么建站" class="headerlink" title="为什么建站"></a>为什么建站</h4><p>说是从零开始，其实也是站在前人搭建好的框架上才能顺利进行的。我很早之前就萌发了搭建个人网站的想法，自从这个学期开始学习生物信息学，我也慢慢对linux系统有了更深入的理解。一开始只是在虚拟机上跑跑程序，后来就想着不如买一个云服务器装linux玩玩，既然买了服务器了，那就再绑个域名吧，既然两个都有了，不如就再建个网站吧<del>（滑稽）</del>。于是趁着腾讯云的轻量级应用服务器打折的机会，一次性买了3年…然后又在阿里云买了个域名，了解到需要备案后才能解析域名，行，又办理各种手续在工信部备了案。不得不说，在各大云服务器商内卷搞活动的时候，有个学生认证还是相当香的。至于怎么用服务器，那就是后面考虑的事了。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/QQ%E6%88%AA%E5%9B%BE20220414022126.jpg" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/QQ%E6%88%AA%E5%9B%BE20220414022126.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="我买的服务器"></p><h4 id="备案和备案期间的学习"><a href="#备案和备案期间的学习" class="headerlink" title="备案和备案期间的学习"></a>备案和备案期间的学习</h4><p>我在腾讯云买的服务器，通过接入商腾讯云协助，腾讯云先审核我的材料，通过以后再提交工信部备案，备案还是相当快的，3天时间就办下来了。备案期间也没闲着，作为一个前端小白的我，又去恶补了一些前端知识，比如什么是css、js、ejs、html文件，这些文件的格式是怎么样的，java的一些基本语法等等。学习的折磨程度不亚于刚开始学R语言和linux操作系统，不过有了一些shell脚本的语法知识以后，还是能感觉到这些语言之间还是有共同的判断方式和逻辑在里面的<u>（纯小白发言，不知道对不对）</u>。在慢慢摸索的过程中痛并快乐着，先是照着别人给的js文件魔改，再是自己调试遇到的问题和bug，尤其在发现bug最后解决bug的时候，那种成就感能给我带来莫大的快乐。</p><h4 id="建站历程"><a href="#建站历程" class="headerlink" title="建站历程"></a>建站历程</h4><p>建站的过程是痛苦的，踩了非常多的坑，我觉得我甚至可以写好几篇攻略出来。我一开始的想法是在github建库搭建个人网站，从安装nodejs和npm这种最基础的开始，配置环境，用hexo框架搭建一个本地静态博客，然后部署到github空间，这样就可以用github仓库名访问我的网站。但是<strong>有一个非常大的问题</strong>，github从国内访问会有DNS污染，连接速度那叫一个绝望。我自己是可以科学上网，但是总不能让别人浏览我网页的时候也科学上网吧？我也不太相信有很多人会用<strong>改host</strong>的办法来访问github，于是我就萌生了将买的云服务器用来搭建网站的想法（我知道这是一种资源浪费），github就可以当做网站的备份，以后即使我的云服务器过期了，我也可以依旧正常访问搭建在github里的静态博客。所以我的部署过程有点绕，就是本地生成静态博客，先部署到github仓库，再同步部署到我的云服务器。这样我就可以用备案后的二级域名解析到云服务器，在通过安装httpd服务来开启外部的访问了。</p><p>可以访问我的网站还是第一步，还要做好安全防护，申请<strong>SSL安全证书</strong>才能开启https连接。免费申请方式也很多，我申请了一年的apache上的SSL安全证书，然后安装到自己服务器上。还想吐槽一下，腾讯云有一键部署SSL安全证书通道，要90块钱，只要有点linux文本操作基础，自己按照教程部署一下半小时左右就能完成，<del>这钱真好赚</del>。SSL证书安装做好以后，就可以上别的云服务商找找免费的<strong>CDN加速</strong>了，有CDN加速一是可以加快网站的加载速度，二是隐藏自己服务器的ip地址，能起到一定的网站安全防护作用。吹一波又拍云，只要在网站底下加上他们的标志，启用他们的CDN加速，就能申请加入又拍云联盟，有免费一年的CDN加速和云储存服务，还可以查看访问记录等等 <del>学生党薅羊毛的利器23333</del> 。因为我的网页图片比较多，所以就应用了网页图片加速。</p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/QQ%E6%88%AA%E5%9B%BE20220414023552.jpg" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/QQ%E6%88%AA%E5%9B%BE20220414023552.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><div class="story post-story"><p>具体过程比如怎么接入第三方各种网站，用什么主题，怎么美化页面等等，就不详细说了，说多了肝疼，以后有想法再更新如何<strong>从零开始搭建自己的博客</strong>吧！<strong>至少没有服务器和域名也是完全可以实现的</strong>。建立这个小破站也主要是为了上传自己的学习笔记，整理生信网站和工具合集（相应的栏目还在建设中 <del>新建文件夹了</del> ），督促自己学习hhhhh</p><p>本人技术实力有限，也不想搞地太花里胡哨，之后可能会有一些简单的小功能接入，还有移动端浏览小破站的优化（现在移动端浏览这个小破站简直是灾难，我都看不下去了），太费心思的东西就暂时放放了，主要专注于内容的创作，这几天会把一些学习笔记陆续上传。本人也是第一次用markdown语法写东西，排版一直搞不定段首的两个空格，先这样吧。 <psw>开摆</psw></p><p><img src="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/u=2001056350,755226689&fm=26&gp=0.jpg" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Phantom-Aria/image/u=2001056350,755226689&fm=26&gp=0.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;div class=&quot;story post-story&quot;&gt;&lt;p&gt;咳咳，经过10天左右紧张地准备，小站今天正式对外开放啦！作为第一次运行个人网站的</summary>
      
    
    
    
    <category term="个人主页" scheme="http://www.shelven.com/categories/%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5/"/>
    
    
    <category term="建站" scheme="http://www.shelven.com/tags/%E5%BB%BA%E7%AB%99/"/>
    
  </entry>
  
</feed>
