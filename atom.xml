<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>我的小破站</title>
  
  
  <link href="http://www.shelven.com/atom.xml" rel="self"/>
  
  <link href="http://www.shelven.com/"/>
  <updated>2022-12-10T16:00:15.000Z</updated>
  <id>http://www.shelven.com/</id>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HTTP基本原理</title>
    <link href="http://www.shelven.com/2022/12/10/a.html"/>
    <id>http://www.shelven.com/2022/12/10/a.html</id>
    <published>2022-12-10T15:10:45.000Z</published>
    <updated>2022-12-10T16:00:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>以前写过一篇博客如何爬取微博热搜的前50条，当时是从代码出发理解爬虫实现的过程。这篇博客主要讲一下HTTP的基本知识，知道从浏览器中输入网址到我们获取网页内容的过程中发生了什么，有助于进一步了解爬虫的基本原理。</p><span id="more"></span><h2 id="1-URI、URL和URN"><a href="#1-URI、URL和URN" class="headerlink" title="1. URI、URL和URN"></a>1. URI、URL和URN</h2><div class="story post-story"><p>先放上这三个名词的定义：</p><ul><li>URI：Uniform Resource Identifier 统一资源标志符</li><li>URL：Uniform Resource Locator 统一资源定位符</li><li>URN：Uniform Resource Name 统一资源名称</li></ul><p>URI是一个抽象定义，只要能定位到一个资源，都叫做URI。</p><p>URL和URN都是URI的子集，简单来说，<strong>URL用地址定位资源，URN用名称定位资源</strong>。只是后来URN在互联网中使用非常少，导致现在几乎所有的URI都是URL，因此我们可以将一般网页链接称之为URI或者URL（后者用的最多）。</p><p>那么URL或者URI具体指什么呢？</p><p>举个例子，本站图标地址<code>https://www.shelven.com/tuchuang/bitbug_favicon.ico</code>，通过这个地址可以访问到一只32*32像素大小的可爱小猫，通过这个地址URL&#x2F;URI指定了它的访问方式，包括了<strong>访问协议</strong>https，<strong>访问路径</strong>和<strong>资源名称</strong>bitbug_favicon.ico。这个访问资源可以是一个图片，一个CSS文档，一个HTML页面等等。</p><p>以HTTPS协议访问web服务器为例，拆解一下完整的URL结构：</p><p><code>https://user:password@www.shelven.com:443/tuchuang/bitbug_favicon.ico</code></p><ul><li><strong>协议</strong>：URL开头部分必须是协议类型，常见的https、http、ftp和mailto，指明浏览器应当使用的访问方法，用&#x2F;&#x2F;做分隔符</li><li><strong>用户名&#x2F;密码</strong>：user:password这部分可以省略</li><li><strong>域名</strong>：我这里域名是<code>www.shelven.com</code>，我们在发送请求前会向DNS服务器解析这个域名的ip地址，域名只是方便我们人类记忆的，计算机访问的最终都是ip地址。当然，如果你能记得住ip地址也可以直接输入。</li><li><strong>端口</strong>：用来区分不同网络服务（web服务、ftp服务等），和域名之间用冒号:分隔，端口不是URL必须的部分，http默认端口80，https默认端口443，ftp默认端口21。</li><li><strong>文件路径&#x2F;文件名</strong>：从域名第一个<code>/</code>到最后一个<code>/</code>之间是虚拟目录；从域名最后一个<code>/</code>到<code>?</code>部分是文件名，没有<code>?</code>则是到<code>#</code>为止，都没有则是从最后一个<code>/</code>一直到结束都是文件名部分。文件名是可以缺省的。</li></ul></div><h2 id="2-超文本"><a href="#2-超文本" class="headerlink" title="2. 超文本"></a>2. 超文本</h2><div class="story post-story"><p>超文本（Hyper Text, HT）是用超链接的方法，将不同空间文字信息组织在一起的网状文本。</p><p>举个例子，<strong>浏览器中看到的网页就是超文本解析而来的</strong>，网页本身就是一个文本文件，而超文本指这种文件既可以包含文本信息，又可以包含图片、视频、链接等非文字信息。</p><p>网页的源代码是一系列HTML（Hyper Text Markup Language, 超文本标记语言）代码，里面包含了一系列标签（尖括号&lt;&gt;包围的关键词，<strong>一般</strong>成对出现）和属性值。在浏览器中打开任意一个页面，按F12就可以打开浏览器的开发者工具，选择<strong>元素（Elements）</strong>选项卡就可以看到当前网页的源代码，而这些源代码都是超文本。</p><p><img src="https://www.shelven.com/tuchuang/20221210/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221210/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>红框框住的左上角箭头，点击以后可以在页面中用鼠标悬停选中元素，右边对应的源代码部分会高亮，方便我们进行元素审查。</p><p>这里顺便记录下HTML常用的标签和属性：</p><table><thead><tr><th>标签名</th><th>用法</th></tr></thead><tbody><tr><td><strong>基本结构标签</strong></td><td></td></tr><tr><td>HTML标签（根标签）</td><td>&lt;html&gt;&lt;&#x2F;html&gt;</td></tr><tr><td>文档头标签</td><td>&lt;head&gt;&lt;&#x2F;head&gt;</td></tr><tr><td>文档标题标签（网页标题）</td><td>&lt;title&gt;&lt;&#x2F;title&gt;</td></tr><tr><td>文档主体标签（页面内容）</td><td>&lt;body&gt;&lt;&#x2F;body&gt;</td></tr><tr><td><strong>列表标签</strong></td><td>（这里因为渲染问题&amp;emsp无法显示空格…知道HTML有缩进的意思就行）</td></tr><tr><td>无序列表</td><td>&lt;ul type&#x3D;”disc&#x2F;circle&#x2F;square”&gt;<br>&amp;emsp;&lt;li&gt;条目内容&lt;&#x2F;li&gt;<br>&lt;&#x2F;ul&gt;</td></tr><tr><td>有序列表</td><td>&lt;ol type&#x3D;”1&#x2F;a&#x2F;A&#x2F;i&#x2F;I”&gt;<br>&amp;emsp;&lt;li&gt;条目内容&lt;&#x2F;li&gt;<br>&lt;&#x2F;ol&gt;</td></tr><tr><td>定义列表</td><td>&lt;dl&gt;<br>&amp;emsp;&lt;dt&gt;列表标题标签&lt;&#x2F;dt&gt;<br>&amp;emsp;&lt;dd&gt;具体列表项&lt;&#x2F;dd&gt;<br>&lt;&#x2F;dl&gt;</td></tr><tr><td><strong>表格标签</strong></td><td></td></tr><tr><td>表格标签（tr为行）</td><td>&lt;table&gt;<br>&amp;emsp;&lt;tr&gt;<br>&amp;emsp;&amp;emsp;&lt;td&gt;单元格内容&lt;&#x2F;td&gt;<br>&amp;emsp;&lt;&#x2F;tr&gt;<br>&lt;&#x2F;table&gt;</td></tr><tr><td><strong>常用标签</strong></td><td></td></tr><tr><td>标题标签（h1-h6）</td><td>&lt;h1&gt;一级标题&lt;&#x2F;h1&gt;</td></tr><tr><td>段落标签</td><td>&lt;p&gt;这里是内容&lt;&#x2F;p&gt;</td></tr><tr><td>字体标签</td><td>&lt;font size&#x3D;”10” color&#x3D;”black” face&#x3D;”微软雅黑”&gt;你好&lt;&#x2F;font&gt;</td></tr><tr><td>换行标签</td><td>&lt;br&#x2F;&gt;</td></tr><tr><td>水平线标签</td><td>&lt;hr size&#x3D;”10” color&#x3D;”red” width&#x3D;”50%” align&#x3D;”left”&#x2F;&gt;</td></tr><tr><td>盒子标签div</td><td>&lt;div&gt;div标签内容独占一行&lt;&#x2F;div&gt;</td></tr><tr><td>盒子标签span</td><td>&lt;span&gt;span标签内容一行可以多个&lt;&#x2F;span&gt;</td></tr><tr><td>图片标签</td><td>&lt;img src&#x3D;”地址” width&#x3D;’”宽度” height&#x3D;”高度”&gt;&lt;&#x2F;img&gt;</td></tr><tr><td>超链接标签</td><td>&lt;a href&#x3D;”跳转网址” target&#x3D;”窗口弹出方式”&gt;&lt;&#x2F;a&gt;</td></tr><tr><td>注释标签</td><td>&lt;!– 注释内容 –&gt;</td></tr></tbody></table><p>还有表单标签&lt;form&gt;&lt;&#x2F;form&gt;等等，太多了这里就不一一详细说了，如果以后有必要再出一个详细的HTML笔记，现在只要看到这些标签心里有个数就行，真正要做前端再去详细探究。</p></div><h2 id="3-协议"><a href="#3-协议" class="headerlink" title="3. 协议"></a>3. 协议</h2><div class="story post-story"><p>前面说URL的开头必须指明协议类型，常用的是ftp（文件传输协议）、http（超文本传输协议）、https（http的安全版）、mailto（电子邮件协议）和smb（通信协议）。不需要对所有协议了如指掌，前三中协议是我们日常用的最多的，http和https是我们访问网站web服务所必须的，爬虫也可以通过这两种协议伪装成浏览器访问，从而抓取我们需要的页面。</p><ul><li><p><strong>HTTP</strong>（Hyper Text Transfer Protocol, 超文本传输协议）就是一个简单的请求-响应协议，运行在TCP之上，指定客户端发送什么样的消息以及得到什么响应，服务器端实现程序有httpd<del>（本站就是用的这个）</del>和nginx。</p></li><li><p><strong>HTTPs</strong>（Hyper Text Transfer Protocol over Secure Socket Layer）以安全为目标的HTTP通道，说白了就是安全版HTTP，在HTTP下加入SSL层，传输内容经过SSL加密。</p></li></ul><p>本站建站之初，我当时绕了一大圈才签下来SSL证书……<strong>HTTPS的安全基础是SSL，主要作用是建立一个信息安全通道</strong>，保证数据传输的安全；确认网站的真实性，<strong>使用https的网站可以通过浏览器地址栏的锁头标志，查看网站认证的真实信息</strong>。</p><p><img src="https://www.shelven.com/tuchuang/20221210/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221210/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>有些网站使用了HTTPs协议但还是会被浏览器提示不安全，那有可能是证书过期了，或者颁发CA证书的机构不是被信任的，这样就会提示”您的连接不是私密连接“。而要用爬虫爬取这种页面的话，<strong>需要设置忽略证书</strong>，否则会提示SSL证书连接错误。</p><p><img src="https://www.shelven.com/tuchuang/20221210/3.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221210/3.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><img src="https://www.shelven.com/tuchuang/20221210/4.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221210/4.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div><h2 id="4-HTTP请求过程"><a href="#4-HTTP请求过程" class="headerlink" title="4. HTTP请求过程"></a>4. HTTP请求过程</h2><div class="story post-story"><p>我们在浏览器中输入一个 URL，回车之后便会在浏览器中观察到页面内容。这个过程是浏览器向网站所在的服务器发送了一个请求，网站服务器接收到这个请求后进行处理和解析，然后返回对应的响应，接着传回给浏览器。响应里包含了页面的源代码等内容，浏览器再对其进行解析，将网页呈现出来。</p><p><img src="https://www.shelven.com/tuchuang/20221210/5.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221210/5.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>以本站作为演示，打开浏览器，按下F12进入开发者工具，点击网络（Network）选项；搜索框输入<code>https://www.shelven.com</code>，回车。观察整个过程中发生了怎样的网络请求。</p><p><img src="https://www.shelven.com/tuchuang/20221210/6.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221210/6.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>看下第一个网络请求<a href="http://www.shelven.com，各列的含义如下：">www.shelven.com，各列的含义如下：</a></p><ul><li>名称name：请求的名称，返回的每一条都是对应的数据包</li><li>状态status：响应的状态码，通过状态码判断发送请求之后是否得到正常的响应</li><li>类型type：请求的文档类型，这里是返回document，内容就是一些html代码</li><li>发起程序initiator：请求源，标记是哪个对象或者进程发起的请求</li><li>大小size：从服务器下载的文件和请求资源的大小</li><li>时间time：发起请求到获取响应的总时间</li><li>时间线waterfall：网络请求的可视化瀑布流</li></ul><p>点击具体条目可以看到更详细的信息。</p><p><img src="https://www.shelven.com/tuchuang/20221210/7.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221210/7.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>主要看三个部分，<strong>常规（general）、响应头（Response Headers）和请求头（Request Headers）</strong>。常规部分是总的数据包概括。请求头带有请求信息，例如Cookies、user-agent等信息，服务器会根据请求头内的信息判断请求是否合法，进而作出对应的响应。响应头就是响应的一部分，包含了服务器的类型、文档类型、日期等信息，浏览器接受到响应后，会解析响应内容，进而呈现网页内容。</p></div><h2 id="5-请求"><a href="#5-请求" class="headerlink" title="5. 请求"></a>5. 请求</h2><div class="story post-story"><p>请求指的是从客户端到服务器端的请求消息，发给服务器的请求称为请求报文，可以分为请求行（request line），请求头（request header）和请求体（request body）。</p><h3 id="5-1-请求行"><a href="#5-1-请求行" class="headerlink" title="5.1 请求行"></a>5.1 请求行</h3><p>请求行中包括了请求方法，请求协议和版本。</p><p>以百度首页为例：</p><p><img src="https://www.shelven.com/tuchuang/20221210/8.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221210/8.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>小框框起来的地方为请求行，可以看到百度首页的请求方法为get，请求协议为HTTP版本1.1</p><p>常见的请求方法有两种：<strong>GET和POST</strong></p><ul><li>GET 请求中的参数包含在URL里面，数据可以在URL中看到，而POST请求的URL不会包含这些数据，数据是通过<strong>表单形式</strong>传输的，会包含在请求体中。</li><li>GET 请求提交的数据最多只有1024字节，而POST方式没有限制。</li></ul><p>因为GET请求方式不涉及和数据库的交换，所以我们浏览网页用的都是GET请求；如果要在一个网站登录，就需要提交用户名和密码的表单，这个时候用的就是POST请求。还有一个重要的因素，<strong>GET方式请求的数据是在URL中完全暴露的</strong>，所以也不会用GET方式发送请求，不然容易造成密码泄露。</p><p>其他请求方法在<a href="https://www.shelven.com/2022/05/03/a.html?keyword=%E7%88%AC%E8%99%AB">前面一篇爬虫博客</a>有提到，这里列个表格：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>GET</td><td>请求页面，并返回页面内容</td></tr><tr><td>POST</td><td>大多用于提交表单或上传文件，数据包含在请求体中</td></tr><tr><td>HEAD</td><td>类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头</td></tr><tr><td>PUT</td><td>从客户端向服务器传送的数据取代指定文档中的内容</td></tr><tr><td>DELETE</td><td>请求服务器删除指定的页面</td></tr><tr><td>CONNECT</td><td>把服务器当作跳板，让服务器代替客户端访问其他网页</td></tr><tr><td>OPTIONS</td><td>允许客户端查看服务器的性能</td></tr><tr><td>TRACE</td><td>回显服务器收到的请求，主要用于测试或诊断</td></tr></tbody></table><p>表格参考：<a href="https://www.runoob.com/http/http-methods.html">HTTP 请求方法 | 菜鸟教程 (runoob.com)</a></p><h3 id="5-2-请求头"><a href="#5-2-请求头" class="headerlink" title="5.2 请求头"></a>5.2 请求头</h3><p>请求头是用来说明服务器使用的附加信息的，上面那个百度首页例子的大框框住部分就是请求头的信息。</p><p>同样列个表格记录下常用的头信息。</p><table><thead><tr><th>头信息</th><th>描述</th></tr></thead><tbody><tr><td>Accept</td><td>请求报头域，用于指定客户端可接受哪些类型的信息</td></tr><tr><td>Accept-Language</td><td>指定客户端可接受的语言类型</td></tr><tr><td>Accept-Encoding</td><td>指定客户端可接受的内容编码</td></tr><tr><td>Host</td><td>指定请求资源的主机IP和端口号</td></tr><tr><td>Cookie</td><td>而存储在用户本地的数据，主要功能是<strong>维持当前访问会话</strong></td></tr><tr><td>Referer</td><td>标识请求是从哪个页面发过来的，服务器可以拿来做来源统计、防盗链处理</td></tr><tr><td>User-Agent</td><td><strong>服务器识别客户使用的操作系统及版本、浏览器及版本等信息</strong>，爬虫伪装浏览器必备</td></tr><tr><td>Content-Type</td><td>请求的数据类型信息<a href="https://tool.oschina.net/commons">HTTP Content-type 对照表 (oschina.net)</a></td></tr></tbody></table><h3 id="5-3-请求体"><a href="#5-3-请求体" class="headerlink" title="5.3 请求体"></a>5.3 请求体</h3><p>请求体承载POST请求中的表单数据，<strong>GET请求的请求体为空</strong>。</p><p>这里以登录github捕获的请求体为例：</p><p><img src="https://www.shelven.com/tuchuang/20221210/11.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221210/11.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>登录的时候填写的用户名和密码信息，提交的时候就会以表单形式提交给服务器，这个时候可以看到请求头中的Cotent-Type为application&#x2F;x-www-form-urlencoded，表示以表单数据的形式提交给服务器。可以设置不同的Cotent-Type，以不同的方式提交数据，如果在做爬虫的时候要构造POST请求，需要注意一下<strong>使用正确的Cotent-Type（类型&#x2F;子类型）</strong>，不然可能会提交后无法正常响应。</p><table><thead><tr><th>Cotent-Type</th><th>数据提交的方式</th></tr></thead><tbody><tr><td>application&#x2F;x-www-form-urlencoded</td><td>表单数据</td></tr><tr><td>multipart&#x2F;form-data</td><td>表单文件上传</td></tr><tr><td>application&#x2F;json</td><td>序列化JSON数据</td></tr><tr><td>text&#x2F;xml</td><td>XML数据</td></tr><tr><td>application&#x2F;pdf</td><td>pdf格式</td></tr><tr><td>application&#x2F;octet-stream</td><td>二进制流数据（如常见的文件下载）</td></tr></tbody></table></div><h2 id="6-响应"><a href="#6-响应" class="headerlink" title="6. 响应"></a>6. 响应</h2><div class="story post-story"><p>和请求类似的，服务器进行HTTP响应也是分为三个部分：<strong>响应状态行，响应头和响应体</strong></p><h3 id="6-1-响应状态行"><a href="#6-1-响应状态行" class="headerlink" title="6.1 响应状态行"></a>6.1 响应状态行</h3><p>回到之前百度首页的例子，我们点开百度首页审查元素，这次点开响应那一栏查看源。</p><p><img src="https://www.shelven.com/tuchuang/20221210/10.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221210/10.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>小框框起来的地方是响应状态行，我们可以看到响应的协议版本是HTTP&#x2F;1.1，<strong>响应状态码是200</strong>，说明返回正常。</p><p>响应状态码其实并不陌生，顾名思义表示服务器的响应状态。200说明服务器正常响应返回正常数据，经常能看到404报错，代表的是页面未找到，403表示服务器拒绝执行请求，503代表服务器不可用，301代表网页被永久转移到其他URL。</p><p>因为状态码非常多，这里就记录一下状态码的分类，详细状态码列表可以参考<a href="https://www.runoob.com/http/http-status-codes.html">HTTP 状态码 | 菜鸟教程 (runoob.com)</a></p><table><thead><tr><th>分类</th><th>分类描述</th></tr></thead><tbody><tr><td>100-199</td><td>信息响应，服务器收到请求，需要请求者继续执行操作</td></tr><tr><td>200-299</td><td><strong>成功响应</strong>，操作被成功接收并处理</td></tr><tr><td>300-399</td><td>重定向，需要进一步的操作以完成请求</td></tr><tr><td>400-499</td><td><strong>客户端错误</strong>，请求包含语法错误或无法完成请求</td></tr><tr><td>500-599</td><td><strong>服务器错误</strong>，服务器在处理请求的过程中发生了错误</td></tr></tbody></table><h3 id="6-2-响应头"><a href="#6-2-响应头" class="headerlink" title="6.2 响应头"></a>6.2 响应头</h3><p>上面例子中红色大框框住的部分就是响应头，包含服务器对请求的应答信息。</p><p>响应头主要有如下的信息：</p><table><thead><tr><th>头信息</th><th>描述</th></tr></thead><tbody><tr><td>Date</td><td>标识响应产生的时间</td></tr><tr><td>Last-Modified</td><td>指定资源的最后修改时间</td></tr><tr><td>Content-Encoding</td><td>指定响应内容的编码</td></tr><tr><td>Server</td><td>服务器的信息，比如名称、版本号</td></tr><tr><td>Content-Type</td><td>返回的数据类型信息</td></tr><tr><td>Set-Cookie</td><td>设置 Cookies，下次请求会携带这个cookies</td></tr><tr><td>Expires</td><td>指定响应的过期时间</td></tr></tbody></table><h3 id="6-3-响应体"><a href="#6-3-响应体" class="headerlink" title="6.3 响应体"></a>6.3 响应体</h3><p>响应体就是响应的内容，请求网页的时候响应体就是对应的HTML源代码，请求一张图片，响应体就是返回的二进制数据。爬虫就是通过请求到网页后，解析响应体中的内容（有的时候是HTML代码，有的时候是JSON数据等等，这两者比较常见），然后从中提取我们要的信息。</p><p>在edge浏览器中，进入开发者工具，点击network选项，选中需要解析的项目名称，点击响应就可以看到返回的响应体数据了。</p><p><img src="https://www.shelven.com/tuchuang/20221210/12.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221210/12.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>以上暂时总结这么多HTTP的基础，参考了相当多的内容，后面做爬虫练习自然会用到。</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;以前写过一篇博客如何爬取微博热搜的前50条，当时是从代码出发理解爬虫实现的过程。这篇博客主要讲一下HTTP的基本知识，知道从浏览器中输入网址到我们获取网页内容的过程中发生了什么，有助于进一步了解爬虫的基本原理。&lt;/p&gt;</summary>
    
    
    
    <category term="网络相关" scheme="http://www.shelven.com/categories/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="爬虫" scheme="http://www.shelven.com/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="HTTP" scheme="http://www.shelven.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>python自学笔记（7）——模块、包和库</title>
    <link href="http://www.shelven.com/2022/11/29/b.html"/>
    <id>http://www.shelven.com/2022/11/29/b.html</id>
    <published>2022-11-29T14:30:03.000Z</published>
    <updated>2022-12-03T15:51:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>前面介绍递归函数的时候用到了sys模块，介绍文件操作函数的时候用到了os模块，之前只是简单说了这两个模块下部分函数的用法，这里详细介绍一下对于模块、包和库的概念，以及一些常见的模块用法。</p><span id="more"></span><p>不需要记住每个模块下所有函数用法，但是平常看到python文件导入模块操作的时候，要大概知道这几个模块有什么作用。</p><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><div class="story post-story"><h3 id="1-1-模块（module）"><a href="#1-1-模块（module）" class="headerlink" title="1.1 模块（module）"></a>1.1 模块（module）</h3><p>函数可以理解为完成特定功能的一段程序，类是包含一组数据及操作这些数据或传递消息的函数的集合，而<strong>模块（module）是在函数和类的基础上，将一系列相关代码组织到一起的集合体</strong>。</p><p>在python中，扩展名为.py的源程序文件就是一个模块，这个和C语言的头文件以及JAVA的包是类似的。</p><p>python官方网站上可以查看当前标准库中的所有模块，<a href="https://docs.python.org/3/py-modindex.html">点击这里</a>。</p><h3 id="1-2-包（package）"><a href="#1-2-包（package）" class="headerlink" title="1.2 包（package）"></a>1.2 包（package）</h3><p>为了方便调用将一些功能相近的模块组织在一起，或是将一个较为复杂的模块拆分为多个组成部分，可以将 .py 源程序文件放在<strong>同一个文件夹下</strong>，按照 Python 的规则进行管理，<strong>这样的文件夹和其中的文件就称为包（package）</strong>。</p><p>包的目录下需要创建__init__.py 模块，可以是一个空文件，可以写一些初始化代码，其作用就是告诉 Python 要将该目录当成包来处理，让python认为你这是一个包而不是单纯的一个目录（否则会显示找不到包）。<strong>有的博客说python3.3版本之后不需要空的__init__.py 模块来声明这是一个包了，但是我在vscode和jupyter运行python3.10的时候发现还是需要__init__.py 模块声明的</strong>，这里先存疑，我保留自己的观点。</p><ul><li>2022.12.3更新：准确来说，从包里导入模块需要__init__.py 声明；直接导入同目录下的模块不需要（3.3版本以后）</li></ul><p>简单来说，包就是有层次地文件目录结构，里面装着各种扩展名.py的python源程序文件，包中也可以含有包。</p><h3 id="1-3-库"><a href="#1-3-库" class="headerlink" title="1.3 库"></a>1.3 库</h3><p>库顾名思义则是功能相关联的包的集合。python的三大特色之一：强大的标准库，第三方库以及自定义模块。</p></div><h2 id="2-常用模块-x2F-库"><a href="#2-常用模块-x2F-库" class="headerlink" title="2. 常用模块&#x2F;库"></a>2. 常用模块&#x2F;库</h2><div class="story post-story"><p>python的三大特色对应三种类型的模块，标准库的内置模块，第三方库开源模块和自定义的模块，这里简单记录一下常用的模块&#x2F;库。</p><table><thead><tr><th>模块名称</th><th>介绍</th></tr></thead><tbody><tr><td><strong>内置模块</strong></td><td></td></tr><tr><td>os</td><td>普遍的操作系统功能接口，包括前面介绍的文件操作函数</td></tr><tr><td>sys</td><td>提供了一系列有关Python运行环境的变量和函数，sys.path.append()</td></tr><tr><td>random</td><td>生成随机数，random() 返回0&lt;n&lt;&#x3D;1</td></tr><tr><td>time</td><td>各种提供日期、时间功能的类和函数，time.time() 时间戳</td></tr><tr><td>datetime</td><td>对time模块的一个高级封装</td></tr><tr><td>logging</td><td>日志打印到了标准输出中</td></tr><tr><td>re</td><td>可以直接调用来实现正则匹配，re.split() 分割字符串，格式化列表</td></tr><tr><td>pymysql</td><td>连接数据库,并实现简单的增删改查</td></tr><tr><td>threading</td><td>提供了更强大的多线程管理方案</td></tr><tr><td>json</td><td>用于字符串和数据类型间进行转换json</td></tr><tr><td>subprocess</td><td>像linux一样创建运行子进程</td></tr><tr><td>shutil</td><td>对压缩包的处理、对文件和文件夹的高级处理，os的补充</td></tr><tr><td>tkinter</td><td>Python的标准Tk GUI工具包的接口</td></tr><tr><td><strong>第三方模块&#x2F;库</strong></td><td></td></tr><tr><td>Requsests</td><td>python最有名的第三方HTTP客户端库</td></tr><tr><td>Scrapy</td><td>屏幕抓取和web抓取框架，编写爬虫用到（上面的也可以）</td></tr><tr><td>Pillow</td><td>常用的图像处理库</td></tr><tr><td>Matplotlib</td><td>绘制二维数据图的库，使用方式对标matlab</td></tr><tr><td>NumPy</td><td>提供大型矩阵计算公式，在很多领域都用到</td></tr><tr><td>Pandas</td><td>基于Numpy 和 Matplotlib，和上面两个组成数据分析三剑客</td></tr><tr><td>Django</td><td>开源的web开发框架</td></tr><tr><td>PyTorch</td><td>开源的深度学习框架，各种张量操作、梯度计算，方便构建各种动态神经网络</td></tr><tr><td>TensorFlow</td><td>也是机器学习库，张量的操作和运算，tensorboard可视化数据很强大</td></tr></tbody></table><p>第三方库实在太多，这里只列举了我知道的比较常见的库；内置模块可以见1.1章节的官网链接，里面有所有内置模块的具体用法。接下来说说怎么导入模块和制作模块。</p></div><h2 id="3-导入包和模块"><a href="#3-导入包和模块" class="headerlink" title="3. 导入包和模块"></a>3. 导入包和模块</h2><div class="story post-story"><h3 id="3-1-导入模块"><a href="#3-1-导入模块" class="headerlink" title="3.1 导入模块"></a>3.1 导入模块</h3><p>制作模块要注意，<strong>自定义的模块名不能和系统内置的模块重名</strong>，否则被重名的系统模块无法被导入。</p><p>python中用关键字<strong>import</strong>引入某个模块，在调用模块中的函数时，需要以 <strong>模块名.函数名</strong> 的方式进行引用。自定义模块名中的函数是可以重名的，因为模块名不会相同（同一层目录下文件名不同），调用的时候可以进行区分，这很好理解。</p><h3 id="3-2-导入包"><a href="#3-2-导入包" class="headerlink" title="3.2 导入包"></a>3.2 导入包</h3><p>有的时候我们只需要包里的某个模块或者模块里的某个函数，而不需要包或者模块里的全部内容，这个时候我们可以用关键词 <strong>from 包名&#x2F;模块名 import 模块名&#x2F;函数名</strong> 来进行调用。</p><p>举个例子，在如下的文件结构中，main.py作为主程序入口，test文件夹相当于一个包，里面有4个.py后缀的模块，分别定义了四则运算的函数，__init__.py 是个空文件（暂时不做处理），声明test文件夹是个python包而不是普通的目录。</p><p><img src="https://www.shelven.com/tuchuang/20221129/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221129/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># add.py文件内容——定义加法运算</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="comment"># sub.py文件内容——定义减法运算</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a - b</span><br><span class="line"></span><br><span class="line"><span class="comment"># mul.py文件内容——定义乘法运算</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mul</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a * b</span><br><span class="line"></span><br><span class="line"><span class="comment"># dev.py文件内容——定义除法运算</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dev</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a / b</span><br></pre></td></tr></table></figure><p>我现在要做的是，在main.py文件里，导入test包里四个模块，调用各自模块中对应的函数，有以下几种调用方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># main.py的文件内容</span></span><br><span class="line"><span class="keyword">import</span> test.add<span class="comment"># 导入test包下的add模块</span></span><br><span class="line"><span class="keyword">import</span> test.sub <span class="keyword">as</span> sb<span class="comment"># 导入test包下的sub模块，并重命名为sb</span></span><br><span class="line"><span class="keyword">from</span> test <span class="keyword">import</span> mul<span class="comment"># 从test包中导入mul模块</span></span><br><span class="line"><span class="keyword">from</span> test.dev <span class="keyword">import</span> dev<span class="comment"># 从test包的dev模块导入dev函数，注意这里导入的是函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculate</span>(<span class="params">x, y, operate</span>):</span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> operate == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">        result = test.add.add(x, y)<span class="comment"># 调用test.add模块中的add函数</span></span><br><span class="line">    <span class="keyword">elif</span> operate == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        result = sb.sub(x, y)<span class="comment"># test.sub被重命名为sb，调用sb中的sub函数</span></span><br><span class="line">    <span class="keyword">elif</span> operate == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">        result = mul.mul(x, y)<span class="comment"># 调用mul模块中的mul函数</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        result = dev(x, y)<span class="comment"># dev函数已经被导入，可以直接调用函数名</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(calculate(<span class="number">100</span>, <span class="number">100</span>, <span class="string">&#x27;+&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(calculate(<span class="number">100</span>, <span class="number">100</span>, <span class="string">&#x27;-&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(calculate(<span class="number">100</span>, <span class="number">100</span>, <span class="string">&#x27;*&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(calculate(<span class="number">100</span>, <span class="number">100</span>, <span class="string">&#x27;/&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">200</span></span><br><span class="line"><span class="string">0</span></span><br><span class="line"><span class="string">10000</span></span><br><span class="line"><span class="string">1.0</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></div><h2 id="4-包和模块导入的思考"><a href="#4-包和模块导入的思考" class="headerlink" title="4. 包和模块导入的思考"></a>4. 包和模块导入的思考</h2><div class="story post-story"><h3 id="4-1-init-py的作用"><a href="#4-1-init-py的作用" class="headerlink" title="4.1 __init__.py的作用"></a>4.1 __init__.py的作用</h3><p>在上面的例子中__init__.py 是个空文件，是声明test文件夹是python包所必须的（<strong>主程序和包的位置在同一个目录下</strong>）。然而我们在编写main.py的主程序文件的时候，仍然要在开头导入相当多的模块，比较繁琐，这个时候可以在__init__.py中批量导入我们所需要的模块（导入包其实就是导入__init__.py文件）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在__init__.py中添加如下内容</span></span><br><span class="line"><span class="keyword">import</span> test.add</span><br><span class="line"><span class="keyword">import</span> test.sub</span><br><span class="line"><span class="keyword">import</span> test.mul</span><br><span class="line"><span class="keyword">import</span> test.dev</span><br><span class="line"></span><br><span class="line">add = test.add.add</span><br><span class="line">sub = test.sub.sub</span><br><span class="line">mul = test.mul.mul</span><br><span class="line">dev = test.dev.dev</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># main.py相应的改为如下内容</span></span><br><span class="line"><span class="keyword">from</span> test <span class="keyword">import</span> *<span class="comment"># 导入包相当于执行包下的__init__.py，这个文件已经将包里的四个模块分别导入了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculate</span>(<span class="params">x, y, operate</span>):</span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> operate == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">        result = add(x, y)</span><br><span class="line">    <span class="keyword">elif</span> operate == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        result = sub(x, y)</span><br><span class="line">    <span class="keyword">elif</span> operate == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">        result = mul(x, y)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        result = dev(x, y)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(calculate(<span class="number">100</span>, <span class="number">100</span>, <span class="string">&#x27;+&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(calculate(<span class="number">100</span>, <span class="number">100</span>, <span class="string">&#x27;-&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(calculate(<span class="number">100</span>, <span class="number">100</span>, <span class="string">&#x27;*&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(calculate(<span class="number">100</span>, <span class="number">100</span>, <span class="string">&#x27;/&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">200</span></span><br><span class="line"><span class="string">0</span></span><br><span class="line"><span class="string">10000</span></span><br><span class="line"><span class="string">1.0</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>可以看到上面的主程序代码量少了很多，起到简化代码的作用。</p><h3 id="4-2-if-name-x3D-x3D-‘-main-‘"><a href="#4-2-if-name-x3D-x3D-‘-main-‘" class="headerlink" title="4.2 if __name__ &#x3D;&#x3D; ‘__main__‘"></a>4.2 if __name__ &#x3D;&#x3D; ‘__main__‘</h3><p>首先来看一个现象，如果在add.py文件中不仅仅有定义函数的代码，还有编写代码时做的测试内容，如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># add.py文件中最后一行对这个函数做了测试</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">3</span>, <span class="number">4</span>))</span><br></pre></td></tr></table></figure><p>其他文件全都不变，再次运行main.py，会发现输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span><span class="comment"># add.py中测试内容也被输出</span></span><br><span class="line"><span class="number">200</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">10000</span></span><br><span class="line"><span class="number">1.0</span></span><br></pre></td></tr></table></figure><p>这显然不是我们想看到的，我们在导入add模块调用add函数的时候，并不想要其他无关的输出结果。</p><p>稍稍改变一下add.py内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># add.py文件内容</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(add(<span class="number">3</span>, <span class="number">4</span>))</span><br></pre></td></tr></table></figure><p>此时再次运行main.py则不会输出add.py中的测试内容。</p><p>首先要了解一个概念，在每个python文件创建的时候都有一个记录名称的变量__name__，当这个python文件作为脚本直接运行，那么__name__的值为‘”__main__“；当这个文件作为模块被导入其他文件中运行的时候，这个__name__的值为模块的名字，也就是说</p><ul><li><p><strong>当.py文件被直接运行时，if __name__ &#x3D;&#x3D; ‘__main__‘ 之下的代码块将被运行</strong></p></li><li><p><strong>当.py文件以模块形式被导入时，if __name__ &#x3D;&#x3D; ‘__main__‘ 之下的代码块不被运行</strong></p></li></ul><p>在导入的模块中有选择性地执行代码，这在实际开发应用中非常普遍。</p><h3 id="4-3-导入模块在主程序的父目录下"><a href="#4-3-导入模块在主程序的父目录下" class="headerlink" title="4.3 导入模块在主程序的父目录下"></a>4.3 导入模块在主程序的父目录下</h3><p>前面的导入模块操作，导入模块要么在主程序的子目录下（加入__init__.py 声明这是一个包），要么和主程序在同一个目录（直接import），如果导入模块在<strong>主程序的父目录</strong>下，应该怎么导入呢？</p><p>首先，按照一般流程直接import导入和加入__init__.py声明都会报错找不到这个包，这里就不演示了。</p><p>其实这个问题在前面的笔记中有记录，<a href="https://www.shelven.com/2022/04/29/a.html">点击这里</a>。 当时是刚用vscode搭建python环境，对python调用一知半解都算不上，现在才有了初步的理解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 两种解决办法</span></span><br><span class="line"><span class="comment"># 1.在主程序内部临时添加python运行环境路径</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">&#x27;父目录绝对路径或者相对路径&#x27;</span>)</span><br><span class="line"><span class="keyword">import</span> module</span><br><span class="line"><span class="comment"># 缺点：只能调用一次（临时加入的环境变量路径），且每个想要导入的自定义模块都要写一次，比较麻烦</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.在python安装目录下Libsite-packages中创建扩展名为.pth的文件，添加想要加入的路径。</span></span><br><span class="line"><span class="comment"># python在遍历已知的库文件目录过程中，如果见到一个.pth 文件，就会将文件中所记录的路径加入到sys.path设置中，于是.pth文件指向的地址也就可以被Python运行环境找到了。</span></span><br><span class="line"><span class="comment"># 这个已知的库文件目录可以通过sys.path查看。</span></span><br></pre></td></tr></table></figure><h3 id="4-4-相对导入"><a href="#4-4-相对导入" class="headerlink" title="4.4 相对导入"></a>4.4 相对导入</h3><p>前面3.2的例子中，包和模块的导入都是用的<strong>绝对导入</strong>（absolute import），导入时写明了工作环境中包的具体位置。</p><p>还有一种导入方式称为相对导入（relative import），还是用3.2的例子理解一下，在如下的文件结构中，主程序入口main.py和test包在同一层目录下，test包中有__init__.py（空文件），add.py和dev.py两个模块的内容如下：</p><p><img src="https://www.shelven.com/tuchuang/20221129/222.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221129/222.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># add.py内容</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="comment"># dev.py内容</span></span><br><span class="line"><span class="keyword">from</span> .add <span class="keyword">import</span> add<span class="comment"># 相对导入，从当前导入包的目录中找到add模块</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dev</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a / b</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>(<span class="params">a, b</span>):</span><br><span class="line">    a = dev(a, b) + add(a, b)</span><br><span class="line">    <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure><p>上面的例子意思是，我现在要在test包的dev.py模块中用add.py模块的函数方法（同一个包中的模块相互引用，这在实际工程中很常见）。如果dev.py是主程序，我们可以直接<code>import add</code>；但是我们这里main是主程序，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># main.py内容</span></span><br><span class="line"><span class="keyword">from</span> test <span class="keyword">import</span> dev</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(dev.func1(<span class="number">1</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>主程序main.py功能是导入test包dev模块，打印dev模块的函数func1(1, 2)执行结果。</p><p>如果我们在dev.py中直接导入<code>from add import add</code>（没有点，也就是不加当前目录），这个时候再运行main.py会报错找不到模块（因为main.py同目录下没有add.py模块）。这个时候就有两种导入方式，要么完善包名字，使用绝对导入<code>from test.add import add</code>；要么使用相对导入<code>from .add import add</code>。</p><p>这个相对导入就像是linux的文件操作方式，一个点代表当前目录，两个点代表父目录，还能用三个点表示linux无法做到的祖父目录，依此类推。</p><p><strong>相对导入的优点就一目了然：就算改变了包的名字，这个时候调用也不会出错，也就是简化代码，方便迁移。</strong></p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;前面介绍递归函数的时候用到了sys模块，介绍文件操作函数的时候用到了os模块，之前只是简单说了这两个模块下部分函数的用法，这里详细介绍一下对于模块、包和库的概念，以及一些常见的模块用法。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="编程自学" scheme="http://www.shelven.com/categories/%E7%BC%96%E7%A8%8B%E8%87%AA%E5%AD%A6/"/>
    
    
    <category term="python" scheme="http://www.shelven.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python自学笔记（6）——函数的变量和高级用法</title>
    <link href="http://www.shelven.com/2022/11/29/a.html"/>
    <id>http://www.shelven.com/2022/11/29/a.html</id>
    <published>2022-11-28T18:37:37.000Z</published>
    <updated>2022-12-03T15:54:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>前面在通过讲什么是高阶函数（能够接受函数作为参数传入的函数，或者可以返回函数对象的函数）引出了装饰器的由来和存在的意义。这里对python函数的其他基础概念做个补充和记录。</p><span id="more"></span><h2 id="1-函数的变量"><a href="#1-函数的变量" class="headerlink" title="1. 函数的变量"></a>1. 函数的变量</h2><div class="story post-story"><p>之前笔记中的例子已经对函数参数传递过程做了总结，提到了怎么调用函数的返回值，怎么实现函数的嵌套，基本概念用法都已经提过，这里只是做个思考和补充。</p><h3 id="1-1-局部变量"><a href="#1-1-局部变量" class="headerlink" title="1.1 局部变量"></a>1.1 局部变量</h3><ul><li>函数内部的定义的变量</li><li>局部变量只在函数内部生效，不同函数可以拥有同名的局部变量，互不影响（作用域为本函数）</li><li>局部变量的作用，为了临时保存数据需要在函数中定义变量来进行存储</li><li>局部变量在函数执行时被创建，函数执行完成后，局部变量会被系统回收</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 局部变量重名互不影响，只作用在当前函数中</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">added</span>(<span class="params">a, b</span>):</span><br><span class="line">    c = a + b</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">a, b</span>):</span><br><span class="line">    c = <span class="built_in">str</span>(a) + <span class="built_in">str</span>(b)</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(added(<span class="number">4</span>, <span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span>(connect(<span class="string">&#x27;Phantom&#x27;</span>, <span class="string">&#x27;Aria&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">9</span></span><br><span class="line"><span class="string">PhantomAria</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="1-2-全局变量"><a href="#1-2-全局变量" class="headerlink" title="1.2 全局变量"></a>1.2 全局变量</h3><ul><li>函数外部定义的变量</li><li>全局变量可以在多个函数中使用（作用域为所有函数）</li><li>全局变量如果和局部变量重名，<strong>只会使用局部变量</strong>（就近原则）</li><li>如果<strong>在函数中修改不可变类型全局变量</strong>，需要使用<strong>global声明</strong></li></ul><p>这里有一个很有意思的现象，前面在数据类型里说过，数据可以分为可变数据类型（列表，字典，集合）和不可变数据类型（数字，元组，字符串），而<strong>python的所有参数传递都是引用传递而非值传递</strong>。因此，对于可变类型的全局变量，在函数中可以被修改；而对于不可变全局对象则无法在函数中直接修改，其本质是修改不可变数据系统会创建一个新的对象（分配一个新的内存地址），然而这个对象名已经被占用了（也就是变量名无法被指向，原来的变量名也没有被收回）。下面举个栗子。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不可变类型全局变量在函数内部可以传递使用但是无法直接修改</span></span><br><span class="line">x = <span class="number">100</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">added</span>():</span><br><span class="line">    x = x + <span class="number">1</span>       <span class="comment"># 不可变数据修改，系统会创建新的对象，而变量名x已经是全局变量的变量名，无法成为新的对象的变量名</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">added()</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">---------------------------------------------------------------------------</span></span><br><span class="line"><span class="string">UnboundLocalError                         Traceback (most recent call last)</span></span><br><span class="line"><span class="string">d:\zhuomian\python\test.ipynb Cell 47 in &lt;cell line: 6&gt;()</span></span><br><span class="line"><span class="string">      3     x = x + 1</span></span><br><span class="line"><span class="string">      4     return x</span></span><br><span class="line"><span class="string">----&gt; 6 added(4)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">d:\zhuomian\python\test.ipynb Cell 47 in added(a)</span></span><br><span class="line"><span class="string">      2 def added(a):</span></span><br><span class="line"><span class="string">----&gt; 3     x = x + 1</span></span><br><span class="line"><span class="string">      4     return x</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">UnboundLocalError: local variable &#x27;x&#x27; referenced before assignment</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>对于global是如何运作，使得python解释器可以将不可变全局变量进行修改的？这点以我的功底还无法解释……暂时只能知道是这么个用法。</p><p>顺带一提，还有个嵌套函数对外围函数的不可变变量进行修改，需要用到类似的<strong>nonlocal</strong>进行声明。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">100</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">added</span>():</span><br><span class="line">    <span class="keyword">global</span> x        <span class="comment"># global声明x为全局变量</span></span><br><span class="line">    x = x + <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line">added()</span><br><span class="line">added()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">A</span>():</span><br><span class="line">    y = <span class="number">200</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">B</span>():</span><br><span class="line">        <span class="keyword">nonlocal</span> y      <span class="comment"># nonlocal声明y为外围函数的变量（不是全局变量！）</span></span><br><span class="line">        y = y + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line">    <span class="keyword">return</span> B</span><br><span class="line">test = A()</span><br><span class="line"><span class="built_in">print</span>(test())</span><br><span class="line"><span class="built_in">print</span>(test())</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">101</span></span><br><span class="line"><span class="string">102</span></span><br><span class="line"><span class="string">201</span></span><br><span class="line"><span class="string">202</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>上面的例子本质上是一样的，对于嵌套函数来说，要修改外围函数的不可变类型的变量（看起来似乎矛盾，不可变的怎么能叫变量呢？前面已经说过，重新赋值造成数字和字符串看起来是“可变的”假象，这里分清两个变分别指什么意思），相当于是上面例子的在函数内修改不可变类型的全局变量（作用域不同，只能说相当于），只不过二者<strong>声明的方式不同</strong>。</p><h3 id="1-3-修改可变全局变量引起的思考"><a href="#1-3-修改可变全局变量引起的思考" class="headerlink" title="1.3 修改可变全局变量引起的思考"></a>1.3 修改可变全局变量引起的思考</h3><p>一个很有意思的现象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add1</span>(<span class="params">ls</span>):</span><br><span class="line">    ls = ls + ls</span><br><span class="line"></span><br><span class="line">b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add2</span>(<span class="params">ls</span>):</span><br><span class="line">    ls += ls</span><br><span class="line"></span><br><span class="line">add1(a)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">add2(b)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">[1, 2, 3]</span></span><br><span class="line"><span class="string">[1, 2, 3, 1, 2, 3]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>a列表和b列表都是<strong>可变全局变量</strong>，同一个算法，为什么a在传入函数执行之后没有发生改变呢？</p><p>这里需要对可变数据类型做个回顾，可变对象可以对自身内容进行<strong>原地修改</strong>而不改变存储地址。原地修改画个重点，意思是利用方法比如reverse、sort、append等在<strong>原有对象上直接修改</strong>。</p><ul><li><p>‘&#x3D;’ 是赋值语句，将右边的表达式的结果对象，引用绑定到等号左边的变量名上。赋值是<strong>创建一个新对象</strong>，赋值给目标，返回的也是新对象，<strong>引用地址会发生改变</strong>。</p></li><li><p>‘+&#x3D;’ 是增强赋值语句，对左边的对象进行<strong>原地修改</strong>，返回值为None，<strong>引用地址不变</strong>。</p></li></ul><p>看到这里就能明白上面两个看似“同样”的操作为什么会返回不一样的结果，也加深了“可变”与“不可变”的理解。</p></div><h2 id="2-函数的高级用法"><a href="#2-函数的高级用法" class="headerlink" title="2. 函数的高级用法"></a>2. 函数的高级用法</h2><div class="story post-story"><p>前一篇笔记写的<strong>装饰器</strong>就是函数的高级用法之一，这里做个完善补充。</p><h3 id="2-1-匿名函数"><a href="#2-1-匿名函数" class="headerlink" title="2.1 匿名函数"></a>2.1 匿名函数</h3><p>除了用def关键字命名函数这种基础方法之外，还可以使用lambda表达式创建匿名函数。</p><p>lambda语法格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> param1,...paramN:expression</span><br></pre></td></tr></table></figure><p>匿名函数的语法比较简洁，能接受任何数量的参数但只能返回一个表达式的值。因为匿名函数比较简洁小巧，也常用在作为参数进行传递。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义匿名函数</span></span><br><span class="line">func1 = <span class="keyword">lambda</span> x, y : x + y</span><br><span class="line">result = func1(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;匿名函数func1执行结果：&quot;</span>,result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 匿名函数作为参数传递</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func2</span>(<span class="params">x, y, opt</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;函数func2执行结果为：&#x27;</span>, opt(x, y))</span><br><span class="line"></span><br><span class="line">func2(<span class="number">4</span>, <span class="number">5</span>, <span class="keyword">lambda</span> x, y : x + y)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">匿名函数func1执行结果： 3</span></span><br><span class="line"><span class="string">函数func2执行结果为： 9</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-嵌套调用"><a href="#2-2-嵌套调用" class="headerlink" title="2.2 嵌套调用"></a>2.2 嵌套调用</h3><p>相比来说函数嵌套调用可能算不上是高级用法，不过这里还是补充一下。嵌套调用指一个函数里调用另一个函数，<strong>注意和嵌套函数区分</strong>。</p><p>一个简单的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>():        <span class="comment"># 定义一个函数</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;第一个函数输出Phantom&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func2</span>():        <span class="comment"># 定义第二个函数</span></span><br><span class="line">    func1()     <span class="comment"># 在第二个函数里调用第一个函数功能</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;第二个函数输出Aria&#x27;</span>)</span><br><span class="line"></span><br><span class="line">func2()     <span class="comment"># 执行一个函数，实际上两个函数都执行了一遍</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">第一个函数输出Phantom</span></span><br><span class="line"><span class="string">第二个函数输出Aria</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="2-3-递归函数"><a href="#2-3-递归函数" class="headerlink" title="2.3 递归函数"></a>2.3 递归函数</h3><p>递归函数就是在一个函数内部调用自身的函数，本质上是一个循环，循环结束的点就是递归出口。</p><p>用阶乘举个最简单的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用迭代实现阶乘算法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">factorial</span>(<span class="params">n</span>):</span><br><span class="line">    result = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n +<span class="number">1</span>):</span><br><span class="line">        result *= i</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用递归实现阶乘算法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">factorial_1</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> n * factorial_1(n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(factorial(<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(factorial_1(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">3628800</span></span><br><span class="line"><span class="string">3628800</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><ul><li><p>迭代的方法，从1开始，进入for循环对之前的结果累积乘以 i，直至 n（上例函数被调用了1次）。</p></li><li><p>递归的方式更为直观，每次通过递减数字的方式递归调用自己（上例函数被调用了10次）。</p></li></ul><p><strong>整体上看递归更简洁明了，但是相比迭代会占用更多内存，运行时间会更长</strong>。</p><p>递归有最大深度限制，在计算机中，函数名、参数、值类型等，都是存放在栈上的。每进行一次函数调用，就会在栈上加一层，函数返回就减一层，由于栈的大小是有限的，递归次数过多就会导致<strong>堆栈溢出</strong>。</p><p>可以调用sys模块，<code>sys.setrecursionlimit(2000)</code>将栈的大小调整为2000，<code>sys.getrecursionlimit()</code>查看当前设置的最大递归深度。这种调整递归深度的方式不是无限大的，我的jupyter在调用递归函数3000次的时候就会直接退出……模块定义和调用方式后一篇笔记再说。</p></div><h2 id="3-文件操作函数"><a href="#3-文件操作函数" class="headerlink" title="3. 文件操作函数"></a>3. 文件操作函数</h2><div class="story post-story"><h3 id="3-1-open-amp-close"><a href="#3-1-open-amp-close" class="headerlink" title="3.1 open() &amp; close()"></a>3.1 open() &amp; close()</h3><p>函数open()可以<strong>打开一个文件，或者创建一个新文件</strong>，函数close()可以关闭文件。两者语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;文件名&#x27;</span>, <span class="string">&#x27;访问模式&#x27;</span>)</span><br><span class="line">f.close()       <span class="comment"># 注意最后一定要有close()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;文件名&#x27;</span>, <span class="string">&#x27;访问模式&#x27;</span>) <span class="keyword">as</span> f:       <span class="comment"># 自动调用close()</span></span><br><span class="line">    f.方法()</span><br></pre></td></tr></table></figure><table><thead><tr><th>访问模式</th><th>说明</th></tr></thead><tbody><tr><td>r</td><td>只读方式打开文件，默认模式，打开文件必须存在。</td></tr><tr><td>w</td><td>写入方式打开文件，已存在的文件会覆盖内容（相当于linux重定向操作符&gt;）。</td></tr><tr><td>a</td><td>追加方式打开文件，已存在的文件会将内容写到最后（相当于linux重定向操作符&gt;&gt;）。</td></tr><tr><td>x</td><td>只写方式打开文件，新建一个文件，若文件存在则报错。</td></tr><tr><td>r+</td><td>读写方式打开文件，打开文件必须存在。</td></tr><tr><td>w+</td><td>读写方式打开文件，已存在的文件会覆盖内容。</td></tr><tr><td>a+</td><td>读写方式打开文件，已存在的文件会将内容写到最后。</td></tr></tbody></table><p>一般用 with open() as 的方式打开文件，这种方式会自动帮我们调用f.close()</p><h3 id="3-2-write-amp-read"><a href="#3-2-write-amp-read" class="headerlink" title="3.2 write() &amp; read()"></a>3.2 write() &amp; read()</h3><p>write()向文件写入数据，以w方式访问，如果文件名存在会先清空文件内容，文件名不存在则新建；以a方式访问，如果文件名存在则续写，文件名不存在则新建；以r方式访问则报错。</p><p>read()从文件中读取数据，括号里面的参数代表读取的数据长度（字节数），如果不传入参数则读取所有数据。</p><p>readline()读取一行，同时会读取一行最后的换行符\n，所以打印出来的时候会多一行空行。</p><p>readlines()按照行的方式读取整个文件数据，返回的是一个列表，每行数据是一个元素，同样会读到换行符\n并且显示出来。</p><p>需要注意一点，<strong>在多次读取的操作中，后一次读取会从上一次读完的位置开始。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:    <span class="comment"># 只写模式创建一个新文件</span></span><br><span class="line">    f.write(<span class="string">&#x27;My name is Phantom. \nI am Aria.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> f:    <span class="comment"># 追加模式进行续写</span></span><br><span class="line">    f.write(<span class="string">&#x27;\nWell, it\&#x27;s been so long.&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">生成的test.txt内容：        # 实际前面两行末尾都有换行符</span></span><br><span class="line"><span class="string">My name is Phantom.</span></span><br><span class="line"><span class="string">I am Aria.</span></span><br><span class="line"><span class="string">Well, it&#x27;s been so long.</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:    <span class="comment"># 只读方式打开文件</span></span><br><span class="line">    line = f.read(<span class="number">1</span>)        <span class="comment"># read读取第一个字节</span></span><br><span class="line">    <span class="built_in">print</span>(line)</span><br><span class="line">    line = f.readline()     <span class="comment"># readline读取第一个字节后的第一行，因为读取了换行符，所以运行结果多一行空行</span></span><br><span class="line">    <span class="built_in">print</span>(line)</span><br><span class="line">    line = f.readlines()    <span class="comment"># readlines读取接下来的两行，每行数据为一个元素，返回一个列表</span></span><br><span class="line">    <span class="built_in">print</span>(line)</span><br><span class="line">    </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">M</span></span><br><span class="line"><span class="string">y name is Phantom. </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[&#x27;I am Aria.\n&#x27;, &quot;Well, it&#x27;s been so long.&quot;]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="3-3-os模块的文件操作函数"><a href="#3-3-os模块的文件操作函数" class="headerlink" title="3.3 os模块的文件操作函数"></a>3.3 os模块的文件操作函数</h3><p>os模块和上面递归函数最后提到的sys模块用的非常多，下篇笔记再详细说明，这里就记一下用法。</p><p>这几个函数也非常直观，举个例子就知道分别有什么作用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.rename(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;TEST.txt&#x27;</span>)   <span class="comment"># 文件重命名</span></span><br><span class="line">os.remove(<span class="string">&#x27;TEST.txt&#x27;</span>)   <span class="comment"># 文件删除</span></span><br><span class="line">os.mkdir(<span class="string">&#x27;./test&#x27;</span>)      <span class="comment"># 创建文件夹，文件夹存在的话会报错,且只能创建一级目录</span></span><br><span class="line">os.rmdir(<span class="string">&#x27;./test&#x27;</span>)      <span class="comment"># 删除文件夹</span></span><br><span class="line">os.makedirs(<span class="string">&#x27;./TEST/TEST1/TEST2&#x27;</span>)   <span class="comment">#递归的方式创建多级目录</span></span><br></pre></td></tr></table></figure></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;前面在通过讲什么是高阶函数（能够接受函数作为参数传入的函数，或者可以返回函数对象的函数）引出了装饰器的由来和存在的意义。这里对python函数的其他基础概念做个补充和记录。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="编程自学" scheme="http://www.shelven.com/categories/%E7%BC%96%E7%A8%8B%E8%87%AA%E5%AD%A6/"/>
    
    
    <category term="python" scheme="http://www.shelven.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python自学笔记（5）——装饰器</title>
    <link href="http://www.shelven.com/2022/11/28/a.html"/>
    <id>http://www.shelven.com/2022/11/28/a.html</id>
    <published>2022-11-27T19:03:55.000Z</published>
    <updated>2022-12-03T15:55:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>这里讲一讲前面提到的python装饰器，@classmethod和@staticmethod是python内置装饰器，在了解什么是装饰器之前首先要了解函数的几个特征。</p><span id="more"></span><h2 id="1-有关函数的几个概念"><a href="#1-有关函数的几个概念" class="headerlink" title="1. 有关函数的几个概念"></a>1. 有关函数的几个概念</h2><div class="story post-story"><h3 id="1-1-函数可以接收另一个函数作为参数传入"><a href="#1-1-函数可以接收另一个函数作为参数传入" class="headerlink" title="1.1 函数可以接收另一个函数作为参数传入"></a>1.1 函数可以接收另一个函数作为参数传入</h3><p>高阶函数可以接收另一个函数作为传入的参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 高阶函数，函数func2接收函数作为参数传入</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func2</span>(<span class="params">func, m, n</span>):</span><br><span class="line">    <span class="keyword">return</span> func(m, n)</span><br><span class="line"></span><br><span class="line">func2(func1, <span class="number">1</span>, <span class="number">2</span>)  </span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>从上面例子可以看到，在执行 func2函数的时候，函数对象func1作为参数被传入func2，返回func1(1, 2)的执行结果也就是3.</p><h3 id="1-2-函数可以把另一个函数作为结果返回"><a href="#1-2-函数可以把另一个函数作为结果返回" class="headerlink" title="1.2 函数可以把另一个函数作为结果返回"></a>1.2 函数可以把另一个函数作为结果返回</h3><p>高阶函数也可以将函数作为结果返回：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 高阶函数，把函数作为结果返回</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func2</span>():    <span class="comment"># 内层函数（嵌套函数）</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;执行func2函数&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> func2        <span class="comment"># 返回内层函数的引用</span></span><br><span class="line"></span><br><span class="line">a = func1()     <span class="comment"># 返回的函数对象func2的引用赋值给a</span></span><br><span class="line"><span class="built_in">print</span>(a)        <span class="comment"># 打印函数对象，获得存储地址</span></span><br><span class="line">a()     <span class="comment"># 执行内层函数func2()的功能</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">&lt;function func1.&lt;locals&gt;.func2 at 0x00000288D3701750&gt;</span></span><br><span class="line"><span class="string">执行func2函数</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>上面的例子可以看到，外围函数 func1将内层函数 func2的引用赋值给a，此时a就有了内层函数func2 的方法，此时打印的a是函数的存储地址，执行a() 就可以执行func2 函数的功能。</p><h3 id="1-3-嵌套函数可以引用外层函数的变量"><a href="#1-3-嵌套函数可以引用外层函数的变量" class="headerlink" title="1.3 嵌套函数可以引用外层函数的变量"></a>1.3 嵌套函数可以引用外层函数的变量</h3><p>稍稍修改1.2的例子，在外层函数添加局部变量msg：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>():    <span class="comment"># 外围函数</span></span><br><span class="line">    msg = <span class="string">&#x27;I am Phantom&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func2</span>():    <span class="comment"># 内层函数（嵌套函数）</span></span><br><span class="line">        <span class="built_in">print</span>(msg)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> func2</span><br><span class="line"></span><br><span class="line">a = func1()     <span class="comment"># 实际上这里获得的就是一个闭包</span></span><br><span class="line">a()     <span class="comment"># 引用外层函数的变量，执行内层函数func2()的功能</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">I am Phantom</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>这里先引用闭包的概念：</p><blockquote><p><strong>闭包</strong>：指延伸了作用域的函数，其中包含函数定义体中引用、但是不在定义体中定义的非全局变量。概念比较晦涩，简单来说就是<strong>嵌套函数引用了外层函数的变量</strong>。</p></blockquote><p>这个例子和上个例子唯一的区别是，msg是一个在外围函数中的局部变量，在print_msg()函数执行之后应该就不会存在了。但是嵌套函数引用了这个变量，将这个局部变量封闭在了嵌套函数中，这样就形成了一个<strong>闭包</strong>。</p><p>有了以上关于高阶函数和闭包的概念后，就可以开始理解什么是装饰器以及装饰器的作用了。</p></div><h2 id="2-装饰器decorator"><a href="#2-装饰器decorator" class="headerlink" title="2. 装饰器decorator"></a>2. 装饰器decorator</h2><div class="story post-story"><p><strong>装饰器的本质就是一个闭包，把一个函数当做参数然后返回一个替代版函数（函数的引用）。</strong></p><h3 id="2-1-标识符将装饰器应用到函数"><a href="#2-1-标识符将装饰器应用到函数" class="headerlink" title="2.1 @标识符将装饰器应用到函数"></a>2.1 @标识符将装饰器应用到函数</h3><p>下面将用代码方式简单演示装饰器是怎么应用的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>(<span class="params">func3</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func2</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;被装饰的函数<span class="subst">&#123;func3.__name__&#125;</span>即将执行&#x27;</span>)</span><br><span class="line">        func3()     <span class="comment"># 被装饰的函数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;被装饰的函数<span class="subst">&#123;func3.__name__&#125;</span>执行结束&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> func2</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">funcx</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;函数正在运行&#x27;</span>)</span><br><span class="line"></span><br><span class="line">a = func1(funcx)        <span class="comment"># 1</span></span><br><span class="line">a()     <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">被装饰的函数funcx即将执行</span></span><br><span class="line"><span class="string">函数正在运行</span></span><br><span class="line"><span class="string">被装饰的函数funcx执行结束</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>上面这个例子就是不用@标识符的装饰器，首先我定义了一个函数func1，它只有一个func3参数，这个函数里面定义了一个嵌套函数func2。func2的作用是调用func3前打印一串字符，然后执行被装饰的函数func3，结束之后再打印一串字符。</p><p>我们再定义一个测试函数funcx，功能是打印一段“函数正在运行”的字符串。</p><p>在1处，函数func1中传入函数funcx，返回函数func2的引用赋值给变量a，此时并没有执行函数，也不会有打印结果。在2处执行了func2函数，前面传入的函数funcx作为参数在原先的func3处执行，这个时候就会依次输出三行字符串。</p><p><strong>将@标识符应用到函数上，只需要在函数定义前加上@和装饰器的名称即可。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>(<span class="params">func3</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func2</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;被装饰的函数<span class="subst">&#123;func3.__name__&#125;</span>即将执行&#x27;</span>)</span><br><span class="line">        func3()     <span class="comment"># 被装饰函数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;被装饰的函数<span class="subst">&#123;func3.__name__&#125;</span>执行结束&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> func2</span><br><span class="line"></span><br><span class="line"><span class="meta">@func1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">funcx</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;函数正在运行&#x27;</span>)</span><br><span class="line"></span><br><span class="line">funcx()</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">被装饰的函数funcx即将执行</span></span><br><span class="line"><span class="string">函数正在运行</span></span><br><span class="line"><span class="string">被装饰的函数funcx执行结束</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>这里@func1就是装饰器，它接受被装饰的函数作为参数传入，返回内部嵌套函数的引用（注意这个时候并没有执行函数），内部嵌套函数func2持有被装饰函数func3的引用。</p><p>可以看到@语法只是将函数传入装饰器函数，并不是什么特别难理解的概念，主要作用就是节省代码量（避免了再一次的赋值操作）。</p><h3 id="2-2-带参数的装饰器"><a href="#2-2-带参数的装饰器" class="headerlink" title="2.2 带参数的装饰器"></a>2.2 带参数的装饰器</h3><p>前面示范的是不带参数的装饰器，带参数的装饰器也是类似的，我们只要知道<strong>装饰器最终返回的一定是嵌套函数的引用</strong>。在前面的参数传递博文中，我们说过<strong>*args和**kargs</strong>可以以包裹传递的方式传递不定长参数，这里也是一样的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>(<span class="params">func3</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func2</span>(<span class="params">*args, **kargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;被装饰的函数<span class="subst">&#123;func3.__name__&#125;</span>即将执行&#x27;</span>)</span><br><span class="line">        func3(*args, **kargs)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;被装饰的函数<span class="subst">&#123;func3.__name__&#125;</span>执行结束&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> func2</span><br><span class="line"></span><br><span class="line"><span class="meta">@func1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">funcx</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="built_in">print</span>(a + b)</span><br><span class="line"></span><br><span class="line"><span class="meta">@func1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">funcy</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(a) + <span class="built_in">str</span>(b) + <span class="built_in">str</span>(c))</span><br><span class="line"></span><br><span class="line">funcx(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*************************&#x27;</span>)</span><br><span class="line">funcy(<span class="string">&#x27;Phan&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;om&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">被装饰的函数funcx即将执行</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">被装饰的函数funcx执行结束</span></span><br><span class="line"><span class="string">*************************</span></span><br><span class="line"><span class="string">被装饰的函数funcy即将执行</span></span><br><span class="line"><span class="string">Phantom</span></span><br><span class="line"><span class="string">被装饰的函数funcy执行结束</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>上面的装饰器带的参数都是我们后面<strong>自定义函数里的参数</strong>，装饰器的语法允许我们在调用时提供<strong>其他参数</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#import functools</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>(<span class="params">text</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">func</span>):</span><br><span class="line">       <span class="comment"># @functools.wraps(func)</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">func2</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            <span class="keyword">if</span> text == <span class="string">&#x27;Phantom&#x27;</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;%s 正在运行&#x27;</span> % func.__name__)</span><br><span class="line">                <span class="built_in">print</span>(*args)</span><br><span class="line">                <span class="built_in">print</span>(text)</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> func2</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line">     </span><br><span class="line"><span class="meta">@func1(<span class="params">text = <span class="string">&quot;Phantom&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">funcx</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="built_in">print</span>(funcx.__name__)</span><br><span class="line"></span><br><span class="line">funcx(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">注释的运行结果：</span></span><br><span class="line"><span class="string">funcx 正在运行</span></span><br><span class="line"><span class="string">test</span></span><br><span class="line"><span class="string">Phantom</span></span><br><span class="line"><span class="string">func2</span></span><br><span class="line"><span class="string">*************************</span></span><br><span class="line"><span class="string">去掉注释的运行结果：</span></span><br><span class="line"><span class="string">funcx 正在运行</span></span><br><span class="line"><span class="string">test</span></span><br><span class="line"><span class="string">Phantom</span></span><br><span class="line"><span class="string">funcx</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>先不看导入的模块，后面再解释。</p><p>上面的例子看上去很复杂，可以一层一层剥开理解。func1是允许带参数的装饰器，实际上是<strong>原有装饰器decorator的再一次封装</strong>，并且返回了这个装饰器，可以理解为含有一个形参text的闭包。当我们使用@func1(text &#x3D; “Phantom”)时，python解释器将我们的实参“Phantom”传入到装饰器的环境。</p><p>而嵌套函数func2在检查到传入的text参数与字符串“Phantom”相同时，就会执行后面的打印函数名、funcx传入的实参和func1传入到decorate的实参。</p><p>通过特殊属性__name__可以看到，funcx函数指向了装饰器内部定义的func2函数，也就是经过装饰器装饰后丢失了原函数的元信息，<strong>我们真正调用的是装饰后生成的新函数</strong>。那么是不是每次都要使用<code>func2.__name__ = func.__name__</code>这样的代码来保留原函数信息呢？并不是，我们可以使用<strong>functools库中的@functools.wraps()来保留原函数的属性</strong>，其实这种保留只是将原始被装饰的函数的属性拷贝给了装饰函数，如果不干这件事，有些依赖函数签名的代码执行就会出错，感兴趣的小伙伴可以继续探究~</p><h3 id="2-3-内置装饰器"><a href="#2-3-内置装饰器" class="headerlink" title="2.3 内置装饰器"></a>2.3 内置装饰器</h3><p>上面说的@functools.wraps()其实也是内置装饰器，下面介绍其他几个常用的内置装饰器。</p><h4 id="2-3-1-property"><a href="#2-3-1-property" class="headerlink" title="2.3.1 @property"></a>2.3.1 @property</h4><p>这个内置装饰器用来装饰类函数，被装饰的类函数不可以在类被实例化后调用，只能通过访问与函数同名的属性进行调用（<strong>也就是把类的方法伪装成属性</strong>）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>():</span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">func1</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Phantom&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">  @property</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">func2</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Aria&#x27;</span>)</span><br><span class="line">  </span><br><span class="line">a = A()     <span class="comment"># 实例化一个对象</span></span><br><span class="line"></span><br><span class="line">a.func1()   <span class="comment"># 通过实例化对象访问类方法</span></span><br><span class="line">a.func2     <span class="comment"># 通过实例化对象将类方法伪装成属性调用</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">Phantom</span></span><br><span class="line"><span class="string">Aria</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>我们知道属性是可以被赋值的，但是<strong>经过property装饰的方法不可以像普通属性那样被赋值</strong>。</p><p>这个特性很有意思，我们可以实现对python类私有属性的安全访问（再次强调不存在严格意义的私有属性）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    __number = <span class="string">&#x27;Phantom&#x27;</span>        <span class="comment"># 类内的私有属性</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">number</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__number</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(a.__number)       <span class="comment"># 尝试直接访问类内的私有属性失败</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;访问私有属性失败&quot;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(a.number)     <span class="comment"># 通过类方法伪装的属性访问私有属性成功</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;访问私有属性成功&quot;</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    a.number = <span class="number">1</span>        <span class="comment"># 类方法伪装的属性无法被赋值</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;修改私有属性失败&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">访问私有属性失败</span></span><br><span class="line"><span class="string">Phantom</span></span><br><span class="line"><span class="string">访问私有属性成功</span></span><br><span class="line"><span class="string">修改私有属性失败</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="2-3-2-classmethod"><a href="#2-3-2-classmethod" class="headerlink" title="2.3.2 @classmethod"></a>2.3.2 @classmethod</h4><p>直接翻译，这个装饰器就是用来定义类方法的，<strong>被装饰的函数必须有一个cls参数用来绑定类本身</strong>，隐式地将类作为对象，传递给方法，调用地时候不需要进行实例化。</p><p>如果不加这个装饰器，<strong>必须要使用self参数</strong>，隐式地将类实例传递给方法，也就是说必须要实例化。</p><p><strong>强调一点，这里地cls和self只是为了方便编程的时候一眼看出来绑定的是类还是对象，都可以用别的xxx名字代替（但是不建议）。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>():</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">func1</span>(<span class="params">self,x,y</span>):      <span class="comment"># 实例方法</span></span><br><span class="line">    <span class="keyword">return</span> x * y</span><br><span class="line">  </span><br><span class="line"><span class="meta">  @classmethod</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">func2</span>(<span class="params">cls,x,y</span>):       <span class="comment"># 类方法</span></span><br><span class="line">    <span class="keyword">return</span> x * y</span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(A().func1(<span class="number">5</span>,<span class="number">5</span>))       <span class="comment"># 必须实例化A()之后通过实例化对象才可以调用方法</span></span><br><span class="line"><span class="built_in">print</span>(A.func2(<span class="number">5</span>,<span class="number">5</span>))     <span class="comment"># 不需要实例化，直接通过类对象调用</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">25</span></span><br><span class="line"><span class="string">25</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>由于被classmethod装饰的函数强制暴露了类自身，所以我们可以通过被classmethod装饰的函数对类的静态变量进行一定操作，在实例化之前和类进行交互。还有类方法可以通过实例对象或者类对象去访问，<a href="https://www.shelven.com/2022/11/25/a.html">所以有一个用途就是通过实例调用类方法实现对类属性的修改（点击见第三篇博客例子）</a>。</p><h4 id="2-3-3-staticmethod"><a href="#2-3-3-staticmethod" class="headerlink" title="2.3.3 @staticmethod"></a>2.3.3 @staticmethod</h4><p>前面博客介绍过，这个装饰器是声明静态方法的，静态方法和上面的类方法一样，不需要实例化就可以直接调用，但是<strong>这个方法不强制要求传递参数</strong>，无法直接使用任何类变量、类方法或者实例方法、实例变量（这里要注意，<strong>只有主动传参才可以调用</strong>，因为主动传参是可以按照逻辑去找需要的参数的）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>():</span><br><span class="line">    name = <span class="string">&#x27;Phantom&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name = <span class="string">&#x27;Aria&#x27;</span></span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getName</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;静态方法调用类属性&#x27;</span>, People.name)        </span><br><span class="line">        <span class="comment">#print(self.name)       #不能调用实例的属性，会报错，名义上是类方法，实际已经和类无关</span></span><br><span class="line"></span><br><span class="line">p = People()</span><br><span class="line">p.getName()     <span class="comment"># 可以通过 类.方法名 或者 实例.方法名 进行调用 </span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">静态方法调用类属性 Phantom</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>staticmethod更像是与实例无关但与类封装功能有关的函数，如果有一个功能实现的方法比较独立，可以考虑用静态方法来实现。</p><p>在继承类中，staticmethod和classmethod有以下区别</p><blockquote><p>子类的实例继承了父类的@staticmethod静态方法，调用该方法，还是调用的父类的方法和类属性。</p><p>子类的实例继承了父类的@classmethod类方法，调用该方法，调用的是子类的方法和子类的类属性。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>():</span><br><span class="line">    name = <span class="string">&#x27;Phantom&#x27;</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func1</span>():</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">print</span>(A.name)</span><br><span class="line">  </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func2</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">print</span>(cls.name)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    name = <span class="string">&#x27;Aria&#x27;</span></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">a.func1()</span><br><span class="line">a.func2()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;***********************&#x27;</span>)</span><br><span class="line">b = B()</span><br><span class="line">b.func1()</span><br><span class="line">b.func2()</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">Phantom</span></span><br><span class="line"><span class="string">Phantom</span></span><br><span class="line"><span class="string">***********************</span></span><br><span class="line"><span class="string">Phantom</span></span><br><span class="line"><span class="string">Aria</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>上面这个例子可以看出来，@classmethod装饰后的func1函数实际上已经和父类没什么关系了，尽管在父类方法里但也可以当作是个独立的函数，不管子类的实例化还是父类的实例化都是调用同一个函数，输出结果一致。而@classmethod装饰后的func2函数，cls参数绑定了类本身，子类在实例化后继承了父类@classmethod类方法，但是调用的是子类的方法和类属性。</p><p>所有装饰器存在的意义都是为函数扩展功能，总结以下几点：</p><blockquote><p>装饰器通过高级函数、嵌套函数和闭包实现</p><p>装饰器返回闭包函数的引用，这个闭包函数引用中有被装饰函数的引用</p><p>装饰器通过语法糖 @ 修饰</p><p>装饰器不修改原函数和调用方式（调用的是装饰后的新函数）</p></blockquote></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;这里讲一讲前面提到的python装饰器，@classmethod和@staticmethod是python内置装饰器，在了解什么是装饰器之前首先要了解函数的几个特征。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="编程自学" scheme="http://www.shelven.com/categories/%E7%BC%96%E7%A8%8B%E8%87%AA%E5%AD%A6/"/>
    
    
    <category term="python" scheme="http://www.shelven.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python自学笔记（4）——面向对象编程（下）</title>
    <link href="http://www.shelven.com/2022/11/26/a.html"/>
    <id>http://www.shelven.com/2022/11/26/a.html</id>
    <published>2022-11-26T15:59:03.000Z</published>
    <updated>2022-12-03T15:55:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>前面说到python中一切皆为对象，面向对象是python的核心，也通过代码方式了解了什么是类和对象、属性和方法以及具体的分类。这篇笔记主要记录下前面没讲完的面向对象编程具体的三个特征。</p><span id="more"></span><h2 id="面向对象编程的特征"><a href="#面向对象编程的特征" class="headerlink" title="面向对象编程的特征"></a>面向对象编程的特征</h2><div class="story post-story"><p>python是面向对象的语言，支持面向对象的三大特征：<strong>封装（隐藏），继承和多态</strong>。</p><h3 id="1-封装（隐藏）"><a href="#1-封装（隐藏）" class="headerlink" title="1. 封装（隐藏）"></a>1. 封装（隐藏）</h3><h4 id="1-1-封装概念"><a href="#1-1-封装概念" class="headerlink" title="1.1 封装概念"></a>1.1 封装概念</h4><p>隐藏对象的属性和实现细节，只对外提供必要的方法。相当于将“细节封装起来”，只对外暴露“相关调用方法”。</p><p>通过私有属性、私有方法（都是在属性或者方法前加上__来实现私有化，类外部不能直接访问）的方式，实现封装(Encapsulation)。封装的概念类似权限控制，有些属性或方法只想于类别内部使用，而不想公开于外部，除了减少代码因来源端不适当的使用发生问题外，也可保护其中重要的商业逻辑。</p><p>当然，前面说过python没有严格意义上的访问控制限制，更多还是靠编程人员的自觉&#x3D; &#x3D;</p><h3 id="2-继承"><a href="#2-继承" class="headerlink" title="2 继承"></a>2 继承</h3><h4 id="2-1-继承概念"><a href="#2-1-继承概念" class="headerlink" title="2.1 继承概念"></a>2.1 继承概念</h4><p>继承是创建新类的方式，是实现代码复用的重要手段（比如一个新类继承自设计好的类，就直接具备已有类的特征，减少代码重复编写）。对于<strong>已有的类</strong>，我们称为<strong>父类或基类</strong>，而要<strong>创建的新类</strong>，我们称为<strong>子类或派生类</strong>。python支持多继承，也就是<strong>新建的类可以有一个或者多个父类</strong>。</p><p>python3中默认继承<strong>object</strong>类，object是根类，是所有类的父亲。编写过程中object可以省略。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个父类(object可省)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, color</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.color = color</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s在进食&#x27;</span> % self.name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个子类，括号中为父类的名字</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pig</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setName</span>(<span class="params">self, newname</span>):</span><br><span class="line">        self.name = newname</span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line">Peggy = Pig(<span class="string">&#x27;猪&#x27;</span>, <span class="string">&#x27;粉色&#x27;</span>)   <span class="comment"># 实例化对象</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Peggy是%s,颜色是%s&#x27;</span> % (Peggy.name, Peggy.color))     <span class="comment"># 查看对象属性</span></span><br><span class="line">Peggy.eat()     <span class="comment"># 调用父类方法</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;现在Peggy的名字叫做%s&#x27;</span> % Peggy.setName(<span class="string">&#x27;George&#x27;</span>))    <span class="comment"># 调用子类方法</span></span><br><span class="line"><span class="built_in">print</span>(Pig.__mro__)      <span class="comment"># 查看类的继承层次结构，可以用类属性__mro__或者类方法mro()</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">Peggy是猪,颜色是粉色</span></span><br><span class="line"><span class="string">猪在进食</span></span><br><span class="line"><span class="string">现在Peggy的名字叫做George</span></span><br><span class="line"><span class="string">(&lt;class &#x27;__main__.Pig&#x27;&gt;, &lt;class &#x27;__main__.Animal&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>从上面的例子可以看到，子类Pig从父类Animal中继承了__init__()方法，从子类中实例化对象Peggy是可以调用父类的方法的。</p><p>需要注意：</p><blockquote><p><strong>私有的属性和方法（前面带有__）不能被子类继承，也不能被访问！</strong></p></blockquote><h4 id="2-2-多继承"><a href="#2-2-多继承" class="headerlink" title="2.2 多继承"></a>2.2 多继承</h4><p>顾名思义一个子类继承自多个直接父类，这样也就有了多个父类的特点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个父类马</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Horse</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">output</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;骡子的一半基因来自马&#x27;</span>)</span><br><span class="line"><span class="comment"># 定义一个父类驴</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Donkey</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">output</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;骡子的一半基因来自驴&#x27;</span>)</span><br><span class="line"><span class="comment"># 定义一个子类骡子，继承自马和驴</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mule</span>(Horse, Donkey):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">a = Mule()  <span class="comment"># 实例化一个对象骡子</span></span><br><span class="line">a.output()  <span class="comment"># 调用同名父类方法</span></span><br><span class="line"><span class="built_in">print</span>(Mule.__mro__)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">骡子的一半基因来自马</span></span><br><span class="line"><span class="string">(&lt;class &#x27;__main__.Mule&#x27;&gt;, &lt;class &#x27;__main__.Horse&#x27;&gt;, &lt;class &#x27;__main__.Donkey&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>上面的例子可以看到，子类骡子(Mule)继承自父类马(Horse)和驴(Donkey)，这样可以拥有两个父类各自的特征。但是，如果父类中如果有同名的方法(这里的output(self))，那么子类只会<strong>从左到右</strong>的顺序，调用<strong>先继承的父类</strong>(Horse)中的方法。</p><p>同样可以通过类属性__mro__来查看继承结构，显示结果也是从左到右的顺序，从子类开始一层层往上到父类，这就是继承的顺序。</p><p>一般情况下不建议用多继承<del>（一个人不可能有两个爹）</del>，代码可读性会变差。</p><h4 id="2-3-重写父类方法"><a href="#2-3-重写父类方法" class="headerlink" title="2.3 重写父类方法"></a>2.3 重写父类方法</h4><p>重写的意思是，当子类中有一个和父类相同的名字的方法，子类中的方法会重新定义覆盖掉父类中的方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;是个动物都会进食&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pig</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;只有猪才会吃了睡睡了吃&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Peggy = Pig()</span><br><span class="line">Peggy.eat()     <span class="comment"># 调用父类同名方法，子类的方法会覆盖</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">只有猪才会吃了睡睡了吃</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>如果想要在子类方法中调用父类的同名方法，最简单的实现方式是在<strong>子类方法中进行类调用</strong>，但是父类名如果修改过，在多继承时子类的方法也要重复改很多次，python为了解决这个问题引入了super()函数，需要注意super()代表父类的定义，而不是父类对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;是个动物都会进食&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pig</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().eat()       <span class="comment"># super()代表父类名，即使父类名改变这里也不需要改</span></span><br><span class="line"></span><br><span class="line">Peggy = Pig()</span><br><span class="line">Peggy.eat()</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">是个动物都会进食</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>一般而言，<strong>super在继承中经常用来继承父类的初始化方法</strong>，例如<code> super().__init__()</code></p><h3 id="3-多态"><a href="#3-多态" class="headerlink" title="3 多态"></a>3 多态</h3><h4 id="3-1-多态概念"><a href="#3-1-多态概念" class="headerlink" title="3.1 多态概念"></a>3.1 多态概念</h4><p>多态指不同对象对同一个方法调用，可能会产生不同的行为。举个栗子，对于同样一个吃饭的方法，不同对象比如中国人用筷子吃饭，印度三哥用手抓饭，欧美人用刀叉吃饭。</p><p>需要注意以下几点：</p><blockquote><ol><li>多态是方法的多态，属性没有多态</li><li>多态存在的必要条件：继承和方法重写</li></ol></blockquote><h4 id="3-2-代码演示多态和“鸭子类型”"><a href="#3-2-代码演示多态和“鸭子类型”" class="headerlink" title="3.2 代码演示多态和“鸭子类型”"></a>3.2 代码演示多态和“鸭子类型”</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Chinese</span>(<span class="title class_ inherited__">People</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;中国人用筷子吃饭&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Indian</span>(<span class="title class_ inherited__">People</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;印度人用手抓饭&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">American</span>(<span class="title class_ inherited__">People</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;欧美人用刀叉吃饭&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分别实例化，并定义一个统一的接口来使用</span></span><br><span class="line">XiaoMing = Chinese()</span><br><span class="line">ASan = Indian()</span><br><span class="line">George = American()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Eatting</span>(<span class="params">self</span>):</span><br><span class="line">    self.eat()</span><br><span class="line">Eatting(XiaoMing)   <span class="comment"># 相当于调用了XiaoMing.eat，以下同理</span></span><br><span class="line">Eatting(ASan)</span><br><span class="line">Eatting(George)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*******************************************&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># “鸭子类型”</span></span><br><span class="line"><span class="comment"># 定义三个不同的类（实际上也都继承自根类object）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Chinese</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;中国人用筷子吃饭&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Indian</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;印度人用手抓饭&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">American</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;欧美人用刀叉吃饭&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">People_list = [Chinese, Indian, American]   <span class="comment"># 封装好的类作为People_list的元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> person <span class="keyword">in</span> People_list:</span><br><span class="line">    person().eat()      <span class="comment"># person()是实例化对象的过程，分别调用不同类的同名方法</span></span><br><span class="line">    </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">中国人用筷子吃饭</span></span><br><span class="line"><span class="string">印度人用手抓饭</span></span><br><span class="line"><span class="string">欧美人用刀叉吃饭</span></span><br><span class="line"><span class="string">*******************************************</span></span><br><span class="line"><span class="string">中国人用筷子吃饭</span></span><br><span class="line"><span class="string">印度人用手抓饭</span></span><br><span class="line"><span class="string">欧美人用刀叉吃饭</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>不同对象调用同名方法，产生不同结果，这就体现了多态性，好处在于增强了程序的灵活性和可扩展性。</p><p>Python崇尚的“鸭子类型”就是动态类型的风格：“当看到一直鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以称为鸭子。”这种动态风格中，<strong>一个对象的有效语义，不是由继承自特定的类或实现特定的接口，而是由当前方法和属性的集合决定</strong>，也就是说，我们并不关心对象是什么类型，而是关心对象是怎么使用的。</p><p>总而言之，这种动态类型使得编程非常灵活，可以避免一些重写和继承，省去复制大量重复代码的操作。</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;前面说到python中一切皆为对象，面向对象是python的核心，也通过代码方式了解了什么是类和对象、属性和方法以及具体的分类。这篇笔记主要记录下前面没讲完的面向对象编程具体的三个特征。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="编程自学" scheme="http://www.shelven.com/categories/%E7%BC%96%E7%A8%8B%E8%87%AA%E5%AD%A6/"/>
    
    
    <category term="python" scheme="http://www.shelven.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python自学笔记（3）——面向对象编程（上）</title>
    <link href="http://www.shelven.com/2022/11/25/a.html"/>
    <id>http://www.shelven.com/2022/11/25/a.html</id>
    <published>2022-11-25T15:31:53.000Z</published>
    <updated>2022-12-03T15:55:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>面向对象是Python的核心概念，一开始在这些概念问题上一直绕不清，这里做个简单记录。</p><span id="more"></span><h2 id="1-面向对象编程"><a href="#1-面向对象编程" class="headerlink" title="1. 面向对象编程"></a>1. 面向对象编程</h2><div class="story post-story"><p>使用计算机语言编写代码时，有两种思路分别是面向过程编程和面向对象编程</p><blockquote><ol><li>面向过程：根据业务逻辑从上到下，直接分析解决问题的步骤，调用函数实现。强调怎么去做</li><li>面向对象：将问题分解成若干“对象”，建立对象是为了描述某个事物在解决问题过程中的行为。强调谁去做</li></ol></blockquote><p><strong>面向过程注重步骤和过程</strong>，所有步骤<strong>从到到尾逐步实现</strong>，将功能独立的代码<strong>封装成函数</strong>，最后完成代码就是<strong>按照顺序地调用不同函数</strong>。</p><p><strong>面向对象注重对象和职责</strong>，确认<strong>职责</strong>，根据职责确定不同对象，<strong>对象内部封装不同的方法</strong>，最后完成代码是按照顺序让<strong>不同对象调用不同方法</strong>。</p><p>python是面向对象编程思想的一门语言，包括做机器学习或者深度学习用的PyTorch、TensorFlow都是面向对象的思想，里面封装了非常多的方法，我们甚至可以不知道方法具体实现的过程和原理，直接调用函数就可以（初学的我就是一开始依葫芦画瓢，程序能跑通但是不能解释实现的原理），对于小白的入门学习确实提供了极大便利<del>（然后一出问题就开始恶补基础了）</del>。</p></div><h2 id="2-概念性名词"><a href="#2-概念性名词" class="headerlink" title="2. 概念性名词"></a>2. 概念性名词</h2><div class="story post-story"><p>先要了解概念性的专业名词，再通过代码的方式加深自己的理解。</p><p>面向对象有三个特性，封装性、继承性和多态性（下一篇博客再细说）。</p><blockquote><ol><li>封装性：把属性和方法放在一个类里面，可以通过访问类的权限属性区分开，不想释放的功能搞成私有机制</li><li>继承性：把实现好的代码和方法通过继承的方法拿过来用，节省代码量</li><li>多态性：同一个方法用不同的方式去实现，体现的多态性</li></ol></blockquote><p>先解释一下上面提到的几个专有名词：</p><blockquote><p>对象(object)：python中一切皆对象，对应现实生活中，任何事物都可以称为对象，有自己独特的特征。对象是通过类创建出的真实的个体（对象是类的实例化），对象由属性和方法组成。</p><p>类(class)：具有同种属性的对象，现实世界中具有共同特征的事物为一类，比如人类，植物类等，描述的是所有对象的共有特征。拥有相似属性和行为的对象都可以抽象出一个类。</p><p>属性(attribute)：属于对象静态的一面，描述对象的一些静态特征，比如小明的身高、体重、年龄等。</p><p>方法(method)：属于对象动态的一面，描述对象的动态特征，比如小明会说话，会码代码等。</p><p>实例化：对象由一个别名叫“实例”，通过类创建对象的过程为“实例化”。</p><p>抽象：由相同特征的对象抽取共同特征的过程为“抽象”。</p></blockquote></div><h2 id="3-代码方式理解类和对象"><a href="#3-代码方式理解类和对象" class="headerlink" title="3. 代码方式理解类和对象"></a>3. 代码方式理解类和对象</h2><div class="story post-story"><p>开头的class来创建一个新的类，class之后为类的名称（通常首字母大写）并以冒号结尾。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>:</span><br><span class="line">    <span class="comment"># 定义方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getPeopleInfo</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;名字:%s, 年龄:%d&#x27;</span> %(self.name, self.age))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化一个对象        </span></span><br><span class="line">Phantom = People()</span><br><span class="line">Phantom.name = <span class="string">&#x27;Phantom&#x27;</span>    <span class="comment"># 使用 . 的方法添加类属性</span></span><br><span class="line">Phantom.age = <span class="number">26</span></span><br><span class="line">Phantom.getPeopleInfo()     <span class="comment"># 使用 .函数名() 的方法调用类中创建的函数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Phantom.age)      <span class="comment"># 打印实例Phantom的年龄属性</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">名字:Phantom, 年龄:26</span></span><br><span class="line"><span class="string">26</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>在创建的类中定义方法，而类中的方法和普通的函数有一个区别——必须有一个额外的第一个参数名称, 按照惯例是 self。self指的是实例的本身，指向当前创建对象的内存地址。某个对象调用其方法时，python解释器会把这个对象作为第一个参数传递给self，所以我们只需要传递后面的参数。</p><p><strong>python是没有方法的重载的</strong>，如果定义了多个重名的方法，只会生效最后一个！</p><p>在上面的例子里我给Phantom添加了两个对象属性：name和age，但是如果再实例化一个其他对象，能否在创建时就给予属性而不用重新添加呢？答案是肯定的，这个时候我们可以用__init__()函数来定义属性的默认值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>:</span><br><span class="line">    <span class="comment"># 初始化函数，使对象的属性具有默认值</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, sex = <span class="string">&#x27;male&#x27;</span>, age = <span class="number">26</span></span>):</span><br><span class="line">        self.sex = sex</span><br><span class="line">        self.age = age</span><br><span class="line">    <span class="comment"># 定义类方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getPeopleInfo</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;性别:%s, 年龄:%d&#x27;</span> %(self.sex, self.age))</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 创建对象Phantom，不传参，属性使用默认值</span></span><br><span class="line">Phantom = People()</span><br><span class="line"><span class="built_in">print</span>(Phantom.sex, Phantom.age)</span><br><span class="line">Phantom.getPeopleInfo()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建第二个对象Aria，传参，新的参数代替默认值</span></span><br><span class="line">Aria = People(<span class="string">&#x27;Female&#x27;</span>, <span class="number">24</span>)</span><br><span class="line"><span class="built_in">print</span>(Aria.sex, Aria.age)</span><br><span class="line">Aria.getPeopleInfo()</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">male 26</span></span><br><span class="line"><span class="string">性别:male, 年龄:26</span></span><br><span class="line"><span class="string">Female 24</span></span><br><span class="line"><span class="string">性别:Female, 年龄:24</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>可以看到上面创建对象Phantom后，我没有传入参数，python解释器立刻调用了__init__()函数给与了两个属性sex和age，这个时候再调用类内的方法getPeopleInfo()，就会将属性的默认值作为实参传入。</p><p>__init__(self)中只有一个默认参数self，<strong>如果创建对象传入了两个实参，那么除了self以外还需要两个形参</strong>，比如__init__(self, sex, age)这个和自定义创建的类方法不一样，一定要做区分，后面会说到。这里的self是不需要我们传递的，python解释器会自动把当前对象的引用传递进去。</p></div><h2 id="4-代码方式理解属性和方法"><a href="#4-代码方式理解属性和方法" class="headerlink" title="4. 代码方式理解属性和方法"></a>4. 代码方式理解属性和方法</h2><div class="story post-story"><h3 id="4-1-类属性"><a href="#4-1-类属性" class="headerlink" title="4.1 类属性"></a>4.1 类属性</h3><p>类拥有的属性分为公有属性（public）和私有属性（private），python对于类的属性没有严格的访问控制限制，这与其他面向对象语言有所区别。</p><blockquote><ol><li><p>_xxx  保护属性，python编辑器不会做任何处理，是给程序员看的，不希望被外部访问</p></li><li><p>xxx  自己定义的公有属性</p></li><li><p>__xxx  类中的私有属性，<strong>不能从外部直接访问</strong>，但是可以通过 <strong>实例._类名__私有属性</strong> 的方式访问</p><p>再次强调，python不存在严格意义上的私有属性。</p></li></ol></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建类，object是对象，可以省略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    name = <span class="string">&#x27;Phantom&#x27;</span>    <span class="comment"># 公有的类属性</span></span><br><span class="line">    __age = <span class="number">26</span>      <span class="comment"># 私有的类属性</span></span><br><span class="line">    _sex = <span class="string">&#x27;male&#x27;</span>       <span class="comment"># 保护的类属性</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span>        <span class="comment"># 空语句，占位用，不会执行任何操作</span></span><br><span class="line">p = People()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(p.name)           <span class="comment"># 通过实例对象访问公有类属性</span></span><br><span class="line"><span class="built_in">print</span>(p._People__age)       <span class="comment"># 通过实例访问私有类属性</span></span><br><span class="line"><span class="built_in">print</span>(p._sex)       <span class="comment"># 访问保护的类属性（可以访问但是不推荐）</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">Phantom</span></span><br><span class="line"><span class="string">26</span></span><br><span class="line"><span class="string">male</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="4-2-实例属性"><a href="#4-2-实例属性" class="headerlink" title="4.2 实例属性"></a>4.2 实例属性</h3><p>实例属性是从属于实例对象的属性。</p><blockquote><ol><li>实例属性可以在__init__()方法中通过 <strong>self.实例属性名 &#x3D; 初始值</strong> 的方式进行定义</li><li>实例属性可以修改、新增和删除，不会影响到类属性</li></ol></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    name = <span class="string">&#x27;Phantom&#x27;</span></span><br><span class="line"></span><br><span class="line">p = People()</span><br><span class="line"><span class="built_in">print</span>(p.name, People.name)      <span class="comment"># 通过实例查看实例属性，通过类对象查看类属性</span></span><br><span class="line">p.name = <span class="string">&#x27;Aria&#x27;</span>     <span class="comment"># 修改实例属性</span></span><br><span class="line"><span class="built_in">print</span>(p.name, People.name)</span><br><span class="line">People.name = <span class="string">&#x27;Aria&#x27;</span>    <span class="comment"># 修改类属性</span></span><br><span class="line"><span class="built_in">print</span>(p.name, People.name)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Phantom Phantom</span></span><br><span class="line"><span class="string">Aria Phantom</span></span><br><span class="line"><span class="string">Aria Aria</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>可以看到通过一个实例对象去引用修改，只是修改了实例属性而不会影响到类属性。</p><h3 id="4-3-特殊属性"><a href="#4-3-特殊属性" class="headerlink" title="4.3 特殊属性"></a>4.3 特殊属性</h3><p>Python 对象中包含了很多双下划线开始和结束的属性，这些是特殊属性，有特殊的用法。</p><table><thead><tr><th>特殊方法</th><th>含义</th></tr></thead><tbody><tr><td>obj.__dict__</td><td>对象的属性字典</td></tr><tr><td>obj.__class__</td><td>对象所属的类</td></tr><tr><td>class.__bases__</td><td>类的基类元组(多继承)</td></tr><tr><td>class.__base__</td><td>类的基类</td></tr><tr><td>class.__mro__</td><td>类层次结构</td></tr><tr><td>class.__subclasses__</td><td>子类列表</td></tr></tbody></table><p>实际操作运行几个简单的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>:</span><br><span class="line">    name = <span class="string">&#x27;Phantom&#x27;</span>    <span class="comment"># 类属性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, sex, age</span>):       <span class="comment"># 实例属性</span></span><br><span class="line">        self.sex = sex</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">p = People(<span class="string">&#x27;male&#x27;</span>, <span class="number">26</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># dict 生成类属性信息的字典和实例对象属性信息的字典</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;People类属性为：&#x27;</span> + <span class="built_in">str</span>(People.__dict__))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;实例对象p属性为：&#x27;</span> + <span class="built_in">str</span>(p.__dict__))</span><br><span class="line"></span><br><span class="line"><span class="comment"># class 对实例对象查询所属类信息</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;实例对象p所属类信息：&#x27;</span> + <span class="built_in">str</span>(p.__class__))</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">People类属性为：&#123;&#x27;__module__&#x27;: &#x27;__main__&#x27;, &#x27;name&#x27;: &#x27;Phantom&#x27;, &#x27;__init__&#x27;: &lt;function People.__init__ at 0x000001A7D212AB00&gt;, &#x27;__dict__&#x27;: &lt;attribute &#x27;__dict__&#x27; of &#x27;People&#x27; objects&gt;, &#x27;__weakref__&#x27;: &lt;attribute &#x27;__weakref__&#x27; of &#x27;People&#x27; objects&gt;, &#x27;__doc__&#x27;: None&#125;</span></span><br><span class="line"><span class="string">实例对象p属性为：&#123;&#x27;sex&#x27;: &#x27;male&#x27;, &#x27;age&#x27;: 26&#125;</span></span><br><span class="line"><span class="string">实例对象p所属类信息：&lt;class &#x27;__main__.People&#x27;&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="4-4-实例方法和类方法"><a href="#4-4-实例方法和类方法" class="headerlink" title="4.4 实例方法和类方法"></a>4.4 实例方法和类方法</h3><p>在类中以def开头定义的方法都是实例方法，实例方法的特点是必须有一个以上的参数（<strong>self</strong>），用于指定这个方法的实例对象。</p><p>类方法也是最少需要一个参数（<strong>cls</strong>），是类对象有的方法，<strong>需要使用装饰器@classmethod来标识其为类方法</strong>，关于装饰器的概念我后面再写一篇博客，这里简单按照字面意思理解一下。类方法可以通过实例对象或者类对象去访问，有一个用途就是通过实例调用类方法实现对类属性的修改。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>():</span><br><span class="line">    name = <span class="string">&#x27;Phantm&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getName</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="keyword">return</span> cls.name</span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setName</span>(<span class="params">cls, name</span>):</span><br><span class="line">        cls.name = name</span><br><span class="line"></span><br><span class="line">p = People()</span><br><span class="line"><span class="built_in">print</span>(p.getName(), People.getName())        <span class="comment"># 通过实例和类对象调用类方法，先查看一下类属性</span></span><br><span class="line">p.setName(<span class="string">&#x27;Aria&#x27;</span>)       <span class="comment"># 通过实例调用类方法改变类属性</span></span><br><span class="line"><span class="built_in">print</span>(p.getName(), People.getName())</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">Phantm Phantm</span></span><br><span class="line"><span class="string">Aria Aria</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="4-5-静态方法"><a href="#4-5-静态方法" class="headerlink" title="4.5 静态方法"></a>4.5 静态方法</h3><p>python是动态的语言，我们可以动态地为类添加新的方法，或者动态地修改已有的方法。静态方法可以理解为不变的方法，不依赖于实例对象也不依赖于类对象，因此无论是实例对象还是类对象都可以调用。如果有一个功能实现的方法比较独立，可以考虑用静态方法来实现，<strong>静态方法需要使用装饰器@staticmethod来标识</strong>。</p><p>需要注意的是，<strong>静态方法无法使用实例的属性和方法</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>():</span><br><span class="line">    name = <span class="string">&#x27;Phantom&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name = <span class="string">&#x27;Aria&#x27;</span></span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getName</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;静态方法调用类属性&#x27;</span>, People.name)</span><br><span class="line">        <span class="comment">#print(self.name)       #不能调用实例的属性，会报错</span></span><br><span class="line"></span><br><span class="line">p = People()</span><br><span class="line">p.getName()</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">静态方法调用类属性 Phantom</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="4-6-特殊方法"><a href="#4-6-特殊方法" class="headerlink" title="4.6 特殊方法"></a>4.6 特殊方法</h3><p>前面的普通方法都是通过 对象名.方法名() 的方式调用，和前面有特殊属性一样，python也有一些特殊方法（或者叫魔术方法），这些特殊方法在符合条件的时候自动触发，不需要调用。</p><p>因为特殊方法非常多，这里只简单记录一些常用的。</p><table><thead><tr><th align="left">特殊方法</th><th>含义</th></tr></thead><tbody><tr><td align="left"><strong>构造类</strong></td><td></td></tr><tr><td align="left">__new__(cls, […])</td><td>对象实例化时调用的第一个方法，第一个参数时类，其他参数传递给__init__()，决定是否使用</td></tr><tr><td align="left">__init__(self, […])</td><td>构造器，当一个实例被创建时调用的初始化方法</td></tr><tr><td align="left">__del__(self)</td><td>构造器，当实例对象被销毁时调用的方法</td></tr><tr><td align="left"><strong>表示类</strong></td><td></td></tr><tr><td align="left">__str__(self)</td><td>描述类或对象信息，比如打印实例化对象，返回定义内容（给人看）</td></tr><tr><td align="left">__repr__(self)</td><td>描述类或对象信息，比如打印实例化对象，返回定义内容（给解释器看）</td></tr><tr><td align="left"><strong>访问控制类</strong></td><td></td></tr><tr><td align="left">__setattr__(self, key, value)</td><td>定义当一个属性被设置时的行为</td></tr><tr><td align="left">__getattr__(self, key)</td><td>定义用户试图获取一个不存在的属性时的行为</td></tr><tr><td align="left">__delattr__(self, key)</td><td>定义当一个属性被删除时的行为</td></tr><tr><td align="left">__getattribute__(self, key)</td><td>定义当该类属性被访问时的行为（所有属性&#x2F;方法调用都要经过这里）</td></tr><tr><td align="left">__dir__(self)</td><td>定义当dir()被调用时的行为</td></tr><tr><td align="left"><strong>比较操作类</strong></td><td></td></tr><tr><td align="left">__eq__(self, other)</td><td>判断两个对象是否相等</td></tr><tr><td align="left">__ne__(self,other)</td><td>判断两个对象是否不相等</td></tr><tr><td align="left">__lt__(self, other)</td><td>定义小于号的行为：x &lt; y 调用 x.__lt__(y)</td></tr><tr><td align="left">__gt__(self, other)</td><td>定义大于号的行为：x &gt; y 调用 x.__gt__(y)</td></tr><tr><td align="left"><strong>容器类</strong></td><td></td></tr><tr><td align="left">__setitem__(self, key, value)</td><td>定义设置容器中指定元素的操作，相当于 self[key] &#x3D; value</td></tr><tr><td align="left">__getitem__(self, key)</td><td>定义获取容器中指定元素的操作 ，相当于 self[key]</td></tr><tr><td align="left">__delitem__(self, key)</td><td>定义删除容器中指定元素的操作 ，相当于 del self[key]</td></tr><tr><td align="left">__len__(self)</td><td>定义当被 len() 调用时的操作，即返回容器中元素个数</td></tr><tr><td align="left">__iter__(self)</td><td>定义迭代容器中的元素的操作</td></tr><tr><td align="left">__contains__(self, item)</td><td>定义当使用成员测试运算符（in 或 not in）时的操作</td></tr><tr><td align="left">__reversed__(self)</td><td>定义当被 reversed() 调用时的操作</td></tr><tr><td align="left"><strong>可调用对象类</strong></td><td></td></tr><tr><td align="left">__call__(self, [args…])</td><td>使实例对象以 对象名() 的形式使用</td></tr></tbody></table><p>这些特殊方法比较常用，看到知道是怎么一回事就好。容器类的特殊方法稍微解释一下，python中常用<strong>字典、元组、列表和字符串</strong>作为容器，它们都实现了<strong>容器协议</strong>，可迭代。最后一个调用对象类特殊方法写个代码描述一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Calculate</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, m, n</span>):</span><br><span class="line">        self.m = m</span><br><span class="line">        self.n = n</span><br><span class="line">        SUM = m + n</span><br><span class="line">        <span class="keyword">return</span> SUM</span><br><span class="line"></span><br><span class="line">a = Calculate(<span class="number">100</span>, <span class="number">200</span>)  </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a(<span class="number">111</span>, <span class="number">222</span>))      <span class="comment"># __call__() 将实例化对象a当作一个方法来执行</span></span><br><span class="line"><span class="built_in">print</span>(a.x, a.y)     <span class="comment"># 实例属性并没有改变</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">333</span></span><br><span class="line"><span class="string">100 200</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>在上面这个例子中，首先初始化了一个Calculate实例a，调用 __init__() 方法，给与了实例属性x和y以及对应的值。但是对于实例对象a又做了调用 a(111, 222) ，实际上调用的是 __call__() 方法，传入自定义参数实现自己的逻辑，这在类实现一个装饰器的场景中比较常见。</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;面向对象是Python的核心概念，一开始在这些概念问题上一直绕不清，这里做个简单记录。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="编程自学" scheme="http://www.shelven.com/categories/%E7%BC%96%E7%A8%8B%E8%87%AA%E5%AD%A6/"/>
    
    
    <category term="python" scheme="http://www.shelven.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python自学笔记（2）——运算符和参数传递</title>
    <link href="http://www.shelven.com/2022/11/24/a.html"/>
    <id>http://www.shelven.com/2022/11/24/a.html</id>
    <published>2022-11-24T09:05:33.000Z</published>
    <updated>2022-12-03T15:57:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇笔记主要记录python基础的运算符和函数参数传递，以及自己学习过程的一些思考。</p><span id="more"></span><h2 id="1-运算符"><a href="#1-运算符" class="headerlink" title="1. 运算符"></a>1. 运算符</h2><div class="story post-story"><h3 id="1-1-比较运算符"><a href="#1-1-比较运算符" class="headerlink" title="1.1 比较运算符"></a>1.1 比较运算符</h3><p>python中常见的比较运算符如下：</p><blockquote><ol><li>&#x3D;&#x3D;  检查左右两个值是否相等，相等则返回True</li><li>!&#x3D;  检查左右两个值是否相等，不相等则返回True</li><li>&lt;&gt;  和 !&#x3D; 一样，检查两个值是否相等，不相等返回True</li><li>&gt;&#x3D;  字面意思，字面意思的还有&lt;&#x3D;、 &lt; 和 &gt;</li></ol></blockquote><h3 id="1-2-算数运算符"><a href="#1-2-算数运算符" class="headerlink" title="1.2 算数运算符"></a>1.2 算数运算符</h3><p>python常见的算数运算符：</p><blockquote><ol><li>&#x2F;  两个数相除，结果为浮点型</li><li>&#x2F;&#x2F;  两个数相除，结果为<strong>向下取整的整数</strong></li><li>%  取模，也就是两个整数相除的余数</li><li>**  幂运算，返回乘方的结果</li><li>+  两个数相加，<strong>或者字符串相连</strong></li><li>*  两个数相乘，<strong>或者返回重复若干次的字符串</strong></li><li>-  字面意思，两个数相减</li></ol></blockquote><h3 id="1-3-赋值运算符"><a href="#1-3-赋值运算符" class="headerlink" title="1.3 赋值运算符"></a>1.3 赋值运算符</h3><p>顾名思义都是在赋值的时候用到的运算符</p><blockquote><ol><li>&#x3D;  常规赋值运算，运算结果赋值给变量</li><li>+&#x3D;  加法赋值运算，a +&#x3D; b等效于a &#x3D; a+b</li><li>其他算数运算符都可以后面跟上&#x3D;，进行运算后赋值</li></ol></blockquote><h3 id="1-4-位运算符"><a href="#1-4-位运算符" class="headerlink" title="1.4 位运算符"></a>1.4 位运算符</h3><p>按位运算就是将数字转换为二进制来运算的运算形式，数值是用补码来表示和存储的，计算机用位运算符进行四则运算速度快。但是我们平常可能用不到，这里稍微记录一下。</p><blockquote><ol><li>&amp;  按位“与”：两个值如果相应位都为1，则结果为1，否则0</li><li>|  按位“或”：两个值相应位有一个位1，结果就为1</li><li>^  按位“异或”：两个值相应位相异，结果为1</li><li>~  按位“取反”：对数据的每个二进制位取反</li><li>&lt;&lt;  左移运算符：运算数的二进制全部座椅若干位，高位丢弃，低位补0；&gt;&gt;右移同理</li></ol></blockquote><h3 id="1-5-逻辑运算符"><a href="#1-5-逻辑运算符" class="headerlink" title="1.5 逻辑运算符"></a>1.5 逻辑运算符</h3><blockquote><ol><li>and  逻辑“与”，两个都为True则返回True，否则False</li><li>or  逻辑“或”，两个至少有一个True则返回True，否则False</li><li>not  逻辑“非”，字面意思</li></ol></blockquote><h3 id="1-6-成员和身份运算符"><a href="#1-6-成员和身份运算符" class="headerlink" title="1.6 成员和身份运算符"></a>1.6 成员和身份运算符</h3><p>python的成员运算符用来判断一个数据是否在指定的序列或者集合中，而身份运算符是用来判断两个变量是否引用自同一个对象。</p><blockquote><ol><li>in  成员运算符，在指定序列中找到值则返回True，否则False</li><li>not in  成员运算符，在指定序列中没有找到值则返回True，否则False</li><li>is  身份运算符，两个标识符是否引自同一个对象，是则返回True，否则False</li><li>is not  身份运算符，两个标识符是否引用同一个对象，不是则返回True，否则False</li></ol></blockquote><p>是否引自同一个对象，简单理解就是看存储的内存位置是否一样，通过函数id()可以查看变量在内存中的存储位置。</p><p><img src="https://www.shelven.com/tuchuang/20221124/111.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221124/111.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div><h2 id="2-参数传递"><a href="#2-参数传递" class="headerlink" title="2. 参数传递"></a>2. 参数传递</h2><div class="story post-story"><p>要理解参数传递的过程，首先要明白关于函数参数的两个具体概念：形参和实参</p><ul><li>定义时小括号中的参数，是用来接收参数的，称为“形参”，可以是缺省参数、不定长参数</li><li>调用时小括号中的参数，是用来传递参数给函数的，称为“实参”</li></ul><p>向函数传递实参的方式很多，确定传递参数个数可以使用位置实参或者关键字实参，不确定传递参数个数可以使用包裹（packing）传递的方式，来包裹位置或者关键字实参，进行参数传递。</p><h3 id="2-1-位置实参"><a href="#2-1-位置实参" class="headerlink" title="2.1 位置实参"></a>2.1 位置实参</h3><p>函数调用时每个实参都要关联到函数定义中的一个形参，最简单的是按照形参的位置从左到右按照顺序传递，位置参数必须一一对应，缺一不可。</p><p><img src="https://www.shelven.com/tuchuang/20221124/222.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221124/222.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>比如上面创建了一个describe_me()函数，形参定义了需要name和age两个参数，因此在调用这个函数的时候要按照顺序提供这两个参数。在上例中，从左到右实参‘Phantom’储存在形参name中，实参26储存在形参age中，<strong>参数传递本质上就是实参到形参的赋值操作</strong>。</p><h3 id="2-2-关键字实参"><a href="#2-2-关键字实参" class="headerlink" title="2.2 关键字实参"></a>2.2 关键字实参</h3><p>关键字实参顾名思义是传递函数的key-Value对，在实参中将关键字和值关联，因为这种对应关系是唯一的，在调用函数的时候就不需要考虑实参的顺序。</p><p><img src="https://www.shelven.com/tuchuang/20221124/333.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221124/333.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>这种参数传递方式比较直观，能一眼看出函数调用时各个值对应的用途。</p><p>关键字实参和位置实参时可以一起使用，需要注意：</p><ul><li>关键字实参必须在位置实参右边（写的时候<strong>位置实参优先</strong>）</li><li>对同一个形参不可重复传值</li></ul><h3 id="2-3-形参的缺省"><a href="#2-3-形参的缺省" class="headerlink" title="2.3 形参的缺省"></a>2.3 形参的缺省</h3><p>创建函数的时候可以给形参指定默认值（缺省）。</p><p><img src="https://www.shelven.com/tuchuang/20221124/444.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221124/444.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>对于缺省形参，需要注意：</p><ul><li>缺省参数要在非缺省参数之后（缺省形参放右边）</li><li>缺省参数是可选参数，可以不传；如果传入则按照传入的值进行运算</li></ul><h3 id="2-4-形参的不定长参数（包裹传递）"><a href="#2-4-形参的不定长参数（包裹传递）" class="headerlink" title="2.4 形参的不定长参数（包裹传递）"></a>2.4 形参的不定长参数（包裹传递）</h3><p>当传入的参数个数不确定时，可以使用包裹位置参数和包裹关键字参数进行参数传递。</p><ul><li>*+形参的方式传递参数，传入后根据参数的位置以<strong>元组</strong>形式保存</li><li>**+形参的方式传递参数，需要使用关键字，传入后以<strong>字典</strong>形式保存，形参名字是传入字典的键</li></ul><p><img src="https://www.shelven.com/tuchuang/20221124/555.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221124/555.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>上面例子形参中的args表示arguments位置参数，kargs表示key arguments关键字参数，这个是可以自定义的。</p><p>不同的参数传递方式可以混用，原则上要遵循<strong>位置参数，默认参数，包裹位置，包裹关键字</strong>的顺序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">name, age = <span class="number">26</span>, *args, **kargs</span>)  <span class="comment"># 定义和调用都遵循这样的顺序</span></span><br></pre></td></tr></table></figure><h3 id="2-5-对传参的思考"><a href="#2-5-对传参的思考" class="headerlink" title="2.5 对传参的思考"></a>2.5 对传参的思考</h3><p>在CSDN上看到一个总结写的很好，<strong>函数的参数传递本质上是从实参到形参的赋值操作，而所有的赋值操作都是“引用的赋值”，因此Python中参数的传递都是“引用传递”，不是“值传递</strong>”。这句话初看有点难以理解，首先看看什么是引用传递和值传递：</p><ul><li>值传递（pass by value）：调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</li><li>引用传递（pass by reference）：调用函数时将实际参数的地址直接传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</li></ul><p>根本区别在于引用传递不创建副本，最直接的理解方式就是通过查看对象的地址，看看传参前后对象在内存的位置是否改变。</p><h4 id="2-5-1-可变对象的传递"><a href="#2-5-1-可变对象的传递" class="headerlink" title="2.5.1 可变对象的传递"></a>2.5.1 可变对象的传递</h4><p>复习一下，可变对象有列表、字典和集合，我们这里以列表为例。</p><p><img src="https://www.shelven.com/tuchuang/20221124/777.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221124/777.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>可以看到，如果传递的对象是<strong>可变对象</strong>，实际上传递的是对象的引用（不创建副本，传递前后在内存中存储位置不变），在函数中修改对象后，<strong>直接在原始对象上做了相应的修改</strong>。</p><h4 id="2-5-2-不可变对象的传递"><a href="#2-5-2-不可变对象的传递" class="headerlink" title="2.5.2 不可变对象的传递"></a>2.5.2 不可变对象的传递</h4><p>如果传递的对象是不可变类型，比如元组，字符和数字，这里以数字为例。</p><p><img src="https://www.shelven.com/tuchuang/20221124/888.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221124/888.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>可以看到，如果传递的对象是<strong>不可变对象</strong>，传进函数的时候同样是对象的引用，但是不可变对象无法修改，因此在赋值操作时，系统新创建了一个对象（和原来a的存储地址不同）进行赋值，<strong>而原始对象并没有改变</strong>。</p><p>也就是说，不可变对象的传递起到类似值传递的效果，但是实际上依然是引用传递的方式进行传参。</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇笔记主要记录python基础的运算符和函数参数传递，以及自己学习过程的一些思考。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="编程自学" scheme="http://www.shelven.com/categories/%E7%BC%96%E7%A8%8B%E8%87%AA%E5%AD%A6/"/>
    
    
    <category term="python" scheme="http://www.shelven.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python自学笔记（1）——数据类型</title>
    <link href="http://www.shelven.com/2022/11/23/a.html"/>
    <id>http://www.shelven.com/2022/11/23/a.html</id>
    <published>2022-11-23T14:09:49.000Z</published>
    <updated>2022-12-03T16:03:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>这两个月经历了突然的疫情隔离，研究生开题，学术论坛，研究生创新项目等等……终于在这一周尘埃落定了，得以静下心来整理整理自己的一些学习笔记。之前我用过一些python编写的项目，我也只是依葫芦画瓢或者在demo上直接改，还没有系统性地学习过这门编程语言。这里就再记录下自己自学python的一些入门时的笔记，以及记录下几个机器学习方面的python库的使用方法。</p><span id="more"></span><h2 id="1-六大数据类型"><a href="#1-六大数据类型" class="headerlink" title="1. 六大数据类型"></a>1. 六大数据类型</h2><div class="story post-story"><p>很多编程语言的数据类型是相通或者有类似之处的，学习一门编程语言最基础的就是熟悉它的数据类型，python有6种标准数据类型。</p><h3 id="1-1-Numbers-数字类型"><a href="#1-1-Numbers-数字类型" class="headerlink" title="1.1 Numbers(数字类型)"></a>1.1 Numbers(数字类型)</h3><p>数字类型简单来说就是数值，在python中<strong>是不可变数据类型</strong>。python的Numbers数据类型又可以分为以下几个子类型</p><blockquote><ol><li>整型(int): 通常称为整型或整数，是正或负整数，不带小数点。python3整型没有大小限制，可以当作python2的Long类型使用，不像其他编程语言有 int，smallint，short，long，longint，long 等。</li><li>浮点型(float): 浮点型由整数和小数两个部分组成，只能以十进制表示或者科学计数法表示，有长度限制。</li><li>布尔型(bool): 布尔型就是逻辑，使用True和False表示。注意一下在上下文环境中，True当做1，False被当作0。</li><li>复数型(complex): 复数型由实数和虚数部分构成，可以用a + bj或者complex(a, b)表示，a和b都是浮点型。</li></ol></blockquote><h3 id="1-2-String-字符串"><a href="#1-2-String-字符串" class="headerlink" title="1.2 String(字符串)"></a>1.2 String(字符串)</h3><p>String是python中最常用的数据类型，说白了就是字符组成的一串内容。可以使用成对的单引号或者双引号(“或‘)创建字符串，用三个单引号或者双引号使字符串内容保持原样输出，可以包含特殊字符。<strong>在python中字符串是不可变变量。</strong></p><h4 id="1-2-1-字符串索引"><a href="#1-2-1-字符串索引" class="headerlink" title="1.2.1 字符串索引"></a>1.2.1 字符串索引</h4><p>索引就是字符的位置序号，使用[]进行字符串索引，python有两种索引方式，下标索引越界均会报错。</p><p>正向索引：字符串长度为n，<strong>从0开始</strong>，索引值范围0 ~ n-1</p><p>反向索引：字符串长度为n，<strong>从-1开始</strong>，索引值范围-1 ~ -n</p><p><img src="https://www.shelven.com/tuchuang/20221123/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221123/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="1-2-2-字符串切片"><a href="#1-2-2-字符串切片" class="headerlink" title="1.2.2 字符串切片"></a>1.2.2 字符串切片</h4><p>切片意思就是取出字符串中你想要的内容。切片的标准写法是两个冒号加三个数字，如a[1:2:3]，需要注意切片是<strong>左闭右开</strong>的取值，切片越界是不会报错的。</p><p>第一个数字表示切片的起始位置（省略就是从第 1 个字符开始，也就是0号位）</p><p>第二个数字表示切片的终止位置（不包括这个位置的字符，右开表现在这里；<strong>可省略，省略是最后一个字符结尾且包含</strong>）</p><p>第三个数字表示步长（缺省值为1，此时可以不写第二个冒号）</p><p><img src="https://www.shelven.com/tuchuang/20221123/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221123/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="1-2-3-转义"><a href="#1-2-3-转义" class="headerlink" title="1.2.3 转义"></a>1.2.3 转义</h4><p>如果使用带有特殊字符的字符串，则需要进行转义，使用反斜杠 \ 进行字符转义。</p><table><thead><tr><th>转义字符</th><th>描述</th></tr></thead><tbody><tr><td>\‘</td><td>表示单引号</td></tr><tr><td>\“</td><td>表示双引号</td></tr><tr><td>\n</td><td>换行</td></tr><tr><td>\t</td><td>制表符（即四个空格）</td></tr><tr><td>\b</td><td>退格（删除前面一个字符）</td></tr><tr><td>\\</td><td>表示反斜杠</td></tr></tbody></table><p>在字符串前加 ’r‘ 可以使整个字符串原样输出，不会被转义。</p><p><img src="https://www.shelven.com/tuchuang/20221123/4.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221123/4.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="1-2-4-格式化输出和占位符"><a href="#1-2-4-格式化输出和占位符" class="headerlink" title="1.2.4 格式化输出和占位符"></a>1.2.4 格式化输出和占位符</h4><p>格式化输出意思是按照格式说明所描述的文字规则进行输出，占位符的使用是格式化输出的表现形式。占位符的意思是替后面的变量占住这个位置，因此所有占位符最后都需要格式化定义占位符的映射（也就是解释占位符代表的东西）。</p><p>这里记录一下最常用的占位符</p><table><thead><tr><th>占位符</th><th>描述</th></tr></thead><tbody><tr><td>%s</td><td>针对所有数据类型</td></tr><tr><td>%d</td><td>针对整型数据类型</td></tr><tr><td>%f</td><td>只针对浮点数</td></tr><tr><td>%.xf</td><td>浮点数精确到小数点后x位，注意有个点</td></tr></tbody></table><p><img src="https://www.shelven.com/tuchuang/20221123/5.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221123/5.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>可以看到两种输出方式得到的结果是一样的，使用占位符进行格式化输出更简介，且更常用。</p><h3 id="1-2-5-常用函数"><a href="#1-2-5-常用函数" class="headerlink" title="1.2.5 常用函数"></a>1.2.5 常用函数</h3><p>python还有很多数据操作的函数，这里记录最常用的几个，以后继续补充</p><blockquote><p>type(): 查看数据类型</p><p>len(): 查看字符串长度</p><p>int(): 将数据类型转换为整数，如int(“1234”)得到结果整型1234</p><p>float(): 转换为浮点数，如float(“12.34”)得到结果浮点型12.34</p><p>str(): 转换为字符串，如str(123456)得到结果“123456”</p></blockquote><h3 id="1-3-List-列表"><a href="#1-3-List-列表" class="headerlink" title="1.3 List(列表)"></a>1.3 List(列表)</h3><p><strong>列表数据可以存储任意一种数据类型</strong>，是python特有的数据类型，列表用来存储由多个值构成的序列，可以嵌套其他列表，<strong>是一种可变数据类型</strong>。</p><p>不同数据项之间由逗号分开，整体放在一个方括号[]里，就可以创建列表，如ls &#x3D; [1, 2, 3, 4]就是一个列表。</p><h4 id="1-3-1-修改列表元素"><a href="#1-3-1-修改列表元素" class="headerlink" title="1.3.1 修改列表元素"></a>1.3.1 修改列表元素</h4><p>因为列表是可变数据类型，因此可以用索引或者切片的方法修改列表中的元素。</p><p><img src="https://www.shelven.com/tuchuang/20221123/6.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221123/6.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>可以使用del删除列表或者列表中索引为某个数的元素。</p><p><img src="https://www.shelven.com/tuchuang/20221123/7.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221123/7.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="1-3-2-列表生成式"><a href="#1-3-2-列表生成式" class="headerlink" title="1.3.2 列表生成式"></a>1.3.2 列表生成式</h4><p>除了直接创建列表，还可以使用列表生成式直接生成列表。</p><p><img src="https://www.shelven.com/tuchuang/20221123/9.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221123/9.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="1-3-3-列表的方法函数"><a href="#1-3-3-列表的方法函数" class="headerlink" title="1.3.3 列表的方法函数"></a>1.3.3 列表的方法函数</h4><p>记录一下操作列表的常用方法，这里就不演示了。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>list.append(obj)</td><td>列表<strong>末尾</strong>添加新的对象</td></tr><tr><td>list.count(obj)</td><td>返回某个元素在列表中出现的次数</td></tr><tr><td>list.extend(seq)</td><td>在列表末尾添加另一个列表的所有元素</td></tr><tr><td>list.index(obj)</td><td>返回第一个匹配的的索引值</td></tr><tr><td>list.insert(index, obj)</td><td>在指定索引插入对象</td></tr><tr><td>list.pop(index)</td><td>移除指定索引的值，并返回该值</td></tr><tr><td>list.sort()</td><td>对原列表进行升序排序（纯数字才可以），降序需要添加reverse&#x3D;True</td></tr><tr><td>list.reverse()</td><td>反转列表元素</td></tr><tr><td>list.remove(obj)</td><td>移除第一个匹配的某对象</td></tr></tbody></table><h3 id="1-4-Tuple-元组"><a href="#1-4-Tuple-元组" class="headerlink" title="1.4 Tuple(元组)"></a>1.4 Tuple(元组)</h3><p>元组也是python的一种特殊数据类型，和列表很相似，<strong>但是是不可变对象</strong>。如果想创建一个全局都不变的变量，可以考虑创建元组。</p><p>元组中的元素用逗号分隔，一般要使用小括号（小括号不是必须的，只是为了方便理解和美观）。</p><p><strong>元组中如果只有一个元素，需要在元素后加逗号。</strong>否则无法判断这是一个元组还是一个整型数据。</p><p><img src="https://www.shelven.com/tuchuang/20221123/8.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221123/8.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>同样元组数据也可以进行索引和切片，这里不赘述。</p><h4 id="1-4-1-元组和列表的互相转化"><a href="#1-4-1-元组和列表的互相转化" class="headerlink" title="1.4.1 元组和列表的互相转化"></a>1.4.1 元组和列表的互相转化</h4><p>元组转化列表使用list()函数，列表转化元组使用tuple()函数。</p><p><img src="https://www.shelven.com/tuchuang/20221123/10.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221123/10.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="1-4-2-结合元组的列表生成式"><a href="#1-4-2-结合元组的列表生成式" class="headerlink" title="1.4.2 结合元组的列表生成式"></a>1.4.2 结合元组的列表生成式</h4><p>元组不能通过和列表一样的生成式来创建，但是列表生成式中可以加入元组。</p><p><img src="https://www.shelven.com/tuchuang/20221123/11.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221123/11.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="1-5-Set-集合"><a href="#1-5-Set-集合" class="headerlink" title="1.5 Set(集合)"></a>1.5 Set(集合)</h3><p>集合是一个无序的不重复元素序列，可以使用大括号{}或者set()函数创建集合，但是创建一个空集合必须要用set()而不是{}，因为{}是用来创建一个空字典的。</p><p>因为用的不多，简单记录一下，集合有三个特点</p><blockquote><p>集合的元素是无序的。 如：{1, 2, 3}和{1, 3, 2}是完全相等的。</p><p>集合的元素是不重复的。 如：{1, 1, 1}只会保留一个值，打印结果为{1}。</p><p>集合的元素必须是不可变数据类型（数字、字符串和元组）。 如：{1, [1, 2]}打印结果会报错，因为列表是可变数据类型。</p></blockquote><h3 id="1-6-Dictionary-字典"><a href="#1-6-Dictionary-字典" class="headerlink" title="1.6 Dictionary(字典)"></a>1.6 Dictionary(字典)</h3><p>字典用的比较多，其存储特点是键值对的形式出现（Key-Value），一个键对应一个值，每个键值对用冒号隔开，每对键值对用逗号隔开。字典也可以存储任意类型数据。</p><p>需要注意的一点，在字典数据类型中，<strong>键必须是唯一的</strong>，但是值可以不唯一，<strong>值可以取任何数据类型，但是键必须是不可变数据类型。</strong></p><h4 id="1-6-1-字典创建和修改"><a href="#1-6-1-字典创建和修改" class="headerlink" title="1.6.1 字典创建和修改"></a>1.6.1 字典创建和修改</h4><p>字典数据可以通过花括号直接创建，或者通过dict()函数创建（非空）。</p><p><img src="https://www.shelven.com/tuchuang/20221123/13.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221123/13.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>通过访问键来访问对应的值，添加、删除和修改的方法均类似。</p><p><img src="https://www.shelven.com/tuchuang/20221123/14.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20221123/14.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="1-6-2-字典的方法函数"><a href="#1-6-2-字典的方法函数" class="headerlink" title="1.6.2 字典的方法函数"></a>1.6.2 字典的方法函数</h4><p>记录一下常用的字典方法函数，就不演示了，具体用到的时候可以查。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>dict.keys()</td><td>返回所有键的列表dict_key对象，可以转换成列表、元组和集合</td></tr><tr><td>dict.values()</td><td>返回所有值的列表dict_values对象，也可以转换成列表、元组和集合</td></tr><tr><td>dict.items()</td><td>返回所有键值对的列表dict_items对象，同样可以转换成列表、元组和集合</td></tr><tr><td>dict.clear()</td><td>清空字典，无返回值，只剩下空字典</td></tr><tr><td>dict.get(key, default&#x3D;None)</td><td><strong>返回</strong>字典中指定key的<strong>value值</strong>，如果key不存在，则返回default值</td></tr><tr><td>dict.pop(key, default&#x3D;None)</td><td><strong>删除</strong>指定的key<strong>并返回</strong>对应的<strong>value值</strong>，如果key不存在，则返回default值</td></tr></tbody></table><p>简单小结一下关于python数据类型的注意点：</p><blockquote><p>1.可变数据类型：List、Dictionary、Set</p><p>2.不可变数据类型：Tuple、Numbers、String。不可变体现在索引这些变量名的元素不可被重新赋值</p><p>3.下标索引：String、List、Tuple支持下标索引，Dictionary是通过Key值索引</p><p>4.切片：String、List、Tuple支持切片操作</p></blockquote></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;这两个月经历了突然的疫情隔离，研究生开题，学术论坛，研究生创新项目等等……终于在这一周尘埃落定了，得以静下心来整理整理自己的一些学习笔记。之前我用过一些python编写的项目，我也只是依葫芦画瓢或者在demo上直接改，还没有系统性地学习过这门编程语言。这里就再记录下自己自学python的一些入门时的笔记，以及记录下几个机器学习方面的python库的使用方法。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="编程自学" scheme="http://www.shelven.com/categories/%E7%BC%96%E7%A8%8B%E8%87%AA%E5%AD%A6/"/>
    
    
    <category term="python" scheme="http://www.shelven.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>深度学习笔记</title>
    <link href="http://www.shelven.com/2022/09/20/a.html"/>
    <id>http://www.shelven.com/2022/09/20/a.html</id>
    <published>2022-09-19T16:58:05.000Z</published>
    <updated>2022-12-03T16:21:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>开坑记录一下学习人工智能(深度学习为主)的笔记，方便以后回顾学习~整理自点头教育</p><span id="more"></span><h2 id="人工智能的趋势展望"><a href="#人工智能的趋势展望" class="headerlink" title="人工智能的趋势展望"></a>人工智能的趋势展望</h2><div class="story post-story"><h3 id="1-前沿技术"><a href="#1-前沿技术" class="headerlink" title="1. 前沿技术"></a>1. 前沿技术</h3><h4 id="Transformer模型"><a href="#Transformer模型" class="headerlink" title="Transformer模型"></a>Transformer模型</h4><p>基于自注意力机制，有效提高模型训练效率</p><p>由Google的Ashish Vaswani等人和多伦多大学的Aidan N.Gomez于2017年首次提出，是一种基于<strong>自注意力机制</strong>（在Transformer模型中起基础作用，可减少对外部信息的依赖,更擅长捕捉数据或特征的内部关系，优化模型训练结果）的深度学习模型，该模型主要由编码器和解码器构成，模型本身并行度较高，在精度和性能上均要优于传统的循环神经网络（RNN）和卷积神经网络（CNN）。Transformer模型在简单语言问答和语言建模任务上有着较好表现。</p><p><img src="https://www.shelven.com/tuchuang/20220919/1.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/1.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="BERT模型"><a href="#BERT模型" class="headerlink" title="BERT模型"></a>BERT模型</h4><p>基于Transformer Encoder构建的预测模型</p><p>由Google于2018年提出，是基于Transformer Encoder构建的一种模型。模型基本思想：给定上下文来预测下一个词。BERT模型架构是由多接口组成的Transformer编码器层，即全连接神经网络增加自注意力机制。对于序列中的每个输入标记，每个接口计算键值和查询向量，相关向量用于创建加权表示，合并同一层中所有接口输出并通过全连接层运行。每个层使用跳跃连接进行包装，之后将层归一化处理。</p><p><img src="https://www.shelven.com/tuchuang/20220919/2.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="自监督学习"><a href="#自监督学习" class="headerlink" title="自监督学习"></a>自监督学习</h4><p>将无监督问题转化为有监督问题的方法</p><p>旨在对于无标签数据，通过设计辅助任务来挖掘数据自身的表征特性作为监督信息，来提升模型的特征提取能力，将无监督问题转化为有监督问题的方法。</p><p>说到自监督就顺便说下<strong>有监督学习</strong>和<strong>无监督学习</strong>，有监督给定的结果是确定的；无监督是实际应用场景中最多的，结果不确定，根据类别未知(没有被标记)的训练样本解决模式识别中的各种问题。</p><p><img src="https://www.shelven.com/tuchuang/20220919/3.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/3.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="类脑计算"><a href="#类脑计算" class="headerlink" title="类脑计算"></a>类脑计算</h4><p>模拟大脑结构和信息加工过程，提高机器认知能力、降低运行功耗</p><p>类脑计算(Brain-Inspired Computing): 又称神经形态计算，是借鉴生物神经系统信息处理模式和结构的计算理论、体系结构、芯片设计以及应用模型与算法的总称。类脑计算可模拟人类大脑信息处理方式，以极低的功耗对信息进行异步、并行、高速和分布式处理，并具备自主感知、识别和学习等多种能力，是实现通用人工智能的途径之一。</p><p><img src="https://www.shelven.com/tuchuang/20220919/4.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/4.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="AI大模型"><a href="#AI大模型" class="headerlink" title="AI大模型"></a>AI大模型</h4><p>包含万亿量级参数的预训练模型，显著降低模型训练成本</p><p>AI大模型(Foundation Models):是指经过大规模数据训练且在经微调后即可适应广泛下游任务的模型。随着参数规模不断扩大，AI大模型在语言、视觉、推理、人机交互等领域涌现出新能力。</p><p><img src="https://www.shelven.com/tuchuang/20220919/5.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/5.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="2-人工智能的产业融合"><a href="#2-人工智能的产业融合" class="headerlink" title="2. 人工智能的产业融合"></a>2. 人工智能的产业融合</h3><h4 id="人工智能与元宇宙"><a href="#人工智能与元宇宙" class="headerlink" title="人工智能与元宇宙"></a>人工智能与元宇宙</h4><p>元宇宙（Metaverse）：本质上是对现实世界的虚拟化、数字化过程，其主要包括基础设施、人机交互、空间计算等七层架构，其中计算机视觉、AI芯片和嵌入式AI等人工智能技术及基础设施共同助力元宇宙加速落地。元宇宙涵盖芯片、云计算、技术平台、通信、智能设备、内容服务等庞大生态系统。</p><p><img src="https://www.shelven.com/tuchuang/20220919/6.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/6.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="人工智能与生命科学"><a href="#人工智能与生命科学" class="headerlink" title="人工智能与生命科学"></a>人工智能与生命科学</h4><p>AlphaFold是由谷歌旗下DeepMind团队基于深度学习算法的<strong>蛋白质结构预测</strong>的人工智能系统，其被视作人工智能深入到生物领域的一大突破。目前AlphaFold已对98.5%的人类蛋白质结构做出预测，此外还对于大肠杆菌、果蝇、斑马鱼、小鼠等研究时常用生物的蛋白质结构进行预测。（这块比较感兴趣，有空继续了解一下）</p><p><img src="https://www.shelven.com/tuchuang/20220919/7.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/7.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="人工智能与新冠疫情"><a href="#人工智能与新冠疫情" class="headerlink" title="人工智能与新冠疫情"></a>人工智能与新冠疫情</h4><p>Eva是用于检测入境旅客新冠病毒的强化学习系统，其由美国南加州大学、美国宾夕法尼亚学、AgentRisk以及希腊相关专家合作开发。 </p><p>2020年，Eva系统被部署到希腊所有入境口岸（机场、港口、车站等），用于识别限制新冠无症状旅客入境。（这里存疑，用算法确定新冠受检者，虽然在一定程度上能缓解新冠检测用品有限的不利情况，但是无疑会漏掉部分入境的可能感染者，一旦感染爆发得不偿失）</p><p><img src="https://www.shelven.com/tuchuang/20220919/8.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/8.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="人工智能与半导体"><a href="#人工智能与半导体" class="headerlink" title="人工智能与半导体"></a>人工智能与半导体</h4><p>AI与EDA紧密融合，促使芯片PPA结果更加稳定</p><p>为使PPA优化结果更佳，同时为应对芯片安全性需求提升、设计规模攀升及工艺节点微缩等趋势，EDA厂商开始利用AI技术解决半导体芯片设计问题。在EDA中，数据快速提取模型、布局和布线、电路仿真模型、 PPA优化决策等环节均有AI技术参与。</p><p><img src="https://www.shelven.com/tuchuang/20220919/9.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/9.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="人工智能与碳中和"><a href="#人工智能与碳中和" class="headerlink" title="人工智能与碳中和"></a>人工智能与碳中和</h4><p>人工智能在预测、监测、优化三大环节赋能碳中和</p><p>当前，碳中和已获得全球超过40个国家和地区承诺，其中大部分国家宣布将于2050年左右实现碳中和目标。从整体来看，人工智能将从预测、监测、优化三大环节助力碳中和，如预测未来碳排放量、实时监测碳足迹、优化工作流程等。</p><p><img src="https://www.shelven.com/tuchuang/20220919/10.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/10.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="人工智能与冬奥会"><a href="#人工智能与冬奥会" class="headerlink" title="人工智能与冬奥会"></a>人工智能与冬奥会</h4><p>2022年2月，第24届冬季奥林匹克运动会成功在北京举办。人工智能技术在冬奥会开幕式、比赛项目、运动员训练等多个场景实现应用，助力科技冬奥目标实现。</p><p><img src="https://www.shelven.com/tuchuang/20220919/11.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/11.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="3-人工智能产业发展的路径探究"><a href="#3-人工智能产业发展的路径探究" class="headerlink" title="3. 人工智能产业发展的路径探究"></a>3. 人工智能产业发展的路径探究</h3><p>人工智能在“科研成果—商业化落地”过程中依然存在诸多挑战</p><p><img src="https://www.shelven.com/tuchuang/20220919/12.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/12.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="伦理与安全"><a href="#伦理与安全" class="headerlink" title="伦理与安全"></a>伦理与安全</h4><p>人工智能发展面临隐私保护与算法合规使用等方面挑战</p><p>随着人工智能技术的高速发展与普及应用，由其产生的伦理与安全问题日益受到关注。人工智能不但延续信息技术的伦理问题，又因深度学习算法具有不透明、难解释、自适应、运用广泛等特征而在基本人权、社会秩序、国家安全等方面产生新问题。</p><p><img src="https://www.shelven.com/tuchuang/20220919/13.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/13.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="国家间技术限制"><a href="#国家间技术限制" class="headerlink" title="国家间技术限制"></a>国家间技术限制</h4><p>国家间技术限制阻碍人工智能技术进步</p><p>当前，开源深度学习框架、开源工具集、开源应用软件快速发展，国际间AI技术交流不断深入，但部分国家和政府间组织为保持自身AI 技术优势，限制AI技术交流。如美国在2021年6月发布《创新与竞争法案》，在AI、无人机、芯片等多个领域限制与中国合作；美国商务部于2019年10月和2020年5月将商汤科技、科大讯飞等多家中国AI公司加入其实体清单，实施投资限制；2022年白宫修订“关键和新兴技术（CET）清单”，对AI技术具体分类并实行技术封锁。欧盟则于2021年9月通过最新出口管制法规，内容涵盖人脸识别等AI技术。 </p><p>上述相关政策与未来人工智能发展趋势背道而驰，不利于各国开展技术合作。</p><p><img src="https://www.shelven.com/tuchuang/20220919/14.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/14.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div><h2 id="深度学习算法部分内容"><a href="#深度学习算法部分内容" class="headerlink" title="深度学习算法部分内容"></a>深度学习算法部分内容</h2><div class="story post-story"><h3 id="迁移学习"><a href="#迁移学习" class="headerlink" title="迁移学习"></a>迁移学习</h3><p>将知识由源域迁移至目标域，提高机器学习效率</p><p>迁移学习（Transfer Learning,TL）：是一种机器学习方法,是把已训练好的模型参数迁移到新的模型来帮助新模型训练，其核心目标是将知识从源域迁移到目标域，让机器也可以做到“触类旁通”。</p><p>迁移学习的主要优点是节省模型训练时间，且在目标域训练数据不足时，模型仍能取得较好的性能。</p><p>迁移学习的训练框架可以概括为：1）选择源模型，从可用模型中挑选出预训练模型；2）重用模型，在目标域中使用源模型进行训练；3）调整模型。模型可以在目标数据集中对输入-输出进行选择性微调，以让其适应目标任务。</p><p>实现迁移学习的方式主要包括样本迁移、特征迁移、模型迁移。目前，迁移学习主要应用在<strong>计算机视觉</strong>、<strong>自然语言处理</strong>等领域。</p><p><img src="https://www.shelven.com/tuchuang/20220919/15.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/15.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="神经网络与卷积神经网络"><a href="#神经网络与卷积神经网络" class="headerlink" title="神经网络与卷积神经网络"></a>神经网络与卷积神经网络</h3><h4 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h4><p>具有适应性简单单元组成的广泛并行互联网络</p><p>神经网络（Neural Network）：由数千甚至数百万个紧密互连的简单处理节点组成，其主要包括输入层（输入数据）、中间层&#x2F;隐藏层（学习复杂决策边界）和输出层（输出结果）。</p><p>神经网络可以用于回归，但主要应用于分类问题。如下图所示：输入层表示输入图像（64维向量），中间层使用Sigmoid等非线性函数对于输入层数据进行计算，输出层使用非线性函数对于中间层数据进行计算。</p><p>神经网络通过采取设置中间层的方式，利用单一算法学习各种决策边界，调节中间层数量以及层的深度，神经网络可学习更复杂的边界特征，而得出更加准确的结果。</p><p><img src="https://www.shelven.com/tuchuang/20220919/16.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/16.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h4><p>以<strong>图像识别</strong>为核心的深度学习算法</p><p>卷积神经网络（Convolutional Neural Network,CNN）：由数千甚至数百万个紧密互连的简单处理节点组成，其主要包括输入层、卷积层、池化层、全连接层和输出层，<strong>适合处理图片、视频等类型数据</strong>。</p><p>1980年，日本科学家福岛邦彦提出一个包含卷积层、池化层的神经网络结构。在此基础上，Yann Lecun将BP算法应用到该神经网络结构的训练上，形成当代卷积神经网络的雏形；1988年，Wei Zhang提出第一个二维卷积神经网络：平移不变人工神经网络（SIANN），并将其应用于<strong>检测医学影像</strong>；1998年Yann LeCun及其合作者构建了更加完备的卷积神经网络LeNet-5并在手写数字的识别问题中取得成功。</p><p><img src="https://www.shelven.com/tuchuang/20220919/17.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/17.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><strong>卷积层</strong>：图片输入转化成RGB对应的数字，然后通过卷积核做卷积，目的是提取输入中的主要特征，卷积层中使用同一卷积核对每个输入样本进行卷积操作；</p><p><strong>池化层</strong>：作用在于减小卷积层产生的特征图尺寸（压缩特征映射图尺寸有助于降低后续网络处理的负载）；</p><p><strong>全连接层</strong>：计算激活值然后通过激活函数计算各单元输出值（激活函数包括<strong>Sigmoid、tanh、ReLU</strong>等）</p><p><strong>输出层</strong>：使用似然函数计算各类别似然概率。</p><p><img src="https://www.shelven.com/tuchuang/20220919/18.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/18.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="循环神经网络与图神经网络"><a href="#循环神经网络与图神经网络" class="headerlink" title="循环神经网络与图神经网络"></a>循环神经网络与图神经网络</h3><h4 id="循环神经网络"><a href="#循环神经网络" class="headerlink" title="循环神经网络"></a>循环神经网络</h4><p>用于处理<strong>序列数据</strong>的神经网络</p><p>循环神经网络（Recurrent Neural Network,RNN）：是一类以序列数据（指相互依赖的数据流，比如时间序列数据、信息性的字符串、对话等）为输入，在序列的演进方向进行递归且所有节点（循环单元）按链式连接的神经网络。目前，<strong>语言建模和文本生成、机器翻译、语音识别、生成图像描述、视频标记是RNN应用最多的领域</strong>。</p><p><img src="https://www.shelven.com/tuchuang/20220919/19.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/19.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="图神经网络"><a href="#图神经网络" class="headerlink" title="图神经网络"></a>图神经网络</h4><p>用于处理图结构数据的神经网络</p><p>图神经网络（Graph Neural Networks，GNN）：将图数据和神经网络进行结合，在图数据上面进行端对端的计算，具备端对端学习、擅长推理、可解释性强的特点。</p><p>图神经网络发展出多个分支，主要包括图卷积网络、图注意力网络、图自编码器、图生成网络和图时空网络等。</p><p>图神经网络的训练框架如下：首先，每个节点获取其相邻节点的所有特征信息，将聚合函数（如求和或取平均）应用于这些信息。 聚合函数的选择必须不受节点顺序和排列的影响。之后，将前一步得到的向量传入一个神经网络层（通常是乘以某个矩阵），然后使用非线性激活函数（如ReLU）来获得新的向量表示。</p><p>目前，图神经网络在许多领域的实际应用中都展现出<strong>强大的表达能力和预测能力，如物理仿真、科学研究、生物医药、金融风控等</strong>。</p><p><img src="https://www.shelven.com/tuchuang/20220919/20.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/20.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="长短期记忆神经网络"><a href="#长短期记忆神经网络" class="headerlink" title="长短期记忆神经网络"></a>长短期记忆神经网络</h3><p>在RNN中加入<strong>门控机制</strong>，解决梯度消失问题</p><p>长短期记忆神经网络（Long Short-Term Memory,LSTM）：LSTM是一种特殊的循环神经网络（RNN）。传统RNN在训练中，随着训练时间的加长和层数的增多，很容易出现梯度爆炸或梯度消失问题，导致无法处理长序列数据，LSTM可有效解决传统RNN“长期依赖”问题。</p><p>LSTM由状态单元、输入门（决定当前时刻网络的输入数据有多少需要保存到单元状态）、遗忘门（决定上一时刻的单元状态有多少需要保留到当前时刻）、输出门（控制当前单元状态有多少需要输出到当前输出值）组成，以此令长期记忆与短期记忆相结合，达到序列学习的目的</p><p>LSTM应用领域主要包括文本生成、机器翻译、语音识别、生成图像描述和视频标记等。（我前一篇博客做的tts用了Tacotron2，其编码器模块中就引入了一个双向LSTM层）</p><p><img src="https://www.shelven.com/tuchuang/20220919/21.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/21.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="自编码器"><a href="#自编码器" class="headerlink" title="自编码器"></a>自编码器</h3><p>通过期望输出等同于输入样本的过程，实现对输入样本抽象特征学习</p><p>典型深度无监督学习模型包括<strong>自编码器</strong>、<strong>受限波尔兹曼机</strong>与<strong>生成对抗网络</strong>。</p><p>自编码器（Autoencoder,AE）：包括编码器和解码器两部分，其中<strong>编码器将高维输入样本映射到低维抽象表示，实现样本压缩与降维</strong>；<strong>解码器将抽象表示转换为期望输出，实现输入样本的复现</strong>。自码器的输入与期望输出均为无标签样本，隐藏层输出则作为样本的抽象特征表示。</p><p>自编码器仅通过最小化输入样本与重构样本之间的误差来获取输入样本的抽象特征表示，无法保证自编码器提取到样本的本质特征。为避免上述问题，需要对自编码器添加约束或修改网络结构，进而产生稀疏自编码器、去噪自编码器、收缩自编码器等改进算法。</p><p>自编码器凭借其优异的特征提取能力，主要应用于目标识别、文本分类、图像重建等诸多领域。</p><p><img src="https://www.shelven.com/tuchuang/20220919/22.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/22.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="生成对抗网络"><a href="#生成对抗网络" class="headerlink" title="生成对抗网络"></a>生成对抗网络</h3><p>生成对抗网络（Generative Adversarial Network,GAN）：通过使用对抗训练机制对两个神经网络进行训练，避免反复应用马尔可夫链学习机制带来的配分函数计算，明显提高应用效率。</p><p>生成对抗网络包含一组相互对抗模型—判别器和生成器，判别器目的是正确区分真实数据和生成数据，使得判别准确率最大化，生成器是尽可能逼近真实数据的潜在分布。生成器类似于造假钞的人，其制造出以假乱真的假钞，判别器类似于警察，尽可能鉴别出假钞，最终造假钞的人和警察双方在博弈中不断提升各自能力。（同样是我前面一篇博客语音合成tts中，应用的HiFiGAN就是基于GAN的声码器）</p><p><img src="https://www.shelven.com/tuchuang/20220919/23.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220919/23.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;开坑记录一下学习人工智能(深度学习为主)的笔记，方便以后回顾学习~整理自点头教育&lt;/p&gt;</summary>
    
    
    
    <category term="深度学习" scheme="http://www.shelven.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="人工智能" scheme="http://www.shelven.com/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>go-cqhttp扫码登录异常的解决方法</title>
    <link href="http://www.shelven.com/2022/09/09/b.html"/>
    <id>http://www.shelven.com/2022/09/09/b.html</id>
    <published>2022-09-09T11:43:05.000Z</published>
    <updated>2022-12-03T16:10:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>假期用自己的服务器搭建了一个基于 Nonebot2 和 go-cqhttp 框架的QQ聊天机器人，使用的开源项目是绪山真寻bot（<a href="https://github.com/HibiKier/zhenxun_bot">项目地址点击这里</a>）。因为项目提供了一键安装包，这里就不详细说安装过程了，简单说下首次运行或者切换bot QQ号会碰到的go-cqhttp扫码登陆异常的问题。</p><span id="more"></span><h3 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h3><p>首次运行或者切换bot QQ号后，go-cqhttp会要求需要登录验证，由于纯linux系统无法使用浏览器抓取滑条，因此会自动跳转到手机QQ扫码验证。</p><p><img src="https://www.shelven.com/tuchuang/20220909_1/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220909_1/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>但是扫码会提示两个设备不在一个网络，无法登录。（很明显我的云端linux服务器不可能和手机能在一个网络中）</p><p><img src="https://www.shelven.com/tuchuang/20220909_1/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220909_1/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>这个问题是腾讯QQ安全机制引起的，很明显是限制QQ机器人的手段，也就是你扫码的网络环境要和服务器的网络环境一致才可以登录。</p><h3 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h3><h4 id="第一步-下载和运行win版go-cqhttp"><a href="#第一步-下载和运行win版go-cqhttp" class="headerlink" title="第一步 下载和运行win版go-cqhttp"></a>第一步 下载和运行win版go-cqhttp</h4><p>项目下载地址<a href="https://github.com/Mrs4s/go-cqhttp/releases">Releases · Mrs4s&#x2F;go-cqhttp (github.com)</a></p><p>选择下载最新版本的go-cqhttp_windows_amd64，解压后有三个文件</p><p><img src="https://www.shelven.com/tuchuang/20220909_1/3.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220909_1/3.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>双击exe文件，提示要在power shell中运行，确认，自动生成<strong>go-cqhttp.bat</strong>的批处理文件</p><p>双击运行<strong>go-cqhttp.bat</strong>，选择013，回车</p><p><img src="https://www.shelven.com/tuchuang/20220909_1/4.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220909_1/4.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>修改生成的config.yml配置文件（主要就是改bot QQ号和密码）</p><p>修改之后再次运行go-cqhttp.bat，看到连接成功，网络没有问题即可</p><p><img src="https://www.shelven.com/tuchuang/20220909_1/5.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220909_1/5.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>前面的反向代理失败统统不用管（因为我没有设置），我们只需要win版go-cqhttp提供设备登录信息文件（<strong>device.json</strong>）和密钥信息文件（<strong>session.token</strong>）即可。这两个文件特别重要，尤其是device.json，缺一个都将会导致登陆失败。</p><h4 id="第二步-替换文件"><a href="#第二步-替换文件" class="headerlink" title="第二步 替换文件"></a>第二步 替换文件</h4><p>替换linux服务器go-cqhttp文件夹下的<strong>device.json和session.token</strong>（有的话替换，无的话直接加进去）文件，<strong>config文件最好不要替换</strong>，你只要改一下qq号和密码就行，防止底下设置的反向连接端口出错（很重要！！）。</p><p><img src="https://www.shelven.com/tuchuang/20220909_1/6.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220909_1/6.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>重新在linux上启动go-cqhttp，问题解决。</p><p><img src="https://www.shelven.com/tuchuang/20220909_1/7.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220909_1/7.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;假期用自己的服务器搭建了一个基于 Nonebot2 和 go-cqhttp 框架的QQ聊天机器人，使用的开源项目是绪山真寻bot（&lt;a href=&quot;https://github.com/HibiKier/zhenxun_bot&quot;&gt;项目地址点击这里&lt;/a&gt;）。因为项目提供了一键安装包，这里就不详细说安装过程了，简单说下首次运行或者切换bot QQ号会碰到的go-cqhttp扫码登陆异常的问题。&lt;/p&gt;</summary>
    
    
    
    <category term="QQ机器人" scheme="http://www.shelven.com/categories/QQ%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    
    
    <category term="qq bot" scheme="http://www.shelven.com/tags/qq-bot/"/>
    
    <category term="go-cqhttp" scheme="http://www.shelven.com/tags/go-cqhttp/"/>
    
  </entry>
  
  <entry>
    <title>深度学习——语音合成tts笔记（下）</title>
    <link href="http://www.shelven.com/2022/09/09/a.html"/>
    <id>http://www.shelven.com/2022/09/09/a.html</id>
    <published>2022-09-08T19:32:17.000Z</published>
    <updated>2022-12-03T16:20:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>（接上篇博客）做完数据集，我们手里现在有训练集（train set）和测试集（test set）音频文件，以及对应的拼音文本，接下来就可以跑Tacotron2来训练模型了。</p><span id="more"></span><h2 id="2-训练模型-amp-合成语音"><a href="#2-训练模型-amp-合成语音" class="headerlink" title="2. 训练模型 &amp; 合成语音"></a>2. 训练模型 &amp; 合成语音</h2><div class="story post-story"><p><a href="https://github.com/NVIDIA/tacotron2">Tacotron2项目地址点击这里</a></p><p><a href="https://github.com/jik876/hifi-gan">HiFi-GAN项目地址点击这里</a></p><p>本篇博客训练模型&amp;合成语音基于以上两个开源项目，再次感谢原作者！</p><h3 id="2-1-Tacotron2简介"><a href="#2-1-Tacotron2简介" class="headerlink" title="2.1 Tacotron2简介"></a>2.1 Tacotron2简介</h3><p>简单讲一讲Tacotron2，它是由google推出的从文本中合成语音的神经网络结构，也就是一个语音合成（Text To Speech，TTS）框架，可以实现端到端的语音合成。Tacotron2与其前代Tacotron类似，比较重要的一个区别是在编码器模块中引入了一个双向LSTM层和卷积层，相比原来的CBHG堆叠结构和GRU循环层更为简洁。</p><p>模型主要由两部分组成：</p><ul><li><ol><li>声谱预测网络：特征预测网络，包含一个编码器和一个引入注意力机制（attention）的解码器，作用是将输入字符序列预测为梅尔频谱的帧序列。</li></ol></li><li><ol start="2"><li>声码器（vocoder）：将预测的梅尔频谱帧序列转换产生时域波形样本，算是WaveNet的修订版。</li></ol></li></ul><p>原项目中的声码器我们暂时不用（<strong>上面地址提供的Tacotron 2就是没有wavenet的版本</strong>），因为有更好的工具HiFi-GAN。</p><p>代码实现详解有很多博客可以参考（<a href="https://blog.csdn.net/whjkm/article/details/89321954#commentBox">(16条消息) Tacotron2 论文 + 代码详解_HJ_彼岸的博客-CSDN博客_tacotron2</a>），<strong>这里只要知道我们是用Tacotron2生成梅尔频谱，在此基础上结合我们输入的字符序列（也就是对应的拼音文本）训练模型。</strong></p><p><u>特别注意一点</u>：Tacotron 2是基于tensorflow1.5版本运行的，如果是自己电脑上配置环境的话，<strong>务必将python版本降到3.7以下！</strong>否则将会无法安装tensorflow1.5，除了tensorflow有硬性版本要求之外，其他依赖都可以安装最新版本——<strong>反复配置环境治好了我的精神内耗</strong></p><p>如果你不想和我一样配置好几天环境的话，我推荐最好使用google colab，一键解决环境问题，下面会说到。</p><h3 id="2-2-HiFi-GAN简介"><a href="#2-2-HiFi-GAN简介" class="headerlink" title="2.2 HiFi-GAN简介"></a>2.2 HiFi-GAN简介</h3><p>简单说下，<strong>声码器的作用就是将梅尔频谱转换成语音信号</strong>，和上面是对应的。</p><p>为什么我们没有用上面Tacotron2的声码器呢，主要原因就是现在有很多更优秀的声码器供我们选择。</p><p>早期比较有名的声码器WaveNet，它是一种自回归卷积神经网络，合成的效果非常好可以说和人类发声非常相似，但有个致命的缺点——合成速度太慢。直到2020年项目作者开发了这套基于GAN（生成式对抗网络）的神经网络声码器，从作者的论文里可以找到，HiFi-GAN在GPU上可以以比实时速度快167.9倍的速度生成22.05 kHz的语音，在CPU上可以以比自回归模型快13.4倍的速度生成语音，这就是它的牛逼之处。</p><p>HiFi-GAN主要有一个生成器和两个判别器，具体结构就不说了，知道一下生成器和两个判别器是通过<strong>对抗学习</strong>的方法训练的，新增加了<strong>两个损失函数</strong>来提高训练的稳定性和提高模型的性能。有能力的小伙伴可以看原论文（HiFi-GAN: Generative Adversarial Networks for Efficient and High Fidelity Speech Synthesis）了解详情。</p><p>需要注意一下作者使用VCTK数据集进行实验，测试了3个模型（V1、V2和V3），简单来说V1是最优模型，作者发布的预训练模型以及相应的配置文件都是以V1模型为基础的。我在这篇博客使用的HiFi-GAN模型<strong>g_02500000</strong>就是作者的预训练模型，配置文件为<strong>config.json</strong>。</p><blockquote><p>HiFi-GAN预训练模型与配置文件下载地址：</p><p><a href="https://drive.google.com/drive/folders/1YuOoV3lO2-Hhn1F2HJ2aQ4S0LC1JdKLd">UNIVERSAL_V1 - Google 云端硬盘</a></p></blockquote><h3 id="2-2-注册谷歌colab和谷歌云盘"><a href="#2-2-注册谷歌colab和谷歌云盘" class="headerlink" title="2.2 注册谷歌colab和谷歌云盘"></a>2.2 注册谷歌colab和谷歌云盘</h3><p>训练模型是一件非常消耗算力的过程，因为涉及到图形处理，我们要用GPU进行加速。我的笔记本GPU非常拉跨，跑模型立马爆显存，因此我个人比较推荐白嫖谷歌colab上面的免费专业级GPU（Nvidia K80），免费用户只能用这一种GPU，至少比我的笔记本好多了。</p><p>需要注意下colab<strong>最大连接时长是12小时</strong>，12小时后会强行关闭GPU连接，因此需要注意下你是什么时候开始用GPU跑模型的，并且及时保存数据。关闭后要等待24小时才可以继续使用GPU，所以<strong>理论上可以用三个号不间断白嫖GPU资源</strong><del>（我特地申请了4个谷歌号）</del>，<strong>你只需要偶尔切换屏幕看下是否有谷歌的人机验证就行</strong>。</p><p>这里为什么还推荐谷歌云盘呢，是因为谷歌云盘可以挂载到colab上，这样调用文件就非常方便，及时保存不用担心数据丢失。谷歌云盘提供15GB的免费空间，如果保存模型比较频繁的话可能不够用，但是我们可以申请无限量的团队盘（<strong>共享云端硬盘</strong>）<del>薅羊毛必备</del>。</p><p><img src="https://www.shelven.com/tuchuang/20220909/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220909/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="2-3-使用colab训练模型-amp-合成语音"><a href="#2-3-使用colab训练模型-amp-合成语音" class="headerlink" title="2.3 使用colab训练模型 &amp; 合成语音"></a>2.3 使用colab训练模型 &amp; 合成语音</h3><p>我使用的colab笔记文件因为时间久远已经找不到出处了（后续如果找到会标注出来，向原作者致谢！），为了跑中文语音模型，自己也修改了很多参数和步骤，一一解释过于麻烦了….感兴趣的小伙伴可以看笔记文件。具体操作流程在底下的视频（<a href="https://www.bilibili.com/video/BV1TG411b7zR">或者点击此处看我的B站视频</a>）。</p><div class="video"><video controls preload><source src='https://www.shelven.com/tuchuang/20220909/80584935.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><blockquote><p>所有工程文件和资源如下：</p><p>Tacotron2+HiFiGAN打包 链接：<a href="https://pan.baidu.com/s/1ngCUvifQM6ETwuG-NFQeGA">https://pan.baidu.com/s/1ngCUvifQM6ETwuG-NFQeGA</a>  提取码：z6h3  </p><p>400条派蒙语音测试集 链接：<a href="https://pan.baidu.com/s/1g0C0Ck4P_BxdTgMirKRc-g">https://pan.baidu.com/s/1g0C0Ck4P_BxdTgMirKRc-g</a>  提取码：5ew1  </p><p>1800条派蒙语音训练集 链接：<a href="https://pan.baidu.com/s/1IDA4lppAJGHnophQAwkxNg">https://pan.baidu.com/s/1IDA4lppAJGHnophQAwkxNg</a>  提取码：f2xk </p></blockquote><p>需要提及一点，colab在2022年8月1号之后不再支持tensorflow1.5，请教大佬之后我将Tacotron2项目下超参数配置hparams.py改成如下即可正常运行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> text <span class="keyword">import</span> symbols</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hparams</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line">    <span class="comment">################################</span></span><br><span class="line">    <span class="comment"># Experiment Parameters        #</span></span><br><span class="line">    <span class="comment">################################</span></span><br><span class="line">    epochs = <span class="number">3</span>  <span class="comment">#500</span></span><br><span class="line">    iters_per_checkpoint = <span class="number">1000</span></span><br><span class="line">    seed = <span class="number">1234</span></span><br><span class="line">    dynamic_loss_scaling = <span class="literal">True</span></span><br><span class="line">    fp16_run = <span class="literal">False</span></span><br><span class="line">    distributed_run = <span class="literal">False</span></span><br><span class="line">    dist_backend = <span class="string">&quot;nccl&quot;</span></span><br><span class="line">    dist_url = <span class="string">&quot;tcp://localhost:54321&quot;</span></span><br><span class="line">    cudnn_enabled = <span class="literal">True</span></span><br><span class="line">    cudnn_benchmark = <span class="literal">True</span></span><br><span class="line">    ignore_layers = [<span class="string">&#x27;embedding.weight&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">################################</span></span><br><span class="line">    <span class="comment"># Data Parameters             #</span></span><br><span class="line">    <span class="comment">################################</span></span><br><span class="line">    load_mel_from_disk = <span class="literal">False</span>  <span class="comment">#实际上是区别用 numpy读wav ，还是用scipy读wav</span></span><br><span class="line">    training_files = <span class="string">&#x27;filelists/zh_audio_text_train_filelist.txt&#x27;</span></span><br><span class="line">    validation_files = <span class="string">&#x27;filelists/zh_audio_text_val_filelist.txt&#x27;</span></span><br><span class="line">    text_cleaners = [<span class="string">&#x27;english_cleaners&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">################################</span></span><br><span class="line">    <span class="comment"># Audio Parameters             #</span></span><br><span class="line">    <span class="comment">################################</span></span><br><span class="line">    max_wav_value = <span class="number">32768.0</span></span><br><span class="line">    sampling_rate = <span class="number">22050</span>   <span class="comment">#22050</span></span><br><span class="line">    filter_length = <span class="number">1024</span></span><br><span class="line">    hop_length = <span class="number">256</span></span><br><span class="line">    win_length = <span class="number">1024</span></span><br><span class="line">    n_mel_channels = <span class="number">80</span></span><br><span class="line">    mel_fmin = <span class="number">0.0</span></span><br><span class="line">    mel_fmax = <span class="number">8000.0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">################################</span></span><br><span class="line">    <span class="comment"># Model Parameters             #</span></span><br><span class="line">    <span class="comment">################################</span></span><br><span class="line">    n_symbols = <span class="built_in">len</span>(symbols)</span><br><span class="line">    symbols_embedding_dim = <span class="number">512</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Encoder parameters</span></span><br><span class="line">    encoder_kernel_size = <span class="number">5</span></span><br><span class="line">    encoder_n_convolutions = <span class="number">3</span></span><br><span class="line">    encoder_embedding_dim = <span class="number">512</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Decoder parameters</span></span><br><span class="line">    n_frames_per_step = <span class="number">1</span>  <span class="comment"># currently only 1 is supported</span></span><br><span class="line">    decoder_rnn_dim = <span class="number">1024</span></span><br><span class="line">    prenet_dim = <span class="number">256</span></span><br><span class="line">    max_decoder_steps = <span class="number">1000</span></span><br><span class="line">    gate_threshold = <span class="number">0.5</span></span><br><span class="line">    p_attention_dropout = <span class="number">0.1</span></span><br><span class="line">    p_decoder_dropout = <span class="number">0.1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Attention parameters</span></span><br><span class="line">    attention_rnn_dim = <span class="number">1024</span></span><br><span class="line">    attention_dim = <span class="number">128</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Location Layer parameters</span></span><br><span class="line">    attention_location_n_filters = <span class="number">32</span></span><br><span class="line">    attention_location_kernel_size = <span class="number">31</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Mel-post processing network parameters</span></span><br><span class="line">    postnet_embedding_dim = <span class="number">512</span></span><br><span class="line">    postnet_kernel_size = <span class="number">5</span></span><br><span class="line">    postnet_n_convolutions = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">################################</span></span><br><span class="line">    <span class="comment"># Optimization Hyperparameters #</span></span><br><span class="line">    <span class="comment">################################</span></span><br><span class="line">    use_saved_learning_rate = <span class="literal">False</span></span><br><span class="line">    learning_rate = <span class="number">1e-3</span></span><br><span class="line">    weight_decay = <span class="number">1e-6</span></span><br><span class="line">    grad_clip_thresh = <span class="number">1.0</span></span><br><span class="line">    batch_size = <span class="number">2</span>  <span class="comment">#64</span></span><br><span class="line">    mask_padding = <span class="literal">True</span>  <span class="comment"># set model&#x27;s padded outputs to padded values</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_hparams</span>(<span class="params">hparams_string=<span class="literal">None</span>, verbose=<span class="literal">False</span></span>):</span><br><span class="line">    <span class="keyword">return</span> hparams</span><br></pre></td></tr></table></figure><h3 id="2-4-注意事项"><a href="#2-4-注意事项" class="headerlink" title="2.4 注意事项"></a>2.4 注意事项</h3><ul><li><ol><li>训练的epoch不是越多越好，我个人经验epoch 超过400会发生<strong>过拟合</strong>，测试集loss会越来越大，当然这和数据集有着密切的关系。过拟合具体表现为合成语音有部分字无法发音。</li></ol></li><li><ol start="2"><li>每个epoch自动保存模型且会覆盖谷歌云盘的原文件，因此务必要<strong>隔一段时间保存到本地</strong>，以免错过最佳模型（或者你改代码，比如50 epoch保存一次）。</li></ol></li><li><ol start="3"><li>对于文本的处理，需要参考Tacotron 2项目下的text文件夹中的四个文件cleaners.py、cmudict.py、numbers.py和symbols.py，我是进行了最简单的设置，可以根据自己需要更改。</li></ol></li><li><ol start="4"><li>如果你原封不动用的我的工程文件，想在本地运行合成语音的推理程序，<strong>务必将cleaners选择english_cleaner</strong><del>（否则会出现古神的低语）</del>。</li></ol></li><li><ol start="5"><li>如果你是自己训练模型，个人认为筛选数据集非常重要，尽量把语气词和背景噪音去掉，否则效果会很差。</li></ol></li><li><ol start="6"><li>训练模型的参数可以根据GPU自行调整，batch_size是影响训练速度最大的因素，当你不确定显卡性能如何，请务必确保运行一段时间后显存没有炸（<strong>我就是运行以后直接睡觉了，醒来发现显存在运行半小时的时候炸了，我心态也炸了</strong>）</li></ol></li></ul><p>其实这个模型效果仍然不是很让我满意，有电音的问题可以用HiFi-GAN再训练过滤一下，我是直接用的官方预训练模型，因此效果会差一点。由于现在开学了要忙着搞开题，最近也没时间再优化模型了，以后有想法会继续补充。</p><p>我自己有考虑过将模型传到服务器，用服务器cpu运行推理，摆脱colab的限制，但是服务器不堪重负…一运行推理运存就炸…github上有不少前人做过纯cpu推理的GUI（<a href="https://github.com/luoyily/MoeTTS">比如MoeTTS</a>），亲测可行。</p><p>哦对了，我在做这个项目的时候，发现已经有人<strong>基于VITS</strong>做了同个游戏的端到端语音合成，甚至开发公布了API…不得不感慨这些大佬真的用心了，有API就意味着有更多的使用方式。我搭了个顺风车，通过搭建QQ机器人，写了个原神语音合成插件，<strong>效果是可以指定原神任何角色合成任意想说的语音并且发在QQ群里</strong>（没有什么技术含量，内行看个笑话），有空尽量更新出来吧！</p><blockquote><p>2022&#x2F;9&#x2F;10更新</p><p>已将插件更新至我的github仓库，地址<a href="https://github.com/Phantom-Aria/zhenxun_plugin_tts">Phantom-Aria&#x2F;zhenxun_plugin_tts: 真寻bot插件，原神角色语音合成tts (github.com)</a></p><p>由于代码写的比较幼稚，就不申请官方插件索引了</p><p><img src="https://www.shelven.com/tuchuang/20220909/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220909/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><ul><li><p>适配绪山真寻bot</p></li><li><p>功能：指定某原神角色合成想要说的话</p></li><li><p>指令：[角色名]说&#x2F;说过[文本]</p></li></ul><p>2022&#x2F;10&#x2F;7更新<br>由于原API已下线，此插件不再生效，后续再更新</p></blockquote></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;（接上篇博客）做完数据集，我们手里现在有训练集（train set）和测试集（test set）音频文件，以及对应的拼音文本，接下来就可以跑Tacotron2来训练模型了。&lt;/p&gt;</summary>
    
    
    
    <category term="深度学习" scheme="http://www.shelven.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="google colab" scheme="http://www.shelven.com/tags/google-colab/"/>
    
    <category term="Tacotron2" scheme="http://www.shelven.com/tags/Tacotron2/"/>
    
    <category term="HiFiGAN" scheme="http://www.shelven.com/tags/HiFiGAN/"/>
    
  </entry>
  
  <entry>
    <title>深度学习——语音合成tts笔记（上）</title>
    <link href="http://www.shelven.com/2022/09/08/a.html"/>
    <id>http://www.shelven.com/2022/09/08/a.html</id>
    <published>2022-09-07T19:15:04.000Z</published>
    <updated>2022-12-03T16:20:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>两个月的暑假已经结束了，假期里自学了一点深度学习的内容，很多地方还是一知半解的，这里稍微记录一下。之前刷到一个很有意思的语音合成视频，抱着试试看的心态想自己做一个模型，于是给自己挖了一个大坑……涉及到深度学习的知识我还需要慢慢学，因此本篇博客重点还是记录下自己的踩坑操作<del>原理部分以后搞明白了再更新</del></p><span id="more"></span><p>总的来说，我通过拆包游戏客户端获得5.6万条语音文件，通过github上的一个声纹识别项目分离其中一个角色的语音文件。接着用百度的语音识别API将语音识别为文本后，人工校正一遍文本，然后转换为拼音+音标，以此制作语音数据训练集和测试集。基于开源项目Tacotron2训练角色语音模型，经历400 epoch后初步训练成型，最后基于HiFiGAN合成语音。整个后半段流程是在google colab上完成的，为了完成模型训练我申请了4个谷歌账号…不得不说<strong>白嫖的GPU真香~</strong></p><h2 id="1-制作数据集"><a href="#1-制作数据集" class="headerlink" title="1. 制作数据集"></a>1. 制作数据集</h2><div class="story post-story"><p>可以说整个项目大部分时间花费在整理数据集上，根据我自己的经验，数据集的语音长度在2秒-10秒之间效果最好，数量大约在2000条左右（为了涵盖尽可能多的汉字发音）。需要注意一点，不管拆包的原语音采样率如何，<strong>都要统一重采样到22050 hz</strong>，这是Tacotron2训练模型的要求。</p><h3 id="1-1-Extractor2-5-vgmstream-win拆包"><a href="#1-1-Extractor2-5-vgmstream-win拆包" class="headerlink" title="1.1 Extractor2.5 + vgmstream-win拆包"></a>1.1 Extractor2.5 + vgmstream-win拆包</h3><p>首先是这款国内游戏的拆包，所有角色的语音文件都在目录D:\Genshin Impact\Genshin Impact Game\YuanShen_Data\StreamingAssets\Audio\GeneratedSoundBanks\Windows\Chinese下，我们使用软件Extractor2.5进行音频文件拆包。</p><p>Extractor2.5是个非常好用的游戏解包工具，我们将所有pck源文件所在目录输进去（可以批量选中文件），确定输出目录，点击开始即可。</p><p><img src="https://www.shelven.com/tuchuang/20220908/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220908/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>运行结束之后可以看到这个游戏拆包有56958条语音文件…点击左下角反选，全部解压到自己的文件夹中。</p><p><img src="https://www.shelven.com/tuchuang/20220908/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220908/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>但是你会发现解压出来的wav文件无法打开，需要使用vgmstream进行解密和转码<a href="https://github.com/vgmstream/vgmstream/">（项目地址戳这里）</a>。</p><p>可以看到vgmstream-win文件夹只有一个可执行程序test.exe，其他都是dll库文件。</p><p><img src="https://www.shelven.com/tuchuang/20220908/3.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220908/3.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>这个test.exe是不能直接运行的，需要把程序拖到刚才拆包的语音文件上，但是几万条语音我们不可能一个个拖过去，因此我们<strong>在语音的文件夹下，</strong>写一个如下的批处理文件（命名为批处理.bat），运行批处理就可以了。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="keyword">for</span> /<span class="built_in">r</span> %%i <span class="keyword">in</span> (*.wav) <span class="keyword">do</span> (</span><br><span class="line">        <span class="string">&quot;D:\zhuomian\vgmstream-win\test.exe&quot;</span> <span class="string">&quot;%%~nxi&quot;</span>    <span class="comment">#路径改成你自己的，注意路径不能有中文</span></span><br><span class="line">)</span><br><span class="line">pause</span><br></pre></td></tr></table></figure><p>运行后生成的wav.wav文件就可以正常播放了，所有音频采样率均为48000Hz（采样率很重要，贯穿整个项目）。</p><p><img src="https://www.shelven.com/tuchuang/20220908/4.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220908/4.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="1-2-基于Tensorflow的声纹识别"><a href="#1-2-基于Tensorflow的声纹识别" class="headerlink" title="1.2 基于Tensorflow的声纹识别"></a>1.2 基于Tensorflow的声纹识别</h3><p>这部分内容来源于github（<a href="https://github.com/yeyupiaoling/VoiceprintRecognition-Tensorflow">项目地址戳这里</a>），作者基于tensorflow做了个声纹识别模型，通过把语音数据转换短时傅里叶变换的幅度谱，使用librosa计算音频的特征，以此来训练、评估模型。因为我只用到了对比部分，因此我下载了作者预训练的模型，以及对声纹对比文件<strong>infer_contrast.py</strong>做了修改。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> utils.reader <span class="keyword">import</span> load_audio</span><br><span class="line"><span class="keyword">from</span> utils.utility <span class="keyword">import</span> add_arguments, print_arguments</span><br><span class="line"><span class="keyword">import</span> os,shutil</span><br><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"></span><br><span class="line">os.environ[<span class="string">&#x27;TF_CPP_MIN_LOG_LEVEL&#x27;</span>]=<span class="string">&#x27;2&#x27;</span></span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser(description=__doc__)</span><br><span class="line">add_arg = functools.partial(add_arguments, argparser=parser)</span><br><span class="line">add_arg(<span class="string">&#x27;audio_path1&#x27;</span>,      <span class="built_in">str</span>,    <span class="string">&#x27;audio_db/Paimon.wav&#x27;</span>,          <span class="string">&#x27;标准的派蒙音频&#x27;</span>)   <span class="comment"># 自己准备的标准音频，下面两个也是</span></span><br><span class="line">add_arg(<span class="string">&#x27;audio_path2&#x27;</span>,      <span class="built_in">str</span>,    <span class="string">&#x27;audio_db/Klee.wav&#x27;</span>,          <span class="string">&#x27;标准的可莉音频&#x27;</span>)</span><br><span class="line">add_arg(<span class="string">&#x27;audio_path3&#x27;</span>,      <span class="built_in">str</span>,    <span class="string">&#x27;audio_db/Kokomi.wav&#x27;</span>,          <span class="string">&#x27;标准的心海音频&#x27;</span>)</span><br><span class="line">add_arg(<span class="string">&#x27;input_shape&#x27;</span>,      <span class="built_in">str</span>,    <span class="string">&#x27;(257, 257, 1)&#x27;</span>,          <span class="string">&#x27;数据输入的形状&#x27;</span>)</span><br><span class="line">add_arg(<span class="string">&#x27;threshold&#x27;</span>,        <span class="built_in">float</span>,   <span class="number">0.8</span>,                     <span class="string">&#x27;判断是否为同一个人的阈值&#x27;</span>)</span><br><span class="line">add_arg(<span class="string">&#x27;model_path&#x27;</span>,       <span class="built_in">str</span>,    <span class="string">&#x27;models1/infer_model.h5&#x27;</span>,  <span class="string">&#x27;预测模型的路径&#x27;</span>)    <span class="comment"># 作者的预训练模型</span></span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载模型</span></span><br><span class="line">model = tf.keras.models.load_model(args.model_path,<span class="built_in">compile</span>=<span class="literal">False</span>)</span><br><span class="line">model = tf.keras.models.Model(inputs=model.<span class="built_in">input</span>, outputs=model.get_layer(<span class="string">&#x27;batch_normalization&#x27;</span>).output)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据输入的形状</span></span><br><span class="line">input_shape = <span class="built_in">eval</span>(args.input_shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测音频</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">infer</span>(<span class="params">audio_path</span>):</span><br><span class="line">    data = load_audio(audio_path, mode=<span class="string">&#x27;test&#x27;</span>, spec_len=input_shape[<span class="number">1</span>])</span><br><span class="line">    data = data[np.newaxis, :]</span><br><span class="line">    feature = model.predict(data)</span><br><span class="line">    <span class="keyword">return</span> feature</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 预测的两个音频文件</span></span><br><span class="line">    feature1 = infer(args.audio_path1)[<span class="number">0</span>]</span><br><span class="line">    feature2 = infer(args.audio_path2)[<span class="number">0</span>]</span><br><span class="line">    feature3 = infer(args.audio_path3)[<span class="number">0</span>]</span><br><span class="line">    datapath = <span class="string">&quot;./test2&quot;</span>        <span class="comment">#上传到集群的解包音频文件位置</span></span><br><span class="line">    dirs = os.listdir(datapath)</span><br><span class="line">    <span class="keyword">for</span> audio <span class="keyword">in</span> dirs:</span><br><span class="line">        personx = <span class="string">&#x27;test2/%s&#x27;</span> % (audio)</span><br><span class="line">        featurex = infer(personx)[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 对角余弦值</span></span><br><span class="line">        dist1 = np.dot(feature1, featurex) / (np.linalg.norm(feature1) * np.linalg.norm(featurex))</span><br><span class="line">        <span class="keyword">if</span> dist1 &gt; args.threshold:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;%s 符合派蒙模型，相似度为：%f&quot;</span> % (personx, dist1))</span><br><span class="line">            shutil.move(<span class="string">&quot;./test2/%s&quot;</span> % (audio),<span class="string">&quot;./dataset/Paimon&quot;</span>)      <span class="comment"># 移动音频文件，路径自选</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dist2 = np.dot(feature2, featurex) / (np.linalg.norm(feature2) * np.linalg.norm(featurex))</span><br><span class="line">            <span class="keyword">if</span> dist2 &gt; args.threshold:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;%s 符合可莉模型，相似度为：%f&quot;</span> % (personx, dist2))</span><br><span class="line">                shutil.move(<span class="string">&quot;./test2/%s&quot;</span> % (audio),<span class="string">&quot;./dataset/Klee&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dist3 = np.dot(feature3, featurex) / (np.linalg.norm(feature3) * np.linalg.norm(featurex))</span><br><span class="line">                <span class="keyword">if</span> dist3 &gt; args.threshold:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;%s 符合心海模型，相似度为：%f&quot;</span> % (personx, dist3))</span><br><span class="line">                    shutil.move(<span class="string">&quot;./test2/%s&quot;</span> % (audio),<span class="string">&quot;./dataset/Kokomi&quot;</span>)</span><br><span class="line">        gc.collect()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>需要注意一点，为了提高识别的准确性，这个项目要求的语音长度不能低于1.7s，因此我用ffmpeg将所有长度低于2s的短音频全部过滤了（这里不赘述实现过程）。</p><p>之后将三个角色的标准语音分别放在audio_db文件夹下，识别的原理是通过预测函数提取三个角色的音频特征值，对5.6万条音频分别比对三个角色的标准音频特征，求对角余弦值，在多次试验后选择了对角余弦值0.8，作为判断两条语音是否为同一个人的阈值。</p><p>直接在集群上运行infer_contrast.py，相似度高于0.8的音频则会被挑选到对应的dataset文件夹中。</p><p><img src="https://www.shelven.com/tuchuang/20220908/5.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220908/5.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>实际上这个声纹识别的结果仅能作为参考，不能保证百分百正确，原因有很多：</p><ul><li><p>1.声优都是怪物，一个人用好多相似的声线配了不同角色，导致无法分辨出不同角色的语音（假阳性）。</p></li><li><p>2.一句话的语调不同会表现出音频特征值不同，而这个算法下会导致对角余弦值偏小，从而判断成发声的是不同的人（假阴性）。</p></li></ul><p>因此识别的结果需要进行人工校正，<strong>也就是需要自己听一遍到底是不是这个角色的语音</strong>&#x3D; &#x3D;（最好同下一步一起进行，省时间）</p><p>这里我验证并分离出2293条长度2秒以上的派蒙语音，以其中的1820条作为训练集，473条作为测试集。后续训练模型用到的时候会说。</p><h3 id="1-3-基于百度语音识别API的语音转文本"><a href="#1-3-基于百度语音识别API的语音转文本" class="headerlink" title="1.3 基于百度语音识别API的语音转文本"></a>1.3 基于百度语音识别API的语音转文本</h3><p>光有语音还不行，我们要训练模型就要有对应的<strong>文本</strong>。很多单机游戏（比如柚子社的游戏）有解包脚本，可以完整解出所有资源，其中就包括语音文件和对应的文本。但是解包有客户端的游戏不同，比如这款游戏发布不同版本的客户端，文件结构就会发生很大的改变，导致以前做的文件定位统统失效，而且包括文本在内的很多文件也是加密的，无法解出（也可能是我个人问题）。</p><p>因此，我们还是需要借助语音识别的软件将语音转成文本。这里涉及到另一个问题，不管多么强大的语音转文字技术，都是在已有的数据集基础上不断训练模型而产生的，游戏中有相当多新造的词（比如中二台词，游戏人名，地点等等），这在转化文本过程中是肯定无法百分百准确的，甚至会“空耳”产生歧义。</p><p>因此转文本这一步结束后需要人工校准，至少保证读音正确。</p><p>我是在<strong>百度AI开放平台</strong>申请了语音识别API，每个账号有200万次免费调用额度，但是限制并发数2<del>（没办法，既然是白嫖就忍忍）</del>。</p><p><img src="https://www.shelven.com/tuchuang/20220908/6.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220908/6.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>查看官方放在github上的demo，改一改就可以调用API了（每当问我不会使用的时候都是看demo然后魔改2333）。</p><p>我这里以官网提供的<strong>asr_raw.py</strong>为例，直接下载，并修改成如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">IS_PY3 = sys.version_info.major == <span class="number">3</span>        <span class="comment"># 判断你用的是python3.x还是2.x版本，推荐还是用3.x</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> IS_PY3:</span><br><span class="line">    <span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line">    <span class="keyword">from</span> urllib.request <span class="keyword">import</span> Request</span><br><span class="line">    <span class="keyword">from</span> urllib.error <span class="keyword">import</span> URLError</span><br><span class="line">    <span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlencode</span><br><span class="line">    timer = time.perf_counter</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">import</span> urllib2</span><br><span class="line">    <span class="keyword">from</span> urllib2 <span class="keyword">import</span> urlopen</span><br><span class="line">    <span class="keyword">from</span> urllib2 <span class="keyword">import</span> Request</span><br><span class="line">    <span class="keyword">from</span> urllib2 <span class="keyword">import</span> URLError</span><br><span class="line">    <span class="keyword">from</span> urllib <span class="keyword">import</span> urlencode</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> sys.platform == <span class="string">&quot;win32&quot;</span>:</span><br><span class="line">        timer = time.clock</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># On most other platforms the best timer is time.time()</span></span><br><span class="line">        timer = time.time</span><br><span class="line"></span><br><span class="line">API_KEY = <span class="string">&#x27;XXXXXXXX&#x27;</span>    <span class="comment"># 改成你自己的，下面一条一样</span></span><br><span class="line">SECRET_KEY = <span class="string">&#x27;XXXXXXXX&#x27;</span> </span><br><span class="line">FORMAT = <span class="string">&quot;wav&quot;</span>;  <span class="comment"># 文件后缀只支持 pcm/wav/amr 格式</span></span><br><span class="line">CUID = <span class="string">&#x27;123456PYTHON&#x27;</span>;</span><br><span class="line">RATE = <span class="number">16000</span>;  <span class="comment"># 固定值，这里一定一定要注意采样率</span></span><br><span class="line">DEV_PID = <span class="number">1537</span>;  <span class="comment"># 1537 表示识别普通话，使用输入法模型。根据文档填写PID，选择语言及识别模型</span></span><br><span class="line">ASR_URL = <span class="string">&#x27;http://vop.baidu.com/server_api&#x27;</span></span><br><span class="line">SCOPE = <span class="string">&#x27;audio_voice_assistant_get&#x27;</span>  <span class="comment"># 有此scope表示有asr能力，没有请在网页里勾选，非常旧的应用可能没有</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DemoError</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;  TOKEN start &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">TOKEN_URL = <span class="string">&#x27;http://aip.baidubce.com/oauth/2.0/token&#x27;</span></span><br><span class="line"><span class="comment"># 核对token</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fetch_token</span>():</span><br><span class="line">    params = &#123;<span class="string">&#x27;grant_type&#x27;</span>: <span class="string">&#x27;client_credentials&#x27;</span>,</span><br><span class="line">              <span class="string">&#x27;client_id&#x27;</span>: API_KEY,</span><br><span class="line">              <span class="string">&#x27;client_secret&#x27;</span>: SECRET_KEY&#125;</span><br><span class="line">    post_data = urlencode(params)</span><br><span class="line">    <span class="keyword">if</span> (IS_PY3):</span><br><span class="line">        post_data = post_data.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    req = Request(TOKEN_URL, post_data)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        f = urlopen(req)</span><br><span class="line">        result_str = f.read()</span><br><span class="line">    <span class="keyword">except</span> URLError <span class="keyword">as</span> err:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;token http response http code : &#x27;</span> + <span class="built_in">str</span>(err.code))</span><br><span class="line">        result_str = err.read()</span><br><span class="line">    <span class="keyword">if</span> (IS_PY3):</span><br><span class="line">        result_str = result_str.decode()</span><br><span class="line"></span><br><span class="line">    result = json.loads(result_str)</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&#x27;access_token&#x27;</span> <span class="keyword">in</span> result.keys() <span class="keyword">and</span> <span class="string">&#x27;scope&#x27;</span> <span class="keyword">in</span> result.keys()):</span><br><span class="line">        <span class="keyword">if</span> SCOPE <span class="keyword">and</span> (<span class="keyword">not</span> SCOPE <span class="keyword">in</span> result[<span class="string">&#x27;scope&#x27;</span>].split(<span class="string">&#x27; &#x27;</span>)):  <span class="comment"># SCOPE = False 忽略检查</span></span><br><span class="line">            <span class="keyword">raise</span> DemoError(<span class="string">&#x27;scope is not correct&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> result[<span class="string">&#x27;access_token&#x27;</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> DemoError(<span class="string">&#x27;MAYBE API_KEY or SECRET_KEY not correct: access_token or scope not found in token response&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;  TOKEN end &quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    token = fetch_token()</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    httpHandler = urllib2.HTTPHandler(debuglevel=1)</span></span><br><span class="line"><span class="string">    opener = urllib2.build_opener(httpHandler)</span></span><br><span class="line"><span class="string">    urllib2.install_opener(opener)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> audio <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">1825</span>):</span><br><span class="line">        AUDIO_FILE = <span class="built_in">str</span>(<span class="string">&#x27;/public/home/wlxie/test4voice/baiduyun/training_16K/train&#x27;</span> + <span class="built_in">str</span>(audio) + <span class="string">&#x27;.wav&#x27;</span>)     <span class="comment">#路径改成自己的</span></span><br><span class="line">        speech_data = []</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(AUDIO_FILE, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> speech_file:</span><br><span class="line">            speech_data = speech_file.read()</span><br><span class="line">        length = <span class="built_in">len</span>(speech_data)</span><br><span class="line">        <span class="keyword">if</span> length == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> DemoError(<span class="string">&#x27;file %s length read 0 bytes&#x27;</span> % AUDIO_FILE)</span><br><span class="line"></span><br><span class="line">        params = &#123;<span class="string">&#x27;cuid&#x27;</span>: CUID, <span class="string">&#x27;token&#x27;</span>: token, <span class="string">&#x27;dev_pid&#x27;</span>: DEV_PID&#125;</span><br><span class="line">        params_query = urlencode(params);</span><br><span class="line"></span><br><span class="line">        headers = &#123;</span><br><span class="line">            <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;audio/&#x27;</span> + FORMAT + <span class="string">&#x27;; rate=&#x27;</span> + <span class="built_in">str</span>(RATE),</span><br><span class="line">            <span class="string">&#x27;Content-Length&#x27;</span>: length</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        url = ASR_URL + <span class="string">&quot;?&quot;</span> + params_query</span><br><span class="line">        req = Request(ASR_URL + <span class="string">&quot;?&quot;</span> + params_query, speech_data, headers)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            begin = timer()</span><br><span class="line">            f = urlopen(req)</span><br><span class="line">            result_str = f.read()</span><br><span class="line">        <span class="keyword">except</span>  URLError <span class="keyword">as</span> err:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;asr http response http code : &#x27;</span> + <span class="built_in">str</span>(err.code))</span><br><span class="line">            result_str = err.read()</span><br><span class="line">    <span class="comment">#输出转文字结果</span></span><br><span class="line">        result_str = result_str.decode()</span><br><span class="line">        result = json.loads(result_str)</span><br><span class="line">        res = result[<span class="string">&#x27;result&#x27;</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;train&#x27;</span> +<span class="built_in">str</span>(audio) + <span class="string">&#x27;.wav&#x27;</span> + <span class="string">&#x27;识别结果：&#x27;</span> + res)</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;training_1800_result.txt&quot;</span>, <span class="string">&quot;a&quot;</span>) <span class="keyword">as</span> of:</span><br><span class="line">            of.write(<span class="string">&#x27;train&#x27;</span> + <span class="built_in">str</span>(audio) + <span class="string">&#x27;.wav&#x27;</span> + <span class="string">&quot;|&quot;</span> + res + <span class="string">&#x27;\n&#x27;</span>)  <span class="comment"># 转成“路径|文本”的格式，方便人工校准</span></span><br><span class="line">    gc.collect()</span><br></pre></td></tr></table></figure><p>这里也有一个<strong>大坑</strong>，这个语音转文本API要求音源采样率必须是16000Hz，前面说到我们解包得到的音频是48000Hz，而且后面训练模型要求采样率为22050Hz！也就是说如果我们现在把所有音频转成16000Hz的话，势必会对训练模型产生影响（高频可以转低频，但是低频转高频语音质量不会有一丁点儿的提升），因此我这边用拆包音频做了两个备份，一个是转成16000Hz，放在training_16K文件下，专门用于语音转文本；一个是转成22050Hz，放在training_22K文件下，专门用于后续训练模型。重采样仍然用我们的老朋友<strong>ffmpeg</strong>，因为就一行命令的事这里也不赘述了。</p><p>前面也说到这个API并发数限制为2，经常是用着用着就断开了（也是我比较笨比，不会写限制并发数发送请求的代码），所以我将训练集的1825个语音写了个小脚本，重命名为train1.wav-train1825.wav，所以才用了for循环一句一句调用API转文本，到哪个地方断了也可以迅速找出来并继续。</p><p>总之效果如下，训练集1825条语音和测试集473条语音全部转换为文本，且能清晰地看到一一对应关系：</p><p><img src="https://www.shelven.com/tuchuang/20220908/7.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220908/7.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>一眼看效果还不错，为了保证准确率，将txt文件传回本地，<strong>人工校正吧</strong>（语气词部分本来是要去除的，但是工作量会比较大放弃了，起码要保证发音没问题）。</p><p>这个数据集因为不是标准的普通话数据集（标准数据集可以找标贝，就有那种纯合成的标准普通话），声优也有特殊的口癖和发音，额，这是无法避免的。</p><h3 id="1-4-基于pypinyin的汉字转拼音"><a href="#1-4-基于pypinyin的汉字转拼音" class="headerlink" title="1.4 基于pypinyin的汉字转拼音"></a>1.4 基于pypinyin的汉字转拼音</h3><p>因为后面训练模型的Tacotron2是基于英文模型开发出来的，我们无法直接用中文文本训练。一个行之有效的方法是将中文转换成拼音+数字声调的方式，这样数据就可以顺利地被载入。</p><p>这里推荐一下pypinyin模块，该模块安装比较方便（直接用pip），也是个非常实用和高质量的汉字拼音转换工具！</p><p>我将人工校准后的txt文件传回集群，去掉前面的“|”之前的内容，再写个小脚本<strong>将所有标点符号删除</strong>，接着汉字转拼音，这里就记录下pypinyin的用法吧。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pypinyin <span class="keyword">import</span> lazy_pinyin, Style</span><br><span class="line"><span class="keyword">import</span> linecache</span><br><span class="line"></span><br><span class="line">output_file = <span class="built_in">open</span>(<span class="string">&quot;/public/home/wlxie/test4voice/baiduyun/training_pinyin.txt&quot;</span>,<span class="string">&quot;w&quot;</span>)</span><br><span class="line">readlist = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">1821</span>))  <span class="comment"># 人工校准的时候去掉了4条不是该角色的音频</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> readlist:</span><br><span class="line">    text = linecache.getline(<span class="string">&quot;/public/home/wlxie/test4voice/baiduyun/cheat_training.txt&quot;</span>,i)        </span><br><span class="line">    text = <span class="string">&quot; &quot;</span>.join(lazy_pinyin(text, style=Style.TONE3))</span><br><span class="line">    output_file.write(text)</span><br></pre></td></tr></table></figure><p>然后将拼音前按照Tacotron2训练的要求，加上了音频文件对应的colab路径（为什么用这个路径我下一篇博客再说明），以及每句话末尾加个英文的句号，最后输出结果如下：</p><p><img src="https://www.shelven.com/tuchuang/20220908/8.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220908/8.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>同样的方法对测试集也转拼音，这样前期的数据集文件就制作完成啦！接下来就是重点——训练模型。下篇博客接着说完。</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;两个月的暑假已经结束了，假期里自学了一点深度学习的内容，很多地方还是一知半解的，这里稍微记录一下。之前刷到一个很有意思的语音合成视频，抱着试试看的心态想自己做一个模型，于是给自己挖了一个大坑……涉及到深度学习的知识我还需要慢慢学，因此本篇博客重点还是记录下自己的踩坑操作&lt;del&gt;原理部分以后搞明白了再更新&lt;/del&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="深度学习" scheme="http://www.shelven.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="拆包" scheme="http://www.shelven.com/tags/%E6%8B%86%E5%8C%85/"/>
    
    <category term="声纹识别" scheme="http://www.shelven.com/tags/%E5%A3%B0%E7%BA%B9%E8%AF%86%E5%88%AB/"/>
    
    <category term="语音转文本" scheme="http://www.shelven.com/tags/%E8%AF%AD%E9%9F%B3%E8%BD%AC%E6%96%87%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>frp内网穿透配置笔记</title>
    <link href="http://www.shelven.com/2022/07/13/a.html"/>
    <id>http://www.shelven.com/2022/07/13/a.html</id>
    <published>2022-07-12T19:55:04.000Z</published>
    <updated>2022-12-03T16:11:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>过一段时间要到校外学习，而学校的资源只能在校园内网下才能使用（登录集群可以看到登录ip是10开头的A类地址，无法公网ip访问）。为了方便在校外访问校园内网的集群，我手里正好也有一个备案过的服务器和域名，于是自己用frp搭建了一个反向代理服务器，穿透了校园内网，这里记录下自己搭建过程。</p><span id="more"></span><p>其实一开始我打算直接用开发比较成熟的花生壳软件做内网穿透，但是不知道怎么回事，显示连接成功但是ssh远程登陆不上，后来就放弃了，最后决定用自己的服务器和域名穿透<del>（后来我还申请了花生壳学生版，羊毛先薅到以后再说用不用）</del>。</p><p><img src="https://www.shelven.com/tuchuang/20220713/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220713/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>frp是一个go语言写的开源内网穿透和反向代理软件，支持tcp, udp, http, https等协议，支持linux、mac、windows平台，操作也很方便，非常适合我这种小白。</p><h2 id="1-下载frp"><a href="#1-下载frp" class="headerlink" title="1 下载frp"></a>1 下载frp</h2><div class="story post-story"><p>源代码作者发布在github，<a href="https://github.com/fatedier/frp">点击这里</a>。</p><p>选择最新的release版本，注意frp在service端和client端有两个不同的程序和配置文件，<strong>service端是你想要做反向代理的有公网ip的服务器，client端是处于内网之下的你想要穿透的服务器</strong>。</p><p>service端和client端一定要<strong>同一个版本</strong>。这里我的service端和client端都是linux操作系统，所以我直接下载了linux_arm64.tar.gz（我想顺便远程操控实验室电脑，所以也下载了windows版本，默认windows远程桌面端口号是3389，这个以后再说）。</p><p><img src="https://www.shelven.com/tuchuang/20220713/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220713/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>将tar.gz文件传到两台服务器上，tar -zxvf解压就可以使用了<del>（不需要编译，就是这么简单）</del>。</p><p><strong>在service端保留frps程序和相应的ini配置文件，在client端保留frpc程序和相应的ini配置文件</strong>（主要防止自己搞错）。配置文件有两种，我们可以选择其中一个；ini是最简单的配置文件，full.ini配置文件中记录了全部配置参数和英文解释，需要的时候可以自己根据情况修改。</p></div><h2 id="2-修改配置文件"><a href="#2-修改配置文件" class="headerlink" title="2 修改配置文件"></a>2 修改配置文件</h2><div class="story post-story"><p>网上的教程很多，full.ini也记载了全部的配置方法，我这里只记录下我自己的配置（敏感信息就不展示了）。</p><h3 id="2-1-service端配置"><a href="#2-1-service端配置" class="headerlink" title="2.1 service端配置"></a>2.1 service端配置</h3><p>frps.ini配置文件修改如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_port = 7000    # frp监听的端口，默认7000，可改</span><br><span class="line">bind_udp_port = 7400    # UDP通讯端口，可不设置，用于点对点穿透</span><br><span class="line">token = xxxxxxxx    # 安全考虑需要设置口令，client端需要用到</span><br><span class="line"></span><br><span class="line">dashboard_port = 7500   # frp管理端口，可改</span><br><span class="line">dashboard_user = xxxx   # 管理端口认证的用户名，用于身份识别，自己设置</span><br><span class="line">dashboard_pwd = xxxx    # 管理端口认证的密码，用于身份识别，自己设置</span><br><span class="line">enable_prometheus = true</span><br><span class="line"></span><br><span class="line">subdomain_host = xxx.xxx.xxx    # 设置子域名，主要方便登录管理界面。不用ip地址，用域名+端口的方式直接访问</span><br><span class="line"></span><br><span class="line">log_file = /usr/local/frp/frps.log  # frp日志配置，这里是记录3天的日志信息</span><br><span class="line">log_level = info</span><br><span class="line">log_max_days = 3</span><br></pre></td></tr></table></figure><p>子域名设置主要是方便登录管理界面，不是必须的，反正我记不住服务器一长串ip地址…<strong>这个域名需要DNS解析后才能使用</strong></p><p>后台不挂起运行frps：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./frps -c frps.ini &amp;</span><br></pre></td></tr></table></figure><p>这个时候我们是看不到运行日志的，打开刚刚设置的frps.log文件</p><p><img src="https://www.shelven.com/tuchuang/20220713/3.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220713/3.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>几个设置端口都监听成功，最后也显示frps started successfully说明开启成功。</p><h3 id="2-2-client端配置"><a href="#2-2-client端配置" class="headerlink" title="2.2 client端配置"></a>2.2 client端配置</h3><p>frpc.ini配置文件修改如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = xxx.xxx.xxx.xxx   # 填写你的service端服务器公网ip，这里我写我的云服务器ip</span><br><span class="line">server_port = 7000  # 前面设置的frp监听端口，需要保持一致</span><br><span class="line">token = xxxxxxxx    # 前面设置的口令</span><br><span class="line"></span><br><span class="line">[ssh]   # 这里只演示ssh端口的映射，其他参考frpc_full.ini</span><br><span class="line">type = tcp  # tcp协议</span><br><span class="line">local_ip = 127.0.0.1    # 这个地址代表本机</span><br><span class="line">local_port = 22     # ssh端口，默认22，由你ssh登录的client服务器决定</span><br><span class="line">remote_port = 6000  # 映射的service端服务器的端口，自己定义</span><br></pre></td></tr></table></figure><p>注意下remote_port这个设置的是service端也就是云服务器的端口，通过这个端口访问client端的22端口，也就是端口映射。</p><p>同样的后台不挂起运行frpc：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./frpc -c frpc.ini &amp;</span><br></pre></td></tr></table></figure><p>打开nohup的输出文件：</p><p><img src="https://www.shelven.com/tuchuang/20220713/4.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220713/4.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>显示login to service success表示和service端连接成功。</p><p><strong>全部设置完成后，理论上我就可以通过云服务器的主机地址+6000端口，通过ssh方式访问学校内网中的集群主机地址+22端口了。</strong></p><p><strong>但是我的云服务器比较特殊，还需要进行一步开放防火墙端口。</strong></p></div><h2 id="3-开放serviced服务器端口"><a href="#3-开放serviced服务器端口" class="headerlink" title="3 开放serviced服务器端口"></a>3 开放serviced服务器端口</h2><div class="story post-story"><p>如果在2.2这一步配置之后一直连不上service端，<strong>那极有可能是service服务器的端口没有开放</strong>。</p><p>特别注意一点，如果是买的云服务器（比如我买的腾讯云服务器），<strong>不仅要在控制台页面开放端口，还需要在linux云服务器开放端口</strong>。举个例子，我们这里用到的云服务器端口是7000，7400，7500和6000，首先要在控制台防火墙页面 开放这几个端口。</p><p><img src="https://www.shelven.com/tuchuang/20220713/6.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220713/6.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>然后在云服务器上打开防火墙，开放对应端口：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">systemctl start firewalld   # 打开防火墙</span><br><span class="line">firewall-cmd --permanent --add-port=7000/tcp    # 永久开放指定的7000端口（其他端口同理）</span><br><span class="line">firewall-cmd --reload   # 重启防火墙</span><br><span class="line">firewall-cmd --list-ports   # 查看防火墙开放的所有端口</span><br></pre></td></tr></table></figure><p>注意一下防火墙端口设定完成后，<strong>需要重载防火墙才会生效</strong>。</p><p>我们把自己云服务器的防火墙和端口配置好就行<del>（学校集群你不是root用户你也配置不了，一般来说也不会设置防火墙）</del>。</p></div><h2 id="4-frp管理面板"><a href="#4-frp管理面板" class="headerlink" title="4 frp管理面板"></a>4 frp管理面板</h2><div class="story post-story"><p>有两种方式可以访问：</p><ul><li><ol><li>service端服务器  ip地址:端口号</li></ol></li><li><ol start="2"><li>设置子域名后可以用  子域名:端口号</li></ol></li></ul><p>用户名密码认证后，可以看到如下页面：</p><p><img src="https://www.shelven.com/tuchuang/20220713/8.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220713/8.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>主要就是看一下连接数量，连接方式，产生的流量等等，具体就不细说了。</p><p>开个手机热点，用xshell登陆一下集群，发现显示的登录ip变成了localhost，而不是10开头的A类地址了，说明反向代理成功。</p><p><img src="https://www.shelven.com/tuchuang/20220713/9.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220713/9.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>连接速度非常快，而且稳定！以后登录集群就再也不用校园网啦！</p></div><h2 id="5-写在最后"><a href="#5-写在最后" class="headerlink" title="5 写在最后"></a>5 写在最后</h2><div class="story post-story"><p>这种用外网服务器做反向代理服务器，通过端口转发的方式访问内网服务器还是有一定安全风险的，该开防火墙开防火墙，小心驶得万年船。</p><p>还有，这种方法也有个缺点。打个比方如果你在校外，而<strong>学校服务器因为某种不可抗力重启了</strong><del>（比如停电，这在新疆真的太常见了）</del>这就相当于你挂在后台nohup的程序被强制杀掉了。等到管理员重启后，client端的frpc程序就需要再执行一次才能生效，这个时候就只能拜托有学校集群账号的人帮你在后台执行nohup，你才能从外网访问集群。</p><p>要应对这种情况，最简单的是你写个开机自启动脚本执行frpc，但是你没有root权限是不可行的…或者你让集群管理员给你su权限，这一般来说也不太可能…如何完美解决这个问题还有待研究</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;过一段时间要到校外学习，而学校的资源只能在校园内网下才能使用（登录集群可以看到登录ip是10开头的A类地址，无法公网ip访问）。为了方便在校外访问校园内网的集群，我手里正好也有一个备案过的服务器和域名，于是自己用frp搭建了一个反向代理服务器，穿透了校园内网，这里记录下自己搭建过程。&lt;/p&gt;</summary>
    
    
    
    <category term="网络相关" scheme="http://www.shelven.com/categories/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="内网穿透" scheme="http://www.shelven.com/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    
    <category term="反向代理" scheme="http://www.shelven.com/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>blastn &amp; blastp 寻找同源基因</title>
    <link href="http://www.shelven.com/2022/07/05/a.html"/>
    <id>http://www.shelven.com/2022/07/05/a.html</id>
    <published>2022-07-05T11:25:26.000Z</published>
    <updated>2022-12-03T16:11:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天接到一个任务，大致内容是在一个植物的全长转录组数据中找拟南芥的三个同源基因。简简单单的描述，我的想法也很简单，直接找基因的<strong>CDS序列做blastn</strong>比对就完事了，结果却没有那么顺利…记录一下踩的坑和解决办法。</p><span id="more"></span><h2 id="1-blastn寻找同源基因"><a href="#1-blastn寻找同源基因" class="headerlink" title="1 blastn寻找同源基因"></a>1 blastn寻找同源基因</h2><div class="story post-story"><p>三个基因TAIR号是AT4G28590、AT2G43010和AT2G34640，从全长转录组测序报告中，我找到了非冗余的转录本序列文件CD-hit-est.fasta，首先第一步就是本地建核酸序列库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">makeblastdb -in CD-hit-est.fasta -dbtype nucl -input_type fasta -out Kc</span><br></pre></td></tr></table></figure><p>因为给的是TAIR号，所以直接去<a href="%5Bwww.arabidopsis.org%5D(https://www.arabidopsis.org/)">TRIR</a>官网查找相应基因的CDS序列做比对</p><p><img src="https://www.shelven.com/tuchuang/20220705/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220705/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>手动创建query gene的fa序列文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim RCB_cds.fna</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">手动创建fa文件</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">AT4G28590</span></span><br><span class="line">ATGAGTTTCTTCGCTGTTGCTTGCTCCGCGCCAAGATCTTCTATGCTTCTCACCGGCTTGAATTCGAGCTTCTCTGATATGCATCGCAGCCCACTATTTGTTTTCCCGGTGACTATATCATCCCGGAGCGTGAAACGCTTCGCCGCTGTTTCGTCTGATTCCGTACTAGACCCTGAATCCAAAAATCAAACTCGGTCCCGTCGCAAAAATAAGGAAGCAGTTACGCCAATTGCTGAAACCGAGAACAATGAAAAGTTTCCGACAAAGGTCCCGCGTAAATCGAAGCGTGGGCGGCGGAGTGAAGCAGACGCTGTGGAAGATTACGTGAGAAGCTCCCTCGAGCGTACTTTCTCCACCATAAAGGAGCAGAATCCGGAGGTTTTTGAGAACAAGGAGAAGGCGAATTTCATCAAAGACAGAGGCGTTGATGAAGAAGAGGAAGAAGAAGAAGAGATGGTGGTGGAAGAGGAAGATCCAGATTGGCCAGTAGATACAGACGTTGGATGGGGAATCAAAGCTTCGGAGTATTTCGATACACATCCAATCAAAAACGTGGTTGGAGATGATGGGAGTGAGATTGATTGGGAAGGTGAGATTGATGATAGTTGGGTCAAGGAGATCAATTGTTTGGAATGGGAAAGCTTTGCTTTTCATCCTAGTCCACTCGTTGTCCTTGTATTCGAGCGATACAAAAGAGCTAGTGATAACTGGAAGACATTGAAGGAGCTTGAGAAAGCTATCAAAGTTTATTGGGATGCGAAAGATCGATTACCTCCACGGGCGGTTAAGATTGACCTGAACATCGAGACAGATTTGGCATATGCTCTTAAAGCTAAGGAATGCCCACAGATTCTCTTCTTACGCGGAAACCGGATTCTGTACAGGGAGAAAGACTTTCGCACGGCGGATGAATTGGTTCATATGATTGCGCATTTCTACTATAAAGCGAAGAGGCCTTCGTGTGTCGACAAGGCTAATGTAACCCCGTACTGTTAG</span><br></pre></td></tr></table></figure><p>blastn比对</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blastn -query RCB_cds.fna -out RCB_blastn_Kc.out -db Kc -outfmt 6 -evalue 1e-5 -num_threads 4</span><br></pre></td></tr></table></figure><p>RCB_blastn_Kc.out是blast的m8格式输出文件，找到匹配长度最长的（也就是第一条）subject gene id，回到非冗余转录本，找到subject gene在哪行，最后找出转录本序列。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">找到subject gene所在行（subject gene <span class="built_in">id</span>中有所在行数，这里验证下）</span></span><br><span class="line">cat CD-hit-est.fasta | grep -n &quot;Kc-zong_1-10k_transcript/10791&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">提取序列</span></span><br><span class="line">awk &#x27;NR&gt;=10719 &amp;&amp; NR&lt;=10720&#x27; CD-hit-est.fasta</span><br></pre></td></tr></table></figure><p><img src="https://www.shelven.com/tuchuang/20220705/3.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220705/3.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><strong>紧接着出现一个问题</strong>：AT2G43010和AT2G34640这两个基因无法通过blastn比对找到同源序列，evalue值不管放到多宽都比对不上。</p><p>因为这个植物在NCBI上没有参考基因组，我们课题组也只测了全长转录组而没有测基因组，所以当一开始没有比对出结果的时候，我一度怀疑是这种植物压根儿就没有这俩基因，或者这个样品叶片（测序的部位）在检测的时间点就没有转录相应的基因。</p><p>本地blast找不到同源基因，我又从近缘菊科植物开始折腾，思路是如果菊科有同源基因则寻找保守结构域，设计引物将CDS区域克隆出来。至今已发表的植物基因组可以从网站<a href="https://www.plabipd.de/plant_genomes_pa.ep">Plabipd（本站网址导航栏有收录）</a>找到，<strong>这个网站很贴心地把物种种属关系也列了出来</strong>，可以很方便地找物种学名和近缘关系。</p><p>理想很丰满现实很骨感，我从菊科一级一级往上找，直到Eudicotyledoneae（真双子叶植物分支）才用blastn比对上同源基因，而且无一例外比对上的全是十字花科（拟南芥所在科）植物，根本不算近缘物种….无奈之下试了blast的其他功能，用氨基酸序列跑了一遍blastp，然后发现菊科也有序列可以比对上了！这才打开新世界的大门</p></div><h2 id="2-blastp寻找同源基因"><a href="#2-blastp寻找同源基因" class="headerlink" title="2 blastp寻找同源基因"></a>2 blastp寻找同源基因</h2><div class="story post-story"><p>基于翻译阅读框对去冗余的全长转录本进行CDS预测（TransDecoder软件），结果以fasta格式保存，后续我会对这个文件验证一遍，先建蛋白库做blastp比对。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">makeblastdb -in transdecoder.pep.fa -dbtype prot -input_type fasta -out nr_Kc</span><br></pre></td></tr></table></figure><p><img src="https://www.shelven.com/tuchuang/20220705/4.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220705/4.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><strong>可以看到只有25128个编码蛋白基因，对于基因组大小在1G左右的菊科物种来说，这个基因数量过少</strong>。因此后续还需要对全长转录组数据再跑一遍验证一下，这个是后话。</p><p>通过TAIR号在TAIR官网查找蛋白序列，创建fa文件后进行本地blastp比对</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">blastp -query PIF4_pep.fna -out PIF4_blastp_nr_Kc.out -db nr_Kc -outfmt 6 -evalue 1e-5 -num_threads 4</span><br><span class="line">blastp -query HMR_pep.fna -out HMR_blastp_nr_Kc.out -db nr_Kc -outfmt 6 -evalue 1e-5 -num_threads 4</span><br></pre></td></tr></table></figure><p>注意下结果文件名写清楚什么基因，用的什么方法比对，比对的什么库。这个时候再查看各自的结果文件，发现有比对结果，再回到非冗余转录本文件找对应的cds序列。操作过程都一样，这里不再赘述了。</p></div><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><div class="story post-story"><p>找三条同源基因花了一整天的时间，主要原因还是对同源序列了解不够深刻。</p><p>同源就是有共同的进化祖先，序列相似性搜索可以通过检测<strong>过高的</strong>相似性来识别同源蛋白质或基因：当两个序列的相似性超过偶然的预期时，我们推断这两个序列存在同源性。 当观察到过高的相似性时，这两个序列不是独立出现的，它们起源于一个共同的祖先。</p><p>通过算法进行序列对库比对的工具，比如blast等，是通过过高相似性来减少假阳性的结果。所以通过算法在统计学上找不到库里显著的匹配项，不代表这个物种中一定没有同源基因。</p><p>从这次blastn和blastp比对结果来看，核酸序列比对可能更不容易找到同源序列。其实也好理解，生物在进化的几亿年时间里，很难保证不同物种有高相似性的核酸序列。同个氨基酸有不同密码子（简并性），也能证明蛋白质一级结构才是对生物影响最大的，蛋白质序列相同，就会有相似结构和功能。因此，蛋白质序列也就是氨基酸序列，对相似性的搜索比核酸序列要敏感的多。</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天接到一个任务，大致内容是在一个植物的全长转录组数据中找拟南芥的三个同源基因。简简单单的描述，我的想法也很简单，直接找基因的&lt;strong&gt;CDS序列做blastn&lt;/strong&gt;比对就完事了，结果却没有那么顺利…记录一下踩的坑和解决办法。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="blast" scheme="http://www.shelven.com/tags/blast/"/>
    
  </entry>
  
  <entry>
    <title>0基础学习基因组三代测序组装（4）——初步组装二代数据</title>
    <link href="http://www.shelven.com/2022/07/03/a.html"/>
    <id>http://www.shelven.com/2022/07/03/a.html</id>
    <published>2022-07-03T11:28:52.000Z</published>
    <updated>2022-12-03T16:12:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>经过前面的全基因组特征调查（survey）后，我们发现这是一个复杂基因组，杂合度较高，可以以二代+三代测序技术相结合的策略进行全基因组组装，还可以以Hi-C（高通量染色体捕获技术，High-through chromosome conformation capture）技术进行辅助组装。这里我用华大开发的二代测序组装工具SOAPdenovo，用二代测序数据对进行初步基因组组装。</p><span id="more"></span><h2 id="1-安装SOAPdenovo-2-0"><a href="#1-安装SOAPdenovo-2-0" class="headerlink" title="1 安装SOAPdenovo 2.0"></a>1 安装SOAPdenovo 2.0</h2><div class="story post-story"><p>github上这个软件的版本是2.0，网址点击<a href="https://github.com/aquaskyline/SOAPdenovo2">这里</a></p><p>软件下载安装过程非常顺利，如果有报错无法解决的话可以在Issue里向作者反馈。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">集群如果无法登录github，下载源码包，通过xftp传到集群</span></span><br><span class="line">tar -zxvf SOAPdenovo2</span><br><span class="line">cd SOAPdenovo2-r242</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>编译之后可以看到有如下几个文件</p><p><img src="https://www.shelven.com/tuchuang/20220702/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220702/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>SOAPdenovo-127mer和SOAPdenovo-63mer是用于组装的两个程序，分<strong>别代表支持的最大k-mer为127和63</strong>，用法上是完全相同的。</p><p>example.config是配置文件，组装之前我们要设置其中的参数内容；README.md是帮助文件，详细记录了各项参数的作用和设置方法。这个后面会讲到。</p></div><h2 id="2-kmergenie计算最佳k值"><a href="#2-kmergenie计算最佳k值" class="headerlink" title="2 kmergenie计算最佳k值"></a>2 kmergenie计算最佳k值</h2><div class="story post-story"><p>现在组装基因组的算法主要有三种：De Bruijn graph，Overlap-Layout-Consensus和String Graph。SOAPdenovo软件组装基因组用的是De Bruijn graph算法，简单理解是通过将reads打断成k-mer后，利用k-mer之间的重复部分构建图，得到最优化路径从而拼接contig。要具体了解什么是De Bruijn graph，可以参考<a href="https://blog.csdn.net/u010608296/article/details/113879863">这一篇博文</a>。</p><p>不同k-mer值构建的De Bruijn graph不一样，会导致组装质量的差异，因此我们需要选择一个最佳的组装k-mer大小（尽管可以用默认值<strong>23</strong>直接组装，但是效果不一定是最好的）。</p><p><strong>kmergenie软件和之前的Jellyfish类似</strong>，都可以用于统计k-mer数量，kmergenie最大优点是可以对预设的多个k-mer进行分析，找到最佳的k-mer。<a href="http://kmergenie.bx.psu.edu/">点击这里进入Kmergenie官网</a>，下载最新版本的软件。</p><p><strong>注意下这个软件安装需要python &gt; 2.7，并且需要安装R和zlib</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf kmergenie-1.7051.tar.gz</span><br><span class="line">cd kmergenie-1.7051</span><br><span class="line">make</span><br><span class="line">python setup.py install --user  # 安装到用户环境中，不报错说明可以使用</span><br><span class="line"></span><br><span class="line">vim file.txt    # 将两个fq文件路径写进去，一行一个</span><br><span class="line"></span><br><span class="line">/public/home/wlxie/biosoft/kmergenie-1.7051/kmergenie file.txt -o ./kmergenie_res -l 15 -k 65 -s 5 -t 30 --diploid      # 运行kmergenie</span><br></pre></td></tr></table></figure><ul><li>-o    # 输出文件位置和名称</li><li>-l    # 设定的最小k值</li><li>-k    # 设定的最大k值</li><li>-s    # 最小k值到最大k值，每次增加的间隔（根据需要设定间隔大小）</li><li>-t    # 运行的线程（CPU核）数</li><li>--diploid    # 二倍体模式，前面我们已经用jellyfish确认过这是个复杂基因组。默认是单倍体模式</li></ul><p><strong>其原理就是设置不同k值进行基因组大小预估，将组装的基因组最大的k值作为最佳k值。</strong></p><p>最终会给出kmergenie_res为前缀的一系列报告，生成的.histo文件还可以用来上一篇笔记中的GenomeScope分析，这里我们只需要看总结的html文件。</p><p><img src="https://www.shelven.com/tuchuang/20220702/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220702/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>确定组装的最佳k值为51</p></div><h2 id="3-SOAPdenovo2组装contigs-x2F-scaffolds"><a href="#3-SOAPdenovo2组装contigs-x2F-scaffolds" class="headerlink" title="3 SOAPdenovo2组装contigs&#x2F;scaffolds"></a>3 SOAPdenovo2组装contigs&#x2F;scaffolds</h2><div class="story post-story"><p>复制一份example.config配置文件，重命名为run_config，修改部分参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">maximal <span class="built_in">read</span> length</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">全局配置参数，只要高于这个参数的序列都会被截取到这个长度</span></span><br><span class="line">max_rd_len=150</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">文库配置以[LIB]开头</span></span><br><span class="line">[LIB]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">average insert size</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">文库插入片段的平均长度，在实际设置时，可以参考文库size分布图，取峰值（默认200）</span></span><br><span class="line">avg_ins=200</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="keyword">if</span> sequence needs to be reversed</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">是否需要将序列反向互补，对于pair-end数据，不需要反向互补，设置为0；对于mate-pair数据，需要反向互补，设置为1</span></span><br><span class="line">reverse_seq=0</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="keyword">in</span> <span class="built_in">which</span> part(s) the reads are used</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1表示只组装contig，2表示只组装scaffold，3表示同时组装contig和scaffold，4表示只补gap</span></span><br><span class="line">asm_flags=3</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">use only first 100 bps of each <span class="built_in">read</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">序列长度阈值，作用和max_rd_len相同，大于该长度的序列会被切除到该长度</span></span><br><span class="line">rd_len_cutoff=150</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="keyword">in</span> <span class="built_in">which</span> order the reads are used <span class="keyword">while</span> scaffolding</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置不同文库数据的优先级顺序，取值范围为整数，rank值相同的多个文库，在组装scaffold时，会同时使用。</span></span><br><span class="line">rank=1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">cutoff of pair number <span class="keyword">for</span> a reliable connection (at least 3 <span class="keyword">for</span> short insert size)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">contig或者scaffold之前的最小overlap个数，对于pair-end数据，默认值为3；对于mate-paird数据，默认值为5</span></span><br><span class="line">pair_num_cutoff=3</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">minimum aligned length to contigs <span class="keyword">for</span> a reliable <span class="built_in">read</span> location (at least 32 <span class="keyword">for</span> short insert size)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">比对长度的最小阈值，对于pair-end数据，默认值为32；对于mate-pair数据，默认值为35</span></span><br><span class="line">map_len=32</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">a pair of fastq file, <span class="built_in">read</span> 1 file should always be followed by <span class="built_in">read</span> 2 file</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">过滤后的双端测序数据文件路径，q为fastq格式，f为fasta格式，b为bam格式</span></span><br><span class="line">q1=/public/home/wlxie/luobuma/luobuma/sample_1_rawdata/Second-generation_sequencing/20211106-BaiYiHuiNeng01/01.rawFq/00.mergeRawFq/1/clean_data/1_r    aw_1_val_1.fq</span><br><span class="line">q2=/public/home/wlxie/luobuma/luobuma/sample_1_rawdata/Second-generation_sequencing/20211106-BaiYiHuiNeng01/01.rawFq/00.mergeRawFq/1/clean_data/1_r    aw_2_val_2.fq</span><br></pre></td></tr></table></figure><p>SOAPdenovo有6个子命令<strong>pregraph、sparse_pregraph、contig、map、scaff和all</strong>，前5个命令对应5个组装步骤，第一和第二是两种不同构图方式，all命令一次执行所有步骤，用all命令比较省事儿。</p><p>SOAPdenovo命令还有一些参数用于调整，<a href="https://zhuanlan.zhihu.com/p/286159368">参数参考</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-s  # 配置文件</span><br><span class="line">-o  # 输出文件的前缀</span><br><span class="line">-K  # 输入的K-mer值大小，默认值23</span><br><span class="line">-p  # 程序运行时设定的线程数，默认值8</span><br><span class="line">-R  # 利用read鉴别短的重复序列，默认值不进行此操作</span><br><span class="line">-d  # 去除频数不大于该值的k-mer，默认值为0</span><br><span class="line">-D  # 去除频数不大于该值的由k-mer连接的边，默认值为1，即该边上每个点的频数都小于等于1时才去除</span><br><span class="line">-M  # 连接contig时合并相似序列的等级，默认值为1，最大值3。</span><br><span class="line">-F  # 利用read对scaffold中的gap进行填补，默认不执行</span><br><span class="line">-u  # 构建scaffold前不屏蔽高覆盖度的contig，这里高频率覆盖度指平均contig覆盖深度的2倍。默认屏蔽</span><br><span class="line">-G  # 估计gap的大小和实际补gap的大小的差异，默认值为50bp。</span><br><span class="line">-L  # 用于构建scaffold的contig的最短长度，默认为：Kmer参数值 ×2</span><br><span class="line">-k  # map步骤中kmer的大小，默认是和K一样的kmer大小</span><br><span class="line">-N  # 基因组大小</span><br><span class="line">-V  # 输出可视化的组装信息</span><br></pre></td></tr></table></figure><p>运行组装命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/public/home/wlxie/biosoft/SOAPdenovo2-r242/SOAPdenovo-63mer all -s /public/home/wlxie/biosoft/SOAPdenovo2-r242/run_config -K 51 -R -V -o A_venetum -p 30</span><br></pre></td></tr></table></figure><p>程序运行了3个小时，结束后生成了以下文件</p><p><img src="https://www.shelven.com/tuchuang/20220702/3.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220702/3.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div><h2 id="4-组装结果解读"><a href="#4-组装结果解读" class="headerlink" title="4 组装结果解读"></a>4 组装结果解读</h2><div class="story post-story"><p>组装结果文件其实只有两个，分别以**.contig结尾和.scafseq结尾**。因为我是在集群上运行的，slurm-11168.out是集群的输出日志文件，记录了详细的组装过程和结果。</p><p>最终得到935861个contigs，总长度295302126 bp，平均长度315 bp，最长的长度38673 bp，contig N50是532 bp，contig N90是103 bp；scaffold个数77918，总长度192992858 bp，平均长度2476 bp，最长的长度108587 bp，scaffold N50是3385 bp，scaffold N90是130 bp。（可以做一个统计表）</p><p>从组装的contig覆盖深度和数量还可以做一个柱状图，理论上来说是和前面k-mer分布图呈现一样的趋势，也就是一个主峰和一个杂峰，两个图相互印证目标基因组是个复杂基因组。</p><p>其他的结果文件在<a href="https://github.com/aquaskyline/SOAPdenovo2">github</a>上有解释，我先直接复制过来，以后用到再翻译翻译……</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">1. Output files from the command &quot;pregraph&quot;</span><br><span class="line">a. *.kmerFreq</span><br><span class="line">      Each row shows the number of Kmers with a frequency equals the row number. Note that those peaks of frequencies which are the integral multiple of 63 are due to the data structure.</span><br><span class="line">b. *.edge</span><br><span class="line">      Each record gives the information of an edge in the pre-graph: length, Kmers on both ends, average kmer coverage, whether it&#x27;s reverse-complementarily identical and the sequence.</span><br><span class="line">c. *.markOnEdge &amp; *.path</span><br><span class="line">      These two files are for using reads to solve small repeats.</span><br><span class="line">e. *.preArc</span><br><span class="line">      Connections between edges which are established by the read paths.</span><br><span class="line">f. *.vertex</span><br><span class="line">      Kmers at the ends of edges.</span><br><span class="line">g. *.preGraphBasic</span><br><span class="line">      Some basic information about the pre-graph: number of vertex, K value, number of edges, maximum read length etc.</span><br><span class="line">      </span><br><span class="line">2. Output files from the command &quot;contig&quot;</span><br><span class="line">a. *.contig</span><br><span class="line">      Contig information: corresponding edge index, length, kmer coverage, whether it&#x27;s tip and the sequence. Either a contig or its reverse complementry counterpart is included. Each reverse complementary contig index is indicated in the *.ContigIndex file.</span><br><span class="line">b. *.Arc</span><br><span class="line">      Arcs coming out of each edge and their corresponding coverage by reads</span><br><span class="line">c. *.updated.edge</span><br><span class="line">      Some information for each edge in graph: length, Kmers at both ends, index difference between the reverse-complementary edge and this one.</span><br><span class="line">d. *.ContigIndex</span><br><span class="line">      Each record gives information about each contig in the *.contig: it&#x27;s edge index, length, the index difference between its reverse-complementary counterpart and itself.</span><br><span class="line">      </span><br><span class="line">3. Output files from the command &quot;map&quot;</span><br><span class="line">a. *.peGrads</span><br><span class="line">      Information for each clone library: insert-size, read index upper bound, rank and pair number cutoff for a reliable link. This file can be revised manually for scaffolding tuning.</span><br><span class="line">b. *.readOnContig</span><br><span class="line">      Reads&#x27; locations on contigs. Here contigs are referred by their edge index. Howerver about half of them are not listed in the *.contig file for their reverse-complementary counterparts are included already.</span><br><span class="line">c. *.readInGap</span><br><span class="line">      This file includes reads that could be located in gaps between contigs. This information will be used to close gaps in scaffolds if &quot;-F&quot; is set.</span><br><span class="line">      </span><br><span class="line">4. Output files from the command &quot;scaff&quot;</span><br><span class="line">a. *.newContigIndex</span><br><span class="line">      Contigs are sorted according their length before scaffolding. Their new index are listed in this file.  This is useful if one wants to corresponds contigs in *.contig with those in *.links.</span><br><span class="line">b. *.links</span><br><span class="line">      Links between contigs which are established by read pairs. New index are used.</span><br><span class="line">c. *.scaf_gap</span><br><span class="line">      Contigs in gaps found by contig graph outputted by the contiging procedure. Here new index are used.</span><br><span class="line">d. *.scaf</span><br><span class="line">      Contigs for each scaffold: contig index (concordant to index in *.contig),  approximate start position on scaffold, orientation, contig length, and its links to others contigs.</span><br><span class="line">e. *.gapSeq</span><br><span class="line">      Gap sequences between contigs.</span><br><span class="line">f. *.scafSeq</span><br><span class="line">      Sequences of each scaffolds.</span><br><span class="line">g. *.contigPosInscaff</span><br><span class="line">      Contigs&#x27; positions in each scaffold.</span><br><span class="line">h. *.bubbleInScaff</span><br><span class="line">      Contigs that form bubble structures in scaffolds. Every two contigs form a bubble and the contig with higher coverage will be kept in scaffold.</span><br><span class="line">i. *.scafStatistics</span><br><span class="line">      Statistic information of final scaffold and contig.</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;经过前面的全基因组特征调查（survey）后，我们发现这是一个复杂基因组，杂合度较高，可以以二代+三代测序技术相结合的策略进行全基因组组装，还可以以Hi-C（高通量染色体捕获技术，High-through chromosome conformation capture）技术进行辅助组装。这里我用华大开发的二代测序组装工具SOAPdenovo，用二代测序数据对进行初步基因组组装。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="基因组三代测序分析" scheme="http://www.shelven.com/categories/%E5%9F%BA%E5%9B%A0%E7%BB%84%E4%B8%89%E4%BB%A3%E6%B5%8B%E5%BA%8F%E5%88%86%E6%9E%90/"/>
    
    
    <category term="kmergenie" scheme="http://www.shelven.com/tags/kmergenie/"/>
    
    <category term="SOAPdenovo2" scheme="http://www.shelven.com/tags/SOAPdenovo2/"/>
    
  </entry>
  
  <entry>
    <title>0基础学习基因组三代测序组装（3）——全基因组Survey</title>
    <link href="http://www.shelven.com/2022/07/02/a.html"/>
    <id>http://www.shelven.com/2022/07/02/a.html</id>
    <published>2022-07-02T07:08:17.000Z</published>
    <updated>2022-12-03T16:13:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前说到如何对三代测序数据做污染评估，取随机序列做blastn比对nt库，确定物种分布情况。实际blast比对还要考虑比对的序列长度和ONT本身数据错误率，以及结合GC-depth确定是否有污染。基因组三代测序数据组装之前，我们还要做一个全基因组survey。主要是为了减少盲目性，先做低深度的基因组分析，也是初步了解物种<strong>基因组特征</strong>的有效方法，比如评估基因组大小和杂合情况，为后续全基因组de novo组装策略指定提供指导。</p><span id="more"></span><p>基因组复杂程度的经验性标准：</p><ul><li>简单基因组: 单倍体；或纯合二倍体；或杂合度低于0.5%, 且重复序列低于50%, 且GC含量在35%-65%的二倍体。</li><li>复杂基因组: 杂合度在0.5%~1.2%之间，或重复序列高于50%，或GC含量异常(&lt;35%或&gt;65%)的二倍体，或者多倍体。<strong>复杂基因组可以采用“2+3”即二代和三代测序技术相结合，加之Hi-C辅助组装的组装策略。</strong></li><li>高复杂基因组: 杂合度&gt;1.2%；或重复序列占比大于65%。</li></ul><p>有条件的话，也可以用流式细胞仪对基因组大小做个预估。我这里只有二代基因组测序数据，因此用基因组二代测序数据做全基因组survey。当然，这里要注意一点，做全基因组survey的样本和后续de novo组装的样本要来自同<strong>一个个体</strong>，避免个体间基因组特征的差异。</p><h2 id="1-原始数据质控"><a href="#1-原始数据质控" class="headerlink" title="1 原始数据质控"></a>1 原始数据质控</h2><div class="story post-story"><p>因为是对二代测序数据进行分析，质控的过程本质上和之前处理转录组二代数据一样，这里只提下过程和结果。</p><h3 id="1-1-fastqc生成质控报告"><a href="#1-1-fastqc生成质控报告" class="headerlink" title="1.1 fastqc生成质控报告"></a>1.1 fastqc生成质控报告</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastqc *.fq.gz -o ./</span><br></pre></td></tr></table></figure><p><img src="https://www.shelven.com/tuchuang/20220630/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220630/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><img src="https://www.shelven.com/tuchuang/20220630/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220630/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><img src="https://www.shelven.com/tuchuang/20220630/3.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220630/3.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>二代测序是双端测序结果，我这里只截图了部分qc报告，可以看出GC含量比较稳定，测序质量也比较高。</p><h3 id="1-2-trim-galore数据过滤"><a href="#1-2-trim-galore数据过滤" class="headerlink" title="1.2 trim-galore数据过滤"></a>1.2 trim-galore数据过滤</h3><p>报告中的结果虽然好，但是还是需要过滤一遍，把末端接头adapter序列过滤掉。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trim_galore -q 25 -phred33 -length 100 -stringency 1 -paired -o clean_data 1_raw_1.fq.gz 1_raw_2.fq.gz</span><br></pre></td></tr></table></figure><p>参数在这篇博客 <a href="https://www.shelven.com/2022/04/14/a.html?keyword=trim">转录组数据分析笔记（1）——如何用fastqc和trim-galore做测序数据质控</a> 有提到，这里不再赘述。</p><p><img src="https://www.shelven.com/tuchuang/20220630/4.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220630/4.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>看下report文件，过滤了Q值25以下的reads和adapter序列</p><p><img src="https://www.shelven.com/tuchuang/20220630/5.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220630/5.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div><h2 id="2-k-mer分析"><a href="#2-k-mer分析" class="headerlink" title="2 k-mer分析"></a>2 k-mer分析</h2><div class="story post-story"><p>先说一下k-mer的概念：k-mer在这里指将reads迭代拆分成包含k个碱基的序列（类似blast中的word length，蛋白质是3，核酸是11），我们后面要分析的基因组特征都是基于k-mer分布基础上进行的。</p><ul><li>基因组大小可以通过总 <strong>（K-mer 数量）&#x2F;（K-mer 期望测序深度）</strong>来估计</li><li>k-mer分布曲线的主峰所在横坐标可以作为<strong>期望的测序深度</strong></li><li>测序覆盖均匀、不存在测序误差和基因组重复序列的理论条件下，K-mer分布曲线会符合泊松分布</li><li><strong>单倍体或纯合基因组的 K-mer 分布曲线只有一个主峰</strong></li><li>杂合二倍体基因组的 K-mer 分布曲线有两个峰， 分别为<strong>杂合峰（主峰1&#x2F;2处）和纯合峰（主峰）</strong>，前者深度只有后者的一半</li><li>重复序列含量较高时会在主峰后面形成一个<strong>重复峰（主峰的2倍处）</strong>或者形成拖尾</li><li>一般选择<strong>17-mer</strong>评估基因组大小，因为ATCG组成长度为17的核酸序列，理论上有4的17次方种可能，足以覆盖一般的正常基因组。为了避免回文序列，K-mer分析选择K长度均为<strong>奇数</strong>。</li></ul><h3 id="2-1-安装jellyfish"><a href="#2-1-安装jellyfish" class="headerlink" title="2.1 安装jellyfish"></a>2.1 安装jellyfish</h3><p>根据上面说的k-mer概念，可以理解k-mer分析是非常耗计算资源的。我们要自己用脚本实现的话，需要将十几个G的reads分割成不同长度片段，再统计出现的次数，耗时而且麻烦。jellyfish是一款统计DNA序列中Kmer的分布的软件，它运行速度快，内存消耗低，支持并行，也是用的最多的统计k-mer的软件。</p><p><del>重点是可以通过conda直接安装……</del>最好不要用conda安装，我之前运行了1天没出结果也没报错（一度怀疑我的参数设置是不是有问题），百思不得其解。后来从github上重新下载，编译和安装之后，不到10分钟就跑出结果了…我不知道两种安装方式有什么区别，<strong>这里就记录下自己踩的坑</strong>。</p><p><strong>因为jellyfish不支持.gz的压缩文件</strong>，所以之前用tram galore过滤后得到的clean reads需要用gunzip命令解压。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install -c bioconda jellyfish  # 可以用conda安装，我运行的时候出了问题，暂未解决，不推荐</span><br></pre></td></tr></table></figure><p><a href="https://github.com/gmarcais/Jellyfish">点击这里进入jellyfish的github下载地址</a></p><p>我们用本地安装的方式，先下载tar.gz的源码包，tar -zxvf解压后进入jellyfish-2.3.0文件夹。</p><p>我是集群登录的，下面讲的步骤都是在集群上操作（非root账户）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第一步检测。本质上是一个shell脚本，根据系统环境产生合适的makefile文件或者C的头文件（.h结尾的文件），非root账户下--prefix后面接上自己账户的绝对路径。</span></span><br><span class="line">./configure --prefix=/public/home/wlxie</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第二步编译。对源代码包进行编译，如果有错误自己看是否有依赖库的缺失，主要是这个问题。</span></span><br><span class="line">make</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第三步安装。如果前面没有指定自己账户的路径，这一步是会报错没有权限的（用户不能向系统目录写入文件）。</span></span><br><span class="line">make install</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第四步自检。</span></span><br><span class="line">make check</span><br></pre></td></tr></table></figure><p>make和make check这两步都会因为<strong>动态链接库命名不同</strong>，导致报错无法找到动态库；以及我在检测通过之后，用集群运行程序仍然出现了动态库的某个模块无法调用的情况。这里统一说下解决方法。</p><p>前面configure会在我们的家目录下生成<strong>bin、lib和share目录</strong>，这里比较重要的是bin和lib目录。我们运行的命令在bin目录里，对应要改环境变量<strong>PATH</strong>；而需要调用的动态库是在lib目录下，对应要改环境变量<strong>LD_LIBRARY_PATH</strong>。家目录下的.bashrc文件加入以下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export PATH=&quot;/public/home/wlxie/bin:$PATH&quot;</span><br><span class="line">export LD_LIBRARY_PATH=&quot;/public/home/wlxie/lib:$LD_LIBRARY_PATH&quot;</span><br></pre></td></tr></table></figure><p>添加之后保存退出，并且source ~&#x2F;.bashrc刷新一下系统环境变量。</p><p>我碰到的报错是<strong>libcrypto.so.1.0.0和libstdc++.so.6</strong>这两个动态库找不到，但是locate命令查看这两个动态库，在系统目录&#x2F;lib64&#x2F;下都能找到文件，因此将这两个动态库文件直接复制到家目录的lib文件夹，问题就全部解决了。</p><p>如果libstdc++.so.6报错某版本的文件不存在，可以先到动态库目录下，运行strings命令查看动态库中是否有对应的文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings /lib64/libstdc++.so.6 | grep CXXABI   # 比如找不到GLIBCXX_3.4.26，看看动态库中是否存在这个版本的文件，如果不存在，更新动态库；如果存在但是找不到，建议直接拷贝到自己的lib目录下</span><br></pre></td></tr></table></figure><p>make check之后会生成一个日志文件test-suite.log，没有fail的项目说明软件安装成功，没有问题。</p><p><img src="https://www.shelven.com/tuchuang/20220630/6.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220630/6.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="2-2-k-mer频数分布"><a href="#2-2-k-mer频数分布" class="headerlink" title="2.2 k-mer频数分布"></a>2.2 k-mer频数分布</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">k-mer计数</span></span><br><span class="line">jellyfish count -m 17 -s 300M -t 50 -C -o 17-mer.jf ./1_raw_1_val_1.fq ./1_raw_2_val_2.fq</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">k-mer频数统计</span></span><br><span class="line">jellyfish histo -t 4 17-mer.jf &gt; 17-mer.histo</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">统计总k-mer数和特征k-mer数等</span></span><br><span class="line">jellyfish stats 17-mer.jf -o counts_stats.txt</span><br></pre></td></tr></table></figure><p>记录一下各个参数的意义：</p><blockquote><ul><li>-m    # k-mer长度设置为17bp，进行计数</li><li>-s    # 存储用的hash表大小，说实话我没看懂什么意思，基因组估计有多大就用多大就是了，单位是M或者G</li><li>-t    # 使用的线程数，也就是cpu核数</li><li>-C    # 大写的C，对正负链reads都进行统计，双端测序一定要加这个参数</li><li>-o    # 结果文件的前缀名，结果文件是一个二进制文件</li></ul></blockquote><p>正常来说，<strong>10分钟就能跑完程序并给出k-mer计数结果文件</strong>。我用conda安装的jellyfish同样条件运行了20个小时没有结束……而且还不报错！第一次运行这个软件，没有人参考和交流，百度到的教程都是抄来抄去的也没有人说明时间的问题……以后还是去官网安装生信软件了，虽然麻烦一点但是靠谱……</p><p><img src="https://www.shelven.com/tuchuang/20220630/7.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220630/7.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><strong>这个软件的帮助文档在&#x2F;jellyfish-2.3.0&#x2F;doc目录下，所有功能和参数都有英文详解</strong>。</p><p>k-mer频数统计是在计数结果文件上进一步统计各个k-mer出现的次数，频数统计结果文件17-mer.histo将k-mer从1统计到10000，最后一行是10001以后对应的总频次。counts_stats.txt是总的统计结果，包括k-mer总数（Total），特异的k-mer数目（Distinct）只出现过一次的k-mer数量（Unique），频数最高的k-mer数量（Max_count）四项。</p><p><img src="https://www.shelven.com/tuchuang/20220630/8.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220630/8.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><img src="https://www.shelven.com/tuchuang/20220630/10.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220630/10.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>有了频数统计结果文件17-mer.histo就可以用R作图了，以下R作图代码来自于CSDN博主 <a href="https://blog.csdn.net/qq_40569830/article/details/125287781">生信技工</a></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kmer <span class="operator">&lt;-</span> read.table<span class="punctuation">(</span><span class="string">&#x27;17-mer.histo&#x27;</span><span class="punctuation">)</span></span><br><span class="line">kmer <span class="operator">&lt;-</span> subset<span class="punctuation">(</span>kmer<span class="punctuation">,</span> V1 <span class="operator">&gt;=</span><span class="number">5</span> <span class="operator">&amp;</span> V1 <span class="operator">&lt;=</span><span class="number">500</span><span class="punctuation">)</span>     <span class="comment"># 只取5-500bp长度的k-mer统计频次</span></span><br><span class="line">Frequency <span class="operator">&lt;-</span> kmer<span class="operator">$</span>V1</span><br><span class="line">Number <span class="operator">&lt;-</span> kmer<span class="operator">$</span>V2</span><br><span class="line">png<span class="punctuation">(</span><span class="string">&#x27;kmer_plot.png&#x27;</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>Frequency<span class="punctuation">,</span> Number<span class="punctuation">,</span> type <span class="operator">=</span> <span class="string">&#x27;l&#x27;</span><span class="punctuation">,</span> col <span class="operator">=</span> <span class="string">&#x27;blue&#x27;</span><span class="punctuation">)</span></span><br><span class="line">dev.off<span class="punctuation">(</span><span class="punctuation">)</span>       <span class="comment"># 保存png</span></span><br></pre></td></tr></table></figure><p>k-mer分布图如下，当然这只是一个简略图，上面R作图代码还有很多细节可以补充</p><p><img src="https://www.shelven.com/tuchuang/20220630/9.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220630/9.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="2-3-基因组大小、重复率、杂合率估算"><a href="#2-3-基因组大小、重复率、杂合率估算" class="headerlink" title="2.3 基因组大小、重复率、杂合率估算"></a>2.3 基因组大小、重复率、杂合率估算</h3><p>横坐标表示k-mer深度，纵坐标为k-mer数量，可以看得出来测序的样本是个杂合二倍体。主峰坐标（116，2584902），杂合峰坐标（57，1188461），也就是说k-mer期望深度为116；k-mer总数为34655456060；主峰2倍深度也就是232之后的k-mer为重复序列k-mer，总数可以通过导出17-mer.histo文件进行统计（改成csv格式直接两步算出），共16361378388</p><ul><li><p><strong>k-mer分布曲线中无异常峰</strong>，说明二代测序提取的DNA纯度较高，没有被污染</p></li><li><p>根据<strong>（K-mer 数量）&#x2F;（K-mer 期望测序深度）</strong>估算基因组大小为298M。去除深度小于5的错误k-mer，估算基因组大小为292M.</p></li><li><p>根据<strong>（重复序列的k-mer总数）&#x2F;（K-mer 期望测序深度）</strong>估计重复序列大小为141M，即重复率48.29%</p></li><li><p>单拷贝序列大小U&#x3D;292-141&#x3D;151M，要计算杂合率，需要统计非重复k-mer的总数，也就是计算杂合峰面积，建议还是用软件或者在线工具比如<a href="http://qb.cshl.edu/genomescope/genomescope2.0/">genomescope2.0</a></p></li></ul><p>jellyfish + GenomeScope是一套应用非常广泛的基因组survey方法，GenomeScope2.0适合用于分析<strong>二倍体</strong>生物。</p><p><img src="https://www.shelven.com/tuchuang/20220630/11.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220630/11.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>上面是GenomeScope2.0网页版界面，只要我们提供jellyfish生成的.histo结果文件，设置参数就行</p><ul><li>k-mer length    # k-mer长度</li><li>Ploidy    # 染色体倍性</li><li>Max k-mer coverage     # 默认-1，即不限制最大k-mer深度，我这里限制了10000</li><li>Average k-mer coverage for polyploid genome    # 默认-1，不进行筛选</li></ul><p>提交后几分钟就生成了可用于发表的图和报告</p><p><img src="https://www.shelven.com/tuchuang/20220630/12.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220630/12.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>可以看到估计的基因组大小是200M，杂合率0.865%，杂合峰覆盖度（深度）58.3。下面说下这个图如何解读：</p><ul><li>蓝色区域是实际观测值</li><li>黑色拟合线是去除错误（errors）后剩下的k-mer分布，认为是正确的数据并以此评估基因组大小</li><li>黄色拟合线是非重复区域的k-mer分布（理想情况）</li><li>橙色拟合线区域是低深度的错误k-mer，认为是测序错误引入的</li><li>黑色虚线是k-mer的几个峰值</li></ul><p>之所以估计的基因组大小比之前自己估计的要小，是因为去除error的标准不同，我之前只是简单去除了k-mer深度1-4的错误序列，这里是构建模型选择的错误序列，更准确一些。</p><p>网页版最后的results里还有总的统计结果，可以很方便地计算重复率，一眼就能看明白这里就不赘述了。</p><p><img src="https://www.shelven.com/tuchuang/20220630/13.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220630/13.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前说到如何对三代测序数据做污染评估，取随机序列做blastn比对nt库，确定物种分布情况。实际blast比对还要考虑比对的序列长度和ONT本身数据错误率，以及结合GC-depth确定是否有污染。基因组三代测序数据组装之前，我们还要做一个全基因组survey。主要是为了减少盲目性，先做低深度的基因组分析，也是初步了解物种&lt;strong&gt;基因组特征&lt;/strong&gt;的有效方法，比如评估基因组大小和杂合情况，为后续全基因组de novo组装策略指定提供指导。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="基因组三代测序分析" scheme="http://www.shelven.com/categories/%E5%9F%BA%E5%9B%A0%E7%BB%84%E4%B8%89%E4%BB%A3%E6%B5%8B%E5%BA%8F%E5%88%86%E6%9E%90/"/>
    
    
    <category term="jellyfish" scheme="http://www.shelven.com/tags/jellyfish/"/>
    
    <category term="GenomeScope2.0" scheme="http://www.shelven.com/tags/GenomeScope2-0/"/>
    
  </entry>
  
  <entry>
    <title>0基础学习基因组三代测序组装（2）——数据污染评估</title>
    <link href="http://www.shelven.com/2022/06/20/a.html"/>
    <id>http://www.shelven.com/2022/06/20/a.html</id>
    <published>2022-06-19T17:17:30.000Z</published>
    <updated>2022-12-03T16:13:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>做完基因组三代测序数据质控之后，我们把所有reads的Q值控制在7以上，每个read的长度在1000bp以上。我们不能明确自己的测序数据是否被其他物种污染，这个时候就要用balst比对的方法确定测序数据是否被污染，以及污染的来源。</p><span id="more"></span><h2 id="1-下载balst-工具和数据库"><a href="#1-下载balst-工具和数据库" class="headerlink" title="1 下载balst+工具和数据库"></a>1 下载balst+工具和数据库</h2><div class="story post-story"><p>在之前的一篇博客中，我详细介绍了如何本地安装NCBI的blast+工具，以及下载nr&#x2F;nt库，建立本地的数据库。<a href="https://www.shelven.com/2022/06/17/a.html">详情点击这里</a>。</p><p>在做数据污染评估的时候，我们还需要知道blast最佳结果对应的物种名，因此还需要下载分类数据库的以下两个子库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ascp工具下载大数据，wget命令下载小文件（md5校验文件）</span></span><br><span class="line">ascp -QT -i /public/home/wlxie/miniconda3/envs/biosoft/etc/asperaweb_id_dsa.openssh -k1 -l 500m anonftp@ftp.ncbi.nlm.nih.gov:/pub/taxonomy/accession2taxid/nucl_gb.accession2taxid.gz ./</span><br><span class="line"></span><br><span class="line">wget https://ftp.ncbi.nlm.nih.gov/pub/taxonomy/accession2taxid/nucl_gb.accession2taxid.gz.md5</span><br><span class="line"></span><br><span class="line">ascp -QT -i /public/home/wlxie/miniconda3/envs/biosoft/etc/asperaweb_id_dsa.openssh -k1 -l 500m anonftp@ftp.ncbi.nlm.nih.gov:/pub/taxonomy/taxdump.tar.gz ./</span><br><span class="line"></span><br><span class="line">wget https://ftp.ncbi.nlm.nih.gov/pub/taxonomy/taxdump.tar.gz.md5</span><br></pre></td></tr></table></figure><p>md5文件校验完成之后，两个数据库分别解压。注意.gz文件用gunzip，.tar.gz文件用tar -zxvf</p><p>看看这两个数据库长什么样：</p><p><img src="https://www.shelven.com/tuchuang/20220619/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220619/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><img src="https://www.shelven.com/tuchuang/20220619/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220619/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>第一张图片是<strong>nucl_gb.accession2taxid</strong>，我们需要用到第二列版本信息和第三列的taxid。</p><p>第二张图片是<strong>names.dmp</strong>，我们需要用到有taxid，学名和scientific name字符串的行。</p><p>这两个数据库怎么使用后面会详细说明。分析思路来自于CSDN的博主<a href="https://blog.csdn.net/qq_42962326/article/details/105081327">风风是超人</a>，遗憾的是从17年开始，NCBI不再提供gi号与blastn结果的关联，博主的本地数据库可能版本比较早，采用的是gi号分析。</p><p>我将后续的代码做了修改，下载的也都是最新的数据库。总的逻辑是利用blast结果的version号，得到nucl_gb.accession2taxid数据库中的taxid号，最后通过names.dmp中的taxid号得到学名。代码方面做了少许优化，对集群服务器可能更友好一点？</p></div><h2 id="2-fq文件处理和blast"><a href="#2-fq文件处理和blast" class="headerlink" title="2 fq文件处理和blast"></a>2 fq文件处理和blast</h2><div class="story post-story"><p>质控后的数据fq文件是“@”开头的，我们要改成fa格式也就是“&gt;”开头。取前10000条序列，每个序列有4行，只取第一行标题和第二行序列。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">NR表示当前行，判断除以4的余数，余数1为标题行，只输出第一个元素即reads <span class="built_in">id</span>；余数2则为序列行，输出所有元素也就是整条序列。最后替换@符号，文件名为test.fa</span></span><br><span class="line">zcat clean_filter.fq.gz | head -n 40000 | awk &#x27;&#123;if(NR%4==1)&#123;print $1&#125;else if(NR%4==2)&#123;print $0&#125;&#125;&#x27; | sed &#x27;s/@/&gt;/g&#x27; &gt;test.fa</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">批量blast程序</span></span><br><span class="line">blastn -query test.fa -out test_blastn_nt.xml -db nt -outfmt 5 -evalue 1e-5 -num_threads 20 -max_target_seqs 1</span><br></pre></td></tr></table></figure><p>批量blast程序注意下我们输出的格式为xml格式，也就是- outfmt 5。为什么要用xml格式，因为xml格式能给出的信息最全，我们需要知道输出的版本号</p><p>evalue值根据需要设定，这里我设置1e-5</p><p>最大匹配数量注意下设置1，我们只需要知道和哪个物种相似度最高，一个输出结果就足够了（虽然设置1会有警告）。</p><p>看下blast生成的test_blastn_nt.xml这个结果文件：</p><p><img src="https://www.shelven.com/tuchuang/20220619/3.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220619/3.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>虽然是第一次接触xml格式，但是感觉非常熟悉！之前做的一个<a href="https://www.shelven.com/2022/05/03/a.html">微博爬虫小程序</a>就是扒了一个类似的html格式的文件……xml格式也挺容易解析的，可以看到比对信息以标签&lt;Iteration&gt;开始，以&lt;&#x2F;Iteration&gt;标签结束，&lt;Hit&gt;标签开始表示的是比对上的结果（因为我设置了最大比对序列数量是1，所以&lt;Hit_num&gt;只有1）；&lt;Hsp&gt;标签表示某一块的比对结果（同一条序列，若干片段比对上），因此&lt;Hsp_num&gt;标签的数量可能不止一个。</p><p>当然，这些都可以不用关心，分析需要的信息我用红框标了出来。比较重要的是&lt;Hit_def&gt;标签，里面的字符串是空格隔开的，<strong>第一个元素是我们需要的物种版本号</strong>。</p></div><h2 id="3-XML文件解析"><a href="#3-XML文件解析" class="headerlink" title="3 XML文件解析"></a>3 XML文件解析</h2><div class="story post-story"><p>前面说了解析的思路，以下是代码的实现。因为用的python语言写的程序，我的建议是在vscode一类的编程软件中写这些代码，如果有错误可以及时调试。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以不写，我是为了确保导入父目录的模块不出错</span></span><br><span class="line">sys.path.append(<span class="string">&quot;./&quot;</span>)</span><br><span class="line"></span><br><span class="line">xmlfile = <span class="built_in">open</span>(<span class="string">&quot;/public/home/wlxie/luobuma/luobuma/sample_1_rawdata/Third_generation_sequencing/test_blastn_nt.xml&quot;</span>,<span class="string">&quot;r&quot;</span>)</span><br><span class="line">outfile = <span class="built_in">open</span>(<span class="string">&quot;/public/home/wlxie/luobuma/luobuma/sample_1_rawdata/Third_generation_sequencing/filted_accession_version.txt&quot;</span>,<span class="string">&quot;w&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个空的字典，提取有queryID和subjectID的行</span></span><br><span class="line">dict1 = defaultdict(<span class="built_in">list</span>)</span><br><span class="line"><span class="keyword">for</span> lines <span class="keyword">in</span> xmlfile:</span><br><span class="line">    line = lines.strip()</span><br><span class="line">    read_id = re.match(<span class="string">&#x27;&lt;Iteration_query-def&gt;.*&lt;/Iteration_query-def&gt;&#x27;</span>,line)</span><br><span class="line">    Hit_def = re.match(<span class="string">&#x27;&lt;Hit_def&gt;.*&lt;/Hit_def&gt;&#x27;</span>,line)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 解析queryID</span></span><br><span class="line">    <span class="keyword">if</span> read_id != <span class="literal">None</span>:     </span><br><span class="line">        read_id = read_id.group()</span><br><span class="line">        read_id = read_id.split(<span class="string">&quot;&lt;&quot;</span>)[<span class="number">1</span>].split(<span class="string">&quot;&gt;&quot;</span>)[<span class="number">1</span>]</span><br><span class="line">        key=read_id</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 字典key值和value值赋值</span></span><br><span class="line">    <span class="keyword">elif</span> Hit_def !=<span class="literal">None</span>:        </span><br><span class="line">        Hit_def = Hit_def.group()</span><br><span class="line">        Hit_def = Hit_def.split(<span class="string">&quot;&lt;&quot;</span>)[<span class="number">1</span>].split(<span class="string">&quot;&gt;&quot;</span>)[<span class="number">1</span>]</span><br><span class="line">        dict1[key].append(Hit_def)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入文件，制表符分割</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> dict1:</span><br><span class="line">    outfile.write(key + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;\t&quot;</span>.join(dict1[key])+<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>看下运行结束后解析得到的文件：</p><p><img src="https://www.shelven.com/tuchuang/20220619/4.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220619/4.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>一共是两列，第一列是reads的queryID，第二列subjectID就是比对上的序列信息。可以看到第二列可以以空格为分隔符，提取第一个元素也就是物种版本号，后面会说。</p><p>为什么要把物种版本号提出来而不直接用这段内容里的物种名呢？因为不同的物种名<strong>字段数量和位置不一样</strong>，无法用统一的命令直接提取，精确的版本号可以对应<strong>唯一一个taxid</strong>，从而被精准地注释上物种学名。</p></div><h2 id="4-匹配物种学名"><a href="#4-匹配物种学名" class="headerlink" title="4 匹配物种学名"></a>4 匹配物种学名</h2><div class="story post-story"><p>这里需要注意一个问题，blast用的nt库还有物种分类用到的两个数据库，他们的<strong>更新时间是不一致的</strong>。也就是说，物种版本号不一定能完全匹配上taxid，而taxid也不一定能匹配上学名。</p><p>而python语言写的程序，用到字典类型数据的时候，如果没有对应的key值匹配是会报错的，不会继续执行下去。一会儿解释，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;./&quot;</span>)</span><br><span class="line"></span><br><span class="line">accession = <span class="built_in">open</span>(<span class="string">&quot;/public/home/wlxie/luobuma/luobuma/sample_1_rawdata/Third_generation_sequencing/filted_accession_version.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)</span><br><span class="line">accession2taxid = <span class="built_in">open</span>(<span class="string">&quot;/public/home/wlxie/luobuma/luobuma/sample_1_rawdata/Third_generation_sequencing/nucl_gb.accession2taxid&quot;</span>,<span class="string">&quot;r&quot;</span>)</span><br><span class="line">taxid2name = <span class="built_in">open</span>(<span class="string">&quot;/public/home/wlxie/luobuma/luobuma/sample_1_rawdata/Third_generation_sequencing/names.dmp&quot;</span>,<span class="string">&quot;r&quot;</span>)</span><br><span class="line">final_res = <span class="built_in">open</span>(<span class="string">&quot;/public/home/wlxie/luobuma/luobuma/sample_1_rawdata/Third_generation_sequencing/final_res.txt&quot;</span>,<span class="string">&quot;w&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从names.dmp提取taxid和学名，匹配有scientific name的行</span></span><br><span class="line">taxid_name_dict = &#123;&#125;        </span><br><span class="line"><span class="keyword">for</span> lines <span class="keyword">in</span> taxid2name:</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;scientific name&quot;</span> <span class="keyword">in</span> lines:</span><br><span class="line">        line = lines.strip().split(<span class="string">&quot;|&quot;</span>)</span><br><span class="line">        taxid = line[<span class="number">0</span>].strip()</span><br><span class="line">        name = line[<span class="number">1</span>].strip()</span><br><span class="line">        taxid_name_dict[taxid] = name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从nucl_gb.accession2taxid提取taxid和版本号</span></span><br><span class="line">accession_taxid_dict = &#123;&#125;       </span><br><span class="line"><span class="keyword">for</span> lines <span class="keyword">in</span> accession2taxid:</span><br><span class="line">    line = lines.strip().split(<span class="string">&quot;\t&quot;</span>)</span><br><span class="line">    TAXID = line[<span class="number">2</span>]</span><br><span class="line">    VERSION = line[<span class="number">1</span>]</span><br><span class="line">    accession_taxid_dict[VERSION] = TAXID</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加两个判断条件，版本号匹配不上taxid和taxid匹配不上学名的情况。gc.collect()释放内存。</span></span><br><span class="line"><span class="keyword">for</span> lines <span class="keyword">in</span> accession:</span><br><span class="line">    line = lines.strip().split(<span class="string">&quot;\t&quot;</span>)</span><br><span class="line">    version = line[<span class="number">1</span>].split()[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> version <span class="keyword">in</span> accession_taxid_dict:</span><br><span class="line">        taxid = accession_taxid_dict[version]</span><br><span class="line">        <span class="keyword">if</span> taxid <span class="keyword">in</span> taxid_name_dict:</span><br><span class="line">            final_res.write(<span class="string">&quot;\t&quot;</span>.join(line)+<span class="string">&quot;\t&quot;</span>+taxid_name_dict[taxid]+<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            final_res.write(<span class="string">&quot;\t&quot;</span>.join(line)+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;INVALID TAXID&quot;</span>+<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        final_res.write(<span class="string">&quot;\t&quot;</span>.join(line)+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;INVALID ACCESSION VERSION&quot;</span>+<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    gc.collect()</span><br></pre></td></tr></table></figure><p>如果不加最后两个判断条件，程序会在报错的那行read序列终止。</p><p>通过比较两个输出结果文件行数是否一致来判断匹配是否完全。</p><p><img src="https://www.shelven.com/tuchuang/20220619/5.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220619/5.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>两个文件输出结果一致说明匹配完成，<strong>为什么这里是9338而不是我们一开始blast的10000条序列呢？那是因为有662条序列balst结果的E值大于1e-5，没有在nt中比对上合适的序列</strong></p></div><h2 id="5-输出物种注释分布结果"><a href="#5-输出物种注释分布结果" class="headerlink" title="5 输出物种注释分布结果"></a>5 输出物种注释分布结果</h2><div class="story post-story"><p>到这一步就有很多种处理方法了，可以把结果文件直接用excel打开，统计reads在nt库的分布情况和比对上的物种分布。也可以直接写个python脚本做个数据统计。</p><p>统计前我们先检查一下是否存在上一步匹配失败的reads。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">统计匹配失败的reads</span></span><br><span class="line">cat final_res.txt | grep &quot;INVALID TAXID&quot;</span><br><span class="line">cat final_res.txt | grep &quot;INVALID ACCESSION VERSION&quot;</span><br></pre></td></tr></table></figure><p><img src="https://www.shelven.com/tuchuang/20220619/6.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220619/6.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>提示有8条reads的物种版本号比对不上taxid，且都是Pyrus x bretschneideri这个物种，说明这个物种还未在nucl_gb.accession2taxid这个NCBI官方数据库中更新。在结果文件中将其替换掉。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sed命令在原文件进行全局替换</span></span><br><span class="line">sed -i &#x27;s/INVALID ACCESSION VERSION/Pyrus x bretschneideri/g&#x27; final_res.txt</span><br></pre></td></tr></table></figure><p>修改完成，检查无误后，用以下python脚本统计物种注释分布：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter     <span class="comment"># 引入counter模块</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;./&quot;</span>)</span><br><span class="line"></span><br><span class="line">name_file = <span class="built_in">open</span>(<span class="string">&quot;/public/home/wlxie/luobuma/luobuma/sample_1_rawdata/Third_generation_sequencing/final_res.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)</span><br><span class="line">res_stastics = <span class="built_in">open</span>(<span class="string">&quot;/public/home/wlxie/luobuma/luobuma/sample_1_rawdata/Third_generation_sequencing/stastics.txt&quot;</span>,<span class="string">&quot;w&quot;</span>)</span><br><span class="line"></span><br><span class="line">name_list = []</span><br><span class="line"><span class="keyword">for</span> lines <span class="keyword">in</span> name_file:</span><br><span class="line">    line = lines.strip().split(<span class="string">&quot;\t&quot;</span>)</span><br><span class="line">    name = line[-<span class="number">1</span>]     <span class="comment"># 取最后一列</span></span><br><span class="line">    name_list.append(name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Counter()函数统计词频</span></span><br><span class="line">count_result = Counter(name_list)</span><br><span class="line">count_list = <span class="built_in">list</span>(count_result.items())     <span class="comment"># 注意需要创建一个list</span></span><br><span class="line">count_list.append((<span class="string">&#x27;Unmap&#x27;</span>,<span class="number">662</span>))        <span class="comment"># 注意手动添加blast失败的序列条数到list中</span></span><br><span class="line">count_list.sort(key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>],reverse=<span class="literal">True</span>) <span class="comment"># 以第二维数据值，即统计的物种学名出现次数排序</span></span><br><span class="line"></span><br><span class="line">res_stastics.write(<span class="string">&quot;Name\tHit_reads\tpercentage\n&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> count_list:</span><br><span class="line">    name = i[<span class="number">0</span>]</span><br><span class="line">    number = i[<span class="number">1</span>]</span><br><span class="line">    reads_num = <span class="number">10000</span></span><br><span class="line">    percentage =<span class="string">&quot;%.2f%%&quot;</span>%(<span class="number">100</span>*<span class="built_in">float</span>(number)/<span class="built_in">float</span>(reads_num))       <span class="comment"># 浮点两位小数的百分比</span></span><br><span class="line">    res_stastics.write(name+<span class="string">&quot;\t&quot;</span>+<span class="built_in">str</span>(number)+<span class="string">&quot;\t&quot;</span>+<span class="built_in">str</span>(percentage)+<span class="string">&quot;\n&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>需要注意手动添加blast失败的序列条数</strong>，方便最后一起统计。打开生成的stastics.txt文件：</p><p><img src="https://www.shelven.com/tuchuang/20220619/8.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220619/8.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>这个数据是制表符分割的，可以用excel做一个分布统计表，或者用R做一个柱状图，底下展示结果</p><p><img src="https://www.shelven.com/tuchuang/20220619/9.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220619/9.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>可以看到，10000条序列比对结果占比最高的前两条序列（橘黄色的）是细菌的核酸序列，总数达到3437条。992条序列比对上罗布麻，662条序列未比对上nt库。可以认为这个序测序数据被细菌污染，可以和测序公司battle要求重新测一遍了……</p></div><h2 id="6-补充说明"><a href="#6-补充说明" class="headerlink" title="6 补充说明"></a>6 补充说明</h2><div class="story post-story"><p>秉着科学严谨的态度，再更新一些内容查漏补缺。</p><p>质控过滤后的reads有183万条，而我只取了前1万条。考虑到测序开头的低质量reads可能会对分析结果产生干扰（比如开头的电信号不稳定），我写了个python脚本对过滤后的数据<strong>随机</strong>取10000条reads，这样就只有随机误差影响分析结果了。</p><p>在第2步fq文件处理部分，为了python调用方便，先解压clean_filter.fq.gz文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gunzip clean_filter.fq.gz</span><br></pre></td></tr></table></figure><p>读取解压后的文件需要49G内存，我只能在集群上处理，接着运行如下python脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random       <span class="comment"># 调用random模块产生随机数</span></span><br><span class="line"><span class="keyword">import</span> linecache    <span class="comment"># 调用linecache模块读入指定行</span></span><br><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"></span><br><span class="line">output_file = <span class="built_in">open</span>(<span class="string">&quot;/public/home/wlxie/luobuma/luobuma/sample_1_rawdata/Third_generation_sequencing/random_test.fa&quot;</span>,<span class="string">&quot;w&quot;</span>)</span><br><span class="line"></span><br><span class="line">reads_list = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">1834926</span>))     <span class="comment"># 共有1834925条reads</span></span><br><span class="line">line = random.sample(reads_list,<span class="number">10000</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> line:</span><br><span class="line">    text1 = linecache.getline(<span class="string">&quot;/public/home/wlxie/luobuma/luobuma/sample_1_rawdata/Third_generation_sequencing/clean_filter.fq&quot;</span>,<span class="number">4</span>*i-<span class="number">3</span>)</span><br><span class="line">    text2 = linecache.getline(<span class="string">&quot;/public/home/wlxie/luobuma/luobuma/sample_1_rawdata/Third_generation_sequencing/clean_filter.fq&quot;</span>,<span class="number">4</span>*i-<span class="number">2</span>)</span><br><span class="line">    query_id = text1.split()[<span class="number">0</span>]</span><br><span class="line">    query_id_fa = query_id.replace(<span class="string">&quot;@&quot;</span>, <span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">    output_file.write(query_id_fa + <span class="string">&quot;\n&quot;</span> + text2)</span><br><span class="line">    gc.collect()</span><br></pre></td></tr></table></figure><p>处理方式比之前多了几步，我运行了两次脚本，发现两次产生的文件大小都在135M左右，也就是随机取10000条reads产生的文件比取前10000条reads产生的文件大了40M。证明<strong>三代测序开头测得序列质量不太行</strong>（短序列不一定质量不好，但是质量不好的序列一定是短序列），拿到随机产生的10000条reads做blast，后续步骤都一样。</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;做完基因组三代测序数据质控之后，我们把所有reads的Q值控制在7以上，每个read的长度在1000bp以上。我们不能明确自己的测序数据是否被其他物种污染，这个时候就要用balst比对的方法确定测序数据是否被污染，以及污染的来源。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="基因组三代测序分析" scheme="http://www.shelven.com/categories/%E5%9F%BA%E5%9B%A0%E7%BB%84%E4%B8%89%E4%BB%A3%E6%B5%8B%E5%BA%8F%E5%88%86%E6%9E%90/"/>
    
    
    <category term="python" scheme="http://www.shelven.com/tags/python/"/>
    
    <category term="blast+" scheme="http://www.shelven.com/tags/blast/"/>
    
  </entry>
  
  <entry>
    <title>0基础学习基因组三代测序组装（1）——数据质控</title>
    <link href="http://www.shelven.com/2022/06/17/b.html"/>
    <id>http://www.shelven.com/2022/06/17/b.html</id>
    <published>2022-06-17T14:31:19.000Z</published>
    <updated>2022-12-03T16:14:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近拿到一个植物基因组的三代和二代测序数据，想通过以三代测序数据为主，二代测序数据为辅的方式学习一下如何拼接组装一个基因组。但是三代测序数据刚到手就懵了，与之前学习的转录组分析不一样，三代测序返回的几个文件不是单纯的fq文件，于是我又开始恶补了一些三代测序的基础知识，开坑写个三代基因组测序组装的系列笔记~</p><span id="more"></span><p><img src="https://www.shelven.com/tuchuang/20220617/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220617/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h2 id="1-技术背景"><a href="#1-技术背景" class="headerlink" title="1 技术背景"></a>1 技术背景</h2><div class="story post-story"><p>当第二代高通量测序技术进入成熟阶段后，读长过短、PCR扩增带来的偏向性等问题开始日益凸显；作为基因组学上新的转折点，以PacBio单分子实时测序技术及纳米孔单分子测序技术为首的第三代高通量测序技术（Third-generation Sequencing）开始进入科研应用，从单分子水平上对DNA分子的实时测序，成功解决了二代测序几大困扰：<strong>极端 GC含量区域覆盖度低、高度重复区域无法较好地拼装、大片段变异难以准确检测、不能直接检测碱基修饰</strong>等问题。</p><p>ONT（Oxford Nanopore Technologies）牛津纳米孔测序技术作为第三代单分子实时测序技术，其原理是基于高分子膜两侧电压和其中的蛋白质纳米孔，当单分子DNA从纳米孔通过时，会引起孔两侧电位差来实现信号检测， 而ATCG四种碱基的带电性质不一样，因此利用<strong>电信号的差异</strong>就能检测出通过的碱基类型，从而实现测序。</p><p>Nanopore商业化平台有三个：MinION、GridION及PromethION。本系列笔记的三代测序数据来源于<strong>PromethION</strong>测序平台测序的一个cell，PromethION测序仪拥有48个流动槽，每个流动槽拥有3000个纳米孔通道（总计144000个），适用于大样本量的高通量快速测序。</p></div><h2 id="2-数据质控"><a href="#2-数据质控" class="headerlink" title="2 数据质控"></a>2 数据质控</h2><div class="story post-story"><h3 id="basecalling"><a href="#basecalling" class="headerlink" title="basecalling"></a>basecalling</h3><p>在ONT的测序平台中，将通过纳米孔的DNA或RNA链产生的电位信号转化为相应的碱基序列的过程，称为<strong>basecalling</strong>。Nanopore测序的下机数据的原始数据格式为包含原始测序电信号的<strong>fast5格式</strong>，官方有提供工具Guppy进行basecalling，以<strong>mean_qscore_template的数值大于等于7</strong>为标准（也就是测序质量大于7的reads）得到原始测序数据，这样得到的basecalling数据为<strong>fastq格式</strong>（.fastq或者.fq结尾），所以我拿到的就是已经basecalling后的结果。</p><ul><li>fast5: 原始电信号文件，以.fast5为文件结尾。此文件既有测序得到的序列信息，还有甲基化修饰信息（甲基化位点电信号会不一样）。</li><li>fastq: fast5文件转换而来，四行一个单位，序列和碱基质量一一对应。</li></ul><p>basecalling的同时还可以一起拆分barcode条码序列，这里我没用到guppy这个软件，了解一下就行。经过basecalling后，文件会分为<strong>fail和pass</strong>两部分，pass部分就是满足<strong>Q值&gt;7</strong>的序列（二代测序质控标准是Q20，这里的三代测序质控标准是Q7，准确性不及二代测序）。</p><p>还有一个summary.txt文件，这是一个测序汇总文件，结构如下：</p><p><img src="https://www.shelven.com/tuchuang/20220617/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220617/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>第一眼看上去很乱，几个重要的列含义如下：</p><blockquote><ol><li>filename_fastq  fasq文件名</li><li>filename_fast5  fast5文件名</li><li>read_id  每条read对应的id号</li><li>run_id  这一次运行产生的id号，一个flowcell通常为一个run</li><li>channel mux  该条read在哪个channel测的</li><li>start_time  这条read测序起始时间</li><li>duration  这条read测序经过时间</li><li>passes_filtering  <strong>Q值大于7为TRUE否则为FALSE</strong></li><li>sequence_length_template   read长度，<strong>三代测序数据过滤的指标之一</strong></li><li>mean_qscore_template  非常重要的指标，<strong>每一个read的平均Q值</strong></li><li>有关barcode的都是标签序列相关参数，因为不同样品接头会添加不同的标签序列，混测的时候根据标签序列与样品的对应关系来区分不同样品。</li></ol></blockquote><p>返回的数据是guppy处理过的，也就是raw reads，接下来质控的过程就需要自己动手了。</p><h3 id="nanoplot质控"><a href="#nanoplot质控" class="headerlink" title="nanoplot质控"></a>nanoplot质控</h3><p>先说明下为什么要用这个工具，三代测序的数据读长比二代测序长很多，而且每条序列的长度都是不一样的。不能用之前转录组数据分析中的fastq工具，会报错，因此使用nanoplot工具来生成质检报告，同样也是会生成各种html文件方便浏览结果。</p><p>先创建一个nanoplot专用的环境，下载nanoplot，之后的质控过程都在这个环境下进行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建环境并下载nanoplot</span></span><br><span class="line">conda create -n nanoplot -y -c bioconda nanoplot</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">激活环境</span></span><br><span class="line">. activate nanoplot</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成质检报告。可以用pass.fq文件，也可以直接用summery.txt文件。-o参数后面是输出文件夹名称。</span></span><br><span class="line">NanoPlot --summary summary.txt --loglength -o summary-plots-log-transformed</span><br><span class="line">NanoPlot -t 4 --fastq pass.fq.gz --plots hex dot -o nanoplot_out</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">详细参数设置可以在NanoPlot --<span class="built_in">help</span>中查看</span></span><br></pre></td></tr></table></figure><p>运行结束之后会生成summary-plots-log-transformed这个文件夹，我们可以用xftp工具查看里面的html结果文件，也可以挑取一些数据做数据质量统计表。</p><p>放一张原始测序数据读长分布图示意一下：</p><p><img src="https://www.shelven.com/tuchuang/20220617/5.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220617/5.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><a href="https://www.shelven.com/tuchuang/20220617/NanoPlot-report.html">点击这里查看用summary.txt生成的质控报告</a></p><p><a href="https://www.shelven.com/tuchuang/20220617/NanoPlot-report1.html">点击这里查看用pass.fq.gz生成的质控报告</a><strong>（推荐用这个）</strong></p><p>两种方法生成的质控报告略微有点差别，因为summary.txt文件中记录了所有序列，可以看到有部分序列质量在Q5-Q7之间；而pass.fg.gz生成的质控报告中，<strong>所有序列的质量都在Q7及以上</strong>。后续以分析pass.fq.gz文件生成的质控报告为准，对这个文件序列的长度进行过滤。</p><p>如果不需要图，只需要知道有多少条reads、reads平均长度、N50、N90这些数据做表格的话，还有一个比较实用的<strong>perl脚本</strong>，怎么使用就不赘述了，源代码放底下参考。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#/usr/bin/perl -w</span></span><br><span class="line"><span class="keyword">use</span> strict;</span><br><span class="line"><span class="keyword">use</span> warnings;</span><br><span class="line"></span><br><span class="line"><span class="comment">### *fastq.gz 数据统计 N50 N90 num_seqs sum_len min_len avg_len max_len </span></span><br><span class="line"><span class="comment">### usage: perl stat.fastq.gz.N50.N90.pl *.fastq.gz</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">my</span> $fastq_gz = $ARGV[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">open</span>(IN,<span class="string">&quot;gzip -dc $fastq_gz|&quot;</span>) <span class="keyword">or</span> <span class="keyword">die</span> (<span class="string">&quot;can not open $fastq_gz\n&quot;</span>);</span><br><span class="line"><span class="keyword">open</span>(OUT,<span class="string">&quot;&gt;$fastq_gz.stat&quot;</span>);</span><br><span class="line"><span class="keyword">print</span> OUT <span class="string">&quot;name num_seqs    sum_len min_len avg_len max_len N50 N90\n&quot;</span>;</span><br><span class="line"><span class="keyword">print</span> OUT <span class="string">&quot;$fastq_gz\t&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">my</span> ($len,$total,$num_seqs,$min_len,$max_len)=(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">my</span> @length_list;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(&lt;IN&gt;)&#123;</span><br><span class="line">    <span class="keyword">my</span> $title = $_;</span><br><span class="line">    <span class="keyword">my</span> $seq = &lt;IN&gt;;</span><br><span class="line">    <span class="keyword">my</span> $add = &lt;IN&gt;;</span><br><span class="line">    <span class="keyword">my</span> $quality = &lt;IN&gt;;</span><br><span class="line">    $seq =~ <span class="regexp">s/\r|\n|\r\n//mg</span>;</span><br><span class="line">    $len = <span class="keyword">length</span>($seq);</span><br><span class="line">    <span class="keyword">if</span>($len&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        $total += $len;</span><br><span class="line">        <span class="keyword">push</span> @length_list,$len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>($min_len == <span class="number">0</span>)&#123;$min_len = $len;&#125;<span class="keyword">elsif</span>($min_len &gt; $len)&#123;$min_len = $len;&#125;</span><br><span class="line">    <span class="keyword">if</span>($max_len == <span class="number">0</span>)&#123;$max_len = $len;&#125;<span class="keyword">elsif</span>($max_len &lt; $len)&#123;$max_len = $len;&#125; </span><br><span class="line">    $len=<span class="number">0</span>;</span><br><span class="line">    $num_seqs++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">my</span> $avg_len = $total/$num_seqs;</span><br><span class="line"><span class="keyword">print</span> OUT <span class="string">&quot;$num_seqs\t&quot;</span>;</span><br><span class="line"><span class="keyword">print</span> OUT <span class="string">&quot;$total\t&quot;</span>;</span><br><span class="line"><span class="keyword">print</span> OUT <span class="string">&quot;$min_len\t&quot;</span>;</span><br><span class="line"><span class="keyword">print</span> OUT <span class="string">&quot;$avg_len\t&quot;</span>;</span><br><span class="line"><span class="keyword">print</span> OUT <span class="string">&quot;$max_len\t&quot;</span>;</span><br><span class="line"></span><br><span class="line">@length_list=<span class="keyword">sort</span>&#123;$b&lt;=&gt;$a&#125; @length_list;</span><br><span class="line"></span><br><span class="line"><span class="keyword">my</span> ($count,$half)=(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">my</span> $j=<span class="number">0</span>;$j&lt;@length_list;$j++)&#123;</span><br><span class="line">    $count+=$length_list[$j];</span><br><span class="line">    <span class="keyword">if</span> (($count&gt;=$total/<span class="number">2</span>)&amp;&amp;($half==<span class="number">0</span>))&#123;</span><br><span class="line">        <span class="keyword">print</span> OUT <span class="string">&quot;$length_list[$j]\t&quot;</span>;</span><br><span class="line">        $half=$length_list[$j]</span><br><span class="line">    &#125;<span class="keyword">elsif</span> ($count&gt;=$total*<span class="number">0</span>.<span class="number">9</span>)&#123;</span><br><span class="line">        <span class="keyword">print</span> OUT <span class="string">&quot;$length_list[$j]\t\n&quot;</span>;</span><br><span class="line">        <span class="keyword">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="filtlong过滤数据"><a href="#filtlong过滤数据" class="headerlink" title="filtlong过滤数据"></a>filtlong过滤数据</h3><p>前面说过，二代测序是双端测序，三代测序是单端测序，两者过滤数据的要求不同。三代测序主要是过滤<strong>长度过短的序列和测序质量较低的序列</strong>。在basecalling中我们过滤了Q值小于7的序列，现在还要过滤read长度小于1000bp的序列。过滤后的序列可以直接用于后续的组装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装filtlong软件</span></span><br><span class="line">conda install -y filtlong</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置序列最短为1000bp，压缩结果文件到新文件中</span></span><br><span class="line">filtlong --min_length 1000 pass.fq.gz | gzip &gt; clean_filter.fq.gz</span><br></pre></td></tr></table></figure><p><img src="https://www.shelven.com/tuchuang/20220617/6.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220617/6.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>可以看到过滤了一部分数据，用过滤后的数据再跑一次NanoPlot</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NanoPlot -t 4 --fastq clean_filter.fq.gz --plots hex dot -o filt_nanoplot_out</span><br></pre></td></tr></table></figure><p>测序数据读长分布如下，可以看到已经没有1kb以下的reads了：</p><p><img src="https://www.shelven.com/tuchuang/20220617/8.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220617/8.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><a href="https://www.shelven.com/tuchuang/20220617/NanoPlot-report2.html">点击这里查看过滤后的质控报告</a></p><p>至此质控过滤流程结束，我们可以做一个下机数据质控统计表：</p><table><thead><tr><th>Type</th><th>Bases(bp)</th><th>Reads Number</th><th>Reads mean length(bp)</th><th>Reads N50 length(bp)</th></tr></thead><tbody><tr><td>Raw Reads</td><td>25,584,046,180.0</td><td>1,933,526.0</td><td>13,231.8</td><td>28,127.0</td></tr><tr><td>Filtered Reads</td><td>25,531,304,191.0</td><td>1,834,925.0</td><td>13,914.1</td><td>28,184.0</td></tr></tbody></table></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近拿到一个植物基因组的三代和二代测序数据，想通过以三代测序数据为主，二代测序数据为辅的方式学习一下如何拼接组装一个基因组。但是三代测序数据刚到手就懵了，与之前学习的转录组分析不一样，三代测序返回的几个文件不是单纯的fq文件，于是我又开始恶补了一些三代测序的基础知识，开坑写个三代基因组测序组装的系列笔记~&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="基因组三代测序分析" scheme="http://www.shelven.com/categories/%E5%9F%BA%E5%9B%A0%E7%BB%84%E4%B8%89%E4%BB%A3%E6%B5%8B%E5%BA%8F%E5%88%86%E6%9E%90/"/>
    
    
    <category term="nanoplot" scheme="http://www.shelven.com/tags/nanoplot/"/>
    
    <category term="filtlong" scheme="http://www.shelven.com/tags/filtlong/"/>
    
  </entry>
  
  <entry>
    <title>NCBI的BLAST+工具本地安装，本地建库和BLAST比对</title>
    <link href="http://www.shelven.com/2022/06/17/a.html"/>
    <id>http://www.shelven.com/2022/06/17/a.html</id>
    <published>2022-06-16T18:33:56.000Z</published>
    <updated>2022-12-03T16:10:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>接触过生物学的小伙伴对<a href="https://blast.ncbi.nlm.nih.gov/Blast.cgi">NCBI在线BLAST网页</a>一定不陌生，简单介绍一下这个网页的5种比对工具：blastn、blastp、blastx、tblastn和tblastx，以及如何进行本地建库和blast比对。</p><span id="more"></span><ul><li>blastn    用核苷酸序列检索核苷酸数据库</li><li>blastp    用蛋白质序列检索蛋白质数据库</li><li>blastx    核苷酸序列通过6种阅读框翻译不同蛋白序列后，检索蛋白数据库</li><li>tblastn    蛋白序列比对核酸库，核酸数据库通过6种开放阅读框翻译不同蛋白质</li><li>tblastx    核酸序列和核酸数据库都通过6种开放阅读框翻译后比对</li></ul><p>平常我们用的最多的就是blastn和blastp，进入网页，选择blast方式，然后贴上自己的quary序列，选择数据库，选择比对的物种，设置参数如E值，wordlength长度等等。但是NCBI网站的BLAST在线工具有个让人特别无语的缺点：<strong>国内访问速度巨慢</strong>！不仅仅是比对过程慢，一条序列还好，大批量数据比对就不要想了，有的时候网页都打不开一直转圈圈。因此本地化blast工具还是很有必要的。</p><p>好在NCBI很贴心地提供了blast+工具，我们安装好blast+工具和下载好数据库以后，就可以不依赖网页和NCBI地服务器，在本地服务器上运行了。</p><h2 id="1-安装blast"><a href="#1-安装blast" class="headerlink" title="1 安装blast+"></a>1 安装blast+</h2><div class="story post-story"><p>最新版blast+工具可以通过ftp方式获得，<a href="https://ftp.ncbi.nlm.nih.gov/blast/executables/blast+/LATEST/">点击这里</a></p><p>我是在集群账户下安装，集群机器都是linux操作系统的，因此我选择的最新linux版本</p><p><img src="https://www.shelven.com/tuchuang/20220616/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220616/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><strong>别忘了要连md5校验文件一起下载</strong>，谁都不知道下载过程中是否会出错，因此大的文件下载完以后都是需要验证文件完整性的！</p><p>将上面的ftp地址拼凑一下，网速好的话可以直接用wget下载，但是我这边服务器连NCBI网速实在太慢了，wget只有10Kb&#x2F;s的速度，甚至还会断开重连。看的我高血压都要犯了，无奈之下挂了个梯子，在自己电脑上下载好这两份文件，通过xftp传到了服务器上。</p><p>在服务器上首先校验文件完整性:</p><p><code>md5sum -c ncbi-blast-2.13.0+-x64-linux.tar.gz.md5</code></p><p>显示结果OK后，解压：</p><p><code>tar -zxvf ncbi-blast-2.13.0+-x64-linux.tar.gz</code></p><p>名字太长了，不方便以后找，顺便改个名就叫blast：</p><p><code>mv ncbi-blast-2.13.0+-x64-linux.tar.gz blast</code></p><p>然后是配置环境变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc       # 编辑环境变量文件</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在.bashrc文件最后一行加入如下内容（根据自己路径修改）</span></span><br><span class="line">export PATH=&quot;/public/home/wlxie/blast/bin:$PATH&quot;</span><br></pre></td></tr></table></figure><p>保存退出后重新source一下.bashrc文件，blast+工具就安装好了。</p></div><h2 id="2-下载nr-x2F-nt数据库"><a href="#2-下载nr-x2F-nt数据库" class="headerlink" title="2 下载nr&#x2F;nt数据库"></a>2 下载nr&#x2F;nt数据库</h2><div class="story post-story"><p>我们比对一般用的是NCBI的非冗余蛋白&#x2F;核酸数据库，有两种方法下载nr&#x2F;nt数据库：</p><ul><li><p>1.通过blast+工具自带的更新程序下载</p></li><li><p>2.通过aspera工具下载</p></li></ul><p>同样是网速的问题，如果用第一种方法下载，我们可以在~&#x2F;blast&#x2F;bin目录下找到如下的perl程序</p><p><img src="https://www.shelven.com/tuchuang/20220616/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220616/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>直接运行命令 <code>perl update_blastdb.pl nt</code></p><p>但是10几kb&#x2F;s的速度真的让人抓狂，所以我推荐第二种方法：用IBM公司开发的快速下载神器——aspera</p><h3 id="安装aspera"><a href="#安装aspera" class="headerlink" title="安装aspera"></a>安装aspera</h3><p>在我之前写的一篇博客里推荐过sra-tools工具中的prefetch，用来下载SRA数据中存放的高通量测序原始数据。prefetch软件就是默认通过aspera工具进行下载的。</p><p>如果之前没有安装过aspera，可以用conda直接安装，命令如下：</p><p><code>conda install -c hcc aspera-cli</code></p><p>这里注意下aspera-cli是aspera的命令行版本，各种不同版本的本质上下载都是调用ascp程序，并且需要<strong>openssh公钥认证</strong>，不同版本的aspera公钥文件存放的位置不同。因为我们是通过conda安装的aspera，aspera-cli公钥文件的位置在<strong>你的conda环境目录下的etc文件夹中</strong>，比如我的aspera-cli公钥文件在&#x2F;public&#x2F;home&#x2F;wlxie&#x2F;miniconda3&#x2F;envs&#x2F;biosoft&#x2F;etc</p><p>而且因为是conda安装的，我们不需要修改什么配置文件和依赖关系，还是挺省事的。</p><h3 id="用aspera下载数据库nr-x2F-nt"><a href="#用aspera下载数据库nr-x2F-nt" class="headerlink" title="用aspera下载数据库nr&#x2F;nt"></a>用aspera下载数据库nr&#x2F;nt</h3><p>nr&#x2F;nt数据库也可以通过ftp方式获得，<a href="https://ftp.ncbi.nlm.nih.gov/blast/db/FASTA/">点击这里查看ftp网址</a></p><p>为了方便找到下载到本地的数据库，先在家目录新建db&#x2F;blast文件夹，进入这个文件夹后，在当前目录下运行如下命令：</p><p><code>ascp -QT -i /public/home/wlxie/miniconda3/envs/biosoft/etc/asperaweb_id_dsa.openssh -k1 -l 500m anonftp@ftp.ncbi.nlm.nih.gov:/blast/db/FASTA/nt.gz ./</code></p><p>这里是其中一个nt数据库，nr数据库只要改一个字母就行了，两个数据库都要下载。</p><p>稍微解释下各参数的含义：</p><ul><li>-Q 用于自适应流量控制，磁盘限制所需；-T 是取消加密，否则有时候数据下载不了。两个参数是搭配一起使用的</li><li>-i 输入私钥文件，注意下载的ascp版本不一样文件位置也不一样</li><li>-k1 这里是加上了断点传续功能</li><li>-l 限制最大下载速度</li><li>后面一串是账户@ftp地址:路径。<strong>注意@和冒号</strong>。NCBI公共账号是<strong>anonftp</strong>，也就是你下载SRA数据库数据也可以用这个账号；EBI公共账号是<strong>era-fasp</strong></li><li>最后指定下载文件的路径，我用了当前路径</li></ul><p><img src="https://www.shelven.com/tuchuang/20220616/3.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220616/3.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>可以看到下载速度杠杠的，提升了不知道多少倍…下载大数据都可以用ascp命令。</p><p><strong>下载好之后同样别忘了校验md5文件，校验后gunzip直接解压到当前文件夹。</strong></p></div><h2 id="3-本地建库"><a href="#3-本地建库" class="headerlink" title="3 本地建库"></a>3 本地建库</h2><div class="story post-story"><p>解压完成以后我们可以看到这两个数据库总大小在980G</p><p><img src="https://www.shelven.com/tuchuang/20220616/5.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220616/5.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>现在还不能用这两个数据库，需要对这两个超大的数据文件建索引，也就是本地建库。</p><p>使用如下命令：</p><p><code>makeblastdb -in nt -dbtype nucl -input_type fasta -out nt</code></p><p><code>makeblastdb -in nr -dbtype prot -input_type fasta -out nr</code></p><ul><li>-in: 待格式化的序列文件</li><li>-dbtype: 数据类型，prot为蛋白序列，nucl为核酸序列</li><li>-input_type: 输入数据的类型，默认为fasta格式</li><li>-out: 自定义的数据库名称</li></ul><p><img src="https://www.shelven.com/tuchuang/20220616/7.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220616/7.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><img src="https://www.shelven.com/tuchuang/20220616/8.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220616/8.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>这一步需要非常长时间，在目录下能看到有文件生成并且没有报错就行了，同样的操作方法可以用<strong>自己的基因组数据建库</strong>。</p><p>这里有两条核苷酸序列可能有问题，序列录到了开头第一行，不过就只有两条序列应该不影响。nt库录入了0.8亿条序列，nr库录入了4.8亿条序列。</p></div><h2 id="4-创建blast全局配置文件"><a href="#4-创建blast全局配置文件" class="headerlink" title="4 创建blast全局配置文件"></a>4 创建blast全局配置文件</h2><div class="story post-story"><p>在家目录下创建blast全局配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">vim .ncbirc        <span class="comment"># 家目录下创建一个新文件.ncbirc，输入如下内容</span></span></span><br><span class="line"></span><br><span class="line">; Start the section for BLAST configuration</span><br><span class="line"></span><br><span class="line">[BLAST]</span><br><span class="line"></span><br><span class="line">; Specifies the path where BLAST databases are installed</span><br><span class="line"></span><br><span class="line">BLASTDB=/public/home/wlxie/db/blast</span><br><span class="line"></span><br><span class="line">; Specifies the data sources to use for automatic resolution</span><br><span class="line"></span><br><span class="line">; for sequence identifiers</span><br><span class="line"></span><br><span class="line">DATA_LOADERS=blastdb</span><br><span class="line"></span><br><span class="line">; Specifies the BLAST database to use resolve protein sequences</span><br><span class="line"></span><br><span class="line">BLASTDB_PROT_DATA_LOADER=/public/home/wlxie/db/blast/nr</span><br><span class="line"></span><br><span class="line">; Specifies the BLAST database to use resolve protein sequences</span><br><span class="line"></span><br><span class="line">BLASTDB_NUCL_DATA_LOADER=/public/home/wlxie/db/blast/nt</span><br><span class="line"></span><br><span class="line">BATCH_SIZE=10G</span><br><span class="line"></span><br><span class="line">; Windowmasker settings</span><br><span class="line"></span><br><span class="line">[WINDOW_MASKER]</span><br><span class="line"></span><br><span class="line">WINDOW_MASKER_PATH=/public/home/wlxie/db/blast/windowmasker</span><br><span class="line"></span><br><span class="line">; end of file</span><br></pre></td></tr></table></figure><p>以上设置中定义了blastn和blastp默认的地址，这样我们在比对数据库的时候可以直接输入数据库的名称而不用给出绝对路径，方便一点（这步不是必须的，可选）。</p></div><h2 id="5-运行blast程序"><a href="#5-运行blast程序" class="headerlink" title="5 运行blast程序"></a>5 运行blast程序</h2><div class="story post-story"><p>以上准备工作完成后，准备一段query序列试一下，我的query序列名称是gene.fna</p><p>运行blastn程序：</p><p><code>blastn -query gene.fna -out gene_blastn_nr.out -db nt -outfmt 6 -evalue 1e-5 -num_threads 10</code></p><ul><li>-query: 用来查询的输入序列</li><li>-db: 指定的数据库名称</li><li>-out: 自定义输出的结果文件，最好统一格式。我是基因名_比对方法_数据库.out，这样比较直观知道比对了什么，怎么比对的</li><li>-outfmt: blast结果的呈现形式，<strong>一般用6比较多</strong>，也就是m8格式，以制表符为分隔符，有部分信息会缺失。5是XML格式比较适合解析，7在6基础上加了表头。</li><li>-evalue: 限定E值</li><li>-num_threads: 指定多少个核运行blast程序</li></ul><p>还有其他参数比如就不一一介绍了，说明一下，一个序列的blast可以用上面的命令，多个序列的blast同样适用，把多个fasta格式的序列放进去即可。</p><p>当然，批量blast的结果需要限定匹配的结果数量，毕竟我们不可能几百上千个序列一一查看，可以指定参数-max_target_seqs 5限制每个序列的最大匹配数量，这个数值推荐是在5以上，5以下会有警告信息。</p><p>blast结果m8格式如下：</p><p><img src="https://www.shelven.com/tuchuang/20220616/9.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220616/9.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>一共12列，分别能获得如下信息：</p><blockquote><p>1、Query id：查询序列ID标识</p><p>2、Subject id：比对上的目标序列ID标识</p><p>3、% identity：序列比对的<strong>一致性</strong>百分比</p><p>4、alignment length：符合比对的比对区域的长度</p><p>5、mismatches：比对区域的错配数</p><p>6、gap openings：比对区域的gap数目</p><p>7、q. start：比对区域在查询序列(Query id)上的起始位点</p><p>8、q. end：比对区域在查询序列(Query id)上的终止位点</p><p>9、s. start：比对区域在目标序列(Subject id)上的起始位点</p><p>10、s. end：比对区域在目标序列(Subject id)上的终止位点</p><p>11、e-value：比对结果的期望值，解释是大概多少次随即比对才能出现一次这个score，Evalue越小，表明这种情况从概率上越不可能发生，那么发生了即说明这更有可能是真实的相似序列</p><p>12、bit score：比对结果的bit score值，越高越好</p></blockquote></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;接触过生物学的小伙伴对&lt;a href=&quot;https://blast.ncbi.nlm.nih.gov/Blast.cgi&quot;&gt;NCBI在线BLAST网页&lt;/a&gt;一定不陌生，简单介绍一下这个网页的5种比对工具：blastn、blastp、blastx、tblastn和tblastx，以及如何进行本地建库和blast比对。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="基因组三代测序分析" scheme="http://www.shelven.com/categories/%E5%9F%BA%E5%9B%A0%E7%BB%84%E4%B8%89%E4%BB%A3%E6%B5%8B%E5%BA%8F%E5%88%86%E6%9E%90/"/>
    
    
    <category term="BLAST+" scheme="http://www.shelven.com/tags/BLAST/"/>
    
    <category term="aspera" scheme="http://www.shelven.com/tags/aspera/"/>
    
  </entry>
  
  <entry>
    <title>perl语言学习笔记（1）</title>
    <link href="http://www.shelven.com/2022/06/16/a.html"/>
    <id>http://www.shelven.com/2022/06/16/a.html</id>
    <published>2022-06-15T16:07:31.000Z</published>
    <updated>2022-12-03T16:06:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在处理三代测序的下机数据，用到了一些挺好用的perl脚本，但是苦于没接触这种类型的编程语言，想根据情况改一些代码却看不懂实现方式&#x3D; &#x3D;</p><span id="more"></span><p>前面说学习perl可以只学怎么调用模块，马上啪啪打脸了，这货和python还是有点不一样的，还是抽空补补基础吧~现在做生信用的最多的就是R、python和perl，多掌握一门编程语言还是挺有必要的。记录一下自学的过程和笔记，自学视频来源是b站up主<a href="https://space.bilibili.com/338686099?spm_id_from=333.337.0.0">生信技能树-jimmy</a></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><div class="story post-story"><p>首先了解一下perl脚本的结构，以blast结果过滤的perl脚本为例，输入文件blast_m8.out是一个12列，分隔符为空格的文件：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/perl -w      # 选择解释器类型为perl，-w是运行错误时提供警告信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> IN,<span class="string">&quot;blast_m8.out&quot;</span>;     <span class="comment"># 打开文件，m8格式输出的blastout文件。每次只读一行</span></span><br><span class="line"><span class="keyword">while</span> (&lt;IN&gt;) &#123;      <span class="comment"># 大括号为程序块，每个程序块是一个独立的部分，执行相对独立的功能</span></span><br><span class="line">    <span class="keyword">chomp</span>;      <span class="comment"># 去掉读进来数据结尾的换行符\n（没有换行符则不起作用）</span></span><br><span class="line">    <span class="keyword">my</span> @line=<span class="keyword">split</span> <span class="regexp">/\s+/</span>,$_;        <span class="comment"># 以空白分割(\s是匹配任何空白符，+表示匹配任意多个),存入数组中</span></span><br><span class="line">    <span class="keyword">if</span> ($line[<span class="number">2</span>] &gt;=<span class="number">50</span> &amp;&amp; $line[<span class="number">3</span>] &gt;=<span class="number">100</span>) &#123;</span><br><span class="line">        <span class="keyword">print</span> <span class="string">&quot;$_\n&quot;</span>;       <span class="comment"># 将第三列identity值大于50，第四列序列长度大于100的blast结果输出</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">next</span>;       <span class="comment"># 否则进入下一个循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">close</span> IN;</span><br><span class="line"><span class="comment"># 这个脚本第四行的my也要注意下，一般是需要申明use strict;也就是使用严谨的方式，在这种方式下，任何变量都必须先定义，不使用my的话定义第一次出现的$和@运行会报错。初学可以不使用use strict。</span></span><br><span class="line"><span class="comment"># $_这个变量是使用非常多的，如果没有定义变量名称，则默认使用$_</span></span><br></pre></td></tr></table></figure><p>OK，格式与python不一样，以<strong>分号</strong>作为每一行结尾，基础语法类似但不完全一样，先从基础学起。</p></div><h2 id="1-标量数据"><a href="#1-标量数据" class="headerlink" title="1 标量数据"></a>1 标量数据</h2><div class="story post-story"><h3 id="标量数据特点"><a href="#标量数据特点" class="headerlink" title="标量数据特点"></a>标量数据特点</h3><ul><li>perl中最基本的数据类型</li><li>可以是数字、字母</li><li>无需定义类型（所有perl语言的数据都是双精度浮点型，<strong>不需要对数据类型进行定义</strong>，代价是消耗内存）</li><li>“单数为标量”</li></ul><h3 id="字符串运算"><a href="#字符串运算" class="headerlink" title="字符串运算"></a>字符串运算</h3><ul><li>字符串就是一连串字符组合，可以是字母数字标点等</li><li>对DNA序列处理本质上就是处理字符串</li><li>字符串可以为空</li><li>需要“引号”，尽量使用双引号</li><li>字符串连接“.”或者“x”  如 “hello” . “world”</li></ul><h3 id="标量变量"><a href="#标量变量" class="headerlink" title="标量变量"></a>标量变量</h3><p>标量变量用来动态存储标量值，以美元符号$表示（定义数组用@符号），<strong>和linux一样不能以数字开头</strong></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一个=表示赋值，两个==表示判断，这里和python是一样的</span></span><br><span class="line">$gene_num=<span class="number">3</span></span><br><span class="line">$gene_num=$gene_num+<span class="number">4</span></span><br><span class="line">$gene_num+=<span class="number">4</span>        <span class="comment"># 双目运算符，运算所需变量为两个运算符，这个简写是非常常用的</span></span><br><span class="line">$dna=<span class="string">&quot;ATCGGGTATCG&quot;</span></span><br><span class="line">$dna.=<span class="string">&quot;ATCGGGTCG&quot;</span>       <span class="comment"># 双目运算符同样可以用于字符串操作，得到标量变量为连接的字符串</span></span><br></pre></td></tr></table></figure></div><h2 id="2-数组和列表"><a href="#2-数组和列表" class="headerlink" title="2 数组和列表"></a>2 数组和列表</h2><div class="story post-story"><h3 id="数组构建"><a href="#数组构建" class="headerlink" title="数组构建"></a>数组构建</h3><p>列表（list）指标量的有序集合，数组（array）则是存储列表的变量</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@array=（<span class="number">1</span>,<span class="string">&quot;hello&quot;</span>,<span class="keyword">undef</span>,$dna,<span class="number">5</span>）;      <span class="comment"># 左边为数组，右边为列表，构建列表中间用逗号隔开</span></span><br><span class="line">$array[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">$array[<span class="number">1</span>]=<span class="string">&quot;hello&quot;</span>       <span class="comment"># 注意下标数字从0开始，0表示第一个元素</span></span><br><span class="line">数组的最后一个元素角标$#array，因此数组元素个数=$#array+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">@number=(<span class="number">1</span>..<span class="number">100</span>)        <span class="comment"># 范围操作符(..)每次加一</span></span><br><span class="line">@string=<span class="string">qw (fred barney betty wilma dino)</span>       <span class="comment"># qw操作符可以省略逗号</span></span><br></pre></td></tr></table></figure><h3 id="split和join函数"><a href="#split和join函数" class="headerlink" title="split和join函数"></a>split和join函数</h3><ul><li>split将字符串根据固定的分隔符进行切割，切割后得到一个数组</li><li>join与split相反，将数组连接成一个标量</li></ul><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/perl</span></span><br><span class="line"></span><br><span class="line">$scalar=<span class="string">&quot;a:bcd:123:de&quot;</span>;</span><br><span class="line">@array=<span class="keyword">split</span> <span class="regexp">/:/</span>,$scalar;       <span class="comment"># 以冒号作为分隔符分割</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;@array\n&quot;</span></span><br><span class="line"></span><br><span class="line">$new_scalar=<span class="keyword">join</span> <span class="string">&quot;\t&quot;</span>,@array;       <span class="comment"># 以制表符作为分割符，好处是excel里打开每个元素在不同单元格</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;$new_scalar\n&quot;</span></span><br></pre></td></tr></table></figure><h3 id="pop和push函数"><a href="#pop和push函数" class="headerlink" title="pop和push函数"></a>pop和push函数</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/perl</span></span><br><span class="line">@number=(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">$value=<span class="keyword">pop</span> @number;     <span class="comment"># pop提取数组的最后一个元素</span></span><br><span class="line"><span class="keyword">push</span> @number,<span class="number">6</span>;     <span class="comment"># push添加一个元素到数组的末尾</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;$value\n@number\n&quot;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://www.shelven.com/tuchuang/20220615/01.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220615/01.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="shift和unshift函数"><a href="#shift和unshift函数" class="headerlink" title="shift和unshift函数"></a>shift和unshift函数</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/perl</span></span><br><span class="line">@number=(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">$value=<span class="keyword">shift</span> @number;       <span class="comment"># shift提取数组第一个元素</span></span><br><span class="line"><span class="keyword">unshift</span> @number,<span class="number">10</span>;     <span class="comment"># unshift添加一个元素到数组的开头</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;$value\n@number\n&quot;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://www.shelven.com/tuchuang/20220615/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220615/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>一般来说pop和shift用的比较多，一个提取数组末尾元素，一个提取数组开头元素。</p><p>因为我们用perl处理的往往是矩阵文件，第一行是ID信息，我们往往是读入一行数据，去掉换行符，存储为标量，分割数组。这个时候就要用shift函数，将ID提取出来，这样呢后面都是<strong>同一种类型的数据</strong>，方便我们操作，也就是底下这个框架：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/perl</span></span><br><span class="line"><span class="keyword">while</span> (&lt;IN&gt;) &#123;</span><br><span class="line">    <span class="keyword">chomp</span>;</span><br><span class="line">    <span class="keyword">my</span> @line=<span class="keyword">split</span> <span class="regexp">/\s+/</span>,$_;</span><br><span class="line">    <span class="keyword">my</span> @id=<span class="keyword">shift</span> @line；</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot;$id\n&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sort和reverse函数"><a href="#sort和reverse函数" class="headerlink" title="sort和reverse函数"></a>sort和reverse函数</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/perl</span></span><br><span class="line">@number=(<span class="number">1</span>..<span class="number">10</span>);</span><br><span class="line">@number_sort=<span class="keyword">sort</span> @number;      <span class="comment"># sort函数使数组按照ASCII码大小排序</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;@number_sort\n&quot;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://www.shelven.com/tuchuang/20220615/3.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220615/3.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>可以看到10在1的后面，因为sort函数是以<strong>ASCII码大小</strong>进行排序的。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/perl</span></span><br><span class="line">$dna=<span class="string">&quot;ATCGCGTAGCATCGATGCTGATCATGC&quot;</span>;</span><br><span class="line">$dna_reverse=<span class="keyword">reverse</span> $dna;      <span class="comment"># reverse函数可以使数组或者字符串反转</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;$dna_reverse\n&quot;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://www.shelven.com/tuchuang/20220615/4.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220615/4.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>reverse函数在做DNA反向互补配对的时候能用到。</p><h3 id="foreach遍历数组"><a href="#foreach遍历数组" class="headerlink" title="foreach遍历数组"></a>foreach遍历数组</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/perl</span></span><br><span class="line">@number=(<span class="number">1</span>..<span class="number">10</span>);</span><br><span class="line"><span class="keyword">foreach</span> $num (@number) &#123;        <span class="comment"># 遍历数组中的值依迭代</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot;$num\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以省略一部分内容</span></span><br><span class="line"><span class="comment">#!/bin/perl</span></span><br><span class="line">@number=(<span class="number">1</span>..<span class="number">10</span>);</span><br><span class="line"><span class="keyword">foreach</span> (@number) &#123;     <span class="comment"># 省略了$num，存储到默认的$_中</span></span><br><span class="line">    <span class="keyword">print</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在处理三代测序的下机数据，用到了一些挺好用的perl脚本，但是苦于没接触这种类型的编程语言，想根据情况改一些代码却看不懂实现方式&amp;#x3D; &amp;#x3D;&lt;/p&gt;</summary>
    
    
    
    <category term="编程自学" scheme="http://www.shelven.com/categories/%E7%BC%96%E7%A8%8B%E8%87%AA%E5%AD%A6/"/>
    
    
    <category term="perl" scheme="http://www.shelven.com/tags/perl/"/>
    
  </entry>
  
</feed>
