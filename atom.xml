<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>我的小破站</title>
  
  
  <link href="http://www.shelven.com/atom.xml" rel="self"/>
  
  <link href="http://www.shelven.com/"/>
  <updated>2022-09-08T19:35:44.272Z</updated>
  <id>http://www.shelven.com/</id>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深度学习——语音合成tts笔记（下）</title>
    <link href="http://www.shelven.com/2022/09/09/a.html"/>
    <id>http://www.shelven.com/2022/09/09/a.html</id>
    <published>2022-09-08T19:32:17.000Z</published>
    <updated>2022-09-08T19:35:44.272Z</updated>
    
    <content type="html"><![CDATA[<p>（接上篇博客）做完数据集，我们手里现在有训练集（train set）和测试集（test set）音频文件，以及对应的拼音文本，接下来就可以跑Tacotron2来训练模型了。</p><h2 id="2-训练模型-amp-合成语音"><a href="#2-训练模型-amp-合成语音" class="headerlink" title="2. 训练模型 &amp; 合成语音"></a>2. 训练模型 &amp; 合成语音</h2><div class="story post-story"><p><a href="https://github.com/NVIDIA/tacotron2">Tacotron2项目地址点击这里</a></p><p><a href="https://github.com/jik876/hifi-gan">HiFi-GAN项目地址点击这里</a></p><p>本篇博客训练模型&amp;合成语音基于以上两个开源项目，再次感谢原作者！</p><h3 id="2-1-Tacotron2简介"><a href="#2-1-Tacotron2简介" class="headerlink" title="2.1 Tacotron2简介"></a>2.1 Tacotron2简介</h3><p>简单讲一讲Tacotron2，它是由google推出的从文本中合成语音的神经网络结构，也就是一个语音合成（Text To Speech，TTS）框架，可以实现端到端的语音合成。Tacotron2与其前代Tacotron类似，比较重要的一个区别是在编码器模块中引入了一个双向LSTM层和卷积层，相比原来的CBHG堆叠结构和GRU循环层更为简洁。</p><p>模型主要由两部分组成：</p><ul><li><ol><li>声谱预测网络：特征预测网络，包含一个编码器和一个引入注意力机制（attention）的解码器，作用是将输入字符序列预测为梅尔频谱的帧序列。</li></ol></li><li><ol start="2"><li>声码器（vocoder）：将预测的梅尔频谱帧序列转换产生时域波形样本，算是WaveNet的修订版。</li></ol></li></ul><p>原项目中的声码器我们暂时不用（<strong>上面地址提供的Tacotron 2就是没有wavenet的版本</strong>），因为有更好的工具HiFi-GAN。</p><p>代码实现详解有很多博客可以参考（<a href="https://blog.csdn.net/whjkm/article/details/89321954#commentBox">(16条消息) Tacotron2 论文 + 代码详解_HJ_彼岸的博客-CSDN博客_tacotron2</a>），<strong>这里只要知道我们是用Tacotron2生成梅尔频谱，在此基础上结合我们输入的字符序列（也就是对应的拼音文本）训练模型。</strong></p><p><u>特别注意一点</u>：Tacotron 2是基于tensorflow1.5版本运行的，如果是自己电脑上配置环境的话，<strong>务必将python版本降到3.7以下！</strong>否则将会无法安装tensorflow1.5，除了tensorflow有硬性版本要求之外，其他依赖都可以安装最新版本——<strong>反复配置环境治好了我的精神内耗</strong></p><p>如果你不想和我一样配置好几天环境的话，我推荐最好使用google colab，一键解决环境问题，下面会说到。</p><h3 id="2-2-HiFi-GAN简介"><a href="#2-2-HiFi-GAN简介" class="headerlink" title="2.2 HiFi-GAN简介"></a>2.2 HiFi-GAN简介</h3><p>简单说下，<strong>声码器的作用就是将梅尔频谱转换成语音信号</strong>，和上面是对应的。</p><p>为什么我们没有用上面Tacotron2的声码器呢，主要原因就是现在有很多更优秀的声码器供我们选择。</p><p>早期比较有名的声码器WaveNet，它是一种自回归卷积神经网络，合成的效果非常好可以说和人类发声非常相似，但有个致命的缺点——合成速度太慢。直到2020年项目作者开发了这套基于GAN（生成式对抗网络）的神经网络声码器，从作者的论文里可以找到，HiFi-GAN在GPU上可以以比实时速度快167.9倍的速度生成22.05 kHz的语音，在CPU上可以以比自回归模型快13.4倍的速度生成语音，这就是它的牛逼之处。</p><p>HiFi-GAN主要有一个生成器和两个判别器，具体结构就不说了，知道一下生成器和两个判别器是通过<strong>对抗学习</strong>的方法训练的，新增加了<strong>两个损失函数</strong>来提高训练的稳定性和提高模型的性能。有能力的小伙伴可以看原论文（HiFi-GAN: Generative Adversarial Networks for Efficient and High Fidelity Speech Synthesis）了解详情。</p><p>需要注意一下作者使用VCTK数据集进行实验，测试了3个模型（V1、V2和V3），简单来说V1是最优模型，作者发布的预训练模型以及相应的配置文件都是以V1模型为基础的。我在这篇博客使用的HiFi-GAN模型<strong>g_02500000</strong>就是作者的预训练模型，配置文件为<strong>config.json</strong>。</p><blockquote><p>HiFi-GAN预训练模型与配置文件下载地址：</p><p><a href="https://drive.google.com/drive/folders/1YuOoV3lO2-Hhn1F2HJ2aQ4S0LC1JdKLd">UNIVERSAL_V1 - Google 云端硬盘</a></p></blockquote><h3 id="2-2-注册谷歌colab和谷歌云盘"><a href="#2-2-注册谷歌colab和谷歌云盘" class="headerlink" title="2.2 注册谷歌colab和谷歌云盘"></a>2.2 注册谷歌colab和谷歌云盘</h3><p>训练模型是一件非常消耗算力的过程，因为涉及到图形处理，我们要用GPU进行加速。我的笔记本GPU非常拉跨，跑模型立马爆显存，因此我个人比较推荐白嫖谷歌colab上面的免费专业级GPU（Nvidia K80），免费用户只能用这一种GPU，至少比我的笔记本好多了。</p><p>需要注意下colab<strong>最大连接时长是12小时</strong>，12小时后会强行关闭GPU连接，因此需要注意下你是什么时候开始用GPU跑模型的，并且及时保存数据。关闭后要等待24小时才可以继续使用GPU，所以<strong>理论上可以用三个号不间断白嫖GPU资源</strong><del>（我特地申请了4个谷歌号）</del>，<strong>你只需要偶尔切换屏幕看下是否有谷歌的人机验证就行</strong>。</p><p>这里为什么还推荐谷歌云盘呢，是因为谷歌云盘可以挂载到colab上，这样调用文件就非常方便，及时保存不用担心数据丢失。谷歌云盘提供15GB的免费空间，如果保存模型比较频繁的话可能不够用，但是我们可以申请无限量的团队盘（<strong>共享云端硬盘</strong>）<del>薅羊毛必备</del>。</p><p><img src="https://www.shelven.com/tuchuang/20220909/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220909/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="2-3-使用colab训练模型-amp-合成语音"><a href="#2-3-使用colab训练模型-amp-合成语音" class="headerlink" title="2.3 使用colab训练模型 &amp; 合成语音"></a>2.3 使用colab训练模型 &amp; 合成语音</h3><p>我使用的colab笔记文件因为时间久远已经找不到出处了（后续如果找到会标注出来，向原作者致谢！），为了跑中文语音模型，自己也修改了很多参数和步骤，一一解释过于麻烦了….感兴趣的小伙伴可以看笔记文件。具体操作流程在底下的视频（<a href="https://www.bilibili.com/video/BV1TG411b7zR">或者点击此处看我的B站视频</a>）。</p><div class="video"><video controls preload><source src='https://www.shelven.com/tuchuang/20220909/805849354-1-80.flv' type='video/mp4'>Your browser does not support the video tag.</video></div><blockquote><p>所有工程文件和资源如下：</p><p>Tacotron2+HiFiGAN打包 链接：<a href="https://pan.baidu.com/s/1ngCUvifQM6ETwuG-NFQeGA">https://pan.baidu.com/s/1ngCUvifQM6ETwuG-NFQeGA</a>  提取码：z6h3  </p><p>400条派蒙语音测试集 链接：<a href="https://pan.baidu.com/s/1g0C0Ck4P_BxdTgMirKRc-g">https://pan.baidu.com/s/1g0C0Ck4P_BxdTgMirKRc-g</a>  提取码：5ew1  </p><p>1800条派蒙语音训练集 链接：<a href="https://pan.baidu.com/s/1IDA4lppAJGHnophQAwkxNg">https://pan.baidu.com/s/1IDA4lppAJGHnophQAwkxNg</a>  提取码：f2xk </p></blockquote><p>需要提及一点，colab在2022年8月1号之后不再支持tensorflow1.5，请教大佬之后我将Tacotron2项目下超参数配置hparams.py改成如下即可正常运行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> text <span class="keyword">import</span> symbols</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hparams</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line">    <span class="comment">################################</span></span><br><span class="line">    <span class="comment"># Experiment Parameters        #</span></span><br><span class="line">    <span class="comment">################################</span></span><br><span class="line">    epochs = <span class="number">3</span>  <span class="comment">#500</span></span><br><span class="line">    iters_per_checkpoint = <span class="number">1000</span></span><br><span class="line">    seed = <span class="number">1234</span></span><br><span class="line">    dynamic_loss_scaling = <span class="literal">True</span></span><br><span class="line">    fp16_run = <span class="literal">False</span></span><br><span class="line">    distributed_run = <span class="literal">False</span></span><br><span class="line">    dist_backend = <span class="string">&quot;nccl&quot;</span></span><br><span class="line">    dist_url = <span class="string">&quot;tcp://localhost:54321&quot;</span></span><br><span class="line">    cudnn_enabled = <span class="literal">True</span></span><br><span class="line">    cudnn_benchmark = <span class="literal">True</span></span><br><span class="line">    ignore_layers = [<span class="string">&#x27;embedding.weight&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">################################</span></span><br><span class="line">    <span class="comment"># Data Parameters             #</span></span><br><span class="line">    <span class="comment">################################</span></span><br><span class="line">    load_mel_from_disk = <span class="literal">False</span>  <span class="comment">#实际上是区别用 numpy读wav ，还是用scipy读wav</span></span><br><span class="line">    training_files = <span class="string">&#x27;filelists/zh_audio_text_train_filelist.txt&#x27;</span></span><br><span class="line">    validation_files = <span class="string">&#x27;filelists/zh_audio_text_val_filelist.txt&#x27;</span></span><br><span class="line">    text_cleaners = [<span class="string">&#x27;english_cleaners&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">################################</span></span><br><span class="line">    <span class="comment"># Audio Parameters             #</span></span><br><span class="line">    <span class="comment">################################</span></span><br><span class="line">    max_wav_value = <span class="number">32768.0</span></span><br><span class="line">    sampling_rate = <span class="number">22050</span>   <span class="comment">#22050</span></span><br><span class="line">    filter_length = <span class="number">1024</span></span><br><span class="line">    hop_length = <span class="number">256</span></span><br><span class="line">    win_length = <span class="number">1024</span></span><br><span class="line">    n_mel_channels = <span class="number">80</span></span><br><span class="line">    mel_fmin = <span class="number">0.0</span></span><br><span class="line">    mel_fmax = <span class="number">8000.0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">################################</span></span><br><span class="line">    <span class="comment"># Model Parameters             #</span></span><br><span class="line">    <span class="comment">################################</span></span><br><span class="line">    n_symbols = <span class="built_in">len</span>(symbols)</span><br><span class="line">    symbols_embedding_dim = <span class="number">512</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Encoder parameters</span></span><br><span class="line">    encoder_kernel_size = <span class="number">5</span></span><br><span class="line">    encoder_n_convolutions = <span class="number">3</span></span><br><span class="line">    encoder_embedding_dim = <span class="number">512</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Decoder parameters</span></span><br><span class="line">    n_frames_per_step = <span class="number">1</span>  <span class="comment"># currently only 1 is supported</span></span><br><span class="line">    decoder_rnn_dim = <span class="number">1024</span></span><br><span class="line">    prenet_dim = <span class="number">256</span></span><br><span class="line">    max_decoder_steps = <span class="number">1000</span></span><br><span class="line">    gate_threshold = <span class="number">0.5</span></span><br><span class="line">    p_attention_dropout = <span class="number">0.1</span></span><br><span class="line">    p_decoder_dropout = <span class="number">0.1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Attention parameters</span></span><br><span class="line">    attention_rnn_dim = <span class="number">1024</span></span><br><span class="line">    attention_dim = <span class="number">128</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Location Layer parameters</span></span><br><span class="line">    attention_location_n_filters = <span class="number">32</span></span><br><span class="line">    attention_location_kernel_size = <span class="number">31</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Mel-post processing network parameters</span></span><br><span class="line">    postnet_embedding_dim = <span class="number">512</span></span><br><span class="line">    postnet_kernel_size = <span class="number">5</span></span><br><span class="line">    postnet_n_convolutions = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">################################</span></span><br><span class="line">    <span class="comment"># Optimization Hyperparameters #</span></span><br><span class="line">    <span class="comment">################################</span></span><br><span class="line">    use_saved_learning_rate = <span class="literal">False</span></span><br><span class="line">    learning_rate = <span class="number">1e-3</span></span><br><span class="line">    weight_decay = <span class="number">1e-6</span></span><br><span class="line">    grad_clip_thresh = <span class="number">1.0</span></span><br><span class="line">    batch_size = <span class="number">2</span>  <span class="comment">#64</span></span><br><span class="line">    mask_padding = <span class="literal">True</span>  <span class="comment"># set model&#x27;s padded outputs to padded values</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_hparams</span>(<span class="params">hparams_string=<span class="literal">None</span>, verbose=<span class="literal">False</span></span>):</span><br><span class="line">    <span class="keyword">return</span> hparams</span><br></pre></td></tr></table></figure><h3 id="2-4-注意事项"><a href="#2-4-注意事项" class="headerlink" title="2.4 注意事项"></a>2.4 注意事项</h3><ul><li><ol><li>训练的epoch不是越多越好，我个人经验epoch 超过400会发生<strong>过拟合</strong>，测试集loss会越来越大，当然这和数据集有着密切的关系。过拟合具体表现为合成语音有部分字无法发音。</li></ol></li><li><ol start="2"><li>每个epoch自动保存模型且会覆盖谷歌云盘的原文件，因此务必要<strong>隔一段时间保存到本地</strong>，以免错过最佳模型（或者你改代码，比如50 epoch保存一次）。</li></ol></li><li><ol start="3"><li>对于文本的处理，需要参考Tacotron 2项目下的text文件夹中的四个文件cleaners.py、cmudict.py、numbers.py和symbols.py，我是进行了最简单的设置，可以根据自己需要更改。</li></ol></li><li><ol start="4"><li>如果你原封不动用的我的工程文件，想在本地运行合成语音的推理程序，<strong>务必将cleaners选择english_cleaner</strong><del>（否则会出现古神的低语）</del>。</li></ol></li><li><ol start="5"><li>如果你是自己训练模型，个人认为筛选数据集非常重要，尽量把语气词和背景噪音去掉，否则效果会很差。</li></ol></li><li><ol start="6"><li>训练模型的参数可以根据GPU自行调整，batch_size是影响训练速度最大的因素，当你不确定显存性能如何，请务必确保运行一段时间后显存没有炸（<strong>我就是运行以后直接睡觉了，醒来发现显存在运行半小时的时候炸了，我心态也炸了</strong>）</li></ol></li></ul><p>其实这个模型效果仍然不是很让我满意，有电音的问题可以用HiFi-GAN再训练过滤一下，我是直接用的官方预训练模型，因此效果会差一点。由于现在开学了要忙着搞开题，最近也没时间再优化模型了，以后有想法会继续补充。</p><p>我自己有考虑过将模型传到服务器，用服务器cpu运行推理，摆脱colab的限制，但是服务器不堪重负…一运行推理运存就炸…github上有不少前人做过纯cpu推理的GUI（<a href="https://github.com/luoyily/MoeTTS">比如MoeTTS</a>），亲测可行。</p><p>哦对了，我在做这个项目的时候，发现已经有人<strong>基于VITS</strong>做了同个游戏的端到端语音合成，甚至开发公布了API…不得不感慨这些大佬真的用心了，有API就意味着有更多的使用方式。我搭了个顺风车，通过搭建QQ机器人，写了个原神语音合成插件，<strong>效果是可以指定原神任何角色合成任意想说的语音并且发在QQ群里</strong>（没有什么技术含量，内行看个笑话），有空尽量更新出来吧！</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;（接上篇博客）做完数据集，我们手里现在有训练集（train set）和测试集（test set）音频文件，以及对应的拼音文本，接下来就可以跑Tacotron2来训练模型了。&lt;/p&gt;
&lt;h2 id=&quot;2-训练模型-amp-合成语音&quot;&gt;&lt;a href=&quot;#2-训练模型-amp-</summary>
      
    
    
    
    <category term="深度学习" scheme="http://www.shelven.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="google colab" scheme="http://www.shelven.com/tags/google-colab/"/>
    
    <category term="Tacotron2" scheme="http://www.shelven.com/tags/Tacotron2/"/>
    
    <category term="HiFiGAN" scheme="http://www.shelven.com/tags/HiFiGAN/"/>
    
  </entry>
  
  <entry>
    <title>深度学习——语音合成tts笔记（上）</title>
    <link href="http://www.shelven.com/2022/09/08/a.html"/>
    <id>http://www.shelven.com/2022/09/08/a.html</id>
    <published>2022-09-07T19:15:04.000Z</published>
    <updated>2022-09-07T19:23:17.251Z</updated>
    
    <content type="html"><![CDATA[<p>两个月的暑假已经结束了，假期里自学了一点深度学习的内容，很多地方还是一知半解的，这里稍微记录一下。之前刷到一个很有意思的语音合成视频，抱着试试看的心态想自己做一个模型，于是给自己挖了一个大坑……涉及到深度学习的知识我还需要慢慢学，因此本篇博客重点还是记录下自己的踩坑操作<del>原理部分以后搞明白了再更新</del>。</p><p>总的来说，我通过拆包游戏客户端获得5.6万条语音文件，通过github上的一个声纹识别项目分离其中一个角色的语音文件。接着用百度的语音识别API将语音识别为文本后，人工校正一遍文本，然后转换为拼音+音标，以此制作语音数据训练集和测试集。基于开源项目Tacotron2训练角色语音模型，经历400 epoch后初步训练成型，最后基于HiFiGAN合成语音。整个后半段流程是在google colab上完成的，为了完成模型训练我申请了4个谷歌账号…不得不说<strong>白嫖的GPU真香~</strong></p><h2 id="1-制作数据集"><a href="#1-制作数据集" class="headerlink" title="1. 制作数据集"></a>1. 制作数据集</h2><div class="story post-story"><p>可以说整个项目大部分时间花费在整理数据集上，根据我自己的经验，数据集的语音长度在2秒-10秒之间效果最好，数量大约在2000条左右（为了涵盖尽可能多的汉字发音）。需要注意一点，不管拆包的原语音采样率如何，<strong>都要统一重采样到22050 hz</strong>，这是Tacotron2训练模型的要求。</p><h3 id="1-1-Extractor2-5-vgmstream-win拆包"><a href="#1-1-Extractor2-5-vgmstream-win拆包" class="headerlink" title="1.1 Extractor2.5 + vgmstream-win拆包"></a>1.1 Extractor2.5 + vgmstream-win拆包</h3><p>首先是这款国内游戏的拆包，所有角色的语音文件都在目录D:\Genshin Impact\Genshin Impact Game\YuanShen_Data\StreamingAssets\Audio\GeneratedSoundBanks\Windows\Chinese下，我们使用软件Extractor2.5进行音频文件拆包。</p><p>Extractor2.5是个非常好用的游戏解包工具，我们将所有pck源文件所在目录输进去（可以批量选中文件），确定输出目录，点击开始即可。</p><p><img src="https://www.shelven.com/tuchuang/20220908/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220908/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>运行结束之后可以看到这个游戏拆包有56958条语音文件…点击左下角反选，全部解压到自己的文件夹中。</p><p><img src="https://www.shelven.com/tuchuang/20220908/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220908/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>但是你会发现解压出来的wav文件无法打开，需要使用vgmstream进行解密和转码<a href="https://github.com/vgmstream/vgmstream/">（项目地址戳这里）</a>。</p><p>可以看到vgmstream-win文件夹只有一个可执行程序test.exe，其他都是dll库文件。</p><p><img src="https://www.shelven.com/tuchuang/20220908/3.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220908/3.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>这个test.exe是不能直接运行的，需要把程序拖到刚才拆包的语音文件上，但是几万条语音我们不可能一个个拖过去，因此我们<strong>在语音的文件夹下，</strong>写一个如下的批处理文件（命名为批处理.bat），运行批处理就可以了。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="keyword">for</span> /<span class="built_in">r</span> %%i <span class="keyword">in</span> (*.wav) <span class="keyword">do</span> (</span><br><span class="line">        <span class="string">&quot;D:\zhuomian\vgmstream-win\test.exe&quot;</span> <span class="string">&quot;%%~nxi&quot;</span>    <span class="comment">#路径改成你自己的，注意路径不能有中文</span></span><br><span class="line">)</span><br><span class="line">pause</span><br></pre></td></tr></table></figure><p>运行后生成的wav.wav文件就可以正常播放了，所有音频采样率均为48000Hz（采样率很重要，贯穿整个项目）。</p><p><img src="https://www.shelven.com/tuchuang/20220908/4.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220908/4.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="1-2-基于Tensorflow的声纹识别"><a href="#1-2-基于Tensorflow的声纹识别" class="headerlink" title="1.2 基于Tensorflow的声纹识别"></a>1.2 基于Tensorflow的声纹识别</h3><p>这部分内容来源于github（<a href="https://github.com/yeyupiaoling/VoiceprintRecognition-Tensorflow">项目地址戳这里</a>），作者基于tensorflow做了个声纹识别模型，通过把语音数据转换短时傅里叶变换的幅度谱，使用librosa计算音频的特征，以此来训练、评估模型。因为我只用到了对比部分，因此我下载了作者预训练的模型，以及对声纹对比文件<strong>infer_contrast.py</strong>做了修改。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> utils.reader <span class="keyword">import</span> load_audio</span><br><span class="line"><span class="keyword">from</span> utils.utility <span class="keyword">import</span> add_arguments, print_arguments</span><br><span class="line"><span class="keyword">import</span> os,shutil</span><br><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"></span><br><span class="line">os.environ[<span class="string">&#x27;TF_CPP_MIN_LOG_LEVEL&#x27;</span>]=<span class="string">&#x27;2&#x27;</span></span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser(description=__doc__)</span><br><span class="line">add_arg = functools.partial(add_arguments, argparser=parser)</span><br><span class="line">add_arg(<span class="string">&#x27;audio_path1&#x27;</span>,      <span class="built_in">str</span>,    <span class="string">&#x27;audio_db/Paimon.wav&#x27;</span>,          <span class="string">&#x27;标准的派蒙音频&#x27;</span>)   <span class="comment"># 自己准备的标准音频，下面两个也是</span></span><br><span class="line">add_arg(<span class="string">&#x27;audio_path2&#x27;</span>,      <span class="built_in">str</span>,    <span class="string">&#x27;audio_db/Klee.wav&#x27;</span>,          <span class="string">&#x27;标准的可莉音频&#x27;</span>)</span><br><span class="line">add_arg(<span class="string">&#x27;audio_path3&#x27;</span>,      <span class="built_in">str</span>,    <span class="string">&#x27;audio_db/Kokomi.wav&#x27;</span>,          <span class="string">&#x27;标准的心海音频&#x27;</span>)</span><br><span class="line">add_arg(<span class="string">&#x27;input_shape&#x27;</span>,      <span class="built_in">str</span>,    <span class="string">&#x27;(257, 257, 1)&#x27;</span>,          <span class="string">&#x27;数据输入的形状&#x27;</span>)</span><br><span class="line">add_arg(<span class="string">&#x27;threshold&#x27;</span>,        <span class="built_in">float</span>,   <span class="number">0.8</span>,                     <span class="string">&#x27;判断是否为同一个人的阈值&#x27;</span>)</span><br><span class="line">add_arg(<span class="string">&#x27;model_path&#x27;</span>,       <span class="built_in">str</span>,    <span class="string">&#x27;models1/infer_model.h5&#x27;</span>,  <span class="string">&#x27;预测模型的路径&#x27;</span>)    <span class="comment"># 作者的预训练模型</span></span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载模型</span></span><br><span class="line">model = tf.keras.models.load_model(args.model_path,<span class="built_in">compile</span>=<span class="literal">False</span>)</span><br><span class="line">model = tf.keras.models.Model(inputs=model.<span class="built_in">input</span>, outputs=model.get_layer(<span class="string">&#x27;batch_normalization&#x27;</span>).output)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据输入的形状</span></span><br><span class="line">input_shape = <span class="built_in">eval</span>(args.input_shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测音频</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">infer</span>(<span class="params">audio_path</span>):</span><br><span class="line">    data = load_audio(audio_path, mode=<span class="string">&#x27;test&#x27;</span>, spec_len=input_shape[<span class="number">1</span>])</span><br><span class="line">    data = data[np.newaxis, :]</span><br><span class="line">    feature = model.predict(data)</span><br><span class="line">    <span class="keyword">return</span> feature</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 预测的两个音频文件</span></span><br><span class="line">    feature1 = infer(args.audio_path1)[<span class="number">0</span>]</span><br><span class="line">    feature2 = infer(args.audio_path2)[<span class="number">0</span>]</span><br><span class="line">    feature3 = infer(args.audio_path3)[<span class="number">0</span>]</span><br><span class="line">    datapath = <span class="string">&quot;./test2&quot;</span>        <span class="comment">#上传到集群的解包音频文件位置</span></span><br><span class="line">    dirs = os.listdir(datapath)</span><br><span class="line">    <span class="keyword">for</span> audio <span class="keyword">in</span> dirs:</span><br><span class="line">        personx = <span class="string">&#x27;test2/%s&#x27;</span> % (audio)</span><br><span class="line">        featurex = infer(personx)[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 对角余弦值</span></span><br><span class="line">        dist1 = np.dot(feature1, featurex) / (np.linalg.norm(feature1) * np.linalg.norm(featurex))</span><br><span class="line">        <span class="keyword">if</span> dist1 &gt; args.threshold:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;%s 符合派蒙模型，相似度为：%f&quot;</span> % (personx, dist1))</span><br><span class="line">            shutil.move(<span class="string">&quot;./test2/%s&quot;</span> % (audio),<span class="string">&quot;./dataset/Paimon&quot;</span>)      <span class="comment"># 移动音频文件，路径自选</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dist2 = np.dot(feature2, featurex) / (np.linalg.norm(feature2) * np.linalg.norm(featurex))</span><br><span class="line">            <span class="keyword">if</span> dist2 &gt; args.threshold:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;%s 符合可莉模型，相似度为：%f&quot;</span> % (personx, dist2))</span><br><span class="line">                shutil.move(<span class="string">&quot;./test2/%s&quot;</span> % (audio),<span class="string">&quot;./dataset/Klee&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dist3 = np.dot(feature3, featurex) / (np.linalg.norm(feature3) * np.linalg.norm(featurex))</span><br><span class="line">                <span class="keyword">if</span> dist3 &gt; args.threshold:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;%s 符合心海模型，相似度为：%f&quot;</span> % (personx, dist3))</span><br><span class="line">                    shutil.move(<span class="string">&quot;./test2/%s&quot;</span> % (audio),<span class="string">&quot;./dataset/Kokomi&quot;</span>)</span><br><span class="line">        gc.collect()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>需要注意一点，为了提高识别的准确性，这个项目要求的语音长度不能低于1.7s，因此我用ffmpeg将所有长度低于2s的短音频全部过滤了（这里不赘述实现过程）。</p><p>之后将三个角色的标准语音分别放在audio_db文件夹下，识别的原理是通过预测函数提取三个角色的音频特征值，对5.6万条音频分别比对三个角色的标准音频特征，求对角余弦值，在多次试验后选择了对角余弦值0.8，作为判断两条语音是否为同一个人的阈值。</p><p>直接在集群上运行infer_contrast.py，相似度高于0.8的音频则会被挑选到对应的dataset文件夹中。</p><p><img src="https://www.shelven.com/tuchuang/20220908/5.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220908/5.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>实际上这个声纹识别的结果仅能作为参考，不能保证百分百正确，原因有很多：</p><ul><li><p>1.声优都是怪物，一个人用好多相似的声线配了不同角色，导致无法分辨出不同角色的语音（假阳性）。</p></li><li><p>2.一句话的语调不同会表现出音频特征值不同，而这个算法下会导致对角余弦值偏小，从而判断成发声的是不同的人（假阴性）。</p></li></ul><p>因此识别的结果需要进行人工校正，<strong>也就是需要自己听一遍到底是不是这个角色的语音</strong>&#x3D; &#x3D;（最好同下一步一起进行，省时间）</p><p>这里我验证并分离出2293条长度2秒以上的派蒙语音，以其中的1820条作为训练集，473条作为测试集。后续训练模型用到的时候会说。</p><h3 id="1-3-基于百度语音识别API的语音转文本"><a href="#1-3-基于百度语音识别API的语音转文本" class="headerlink" title="1.3 基于百度语音识别API的语音转文本"></a>1.3 基于百度语音识别API的语音转文本</h3><p>光有语音还不行，我们要训练模型就要有对应的<strong>文本</strong>。很多单机游戏（比如柚子社的游戏）有解包脚本，可以完整解出所有资源，其中就包括语音文件和对应的文本。但是解包有客户端的游戏不同，比如这款游戏发布不同版本的客户端，文件结构就会发生很大的改变，导致以前做的文件定位统统失效，而且包括文本在内的很多文件也是加密的，无法解出（也可能是我个人问题）。</p><p>因此，我们还是需要借助语音识别的软件将语音转成文本。这里涉及到另一个问题，不管多么强大的语音转文字技术，都是在已有的数据集基础上不断训练模型而产生的，游戏中有相当多新造的词（比如中二台词，游戏人名，地点等等），这在转化文本过程中是肯定无法百分百准确的，甚至会“空耳”产生歧义。</p><p>因此转文本这一步结束后需要人工校准，至少保证读音正确。</p><p>我是在<strong>百度AI开放平台</strong>申请了语音识别API，每个账号有200万次免费调用额度，但是限制并发数2<del>（没办法，既然是白嫖就忍忍）</del>。</p><p><img src="https://www.shelven.com/tuchuang/20220908/6.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220908/6.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>查看官方放在github上的demo，改一改就可以调用API了（每当问我不会使用的时候都是看demo然后魔改2333）。</p><p>我这里以官网提供的<strong>asr_raw.py</strong>为例，直接下载，并修改成如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">IS_PY3 = sys.version_info.major == <span class="number">3</span>        <span class="comment"># 判断你用的是python3.x还是2.x版本，推荐还是用3.x</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> IS_PY3:</span><br><span class="line">    <span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line">    <span class="keyword">from</span> urllib.request <span class="keyword">import</span> Request</span><br><span class="line">    <span class="keyword">from</span> urllib.error <span class="keyword">import</span> URLError</span><br><span class="line">    <span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlencode</span><br><span class="line">    timer = time.perf_counter</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">import</span> urllib2</span><br><span class="line">    <span class="keyword">from</span> urllib2 <span class="keyword">import</span> urlopen</span><br><span class="line">    <span class="keyword">from</span> urllib2 <span class="keyword">import</span> Request</span><br><span class="line">    <span class="keyword">from</span> urllib2 <span class="keyword">import</span> URLError</span><br><span class="line">    <span class="keyword">from</span> urllib <span class="keyword">import</span> urlencode</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> sys.platform == <span class="string">&quot;win32&quot;</span>:</span><br><span class="line">        timer = time.clock</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># On most other platforms the best timer is time.time()</span></span><br><span class="line">        timer = time.time</span><br><span class="line"></span><br><span class="line">API_KEY = <span class="string">&#x27;XXXXXXXX&#x27;</span>    <span class="comment"># 改成你自己的，下面一条一样</span></span><br><span class="line">SECRET_KEY = <span class="string">&#x27;XXXXXXXX&#x27;</span> </span><br><span class="line">FORMAT = <span class="string">&quot;wav&quot;</span>;  <span class="comment"># 文件后缀只支持 pcm/wav/amr 格式</span></span><br><span class="line">CUID = <span class="string">&#x27;123456PYTHON&#x27;</span>;</span><br><span class="line">RATE = <span class="number">16000</span>;  <span class="comment"># 固定值，这里一定一定要注意采样率</span></span><br><span class="line">DEV_PID = <span class="number">1537</span>;  <span class="comment"># 1537 表示识别普通话，使用输入法模型。根据文档填写PID，选择语言及识别模型</span></span><br><span class="line">ASR_URL = <span class="string">&#x27;http://vop.baidu.com/server_api&#x27;</span></span><br><span class="line">SCOPE = <span class="string">&#x27;audio_voice_assistant_get&#x27;</span>  <span class="comment"># 有此scope表示有asr能力，没有请在网页里勾选，非常旧的应用可能没有</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DemoError</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;  TOKEN start &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">TOKEN_URL = <span class="string">&#x27;http://aip.baidubce.com/oauth/2.0/token&#x27;</span></span><br><span class="line"><span class="comment"># 核对token</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fetch_token</span>():</span><br><span class="line">    params = &#123;<span class="string">&#x27;grant_type&#x27;</span>: <span class="string">&#x27;client_credentials&#x27;</span>,</span><br><span class="line">              <span class="string">&#x27;client_id&#x27;</span>: API_KEY,</span><br><span class="line">              <span class="string">&#x27;client_secret&#x27;</span>: SECRET_KEY&#125;</span><br><span class="line">    post_data = urlencode(params)</span><br><span class="line">    <span class="keyword">if</span> (IS_PY3):</span><br><span class="line">        post_data = post_data.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    req = Request(TOKEN_URL, post_data)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        f = urlopen(req)</span><br><span class="line">        result_str = f.read()</span><br><span class="line">    <span class="keyword">except</span> URLError <span class="keyword">as</span> err:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;token http response http code : &#x27;</span> + <span class="built_in">str</span>(err.code))</span><br><span class="line">        result_str = err.read()</span><br><span class="line">    <span class="keyword">if</span> (IS_PY3):</span><br><span class="line">        result_str = result_str.decode()</span><br><span class="line"></span><br><span class="line">    result = json.loads(result_str)</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&#x27;access_token&#x27;</span> <span class="keyword">in</span> result.keys() <span class="keyword">and</span> <span class="string">&#x27;scope&#x27;</span> <span class="keyword">in</span> result.keys()):</span><br><span class="line">        <span class="keyword">if</span> SCOPE <span class="keyword">and</span> (<span class="keyword">not</span> SCOPE <span class="keyword">in</span> result[<span class="string">&#x27;scope&#x27;</span>].split(<span class="string">&#x27; &#x27;</span>)):  <span class="comment"># SCOPE = False 忽略检查</span></span><br><span class="line">            <span class="keyword">raise</span> DemoError(<span class="string">&#x27;scope is not correct&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> result[<span class="string">&#x27;access_token&#x27;</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> DemoError(<span class="string">&#x27;MAYBE API_KEY or SECRET_KEY not correct: access_token or scope not found in token response&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;  TOKEN end &quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    token = fetch_token()</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    httpHandler = urllib2.HTTPHandler(debuglevel=1)</span></span><br><span class="line"><span class="string">    opener = urllib2.build_opener(httpHandler)</span></span><br><span class="line"><span class="string">    urllib2.install_opener(opener)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> audio <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">1825</span>):</span><br><span class="line">        AUDIO_FILE = <span class="built_in">str</span>(<span class="string">&#x27;/public/home/wlxie/test4voice/baiduyun/training_16K/train&#x27;</span> + <span class="built_in">str</span>(audio) + <span class="string">&#x27;.wav&#x27;</span>)     <span class="comment">#路径改成自己的</span></span><br><span class="line">        speech_data = []</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(AUDIO_FILE, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> speech_file:</span><br><span class="line">            speech_data = speech_file.read()</span><br><span class="line">        length = <span class="built_in">len</span>(speech_data)</span><br><span class="line">        <span class="keyword">if</span> length == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> DemoError(<span class="string">&#x27;file %s length read 0 bytes&#x27;</span> % AUDIO_FILE)</span><br><span class="line"></span><br><span class="line">        params = &#123;<span class="string">&#x27;cuid&#x27;</span>: CUID, <span class="string">&#x27;token&#x27;</span>: token, <span class="string">&#x27;dev_pid&#x27;</span>: DEV_PID&#125;</span><br><span class="line">        params_query = urlencode(params);</span><br><span class="line"></span><br><span class="line">        headers = &#123;</span><br><span class="line">            <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;audio/&#x27;</span> + FORMAT + <span class="string">&#x27;; rate=&#x27;</span> + <span class="built_in">str</span>(RATE),</span><br><span class="line">            <span class="string">&#x27;Content-Length&#x27;</span>: length</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        url = ASR_URL + <span class="string">&quot;?&quot;</span> + params_query</span><br><span class="line">        req = Request(ASR_URL + <span class="string">&quot;?&quot;</span> + params_query, speech_data, headers)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            begin = timer()</span><br><span class="line">            f = urlopen(req)</span><br><span class="line">            result_str = f.read()</span><br><span class="line">        <span class="keyword">except</span>  URLError <span class="keyword">as</span> err:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;asr http response http code : &#x27;</span> + <span class="built_in">str</span>(err.code))</span><br><span class="line">            result_str = err.read()</span><br><span class="line">    <span class="comment">#输出转文字结果</span></span><br><span class="line">        result_str = result_str.decode()</span><br><span class="line">        result = json.loads(result_str)</span><br><span class="line">        res = result[<span class="string">&#x27;result&#x27;</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;train&#x27;</span> +<span class="built_in">str</span>(audio) + <span class="string">&#x27;.wav&#x27;</span> + <span class="string">&#x27;识别结果：&#x27;</span> + res)</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;training_1800_result.txt&quot;</span>, <span class="string">&quot;a&quot;</span>) <span class="keyword">as</span> of:</span><br><span class="line">            of.write(<span class="string">&#x27;train&#x27;</span> + <span class="built_in">str</span>(audio) + <span class="string">&#x27;.wav&#x27;</span> + <span class="string">&quot;|&quot;</span> + res + <span class="string">&#x27;\n&#x27;</span>)  <span class="comment"># 转成“路径|文本”的格式，方便人工校准</span></span><br><span class="line">    gc.collect()</span><br></pre></td></tr></table></figure><p>这里也有一个<strong>大坑</strong>，这个语音转文本API要求音源采样率必须是16000Hz，前面说到我们解包得到的音频是48000Hz，而且后面训练模型要求采样率为22050Hz！也就是说如果我们现在把所有音频转成16000Hz的话，势必会对训练模型产生影响（高频可以转低频，但是低频转高频语音质量不会有一丁点儿的提升），因此我这边用拆包音频做了两个备份，一个是转成16000Hz，放在training_16K文件下，专门用于语音转文本；一个是转成22050Hz，放在training_22K文件下，专门用于后续训练模型。重采样仍然用我们的老朋友<strong>ffmpeg</strong>，因为就一行命令的事这里也不赘述了。</p><p>前面也说到这个API并发数限制为2，经常是用着用着就断开了（也是我比较笨比，不会写限制并发数发送请求的代码），所以我将训练集的1825个语音写了个小脚本，重命名为train1.wav-train1825.wav，所以才用了for循环一句一句调用API转文本，到哪个地方断了也可以迅速找出来并继续。</p><p>总之效果如下，训练集1825条语音和测试集473条语音全部转换为文本，且能清晰地看到一一对应关系：</p><p><img src="https://www.shelven.com/tuchuang/20220908/7.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220908/7.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>一眼看效果还不错，为了保证准确率，将txt文件传回本地，<strong>人工校正吧</strong>（语气词部分本来是要去除的，但是工作量会比较大放弃了，起码要保证发音没问题）。</p><p>这个数据集因为不是标准的普通话数据集（标准数据集可以找标贝，就有那种纯合成的标准普通话），声优也有特殊的口癖和发音，额，这是无法避免的。</p><h3 id="1-4-基于pypinyin的汉字转拼音"><a href="#1-4-基于pypinyin的汉字转拼音" class="headerlink" title="1.4 基于pypinyin的汉字转拼音"></a>1.4 基于pypinyin的汉字转拼音</h3><p>因为后面训练模型的Tacotron2是基于英文模型开发出来的，我们无法直接用中文文本训练。一个行之有效的方法是将中文转换成拼音+数字声调的方式，这样数据就可以顺利地被载入。</p><p>这里推荐一下pypinyin模块，该模块安装比较方便（直接用pip），也是个非常实用和高质量的汉字拼音转换工具！</p><p>我将人工校准后的txt文件传回集群，去掉前面的“|”之前的内容，再写个小脚本<strong>将所有标点符号删除</strong>，接着汉字转拼音，这里就记录下pypinyin的用法吧。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pypinyin <span class="keyword">import</span> lazy_pinyin, Style</span><br><span class="line"><span class="keyword">import</span> linecache</span><br><span class="line"></span><br><span class="line">output_file = <span class="built_in">open</span>(<span class="string">&quot;/public/home/wlxie/test4voice/baiduyun/training_pinyin.txt&quot;</span>,<span class="string">&quot;w&quot;</span>)</span><br><span class="line">readlist = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">1821</span>))  <span class="comment"># 人工校准的时候去掉了4条不是该角色的音频</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> readlist:</span><br><span class="line">    text = linecache.getline(<span class="string">&quot;/public/home/wlxie/test4voice/baiduyun/cheat_training.txt&quot;</span>,i)        </span><br><span class="line">    text = <span class="string">&quot; &quot;</span>.join(lazy_pinyin(text, style=Style.TONE3))</span><br><span class="line">    output_file.write(text)</span><br></pre></td></tr></table></figure><p>然后将拼音前按照Tacotron2训练的要求，加上了音频文件对应的colab路径（为什么用这个路径我下一篇博客再说明），以及每句话末尾加个英文的句号，最后输出结果如下：</p><p><img src="https://www.shelven.com/tuchuang/20220908/8.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220908/8.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>同样的方法对测试集也转拼音，这样前期的数据集文件就制作完成啦！接下来就是重点——训练模型。下篇博客接着说完。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;两个月的暑假已经结束了，假期里自学了一点深度学习的内容，很多地方还是一知半解的，这里稍微记录一下。之前刷到一个很有意思的语音合成视频，抱着试试看的心态想自己做一个模型，于是给自己挖了一个大坑……涉及到深度学习的知识我还需要慢慢学，因此本篇博客重点还是记录下自己的踩坑操作&lt;d</summary>
      
    
    
    
    <category term="深度学习" scheme="http://www.shelven.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="拆包" scheme="http://www.shelven.com/tags/%E6%8B%86%E5%8C%85/"/>
    
    <category term="声纹识别" scheme="http://www.shelven.com/tags/%E5%A3%B0%E7%BA%B9%E8%AF%86%E5%88%AB/"/>
    
    <category term="语音转文本" scheme="http://www.shelven.com/tags/%E8%AF%AD%E9%9F%B3%E8%BD%AC%E6%96%87%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>frp内网穿透配置笔记</title>
    <link href="http://www.shelven.com/2022/07/13/a.html"/>
    <id>http://www.shelven.com/2022/07/13/a.html</id>
    <published>2022-07-12T19:55:04.000Z</published>
    <updated>2022-07-12T19:57:29.299Z</updated>
    
    <content type="html"><![CDATA[<p>过一段时间要到校外学习，而学校的资源只能在校园内网下才能使用（登录集群可以看到登录ip是10开头的A类地址，无法公网ip访问）。为了方便在校外访问校园内网的集群，我手里正好也有一个备案过的服务器和域名，于是自己用frp搭建了一个反向代理服务器，穿透了校园内网，这里记录下自己搭建过程。</p><p>其实一开始我打算直接用开发比较成熟的花生壳软件做内网穿透，但是不知道怎么回事，显示连接成功但是ssh远程登陆不上，后来就放弃了，最后决定用自己的服务器和域名穿透<del>（后来我还申请了花生壳学生版，羊毛先薅到以后再说用不用）</del>。</p><p><img src="https://www.shelven.com/tuchuang/20220713/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220713/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>frp是一个go语言写的开源内网穿透和反向代理软件，支持tcp, udp, http, https等协议，支持linux、mac、windows平台，操作也很方便，非常适合我这种小白。</p><h2 id="1-下载frp"><a href="#1-下载frp" class="headerlink" title="1 下载frp"></a>1 下载frp</h2><div class="story post-story"><p>源代码作者发布在github，<a href="https://github.com/fatedier/frp">点击这里</a>。</p><p>选择最新的release版本，注意frp在service端和client端有两个不同的程序和配置文件，<strong>service端是你想要做反向代理的有公网ip的服务器，client端是处于内网之下的你想要穿透的服务器</strong>。</p><p>service端和client端一定要<strong>同一个版本</strong>。这里我的service端和client端都是linux操作系统，所以我直接下载了linux_arm64.tar.gz（我想顺便远程操控实验室电脑，所以也下载了windows版本，默认windows远程桌面端口号是3389，这个以后再说）。</p><p><img src="https://www.shelven.com/tuchuang/20220713/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220713/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>将tar.gz文件传到两台服务器上，tar -zxvf解压就可以使用了<del>（不需要编译，就是这么简单）</del>。</p><p><strong>在service端保留frps程序和相应的ini配置文件，在client端保留frpc程序和相应的ini配置文件</strong>（主要防止自己搞错）。配置文件有两种，我们可以选择其中一个；ini是最简单的配置文件，full.ini配置文件中记录了全部配置参数和英文解释，需要的时候可以自己根据情况修改。</p></div><h2 id="2-修改配置文件"><a href="#2-修改配置文件" class="headerlink" title="2 修改配置文件"></a>2 修改配置文件</h2><div class="story post-story"><p>网上的教程很多，full.ini也记载了全部的配置方法，我这里只记录下我自己的配置（敏感信息就不展示了）。</p><h3 id="2-1-service端配置"><a href="#2-1-service端配置" class="headerlink" title="2.1 service端配置"></a>2.1 service端配置</h3><p>frps.ini配置文件修改如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_port = 7000    # frp监听的端口，默认7000，可改</span><br><span class="line">bind_udp_port = 7400    # UDP通讯端口，可不设置，用于点对点穿透</span><br><span class="line">token = xxxxxxxx    # 安全考虑需要设置口令，client端需要用到</span><br><span class="line"></span><br><span class="line">dashboard_port = 7500   # frp管理端口，可改</span><br><span class="line">dashboard_user = xxxx   # 管理端口认证的用户名，用于身份识别，自己设置</span><br><span class="line">dashboard_pwd = xxxx    # 管理端口认证的密码，用于身份识别，自己设置</span><br><span class="line">enable_prometheus = true</span><br><span class="line"></span><br><span class="line">subdomain_host = xxx.xxx.xxx    # 设置子域名，主要方便登录管理界面。不用ip地址，用域名+端口的方式直接访问</span><br><span class="line"></span><br><span class="line">log_file = /usr/local/frp/frps.log  # frp日志配置，这里是记录3天的日志信息</span><br><span class="line">log_level = info</span><br><span class="line">log_max_days = 3</span><br></pre></td></tr></table></figure><p>子域名设置主要是方便登录管理界面，不是必须的，反正我记不住服务器一长串ip地址…<strong>这个域名需要DNS解析后才能使用</strong></p><p>后台不挂起运行frps：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./frps -c frps.ini &amp;</span><br></pre></td></tr></table></figure><p>这个时候我们是看不到运行日志的，打开刚刚设置的frps.log文件</p><p><img src="https://www.shelven.com/tuchuang/20220713/3.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220713/3.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>几个设置端口都监听成功，最后也显示frps started successfully说明开启成功。</p><h3 id="2-2-client端配置"><a href="#2-2-client端配置" class="headerlink" title="2.2 client端配置"></a>2.2 client端配置</h3><p>frpc.ini配置文件修改如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = xxx.xxx.xxx.xxx   # 填写你的service端服务器公网ip，这里我写我的云服务器ip</span><br><span class="line">server_port = 7000  # 前面设置的frp监听端口，需要保持一致</span><br><span class="line">token = xxxxxxxx    # 前面设置的口令</span><br><span class="line"></span><br><span class="line">[ssh]   # 这里只演示ssh端口的映射，其他参考frpc_full.ini</span><br><span class="line">type = tcp  # tcp协议</span><br><span class="line">local_ip = 127.0.0.1    # 这个地址代表本机</span><br><span class="line">local_port = 22     # ssh端口，默认22，由你ssh登录的client服务器决定</span><br><span class="line">remote_port = 6000  # 映射的service端服务器的端口，自己定义</span><br></pre></td></tr></table></figure><p>注意下remote_port这个设置的是service端也就是云服务器的端口，通过这个端口访问client端的22端口，也就是端口映射。</p><p>同样的后台不挂起运行frpc：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./frpc -c frpc.ini &amp;</span><br></pre></td></tr></table></figure><p>打开nohup的输出文件：</p><p><img src="https://www.shelven.com/tuchuang/20220713/4.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220713/4.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>显示login to service success表示和service端连接成功。</p><p><strong>全部设置完成后，理论上我就可以通过云服务器的主机地址+6000端口，通过ssh方式访问学校内网中的集群主机地址+22端口了。</strong></p><p><strong>但是我的云服务器比较特殊，还需要进行一步开放防火墙端口。</strong></p></div><h2 id="3-开放serviced服务器端口"><a href="#3-开放serviced服务器端口" class="headerlink" title="3 开放serviced服务器端口"></a>3 开放serviced服务器端口</h2><div class="story post-story"><p>如果在2.2这一步配置之后一直连不上service端，<strong>那极有可能是service服务器的端口没有开放</strong>。</p><p>特别注意一点，如果是买的云服务器（比如我买的腾讯云服务器），<strong>不仅要在控制台页面开放端口，还需要在linux云服务器开放端口</strong>。举个例子，我们这里用到的云服务器端口是7000，7400，7500和6000，首先要在控制台防火墙页面 开放这几个端口。</p><p><img src="https://www.shelven.com/tuchuang/20220713/6.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220713/6.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>然后在云服务器上打开防火墙，开放对应端口：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">systemctl start firewalld   # 打开防火墙</span><br><span class="line">firewall-cmd --permanent --add-port=7000/tcp    # 永久开放指定的7000端口（其他端口同理）</span><br><span class="line">firewall-cmd --reload   # 重启防火墙</span><br><span class="line">firewall-cmd --list-ports   # 查看防火墙开放的所有端口</span><br></pre></td></tr></table></figure><p>注意一下防火墙端口设定完成后，<strong>需要重载防火墙才会生效</strong>。</p><p>我们把自己云服务器的防火墙和端口配置好就行<del>（学校集群你不是root用户你也配置不了，一般来说也不会设置防火墙）</del>。</p></div><h2 id="4-frp管理面板"><a href="#4-frp管理面板" class="headerlink" title="4 frp管理面板"></a>4 frp管理面板</h2><div class="story post-story"><p>有两种方式可以访问：</p><ul><li><ol><li>service端服务器  ip地址:端口号</li></ol></li><li><ol start="2"><li>设置子域名后可以用  子域名:端口号</li></ol></li></ul><p>用户名密码认证后，可以看到如下页面：</p><p><img src="https://www.shelven.com/tuchuang/20220713/8.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220713/8.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>主要就是看一下连接数量，连接方式，产生的流量等等，具体就不细说了。</p><p>开个手机热点，用xshell登陆一下集群，发现显示的登录ip变成了localhost，而不是10开头的A类地址了，说明反向代理成功。</p><p><img src="https://www.shelven.com/tuchuang/20220713/9.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220713/9.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>连接速度非常快，而且稳定！以后登录集群就再也不用校园网啦！</p></div><h2 id="5-写在最后"><a href="#5-写在最后" class="headerlink" title="5 写在最后"></a>5 写在最后</h2><div class="story post-story"><p>这种用外网服务器做反向代理服务器，通过端口转发的方式访问内网服务器还是有一定安全风险的，该开防火墙开防火墙，小心驶得万年船。</p><p>还有，这种方法也有个缺点。打个比方如果你在校外，而<strong>学校服务器因为某种不可抗力重启了</strong><del>（比如停电，这在新疆真的太常见了）</del>这就相当于你挂在后台nohup的程序被强制杀掉了。等到管理员重启后，client端的frpc程序就需要再执行一次才能生效，这个时候就只能拜托有学校集群账号的人帮你在后台执行nohup，你才能从外网访问集群。</p><p>要应对这种情况，最简单的是你写个开机自启动脚本执行frpc，但是你没有root权限是不可行的…或者你让集群管理员给你su权限，这一般来说也不太可能…如何完美解决这个问题还有待研究</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;过一段时间要到校外学习，而学校的资源只能在校园内网下才能使用（登录集群可以看到登录ip是10开头的A类地址，无法公网ip访问）。为了方便在校外访问校园内网的集群，我手里正好也有一个备案过的服务器和域名，于是自己用frp搭建了一个反向代理服务器，穿透了校园内网，这里记录下自己</summary>
      
    
    
    
    <category term="网络相关" scheme="http://www.shelven.com/categories/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="内网穿透" scheme="http://www.shelven.com/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    
    <category term="反向代理" scheme="http://www.shelven.com/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>blastn &amp; blastp 寻找同源基因</title>
    <link href="http://www.shelven.com/2022/07/05/a.html"/>
    <id>http://www.shelven.com/2022/07/05/a.html</id>
    <published>2022-07-05T11:25:26.000Z</published>
    <updated>2022-07-05T11:35:03.990Z</updated>
    
    <content type="html"><![CDATA[<p>今天接到一个任务，大致内容是在一个植物的全长转录组数据中找拟南芥的三个同源基因。简简单单的描述，我的想法也很简单，直接找基因的<strong>CDS序列做blastn</strong>比对就完事了，结果却没有那么顺利…记录一下踩的坑和解决办法。</p><h2 id="1-blastn寻找同源基因"><a href="#1-blastn寻找同源基因" class="headerlink" title="1 blastn寻找同源基因"></a>1 blastn寻找同源基因</h2><div class="story post-story"><p>三个基因TAIR号是AT4G28590、AT2G43010和AT2G34640，从全长转录组测序报告中，我找到了非冗余的转录本序列文件CD-hit-est.fasta，首先第一步就是本地建核酸序列库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">makeblastdb -in CD-hit-est.fasta -dbtype nucl -input_type fasta -out Kc</span><br></pre></td></tr></table></figure><p>因为给的是TAIR号，所以直接去<a href="%5Bwww.arabidopsis.org%5D(https://www.arabidopsis.org/)">TRIR</a>官网查找相应基因的CDS序列做比对</p><p><img src="https://www.shelven.com/tuchuang/20220705/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220705/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>手动创建query gene的fa序列文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim RCB_cds.fna</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">手动创建fa文件</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">AT4G28590</span></span><br><span class="line">ATGAGTTTCTTCGCTGTTGCTTGCTCCGCGCCAAGATCTTCTATGCTTCTCACCGGCTTGAATTCGAGCTTCTCTGATATGCATCGCAGCCCACTATTTGTTTTCCCGGTGACTATATCATCCCGGAGCGTGAAACGCTTCGCCGCTGTTTCGTCTGATTCCGTACTAGACCCTGAATCCAAAAATCAAACTCGGTCCCGTCGCAAAAATAAGGAAGCAGTTACGCCAATTGCTGAAACCGAGAACAATGAAAAGTTTCCGACAAAGGTCCCGCGTAAATCGAAGCGTGGGCGGCGGAGTGAAGCAGACGCTGTGGAAGATTACGTGAGAAGCTCCCTCGAGCGTACTTTCTCCACCATAAAGGAGCAGAATCCGGAGGTTTTTGAGAACAAGGAGAAGGCGAATTTCATCAAAGACAGAGGCGTTGATGAAGAAGAGGAAGAAGAAGAAGAGATGGTGGTGGAAGAGGAAGATCCAGATTGGCCAGTAGATACAGACGTTGGATGGGGAATCAAAGCTTCGGAGTATTTCGATACACATCCAATCAAAAACGTGGTTGGAGATGATGGGAGTGAGATTGATTGGGAAGGTGAGATTGATGATAGTTGGGTCAAGGAGATCAATTGTTTGGAATGGGAAAGCTTTGCTTTTCATCCTAGTCCACTCGTTGTCCTTGTATTCGAGCGATACAAAAGAGCTAGTGATAACTGGAAGACATTGAAGGAGCTTGAGAAAGCTATCAAAGTTTATTGGGATGCGAAAGATCGATTACCTCCACGGGCGGTTAAGATTGACCTGAACATCGAGACAGATTTGGCATATGCTCTTAAAGCTAAGGAATGCCCACAGATTCTCTTCTTACGCGGAAACCGGATTCTGTACAGGGAGAAAGACTTTCGCACGGCGGATGAATTGGTTCATATGATTGCGCATTTCTACTATAAAGCGAAGAGGCCTTCGTGTGTCGACAAGGCTAATGTAACCCCGTACTGTTAG</span><br></pre></td></tr></table></figure><p>blastn比对</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blastn -query RCB_cds.fna -out RCB_blastn_Kc.out -db Kc -outfmt 6 -evalue 1e-5 -num_threads 4</span><br></pre></td></tr></table></figure><p>RCB_blastn_Kc.out是blast的m8格式输出文件，找到匹配长度最长的（也就是第一条）subject gene id，回到非冗余转录本，找到subject gene在哪行，最后找出转录本序列。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">找到subject gene所在行（subject gene <span class="built_in">id</span>中有所在行数，这里验证下）</span></span><br><span class="line">cat CD-hit-est.fasta | grep -n &quot;Kc-zong_1-10k_transcript/10791&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">提取序列</span></span><br><span class="line">awk &#x27;NR&gt;=10719 &amp;&amp; NR&lt;=10720&#x27; CD-hit-est.fasta</span><br></pre></td></tr></table></figure><p><img src="https://www.shelven.com/tuchuang/20220705/3.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220705/3.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><strong>紧接着出现一个问题</strong>：AT2G43010和AT2G34640这两个基因无法通过blastn比对找到同源序列，evalue值不管放到多宽都比对不上。</p><p>因为这个植物在NCBI上没有参考基因组，我们课题组也只测了全长转录组而没有测基因组，所以当一开始没有比对出结果的时候，我一度怀疑是这种植物压根儿就没有这俩基因，或者这个样品叶片（测序的部位）在检测的时间点就没有转录相应的基因。</p><p>本地blast找不到同源基因，我又从近缘菊科植物开始折腾，思路是如果菊科有同源基因则寻找保守结构域，设计引物将CDS区域克隆出来。至今已发表的植物基因组可以从网站<a href="https://www.plabipd.de/plant_genomes_pa.ep">Plabipd（本站网址导航栏有收录）</a>找到，<strong>这个网站很贴心地把物种种属关系也列了出来</strong>，可以很方便地找物种学名和近缘关系。</p><p>理想很丰满现实很骨感，我从菊科一级一级往上找，直到Eudicotyledoneae（真双子叶植物分支）才用blastn比对上同源基因，而且无一例外比对上的全是十字花科（拟南芥所在科）植物，根本不算近缘物种….无奈之下试了blast的其他功能，用氨基酸序列跑了一遍blastp，然后发现菊科也有序列可以比对上了！这才打开新世界的大门</p></div><h2 id="2-blastp寻找同源基因"><a href="#2-blastp寻找同源基因" class="headerlink" title="2 blastp寻找同源基因"></a>2 blastp寻找同源基因</h2><div class="story post-story"><p>基于翻译阅读框对去冗余的全长转录本进行CDS预测（TransDecoder软件），结果以fasta格式保存，后续我会对这个文件验证一遍，先建蛋白库做blastp比对。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">makeblastdb -in transdecoder.pep.fa -dbtype prot -input_type fasta -out nr_Kc</span><br></pre></td></tr></table></figure><p><img src="https://www.shelven.com/tuchuang/20220705/4.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220705/4.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><strong>可以看到只有25128个编码蛋白基因，对于基因组大小在1G左右的菊科物种来说，这个基因数量过少</strong>。因此后续还需要对全长转录组数据再跑一遍验证一下，这个是后话。</p><p>通过TAIR号在TAIR官网查找蛋白序列，创建fa文件后进行本地blastp比对</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">blastp -query PIF4_pep.fna -out PIF4_blastp_nr_Kc.out -db nr_Kc -outfmt 6 -evalue 1e-5 -num_threads 4</span><br><span class="line">blastp -query HMR_pep.fna -out HMR_blastp_nr_Kc.out -db nr_Kc -outfmt 6 -evalue 1e-5 -num_threads 4</span><br></pre></td></tr></table></figure><p>注意下结果文件名写清楚什么基因，用的什么方法比对，比对的什么库。这个时候再查看各自的结果文件，发现有比对结果，再回到非冗余转录本文件找对应的cds序列。操作过程都一样，这里不再赘述了。</p></div><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><div class="story post-story"><p>找三条同源基因花了一整天的时间，主要原因还是对同源序列了解不够深刻。</p><p>同源就是有共同的进化祖先，序列相似性搜索可以通过检测<strong>过高的</strong>相似性来识别同源蛋白质或基因：当两个序列的相似性超过偶然的预期时，我们推断这两个序列存在同源性。 当观察到过高的相似性时，这两个序列不是独立出现的，它们起源于一个共同的祖先。</p><p>通过算法进行序列对库比对的工具，比如blast等，是通过过高相似性来减少假阳性的结果。所以通过算法在统计学上找不到库里显著的匹配项，不代表这个物种中一定没有同源基因。</p><p>从这次blastn和blastp比对结果来看，核酸序列比对可能更不容易找到同源序列。其实也好理解，生物在进化的几亿年时间里，很难保证不同物种有高相似性的核酸序列。同个氨基酸有不同密码子（简并性），也能证明蛋白质一级结构才是对生物影响最大的，蛋白质序列相同，就会有相似结构和功能。因此，蛋白质序列也就是氨基酸序列，对相似性的搜索比核酸序列要敏感的多。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天接到一个任务，大致内容是在一个植物的全长转录组数据中找拟南芥的三个同源基因。简简单单的描述，我的想法也很简单，直接找基因的&lt;strong&gt;CDS序列做blastn&lt;/strong&gt;比对就完事了，结果却没有那么顺利…记录一下踩的坑和解决办法。&lt;/p&gt;
&lt;h2 id=&quot;1-</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="blast" scheme="http://www.shelven.com/tags/blast/"/>
    
  </entry>
  
  <entry>
    <title>0基础学习基因组三代测序组装（4）——初步组装二代数据</title>
    <link href="http://www.shelven.com/2022/07/03/a.html"/>
    <id>http://www.shelven.com/2022/07/03/a.html</id>
    <published>2022-07-03T11:28:52.000Z</published>
    <updated>2022-07-03T11:33:05.956Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><div class="story post-story"><p>经过前面的全基因组特征调查（survey）后，我们发现这是一个复杂基因组，杂合度较高，可以以二代+三代测序技术相结合的策略进行全基因组组装，还可以以Hi-C（高通量染色体捕获技术，High-through chromosome conformation capture）技术进行辅助组装。</p><p>这里我用华大开发的二代测序组装工具SOAPdenovo，用二代测序数据对进行初步基因组组装。</p></div><h2 id="1-安装SOAPdenovo-2-0"><a href="#1-安装SOAPdenovo-2-0" class="headerlink" title="1 安装SOAPdenovo 2.0"></a>1 安装SOAPdenovo 2.0</h2><div class="story post-story"><p>github上这个软件的版本是2.0，网址点击<a href="https://github.com/aquaskyline/SOAPdenovo2">这里</a></p><p>软件下载安装过程非常顺利，如果有报错无法解决的话可以在Issue里向作者反馈。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">集群如果无法登录github，下载源码包，通过xftp传到集群</span></span><br><span class="line">tar -zxvf SOAPdenovo2</span><br><span class="line">cd SOAPdenovo2-r242</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>编译之后可以看到有如下几个文件</p><p><img src="https://www.shelven.com/tuchuang/20220702/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220702/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>SOAPdenovo-127mer和SOAPdenovo-63mer是用于组装的两个程序，分<strong>别代表支持的最大k-mer为127和63</strong>，用法上是完全相同的。</p><p>example.config是配置文件，组装之前我们要设置其中的参数内容；README.md是帮助文件，详细记录了各项参数的作用和设置方法。这个后面会讲到。</p></div><h2 id="2-kmergenie计算最佳k值"><a href="#2-kmergenie计算最佳k值" class="headerlink" title="2 kmergenie计算最佳k值"></a>2 kmergenie计算最佳k值</h2><div class="story post-story"><p>现在组装基因组的算法主要有三种：De Bruijn graph，Overlap-Layout-Consensus和String Graph。SOAPdenovo软件组装基因组用的是De Bruijn graph算法，简单理解是通过将reads打断成k-mer后，利用k-mer之间的重复部分构建图，得到最优化路径从而拼接contig。要具体了解什么是De Bruijn graph，可以参考<a href="https://blog.csdn.net/u010608296/article/details/113879863">这一篇博文</a>。</p><p>不同k-mer值构建的De Bruijn graph不一样，会导致组装质量的差异，因此我们需要选择一个最佳的组装k-mer大小（尽管可以用默认值<strong>23</strong>直接组装，但是效果不一定是最好的）。</p><p><strong>kmergenie软件和之前的Jellyfish类似</strong>，都可以用于统计k-mer数量，kmergenie最大优点是可以对预设的多个k-mer进行分析，找到最佳的k-mer。<a href="http://kmergenie.bx.psu.edu/">点击这里进入Kmergenie官网</a>，下载最新版本的软件。</p><p><strong>注意下这个软件安装需要python &gt; 2.7，并且需要安装R和zlib</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf kmergenie-1.7051.tar.gz</span><br><span class="line">cd kmergenie-1.7051</span><br><span class="line">make</span><br><span class="line">python setup.py install --user  # 安装到用户环境中，不报错说明可以使用</span><br><span class="line"></span><br><span class="line">vim file.txt    # 将两个fq文件路径写进去，一行一个</span><br><span class="line"></span><br><span class="line">/public/home/wlxie/biosoft/kmergenie-1.7051/kmergenie file.txt -o ./kmergenie_res -l 15 -k 65 -s 5 -t 30 --diploid      # 运行kmergenie</span><br></pre></td></tr></table></figure><ul><li>-o    # 输出文件位置和名称</li><li>-l    # 设定的最小k值</li><li>-k    # 设定的最大k值</li><li>-s    # 最小k值到最大k值，每次增加的间隔（根据需要设定间隔大小）</li><li>-t    # 运行的线程（CPU核）数</li><li>--diploid    # 二倍体模式，前面我们已经用jellyfish确认过这是个复杂基因组。默认是单倍体模式</li></ul><p><strong>其原理就是设置不同k值进行基因组大小预估，将组装的基因组最大的k值作为最佳k值。</strong></p><p>最终会给出kmergenie_res为前缀的一系列报告，生成的.histo文件还可以用来上一篇笔记中的GenomeScope分析，这里我们只需要看总结的html文件。</p><p><img src="https://www.shelven.com/tuchuang/20220702/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220702/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>确定组装的最佳k值为51</p></div><h2 id="3-SOAPdenovo2组装contigs-x2F-scaffolds"><a href="#3-SOAPdenovo2组装contigs-x2F-scaffolds" class="headerlink" title="3 SOAPdenovo2组装contigs&#x2F;scaffolds"></a>3 SOAPdenovo2组装contigs&#x2F;scaffolds</h2><div class="story post-story"><p>复制一份example.config配置文件，重命名为run_config，修改部分参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">maximal <span class="built_in">read</span> length</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">全局配置参数，只要高于这个参数的序列都会被截取到这个长度</span></span><br><span class="line">max_rd_len=150</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">文库配置以[LIB]开头</span></span><br><span class="line">[LIB]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">average insert size</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">文库插入片段的平均长度，在实际设置时，可以参考文库size分布图，取峰值（默认200）</span></span><br><span class="line">avg_ins=200</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="keyword">if</span> sequence needs to be reversed</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">是否需要将序列反向互补，对于pair-end数据，不需要反向互补，设置为0；对于mate-pair数据，需要反向互补，设置为1</span></span><br><span class="line">reverse_seq=0</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="keyword">in</span> <span class="built_in">which</span> part(s) the reads are used</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1表示只组装contig，2表示只组装scaffold，3表示同时组装contig和scaffold，4表示只补gap</span></span><br><span class="line">asm_flags=3</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">use only first 100 bps of each <span class="built_in">read</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">序列长度阈值，作用和max_rd_len相同，大于该长度的序列会被切除到该长度</span></span><br><span class="line">rd_len_cutoff=150</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="keyword">in</span> <span class="built_in">which</span> order the reads are used <span class="keyword">while</span> scaffolding</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置不同文库数据的优先级顺序，取值范围为整数，rank值相同的多个文库，在组装scaffold时，会同时使用。</span></span><br><span class="line">rank=1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">cutoff of pair number <span class="keyword">for</span> a reliable connection (at least 3 <span class="keyword">for</span> short insert size)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">contig或者scaffold之前的最小overlap个数，对于pair-end数据，默认值为3；对于mate-paird数据，默认值为5</span></span><br><span class="line">pair_num_cutoff=3</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">minimum aligned length to contigs <span class="keyword">for</span> a reliable <span class="built_in">read</span> location (at least 32 <span class="keyword">for</span> short insert size)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">比对长度的最小阈值，对于pair-end数据，默认值为32；对于mate-pair数据，默认值为35</span></span><br><span class="line">map_len=32</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">a pair of fastq file, <span class="built_in">read</span> 1 file should always be followed by <span class="built_in">read</span> 2 file</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">过滤后的双端测序数据文件路径，q为fastq格式，f为fasta格式，b为bam格式</span></span><br><span class="line">q1=/public/home/wlxie/luobuma/luobuma/sample_1_rawdata/Second-generation_sequencing/20211106-BaiYiHuiNeng01/01.rawFq/00.mergeRawFq/1/clean_data/1_r    aw_1_val_1.fq</span><br><span class="line">q2=/public/home/wlxie/luobuma/luobuma/sample_1_rawdata/Second-generation_sequencing/20211106-BaiYiHuiNeng01/01.rawFq/00.mergeRawFq/1/clean_data/1_r    aw_2_val_2.fq</span><br></pre></td></tr></table></figure><p>SOAPdenovo有6个子命令<strong>pregraph、sparse_pregraph、contig、map、scaff和all</strong>，前5个命令对应5个组装步骤，第一和第二是两种不同构图方式，all命令一次执行所有步骤，用all命令比较省事儿。</p><p>SOAPdenovo命令还有一些参数用于调整，<a href="https://zhuanlan.zhihu.com/p/286159368">参数参考</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-s  # 配置文件</span><br><span class="line">-o  # 输出文件的前缀</span><br><span class="line">-K  # 输入的K-mer值大小，默认值23</span><br><span class="line">-p  # 程序运行时设定的线程数，默认值8</span><br><span class="line">-R  # 利用read鉴别短的重复序列，默认值不进行此操作</span><br><span class="line">-d  # 去除频数不大于该值的k-mer，默认值为0</span><br><span class="line">-D  # 去除频数不大于该值的由k-mer连接的边，默认值为1，即该边上每个点的频数都小于等于1时才去除</span><br><span class="line">-M  # 连接contig时合并相似序列的等级，默认值为1，最大值3。</span><br><span class="line">-F  # 利用read对scaffold中的gap进行填补，默认不执行</span><br><span class="line">-u  # 构建scaffold前不屏蔽高覆盖度的contig，这里高频率覆盖度指平均contig覆盖深度的2倍。默认屏蔽</span><br><span class="line">-G  # 估计gap的大小和实际补gap的大小的差异，默认值为50bp。</span><br><span class="line">-L  # 用于构建scaffold的contig的最短长度，默认为：Kmer参数值 ×2</span><br><span class="line">-k  # map步骤中kmer的大小，默认是和K一样的kmer大小</span><br><span class="line">-N  # 基因组大小</span><br><span class="line">-V  # 输出可视化的组装信息</span><br></pre></td></tr></table></figure><p>运行组装命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/public/home/wlxie/biosoft/SOAPdenovo2-r242/SOAPdenovo-63mer all -s /public/home/wlxie/biosoft/SOAPdenovo2-r242/run_config -K 51 -R -V -o A_venetum -p 30</span><br></pre></td></tr></table></figure><p>程序运行了3个小时，结束后生成了以下文件</p><p><img src="https://www.shelven.com/tuchuang/20220702/3.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220702/3.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div><h2 id="4-组装结果解读"><a href="#4-组装结果解读" class="headerlink" title="4 组装结果解读"></a>4 组装结果解读</h2><div class="story post-story"><p>组装结果文件其实只有两个，分别以**.contig结尾和.scafseq结尾**。因为我是在集群上运行的，slurm-11168.out是集群的输出日志文件，记录了详细的组装过程和结果。</p><p>最终得到935861个contigs，总长度295302126 bp，平均长度315 bp，最长的长度38673 bp，contig N50是532 bp，contig N90是103 bp；scaffold个数77918，总长度192992858 bp，平均长度2476 bp，最长的长度108587 bp，scaffold N50是3385 bp，scaffold N90是130 bp。（可以做一个统计表）</p><p>从组装的contig覆盖深度和数量还可以做一个柱状图，理论上来说是和前面k-mer分布图呈现一样的趋势，也就是一个主峰和一个杂峰，两个图相互印证目标基因组是个复杂基因组。</p><p>其他的结果文件在<a href="https://github.com/aquaskyline/SOAPdenovo2">github</a>上有解释，我先直接复制过来，以后用到再翻译翻译……</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">1. Output files from the command &quot;pregraph&quot;</span><br><span class="line">a. *.kmerFreq</span><br><span class="line">      Each row shows the number of Kmers with a frequency equals the row number. Note that those peaks of frequencies which are the integral multiple of 63 are due to the data structure.</span><br><span class="line">b. *.edge</span><br><span class="line">      Each record gives the information of an edge in the pre-graph: length, Kmers on both ends, average kmer coverage, whether it&#x27;s reverse-complementarily identical and the sequence.</span><br><span class="line">c. *.markOnEdge &amp; *.path</span><br><span class="line">      These two files are for using reads to solve small repeats.</span><br><span class="line">e. *.preArc</span><br><span class="line">      Connections between edges which are established by the read paths.</span><br><span class="line">f. *.vertex</span><br><span class="line">      Kmers at the ends of edges.</span><br><span class="line">g. *.preGraphBasic</span><br><span class="line">      Some basic information about the pre-graph: number of vertex, K value, number of edges, maximum read length etc.</span><br><span class="line">      </span><br><span class="line">2. Output files from the command &quot;contig&quot;</span><br><span class="line">a. *.contig</span><br><span class="line">      Contig information: corresponding edge index, length, kmer coverage, whether it&#x27;s tip and the sequence. Either a contig or its reverse complementry counterpart is included. Each reverse complementary contig index is indicated in the *.ContigIndex file.</span><br><span class="line">b. *.Arc</span><br><span class="line">      Arcs coming out of each edge and their corresponding coverage by reads</span><br><span class="line">c. *.updated.edge</span><br><span class="line">      Some information for each edge in graph: length, Kmers at both ends, index difference between the reverse-complementary edge and this one.</span><br><span class="line">d. *.ContigIndex</span><br><span class="line">      Each record gives information about each contig in the *.contig: it&#x27;s edge index, length, the index difference between its reverse-complementary counterpart and itself.</span><br><span class="line">      </span><br><span class="line">3. Output files from the command &quot;map&quot;</span><br><span class="line">a. *.peGrads</span><br><span class="line">      Information for each clone library: insert-size, read index upper bound, rank and pair number cutoff for a reliable link. This file can be revised manually for scaffolding tuning.</span><br><span class="line">b. *.readOnContig</span><br><span class="line">      Reads&#x27; locations on contigs. Here contigs are referred by their edge index. Howerver about half of them are not listed in the *.contig file for their reverse-complementary counterparts are included already.</span><br><span class="line">c. *.readInGap</span><br><span class="line">      This file includes reads that could be located in gaps between contigs. This information will be used to close gaps in scaffolds if &quot;-F&quot; is set.</span><br><span class="line">      </span><br><span class="line">4. Output files from the command &quot;scaff&quot;</span><br><span class="line">a. *.newContigIndex</span><br><span class="line">      Contigs are sorted according their length before scaffolding. Their new index are listed in this file.  This is useful if one wants to corresponds contigs in *.contig with those in *.links.</span><br><span class="line">b. *.links</span><br><span class="line">      Links between contigs which are established by read pairs. New index are used.</span><br><span class="line">c. *.scaf_gap</span><br><span class="line">      Contigs in gaps found by contig graph outputted by the contiging procedure. Here new index are used.</span><br><span class="line">d. *.scaf</span><br><span class="line">      Contigs for each scaffold: contig index (concordant to index in *.contig),  approximate start position on scaffold, orientation, contig length, and its links to others contigs.</span><br><span class="line">e. *.gapSeq</span><br><span class="line">      Gap sequences between contigs.</span><br><span class="line">f. *.scafSeq</span><br><span class="line">      Sequences of each scaffolds.</span><br><span class="line">g. *.contigPosInscaff</span><br><span class="line">      Contigs&#x27; positions in each scaffold.</span><br><span class="line">h. *.bubbleInScaff</span><br><span class="line">      Contigs that form bubble structures in scaffolds. Every two contigs form a bubble and the contig with higher coverage will be kept in scaffold.</span><br><span class="line">i. *.scafStatistics</span><br><span class="line">      Statistic information of final scaffold and contig.</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;div class=&quot;story post-story&quot;&gt;&lt;p&gt;经过前面的全基因组特征调查（survey）后，我们发现这是一个复杂基因组，杂合度</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="基因组三代测序分析" scheme="http://www.shelven.com/categories/%E5%9F%BA%E5%9B%A0%E7%BB%84%E4%B8%89%E4%BB%A3%E6%B5%8B%E5%BA%8F%E5%88%86%E6%9E%90/"/>
    
    
    <category term="kmergenie" scheme="http://www.shelven.com/tags/kmergenie/"/>
    
    <category term="SOAPdenovo2" scheme="http://www.shelven.com/tags/SOAPdenovo2/"/>
    
  </entry>
  
  <entry>
    <title>0基础学习基因组三代测序组装（3）——全基因组Survey</title>
    <link href="http://www.shelven.com/2022/07/02/a.html"/>
    <id>http://www.shelven.com/2022/07/02/a.html</id>
    <published>2022-07-02T07:08:17.000Z</published>
    <updated>2022-07-02T07:30:31.832Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><div class="story post-story"><p>之前说到如何对三代测序数据做污染评估，取随机序列做blastn比对nt库，确定物种分布情况。实际blast比对还要考虑比对的序列长度和ONT本身数据错误率，以及结合GC-depth确定是否有污染。</p><p>基因组三代测序数据组装之前，我们还要做一个全基因组survey。主要是为了减少盲目性，先做低深度的基因组分析，也是初步了解物种<strong>基因组特征</strong>的有效方法，比如评估基因组大小和杂合情况，为后续全基因组de novo组装策略指定提供指导。</p><p>基因组复杂程度的经验性标准：</p><ul><li>简单基因组: 单倍体；或纯合二倍体；或杂合度低于0.5%, 且重复序列低于50%, 且GC含量在35%-65%的二倍体。</li><li>复杂基因组: 杂合度在0.5%~1.2%之间，或重复序列高于50%，或GC含量异常(&lt;35%或&gt;65%)的二倍体，或者多倍体。<strong>复杂基因组可以采用“2+3”即二代和三代测序技术相结合，加之Hi-C辅助组装的组装策略。</strong></li><li>高复杂基因组: 杂合度&gt;1.2%；或重复序列占比大于65%。</li></ul><p>有条件的话，也可以用流式细胞仪对基因组大小做个预估。我这里只有二代基因组测序数据，因此用基因组二代测序数据做全基因组survey。当然，这里要注意一点，做全基因组survey的样本和后续de novo组装的样本要来自同<strong>一个个体</strong>，避免个体间基因组特征的差异。</p></div><h2 id="1-原始数据质控"><a href="#1-原始数据质控" class="headerlink" title="1 原始数据质控"></a>1 原始数据质控</h2><div class="story post-story"><p>因为是对二代测序数据进行分析，质控的过程本质上和之前处理转录组二代数据一样，这里只提下过程和结果。</p><h3 id="1-1-fastqc生成质控报告"><a href="#1-1-fastqc生成质控报告" class="headerlink" title="1.1 fastqc生成质控报告"></a>1.1 fastqc生成质控报告</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastqc *.fq.gz -o ./</span><br></pre></td></tr></table></figure><p><img src="https://www.shelven.com/tuchuang/20220630/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220630/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><img src="https://www.shelven.com/tuchuang/20220630/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220630/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><img src="https://www.shelven.com/tuchuang/20220630/3.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220630/3.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>二代测序是双端测序结果，我这里只截图了部分qc报告，可以看出GC含量比较稳定，测序质量也比较高。</p><h3 id="1-2-trim-galore数据过滤"><a href="#1-2-trim-galore数据过滤" class="headerlink" title="1.2 trim-galore数据过滤"></a>1.2 trim-galore数据过滤</h3><p>报告中的结果虽然好，但是还是需要过滤一遍，把末端接头adapter序列过滤掉。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trim_galore -q 25 -phred33 -length 100 -stringency 1 -paired -o clean_data 1_raw_1.fq.gz 1_raw_2.fq.gz</span><br></pre></td></tr></table></figure><p>参数在这篇博客 <a href="https://www.shelven.com/2022/04/14/a.html?keyword=trim">转录组数据分析笔记（1）——如何用fastqc和trim-galore做测序数据质控</a> 有提到，这里不再赘述。</p><p><img src="https://www.shelven.com/tuchuang/20220630/4.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220630/4.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>看下report文件，过滤了Q值25以下的reads和adapter序列</p><p><img src="https://www.shelven.com/tuchuang/20220630/5.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220630/5.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div><h2 id="2-k-mer分析"><a href="#2-k-mer分析" class="headerlink" title="2 k-mer分析"></a>2 k-mer分析</h2><div class="story post-story"><p>先说一下k-mer的概念：k-mer在这里指将reads迭代拆分成包含k个碱基的序列（类似blast中的word length，蛋白质是3，核酸是11），我们后面要分析的基因组特征都是基于k-mer分布基础上进行的。</p><ul><li>基因组大小可以通过总 <strong>（K-mer 数量）&#x2F;（K-mer 期望测序深度）</strong>来估计</li><li>k-mer分布曲线的主峰所在横坐标可以作为<strong>期望的测序深度</strong></li><li>测序覆盖均匀、不存在测序误差和基因组重复序列的理论条件下，K-mer分布曲线会符合泊松分布</li><li><strong>单倍体或纯合基因组的 K-mer 分布曲线只有一个主峰</strong></li><li>杂合二倍体基因组的 K-mer 分布曲线有两个峰， 分别为<strong>杂合峰（主峰1&#x2F;2处）和纯合峰（主峰）</strong>，前者深度只有后者的一半</li><li>重复序列含量较高时会在主峰后面形成一个<strong>重复峰（主峰的2倍处）</strong>或者形成拖尾</li><li>一般选择<strong>17-mer</strong>评估基因组大小，因为ATCG组成长度为17的核酸序列，理论上有4的17次方种可能，足以覆盖一般的正常基因组。为了避免回文序列，K-mer分析选择K长度均为<strong>奇数</strong>。</li></ul><h3 id="2-1-安装jellyfish"><a href="#2-1-安装jellyfish" class="headerlink" title="2.1 安装jellyfish"></a>2.1 安装jellyfish</h3><p>根据上面说的k-mer概念，可以理解k-mer分析是非常耗计算资源的。我们要自己用脚本实现的话，需要将十几个G的reads分割成不同长度片段，再统计出现的次数，耗时而且麻烦。jellyfish是一款统计DNA序列中Kmer的分布的软件，它运行速度快，内存消耗低，支持并行，也是用的最多的统计k-mer的软件。</p><p><del>重点是可以通过conda直接安装……</del>最好不要用conda安装，我之前运行了1天没出结果也没报错（一度怀疑我的参数设置是不是有问题），百思不得其解。后来从github上重新下载，编译和安装之后，不到10分钟就跑出结果了…我不知道两种安装方式有什么区别，<strong>这里就记录下自己踩的坑</strong>。</p><p><strong>因为jellyfish不支持.gz的压缩文件</strong>，所以之前用tram galore过滤后得到的clean reads需要用gunzip命令解压。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install -c bioconda jellyfish  # 可以用conda安装，我运行的时候出了问题，暂未解决，不推荐</span><br></pre></td></tr></table></figure><p><a href="https://github.com/gmarcais/Jellyfish">点击这里进入jellyfish的github下载地址</a></p><p>我们用本地安装的方式，先下载tar.gz的源码包，tar -zxvf解压后进入jellyfish-2.3.0文件夹。</p><p>我是集群登录的，下面讲的步骤都是在集群上操作（非root账户）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第一步检测。本质上是一个shell脚本，根据系统环境产生合适的makefile文件或者C的头文件（.h结尾的文件），非root账户下--prefix后面接上自己账户的绝对路径。</span></span><br><span class="line">./configure --prefix=/public/home/wlxie</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第二步编译。对源代码包进行编译，如果有错误自己看是否有依赖库的缺失，主要是这个问题。</span></span><br><span class="line">make</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第三步安装。如果前面没有指定自己账户的路径，这一步是会报错没有权限的（用户不能向系统目录写入文件）。</span></span><br><span class="line">make install</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第四步自检。</span></span><br><span class="line">make check</span><br></pre></td></tr></table></figure><p>make和make check这两步都会因为<strong>动态链接库命名不同</strong>，导致报错无法找到动态库；以及我在检测通过之后，用集群运行程序仍然出现了动态库的某个模块无法调用的情况。这里统一说下解决方法。</p><p>前面configure会在我们的家目录下生成<strong>bin、lib和share目录</strong>，这里比较重要的是bin和lib目录。我们运行的命令在bin目录里，对应要改环境变量<strong>PATH</strong>；而需要调用的动态库是在lib目录下，对应要改环境变量<strong>LD_LIBRARY_PATH</strong>。家目录下的.bashrc文件加入以下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export PATH=&quot;/public/home/wlxie/bin:$PATH&quot;</span><br><span class="line">export LD_LIBRARY_PATH=&quot;/public/home/wlxie/lib:$LD_LIBRARY_PATH&quot;</span><br></pre></td></tr></table></figure><p>添加之后保存退出，并且source ~&#x2F;.bashrc刷新一下系统环境变量。</p><p>我碰到的报错是<strong>libcrypto.so.1.0.0和libstdc++.so.6</strong>这两个动态库找不到，但是locate命令查看这两个动态库，在系统目录&#x2F;lib64&#x2F;下都能找到文件，因此将这两个动态库文件直接复制到家目录的lib文件夹，问题就全部解决了。</p><p>如果libstdc++.so.6报错某版本的文件不存在，可以先到动态库目录下，运行strings命令查看动态库中是否有对应的文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings /lib64/libstdc++.so.6 | grep CXXABI   # 比如找不到GLIBCXX_3.4.26，看看动态库中是否存在这个版本的文件，如果不存在，更新动态库；如果存在但是找不到，建议直接拷贝到自己的lib目录下</span><br></pre></td></tr></table></figure><p>make check之后会生成一个日志文件test-suite.log，没有fail的项目说明软件安装成功，没有问题。</p><p><img src="https://www.shelven.com/tuchuang/20220630/6.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220630/6.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="2-2-k-mer频数分布"><a href="#2-2-k-mer频数分布" class="headerlink" title="2.2 k-mer频数分布"></a>2.2 k-mer频数分布</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">k-mer计数</span></span><br><span class="line">jellyfish count -m 17 -s 300M -t 50 -C -o 17-mer.jf ./1_raw_1_val_1.fq ./1_raw_2_val_2.fq</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">k-mer频数统计</span></span><br><span class="line">jellyfish histo -t 4 17-mer.jf &gt; 17-mer.histo</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">统计总k-mer数和特征k-mer数等</span></span><br><span class="line">jellyfish stats 17-mer.jf -o counts_stats.txt</span><br></pre></td></tr></table></figure><p>记录一下各个参数的意义：</p><blockquote><ul><li>-m    # k-mer长度设置为17bp，进行计数</li><li>-s    # 存储用的hash表大小，说实话我没看懂什么意思，基因组估计有多大就用多大就是了，单位是M或者G</li><li>-t    # 使用的线程数，也就是cpu核数</li><li>-C    # 大写的C，对正负链reads都进行统计，双端测序一定要加这个参数</li><li>-o    # 结果文件的前缀名，结果文件是一个二进制文件</li></ul></blockquote><p>正常来说，<strong>10分钟就能跑完程序并给出k-mer计数结果文件</strong>。我用conda安装的jellyfish同样条件运行了20个小时没有结束……而且还不报错！第一次运行这个软件，没有人参考和交流，百度到的教程都是抄来抄去的也没有人说明时间的问题……以后还是去官网安装生信软件了，虽然麻烦一点但是靠谱……</p><p><img src="https://www.shelven.com/tuchuang/20220630/7.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220630/7.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><strong>这个软件的帮助文档在&#x2F;jellyfish-2.3.0&#x2F;doc目录下，所有功能和参数都有英文详解</strong>。</p><p>k-mer频数统计是在计数结果文件上进一步统计各个k-mer出现的次数，频数统计结果文件17-mer.histo将k-mer从1统计到10000，最后一行是10001以后对应的总频次。counts_stats.txt是总的统计结果，包括k-mer总数（Total），特异的k-mer数目（Distinct）只出现过一次的k-mer数量（Unique），频数最高的k-mer数量（Max_count）四项。</p><p><img src="https://www.shelven.com/tuchuang/20220630/8.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220630/8.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><img src="https://www.shelven.com/tuchuang/20220630/10.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220630/10.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>有了频数统计结果文件17-mer.histo就可以用R作图了，以下R作图代码来自于CSDN博主 <a href="https://blog.csdn.net/qq_40569830/article/details/125287781">生信技工</a></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kmer <span class="operator">&lt;-</span> read.table<span class="punctuation">(</span><span class="string">&#x27;17-mer.histo&#x27;</span><span class="punctuation">)</span></span><br><span class="line">kmer <span class="operator">&lt;-</span> subset<span class="punctuation">(</span>kmer<span class="punctuation">,</span> V1 <span class="operator">&gt;=</span><span class="number">5</span> <span class="operator">&amp;</span> V1 <span class="operator">&lt;=</span><span class="number">500</span><span class="punctuation">)</span>     <span class="comment"># 只取5-500bp长度的k-mer统计频次</span></span><br><span class="line">Frequency <span class="operator">&lt;-</span> kmer<span class="operator">$</span>V1</span><br><span class="line">Number <span class="operator">&lt;-</span> kmer<span class="operator">$</span>V2</span><br><span class="line">png<span class="punctuation">(</span><span class="string">&#x27;kmer_plot.png&#x27;</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>Frequency<span class="punctuation">,</span> Number<span class="punctuation">,</span> type <span class="operator">=</span> <span class="string">&#x27;l&#x27;</span><span class="punctuation">,</span> col <span class="operator">=</span> <span class="string">&#x27;blue&#x27;</span><span class="punctuation">)</span></span><br><span class="line">dev.off<span class="punctuation">(</span><span class="punctuation">)</span>       <span class="comment"># 保存png</span></span><br></pre></td></tr></table></figure><p>k-mer分布图如下，当然这只是一个简略图，上面R作图代码还有很多细节可以补充</p><p><img src="https://www.shelven.com/tuchuang/20220630/9.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220630/9.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="2-3-基因组大小、重复率、杂合率估算"><a href="#2-3-基因组大小、重复率、杂合率估算" class="headerlink" title="2.3 基因组大小、重复率、杂合率估算"></a>2.3 基因组大小、重复率、杂合率估算</h3><p>横坐标表示k-mer深度，纵坐标为k-mer数量，可以看得出来测序的样本是个杂合二倍体。主峰坐标（116，2584902），杂合峰坐标（57，1188461），也就是说k-mer期望深度为116；k-mer总数为34655456060；主峰2倍深度也就是232之后的k-mer为重复序列k-mer，总数可以通过导出17-mer.histo文件进行统计（改成csv格式直接两步算出），共16361378388</p><ul><li><p><strong>k-mer分布曲线中无异常峰</strong>，说明二代测序提取的DNA纯度较高，没有被污染</p></li><li><p>根据<strong>（K-mer 数量）&#x2F;（K-mer 期望测序深度）</strong>估算基因组大小为298M。去除深度小于5的错误k-mer，估算基因组大小为292M.</p></li><li><p>根据<strong>（重复序列的k-mer总数）&#x2F;（K-mer 期望测序深度）</strong>估计重复序列大小为141M，即重复率48.29%</p></li><li><p>单拷贝序列大小U&#x3D;292-141&#x3D;151M，要计算杂合率，需要统计非重复k-mer的总数，也就是计算杂合峰面积，建议还是用软件或者在线工具比如<a href="http://qb.cshl.edu/genomescope/genomescope2.0/">genomescope2.0</a></p></li></ul><p>jellyfish + GenomeScope是一套应用非常广泛的基因组survey方法，GenomeScope2.0适合用于分析<strong>二倍体</strong>生物。</p><p><img src="https://www.shelven.com/tuchuang/20220630/11.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220630/11.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>上面是GenomeScope2.0网页版界面，只要我们提供jellyfish生成的.histo结果文件，设置参数就行</p><ul><li>k-mer length    # k-mer长度</li><li>Ploidy    # 染色体倍性</li><li>Max k-mer coverage     # 默认-1，即不限制最大k-mer深度，我这里限制了10000</li><li>Average k-mer coverage for polyploid genome    # 默认-1，不进行筛选</li></ul><p>提交后几分钟就生成了可用于发表的图和报告</p><p><img src="https://www.shelven.com/tuchuang/20220630/12.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220630/12.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>可以看到估计的基因组大小是200M，杂合率0.865%，杂合峰覆盖度（深度）58.3。下面说下这个图如何解读：</p><ul><li>蓝色区域是实际观测值</li><li>黑色拟合线是去除错误（errors）后剩下的k-mer分布，认为是正确的数据并以此评估基因组大小</li><li>黄色拟合线是非重复区域的k-mer分布（理想情况）</li><li>橙色拟合线区域是低深度的错误k-mer，认为是测序错误引入的</li><li>黑色虚线是k-mer的几个峰值</li></ul><p>之所以估计的基因组大小比之前自己估计的要小，是因为去除error的标准不同，我之前只是简单去除了k-mer深度1-4的错误序列，这里是构建模型选择的错误序列，更准确一些。</p><p>网页版最后的results里还有总的统计结果，可以很方便地计算重复率，一眼就能看明白这里就不赘述了。</p><p><img src="https://www.shelven.com/tuchuang/20220630/13.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220630/13.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;div class=&quot;story post-story&quot;&gt;&lt;p&gt;之前说到如何对三代测序数据做污染评估，取随机序列做blastn比对nt库，确定物</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="基因组三代测序分析" scheme="http://www.shelven.com/categories/%E5%9F%BA%E5%9B%A0%E7%BB%84%E4%B8%89%E4%BB%A3%E6%B5%8B%E5%BA%8F%E5%88%86%E6%9E%90/"/>
    
    
    <category term="jellyfish" scheme="http://www.shelven.com/tags/jellyfish/"/>
    
    <category term="GenomeScope2.0" scheme="http://www.shelven.com/tags/GenomeScope2-0/"/>
    
  </entry>
  
  <entry>
    <title>0基础学习基因组三代测序组装（2）——数据污染评估</title>
    <link href="http://www.shelven.com/2022/06/20/a.html"/>
    <id>http://www.shelven.com/2022/06/20/a.html</id>
    <published>2022-06-19T17:17:30.000Z</published>
    <updated>2022-06-20T15:55:41.002Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><div class="story post-story"><p>做完基因组三代测序数据质控之后，我们把所有reads的Q值控制在7以上，每个read的长度在1000bp以上。我们不能明确自己的测序数据是否被其他物种污染，这个时候就要用balst比对的方法确定测序数据是否被污染，以及污染的来源。</p></div><h2 id="1-下载balst-工具和数据库"><a href="#1-下载balst-工具和数据库" class="headerlink" title="1 下载balst+工具和数据库"></a>1 下载balst+工具和数据库</h2><div class="story post-story"><p>在之前的一篇博客中，我详细介绍了如何本地安装NCBI的blast+工具，以及下载nr&#x2F;nt库，建立本地的数据库。<a href="https://www.shelven.com/2022/06/17/a.html">详情点击这里</a>。</p><p>在做数据污染评估的时候，我们还需要知道blast最佳结果对应的物种名，因此还需要下载分类数据库的以下两个子库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ascp工具下载大数据，wget命令下载小文件（md5校验文件）</span></span><br><span class="line">ascp -QT -i /public/home/wlxie/miniconda3/envs/biosoft/etc/asperaweb_id_dsa.openssh -k1 -l 500m anonftp@ftp.ncbi.nlm.nih.gov:/pub/taxonomy/accession2taxid/nucl_gb.accession2taxid.gz ./</span><br><span class="line"></span><br><span class="line">wget https://ftp.ncbi.nlm.nih.gov/pub/taxonomy/accession2taxid/nucl_gb.accession2taxid.gz.md5</span><br><span class="line"></span><br><span class="line">ascp -QT -i /public/home/wlxie/miniconda3/envs/biosoft/etc/asperaweb_id_dsa.openssh -k1 -l 500m anonftp@ftp.ncbi.nlm.nih.gov:/pub/taxonomy/taxdump.tar.gz ./</span><br><span class="line"></span><br><span class="line">wget https://ftp.ncbi.nlm.nih.gov/pub/taxonomy/taxdump.tar.gz.md5</span><br></pre></td></tr></table></figure><p>md5文件校验完成之后，两个数据库分别解压。注意.gz文件用gunzip，.tar.gz文件用tar -zxvf</p><p>看看这两个数据库长什么样：</p><p><img src="https://www.shelven.com/tuchuang/20220619/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220619/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><img src="https://www.shelven.com/tuchuang/20220619/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220619/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>第一张图片是<strong>nucl_gb.accession2taxid</strong>，我们需要用到第二列版本信息和第三列的taxid。</p><p>第二张图片是<strong>names.dmp</strong>，我们需要用到有taxid，学名和scientific name字符串的行。</p><p>这两个数据库怎么使用后面会详细说明。分析思路来自于CSDN的博主<a href="https://blog.csdn.net/qq_42962326/article/details/105081327">风风是超人</a>，遗憾的是从17年开始，NCBI不再提供gi号与blastn结果的关联，博主的本地数据库可能版本比较早，采用的是gi号分析。</p><p>我将后续的代码做了修改，下载的也都是最新的数据库。总的逻辑是利用blast结果的version号，得到nucl_gb.accession2taxid数据库中的taxid号，最后通过names.dmp中的taxid号得到学名。代码方面做了少许优化，对集群服务器可能更友好一点？</p></div><h2 id="2-fq文件处理和blast"><a href="#2-fq文件处理和blast" class="headerlink" title="2 fq文件处理和blast"></a>2 fq文件处理和blast</h2><div class="story post-story"><p>质控后的数据fq文件是“@”开头的，我们要改成fa格式也就是“&gt;”开头。取前10000条序列，每个序列有4行，只取第一行标题和第二行序列。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">NR表示当前行，判断除以4的余数，余数1为标题行，只输出第一个元素即reads <span class="built_in">id</span>；余数2则为序列行，输出所有元素也就是整条序列。最后替换@符号，文件名为test.fa</span></span><br><span class="line">zcat clean_filter.fq.gz | head -n 40000 | awk &#x27;&#123;if(NR%4==1)&#123;print $1&#125;else if(NR%4==2)&#123;print $0&#125;&#125;&#x27; | sed &#x27;s/@/&gt;/g&#x27; &gt;test.fa</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">批量blast程序</span></span><br><span class="line">blastn -query test.fa -out test_blastn_nt.xml -db nt -outfmt 5 -evalue 1e-5 -num_threads 20 -max_target_seqs 1</span><br></pre></td></tr></table></figure><p>批量blast程序注意下我们输出的格式为xml格式，也就是- outfmt 5。为什么要用xml格式，因为xml格式能给出的信息最全，我们需要知道输出的版本号</p><p>evalue值根据需要设定，这里我设置1e-5</p><p>最大匹配数量注意下设置1，我们只需要知道和哪个物种相似度最高，一个输出结果就足够了（虽然设置1会有警告）。</p><p>看下blast生成的test_blastn_nt.xml这个结果文件：</p><p><img src="https://www.shelven.com/tuchuang/20220619/3.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220619/3.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>虽然是第一次接触xml格式，但是感觉非常熟悉！之前做的一个<a href="https://www.shelven.com/2022/05/03/a.html">微博爬虫小程序</a>就是扒了一个类似的html格式的文件……xml格式也挺容易解析的，可以看到比对信息以标签&lt;Iteration&gt;开始，以&lt;&#x2F;Iteration&gt;标签结束，&lt;Hit&gt;标签开始表示的是比对上的结果（因为我设置了最大比对序列数量是1，所以&lt;Hit_num&gt;只有1）；&lt;Hsp&gt;标签表示某一块的比对结果（同一条序列，若干片段比对上），因此&lt;Hsp_num&gt;标签的数量可能不止一个。</p><p>当然，这些都可以不用关心，分析需要的信息我用红框标了出来。比较重要的是&lt;Hit_def&gt;标签，里面的字符串是空格隔开的，<strong>第一个元素是我们需要的物种版本号</strong>。</p></div><h2 id="3-XML文件解析"><a href="#3-XML文件解析" class="headerlink" title="3 XML文件解析"></a>3 XML文件解析</h2><div class="story post-story"><p>前面说了解析的思路，以下是代码的实现。因为用的python语言写的程序，我的建议是在vscode一类的编程软件中写这些代码，如果有错误可以及时调试。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以不写，我是为了确保导入父目录的模块不出错</span></span><br><span class="line">sys.path.append(<span class="string">&quot;./&quot;</span>)</span><br><span class="line"></span><br><span class="line">xmlfile = <span class="built_in">open</span>(<span class="string">&quot;/public/home/wlxie/luobuma/luobuma/sample_1_rawdata/Third_generation_sequencing/test_blastn_nt.xml&quot;</span>,<span class="string">&quot;r&quot;</span>)</span><br><span class="line">outfile = <span class="built_in">open</span>(<span class="string">&quot;/public/home/wlxie/luobuma/luobuma/sample_1_rawdata/Third_generation_sequencing/filted_accession_version.txt&quot;</span>,<span class="string">&quot;w&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个空的字典，提取有queryID和subjectID的行</span></span><br><span class="line">dict1 = defaultdict(<span class="built_in">list</span>)</span><br><span class="line"><span class="keyword">for</span> lines <span class="keyword">in</span> xmlfile:</span><br><span class="line">    line = lines.strip()</span><br><span class="line">    read_id = re.match(<span class="string">&#x27;&lt;Iteration_query-def&gt;.*&lt;/Iteration_query-def&gt;&#x27;</span>,line)</span><br><span class="line">    Hit_def = re.match(<span class="string">&#x27;&lt;Hit_def&gt;.*&lt;/Hit_def&gt;&#x27;</span>,line)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 解析queryID</span></span><br><span class="line">    <span class="keyword">if</span> read_id != <span class="literal">None</span>:     </span><br><span class="line">        read_id = read_id.group()</span><br><span class="line">        read_id = read_id.split(<span class="string">&quot;&lt;&quot;</span>)[<span class="number">1</span>].split(<span class="string">&quot;&gt;&quot;</span>)[<span class="number">1</span>]</span><br><span class="line">        key=read_id</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 字典key值和value值赋值</span></span><br><span class="line">    <span class="keyword">elif</span> Hit_def !=<span class="literal">None</span>:        </span><br><span class="line">        Hit_def = Hit_def.group()</span><br><span class="line">        Hit_def = Hit_def.split(<span class="string">&quot;&lt;&quot;</span>)[<span class="number">1</span>].split(<span class="string">&quot;&gt;&quot;</span>)[<span class="number">1</span>]</span><br><span class="line">        dict1[key].append(Hit_def)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入文件，制表符分割</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> dict1:</span><br><span class="line">    outfile.write(key + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;\t&quot;</span>.join(dict1[key])+<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>看下运行结束后解析得到的文件：</p><p><img src="https://www.shelven.com/tuchuang/20220619/4.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220619/4.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>一共是两列，第一列是reads的queryID，第二列subjectID就是比对上的序列信息。可以看到第二列可以以空格为分隔符，提取第一个元素也就是物种版本号，后面会说。</p><p>为什么要把物种版本号提出来而不直接用这段内容里的物种名呢？因为不同的物种名<strong>字段数量和位置不一样</strong>，无法用统一的命令直接提取，精确的版本号可以对应<strong>唯一一个taxid</strong>，从而被精准地注释上物种学名。</p></div><h2 id="4-匹配物种学名"><a href="#4-匹配物种学名" class="headerlink" title="4 匹配物种学名"></a>4 匹配物种学名</h2><div class="story post-story"><p>这里需要注意一个问题，blast用的nt库还有物种分类用到的两个数据库，他们的<strong>更新时间是不一致的</strong>。也就是说，物种版本号不一定能完全匹配上taxid，而taxid也不一定能匹配上学名。</p><p>而python语言写的程序，用到字典类型数据的时候，如果没有对应的key值匹配是会报错的，不会继续执行下去。一会儿解释，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;./&quot;</span>)</span><br><span class="line"></span><br><span class="line">accession = <span class="built_in">open</span>(<span class="string">&quot;/public/home/wlxie/luobuma/luobuma/sample_1_rawdata/Third_generation_sequencing/filted_accession_version.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)</span><br><span class="line">accession2taxid = <span class="built_in">open</span>(<span class="string">&quot;/public/home/wlxie/luobuma/luobuma/sample_1_rawdata/Third_generation_sequencing/nucl_gb.accession2taxid&quot;</span>,<span class="string">&quot;r&quot;</span>)</span><br><span class="line">taxid2name = <span class="built_in">open</span>(<span class="string">&quot;/public/home/wlxie/luobuma/luobuma/sample_1_rawdata/Third_generation_sequencing/names.dmp&quot;</span>,<span class="string">&quot;r&quot;</span>)</span><br><span class="line">final_res = <span class="built_in">open</span>(<span class="string">&quot;/public/home/wlxie/luobuma/luobuma/sample_1_rawdata/Third_generation_sequencing/final_res.txt&quot;</span>,<span class="string">&quot;w&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从names.dmp提取taxid和学名，匹配有scientific name的行</span></span><br><span class="line">taxid_name_dict = &#123;&#125;        </span><br><span class="line"><span class="keyword">for</span> lines <span class="keyword">in</span> taxid2name:</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;scientific name&quot;</span> <span class="keyword">in</span> lines:</span><br><span class="line">        line = lines.strip().split(<span class="string">&quot;|&quot;</span>)</span><br><span class="line">        taxid = line[<span class="number">0</span>].strip()</span><br><span class="line">        name = line[<span class="number">1</span>].strip()</span><br><span class="line">        taxid_name_dict[taxid] = name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从nucl_gb.accession2taxid提取taxid和版本号</span></span><br><span class="line">accession_taxid_dict = &#123;&#125;       </span><br><span class="line"><span class="keyword">for</span> lines <span class="keyword">in</span> accession2taxid:</span><br><span class="line">    line = lines.strip().split(<span class="string">&quot;\t&quot;</span>)</span><br><span class="line">    TAXID = line[<span class="number">2</span>]</span><br><span class="line">    VERSION = line[<span class="number">1</span>]</span><br><span class="line">    accession_taxid_dict[VERSION] = TAXID</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加两个判断条件，版本号匹配不上taxid和taxid匹配不上学名的情况。gc.collect()释放内存。</span></span><br><span class="line"><span class="keyword">for</span> lines <span class="keyword">in</span> accession:</span><br><span class="line">    line = lines.strip().split(<span class="string">&quot;\t&quot;</span>)</span><br><span class="line">    version = line[<span class="number">1</span>].split()[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> version <span class="keyword">in</span> accession_taxid_dict:</span><br><span class="line">        taxid = accession_taxid_dict[version]</span><br><span class="line">        <span class="keyword">if</span> taxid <span class="keyword">in</span> taxid_name_dict:</span><br><span class="line">            final_res.write(<span class="string">&quot;\t&quot;</span>.join(line)+<span class="string">&quot;\t&quot;</span>+taxid_name_dict[taxid]+<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            final_res.write(<span class="string">&quot;\t&quot;</span>.join(line)+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;INVALID TAXID&quot;</span>+<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        final_res.write(<span class="string">&quot;\t&quot;</span>.join(line)+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;INVALID ACCESSION VERSION&quot;</span>+<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    gc.collect()</span><br></pre></td></tr></table></figure><p>如果不加最后两个判断条件，程序会在报错的那行read序列终止。</p><p>通过比较两个输出结果文件行数是否一致来判断匹配是否完全。</p><p><img src="https://www.shelven.com/tuchuang/20220619/5.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220619/5.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>两个文件输出结果一致说明匹配完成，<strong>为什么这里是9338而不是我们一开始blast的10000条序列呢？那是因为有662条序列balst结果的E值大于1e-5，没有在nt中比对上合适的序列</strong></p></div><h2 id="5-输出物种注释分布结果"><a href="#5-输出物种注释分布结果" class="headerlink" title="5 输出物种注释分布结果"></a>5 输出物种注释分布结果</h2><div class="story post-story"><p>到这一步就有很多种处理方法了，可以把结果文件直接用excel打开，统计reads在nt库的分布情况和比对上的物种分布。也可以直接写个python脚本做个数据统计。</p><p>统计前我们先检查一下是否存在上一步匹配失败的reads。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">统计匹配失败的reads</span></span><br><span class="line">cat final_res.txt | grep &quot;INVALID TAXID&quot;</span><br><span class="line">cat final_res.txt | grep &quot;INVALID ACCESSION VERSION&quot;</span><br></pre></td></tr></table></figure><p><img src="https://www.shelven.com/tuchuang/20220619/6.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220619/6.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>提示有8条reads的物种版本号比对不上taxid，且都是Pyrus x bretschneideri这个物种，说明这个物种还未在nucl_gb.accession2taxid这个NCBI官方数据库中更新。在结果文件中将其替换掉。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sed命令在原文件进行全局替换</span></span><br><span class="line">sed -i &#x27;s/INVALID ACCESSION VERSION/Pyrus x bretschneideri/g&#x27; final_res.txt</span><br></pre></td></tr></table></figure><p>修改完成，检查无误后，用以下python脚本统计物种注释分布：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter     <span class="comment"># 引入counter模块</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;./&quot;</span>)</span><br><span class="line"></span><br><span class="line">name_file = <span class="built_in">open</span>(<span class="string">&quot;/public/home/wlxie/luobuma/luobuma/sample_1_rawdata/Third_generation_sequencing/final_res.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)</span><br><span class="line">res_stastics = <span class="built_in">open</span>(<span class="string">&quot;/public/home/wlxie/luobuma/luobuma/sample_1_rawdata/Third_generation_sequencing/stastics.txt&quot;</span>,<span class="string">&quot;w&quot;</span>)</span><br><span class="line"></span><br><span class="line">name_list = []</span><br><span class="line"><span class="keyword">for</span> lines <span class="keyword">in</span> name_file:</span><br><span class="line">    line = lines.strip().split(<span class="string">&quot;\t&quot;</span>)</span><br><span class="line">    name = line[-<span class="number">1</span>]     <span class="comment"># 取最后一列</span></span><br><span class="line">    name_list.append(name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Counter()函数统计词频</span></span><br><span class="line">count_result = Counter(name_list)</span><br><span class="line">count_list = <span class="built_in">list</span>(count_result.items())     <span class="comment"># 注意需要创建一个list</span></span><br><span class="line">count_list.append((<span class="string">&#x27;Unmap&#x27;</span>,<span class="number">662</span>))        <span class="comment"># 注意手动添加blast失败的序列条数到list中</span></span><br><span class="line">count_list.sort(key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>],reverse=<span class="literal">True</span>) <span class="comment"># 以第二维数据值，即统计的物种学名出现次数排序</span></span><br><span class="line"></span><br><span class="line">res_stastics.write(<span class="string">&quot;Name\tHit_reads\tpercentage\n&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> count_list:</span><br><span class="line">    name = i[<span class="number">0</span>]</span><br><span class="line">    number = i[<span class="number">1</span>]</span><br><span class="line">    reads_num = <span class="number">10000</span></span><br><span class="line">    percentage =<span class="string">&quot;%.2f%%&quot;</span>%(<span class="number">100</span>*<span class="built_in">float</span>(number)/<span class="built_in">float</span>(reads_num))       <span class="comment"># 浮点两位小数的百分比</span></span><br><span class="line">    res_stastics.write(name+<span class="string">&quot;\t&quot;</span>+<span class="built_in">str</span>(number)+<span class="string">&quot;\t&quot;</span>+<span class="built_in">str</span>(percentage)+<span class="string">&quot;\n&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>需要注意手动添加blast失败的序列条数</strong>，方便最后一起统计。打开生成的stastics.txt文件：</p><p><img src="https://www.shelven.com/tuchuang/20220619/8.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220619/8.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>这个数据是制表符分割的，可以用excel做一个分布统计表，或者用R做一个柱状图，底下展示结果</p><p><img src="https://www.shelven.com/tuchuang/20220619/9.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220619/9.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>可以看到，10000条序列比对结果占比最高的前两条序列（橘黄色的）是细菌的核酸序列，总数达到3437条。992条序列比对上罗布麻，662条序列未比对上nt库。可以认为这个序测序数据被细菌污染，可以和测序公司battle要求重新测一遍了……</p></div><h2 id="6-补充说明"><a href="#6-补充说明" class="headerlink" title="6 补充说明"></a>6 补充说明</h2><div class="story post-story"><p>秉着科学严谨的态度，再更新一些内容查漏补缺。</p><p>质控过滤后的reads有183万条，而我只取了前1万条。考虑到测序开头的低质量reads可能会对分析结果产生干扰（比如开头的电信号不稳定），我写了个python脚本对过滤后的数据<strong>随机</strong>取10000条reads，这样就只有随机误差影响分析结果了。</p><p>在第2步fq文件处理部分，为了python调用方便，先解压clean_filter.fq.gz文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gunzip clean_filter.fq.gz</span><br></pre></td></tr></table></figure><p>读取解压后的文件需要49G内存，我只能在集群上处理，接着运行如下python脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random       <span class="comment"># 调用random模块产生随机数</span></span><br><span class="line"><span class="keyword">import</span> linecache    <span class="comment"># 调用linecache模块读入指定行</span></span><br><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"></span><br><span class="line">output_file = <span class="built_in">open</span>(<span class="string">&quot;/public/home/wlxie/luobuma/luobuma/sample_1_rawdata/Third_generation_sequencing/random_test.fa&quot;</span>,<span class="string">&quot;w&quot;</span>)</span><br><span class="line"></span><br><span class="line">reads_list = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">1834926</span>))     <span class="comment"># 共有1834925条reads</span></span><br><span class="line">line = random.sample(reads_list,<span class="number">10000</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> line:</span><br><span class="line">    text1 = linecache.getline(<span class="string">&quot;/public/home/wlxie/luobuma/luobuma/sample_1_rawdata/Third_generation_sequencing/clean_filter.fq&quot;</span>,<span class="number">4</span>*i-<span class="number">3</span>)</span><br><span class="line">    text2 = linecache.getline(<span class="string">&quot;/public/home/wlxie/luobuma/luobuma/sample_1_rawdata/Third_generation_sequencing/clean_filter.fq&quot;</span>,<span class="number">4</span>*i-<span class="number">2</span>)</span><br><span class="line">    query_id = text1.split()[<span class="number">0</span>]</span><br><span class="line">    query_id_fa = query_id.replace(<span class="string">&quot;@&quot;</span>, <span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">    output_file.write(query_id_fa + <span class="string">&quot;\n&quot;</span> + text2)</span><br><span class="line">    gc.collect()</span><br></pre></td></tr></table></figure><p>处理方式比之前多了几步，我运行了两次脚本，发现两次产生的文件大小都在135M左右，也就是随机取10000条reads产生的文件比取前10000条reads产生的文件大了40M。证明<strong>三代测序开头测得序列质量不太行</strong>（短序列不一定质量不好，但是质量不好的序列一定是短序列），拿到随机产生的10000条reads做blast，后续步骤都一样。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;div class=&quot;story post-story&quot;&gt;&lt;p&gt;做完基因组三代测序数据质控之后，我们把所有reads的Q值控制在7以上，每个re</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="基因组三代测序分析" scheme="http://www.shelven.com/categories/%E5%9F%BA%E5%9B%A0%E7%BB%84%E4%B8%89%E4%BB%A3%E6%B5%8B%E5%BA%8F%E5%88%86%E6%9E%90/"/>
    
    
    <category term="python" scheme="http://www.shelven.com/tags/python/"/>
    
    <category term="blast+" scheme="http://www.shelven.com/tags/blast/"/>
    
  </entry>
  
  <entry>
    <title>0基础学习基因组三代测序组装（1）——数据质控</title>
    <link href="http://www.shelven.com/2022/06/17/b.html"/>
    <id>http://www.shelven.com/2022/06/17/b.html</id>
    <published>2022-06-17T14:31:19.000Z</published>
    <updated>2022-06-17T15:32:47.737Z</updated>
    
    <content type="html"><![CDATA[<p>最近拿到一个植物基因组的三代和二代测序数据，想通过以三代测序数据为主，二代测序数据为辅的方式学习一下如何拼接组装一个基因组。但是三代测序数据刚到手就懵了，与之前学习的转录组分析不一样，三代测序返回的几个文件不是单纯的fq文件，如下所示：</p><p><img src="https://www.shelven.com/tuchuang/20220617/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220617/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>于是我又开始恶补了一些三代测序的基础知识，开坑写个三代基因组测序组装的系列笔记~</p><h2 id="1-技术背景"><a href="#1-技术背景" class="headerlink" title="1 技术背景"></a>1 技术背景</h2><div class="story post-story"><p>当第二代高通量测序技术进入成熟阶段后，读长过短、PCR扩增带来的偏向性等问题开始日益凸显；作为基因组学上新的转折点，以PacBio单分子实时测序技术及纳米孔单分子测序技术为首的第三代高通量测序技术（Third-generation Sequencing）开始进入科研应用，从单分子水平上对DNA分子的实时测序，成功解决了二代测序几大困扰：<strong>极端 GC含量区域覆盖度低、高度重复区域无法较好地拼装、大片段变异难以准确检测、不能直接检测碱基修饰</strong>等问题。</p><p>ONT（Oxford Nanopore Technologies）牛津纳米孔测序技术作为第三代单分子实时测序技术，其原理是基于高分子膜两侧电压和其中的蛋白质纳米孔，当单分子DNA从纳米孔通过时，会引起孔两侧电位差来实现信号检测， 而ATCG四种碱基的带电性质不一样，因此利用<strong>电信号的差异</strong>就能检测出通过的碱基类型，从而实现测序。</p><p>Nanopore商业化平台有三个：MinION、GridION及PromethION。本系列笔记的三代测序数据来源于<strong>PromethION</strong>测序平台测序的一个cell，PromethION测序仪拥有48个流动槽，每个流动槽拥有3000个纳米孔通道（总计144000个），适用于大样本量的高通量快速测序。</p></div><h2 id="2-数据质控"><a href="#2-数据质控" class="headerlink" title="2 数据质控"></a>2 数据质控</h2><div class="story post-story"><h3 id="basecalling"><a href="#basecalling" class="headerlink" title="basecalling"></a>basecalling</h3><p>在ONT的测序平台中，将通过纳米孔的DNA或RNA链产生的电位信号转化为相应的碱基序列的过程，称为<strong>basecalling</strong>。Nanopore测序的下机数据的原始数据格式为包含原始测序电信号的<strong>fast5格式</strong>，官方有提供工具Guppy进行basecalling，以<strong>mean_qscore_template的数值大于等于7</strong>为标准（也就是测序质量大于7的reads）得到原始测序数据，这样得到的basecalling数据为<strong>fastq格式</strong>（.fastq或者.fq结尾），所以我拿到的就是已经basecalling后的结果。</p><ul><li>fast5: 原始电信号文件，以.fast5为文件结尾。此文件既有测序得到的序列信息，还有甲基化修饰信息（甲基化位点电信号会不一样）。</li><li>fastq: fast5文件转换而来，四行一个单位，序列和碱基质量一一对应。</li></ul><p>basecalling的同时还可以一起拆分barcode条码序列，这里我没用到guppy这个软件，了解一下就行。经过basecalling后，文件会分为<strong>fail和pass</strong>两部分，pass部分就是满足<strong>Q值&gt;7</strong>的序列（二代测序质控标准是Q20，这里的三代测序质控标准是Q7，准确性不及二代测序）。</p><p>还有一个summary.txt文件，这是一个测序汇总文件，结构如下：</p><p><img src="https://www.shelven.com/tuchuang/20220617/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220617/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>第一眼看上去很乱，几个重要的列含义如下：</p><blockquote><ol><li>filename_fastq  fasq文件名</li><li>filename_fast5  fast5文件名</li><li>read_id  每条read对应的id号</li><li>run_id  这一次运行产生的id号，一个flowcell通常为一个run</li><li>channel mux  该条read在哪个channel测的</li><li>start_time  这条read测序起始时间</li><li>duration  这条read测序经过时间</li><li>passes_filtering  <strong>Q值大于7为TRUE否则为FALSE</strong></li><li>sequence_length_template   read长度，<strong>三代测序数据过滤的指标之一</strong></li><li>mean_qscore_template  非常重要的指标，<strong>每一个read的平均Q值</strong></li><li>有关barcode的都是标签序列相关参数，因为不同样品接头会添加不同的标签序列，混测的时候根据标签序列与样品的对应关系来区分不同样品。</li></ol></blockquote><p>返回的数据是guppy处理过的，也就是raw reads，接下来质控的过程就需要自己动手了。</p><h3 id="nanoplot质控"><a href="#nanoplot质控" class="headerlink" title="nanoplot质控"></a>nanoplot质控</h3><p>先说明下为什么要用这个工具，三代测序的数据读长比二代测序长很多，而且每条序列的长度都是不一样的。不能用之前转录组数据分析中的fastq工具，会报错，因此使用nanoplot工具来生成质检报告，同样也是会生成各种html文件方便浏览结果。</p><p>先创建一个nanoplot专用的环境，下载nanoplot，之后的质控过程都在这个环境下进行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建环境并下载nanoplot</span></span><br><span class="line">conda create -n nanoplot -y -c bioconda nanoplot</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">激活环境</span></span><br><span class="line">. activate nanoplot</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成质检报告。可以用pass.fq文件，也可以直接用summery.txt文件。-o参数后面是输出文件夹名称。</span></span><br><span class="line">NanoPlot --summary summary.txt --loglength -o summary-plots-log-transformed</span><br><span class="line">NanoPlot -t 4 --fastq pass.fq.gz --plots hex dot -o nanoplot_out</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">详细参数设置可以在NanoPlot --<span class="built_in">help</span>中查看</span></span><br></pre></td></tr></table></figure><p>运行结束之后会生成summary-plots-log-transformed这个文件夹，我们可以用xftp工具查看里面的html结果文件，也可以挑取一些数据做数据质量统计表。</p><p>放一张原始测序数据读长分布图示意一下：</p><p><img src="https://www.shelven.com/tuchuang/20220617/5.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220617/5.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><a href="https://www.shelven.com/tuchuang/20220617/NanoPlot-report.html">点击这里查看用summary.txt生成的质控报告</a></p><p><a href="https://www.shelven.com/tuchuang/20220617/NanoPlot-report1.html">点击这里查看用pass.fq.gz生成的质控报告</a><strong>（推荐用这个）</strong></p><p>两种方法生成的质控报告略微有点差别，因为summary.txt文件中记录了所有序列，可以看到有部分序列质量在Q5-Q7之间；而pass.fg.gz生成的质控报告中，<strong>所有序列的质量都在Q7及以上</strong>。后续以分析pass.fq.gz文件生成的质控报告为准，对这个文件序列的长度进行过滤。</p><p>如果不需要图，只需要知道有多少条reads、reads平均长度、N50、N90这些数据做表格的话，还有一个比较实用的<strong>perl脚本</strong>，怎么使用就不赘述了，源代码放底下参考。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#/usr/bin/perl -w</span></span><br><span class="line"><span class="keyword">use</span> strict;</span><br><span class="line"><span class="keyword">use</span> warnings;</span><br><span class="line"></span><br><span class="line"><span class="comment">### *fastq.gz 数据统计 N50 N90 num_seqs sum_len min_len avg_len max_len </span></span><br><span class="line"><span class="comment">### usage: perl stat.fastq.gz.N50.N90.pl *.fastq.gz</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">my</span> $fastq_gz = $ARGV[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">open</span>(IN,<span class="string">&quot;gzip -dc $fastq_gz|&quot;</span>) <span class="keyword">or</span> <span class="keyword">die</span> (<span class="string">&quot;can not open $fastq_gz\n&quot;</span>);</span><br><span class="line"><span class="keyword">open</span>(OUT,<span class="string">&quot;&gt;$fastq_gz.stat&quot;</span>);</span><br><span class="line"><span class="keyword">print</span> OUT <span class="string">&quot;name num_seqs    sum_len min_len avg_len max_len N50 N90\n&quot;</span>;</span><br><span class="line"><span class="keyword">print</span> OUT <span class="string">&quot;$fastq_gz\t&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">my</span> ($len,$total,$num_seqs,$min_len,$max_len)=(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">my</span> @length_list;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(&lt;IN&gt;)&#123;</span><br><span class="line">    <span class="keyword">my</span> $title = $_;</span><br><span class="line">    <span class="keyword">my</span> $seq = &lt;IN&gt;;</span><br><span class="line">    <span class="keyword">my</span> $add = &lt;IN&gt;;</span><br><span class="line">    <span class="keyword">my</span> $quality = &lt;IN&gt;;</span><br><span class="line">    $seq =~ <span class="regexp">s/\r|\n|\r\n//mg</span>;</span><br><span class="line">    $len = <span class="keyword">length</span>($seq);</span><br><span class="line">    <span class="keyword">if</span>($len&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        $total += $len;</span><br><span class="line">        <span class="keyword">push</span> @length_list,$len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>($min_len == <span class="number">0</span>)&#123;$min_len = $len;&#125;<span class="keyword">elsif</span>($min_len &gt; $len)&#123;$min_len = $len;&#125;</span><br><span class="line">    <span class="keyword">if</span>($max_len == <span class="number">0</span>)&#123;$max_len = $len;&#125;<span class="keyword">elsif</span>($max_len &lt; $len)&#123;$max_len = $len;&#125; </span><br><span class="line">    $len=<span class="number">0</span>;</span><br><span class="line">    $num_seqs++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">my</span> $avg_len = $total/$num_seqs;</span><br><span class="line"><span class="keyword">print</span> OUT <span class="string">&quot;$num_seqs\t&quot;</span>;</span><br><span class="line"><span class="keyword">print</span> OUT <span class="string">&quot;$total\t&quot;</span>;</span><br><span class="line"><span class="keyword">print</span> OUT <span class="string">&quot;$min_len\t&quot;</span>;</span><br><span class="line"><span class="keyword">print</span> OUT <span class="string">&quot;$avg_len\t&quot;</span>;</span><br><span class="line"><span class="keyword">print</span> OUT <span class="string">&quot;$max_len\t&quot;</span>;</span><br><span class="line"></span><br><span class="line">@length_list=<span class="keyword">sort</span>&#123;$b&lt;=&gt;$a&#125; @length_list;</span><br><span class="line"></span><br><span class="line"><span class="keyword">my</span> ($count,$half)=(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">my</span> $j=<span class="number">0</span>;$j&lt;@length_list;$j++)&#123;</span><br><span class="line">    $count+=$length_list[$j];</span><br><span class="line">    <span class="keyword">if</span> (($count&gt;=$total/<span class="number">2</span>)&amp;&amp;($half==<span class="number">0</span>))&#123;</span><br><span class="line">        <span class="keyword">print</span> OUT <span class="string">&quot;$length_list[$j]\t&quot;</span>;</span><br><span class="line">        $half=$length_list[$j]</span><br><span class="line">    &#125;<span class="keyword">elsif</span> ($count&gt;=$total*<span class="number">0</span>.<span class="number">9</span>)&#123;</span><br><span class="line">        <span class="keyword">print</span> OUT <span class="string">&quot;$length_list[$j]\t\n&quot;</span>;</span><br><span class="line">        <span class="keyword">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="filtlong过滤数据"><a href="#filtlong过滤数据" class="headerlink" title="filtlong过滤数据"></a>filtlong过滤数据</h3><p>前面说过，二代测序是双端测序，三代测序是单端测序，两者过滤数据的要求不同。三代测序主要是过滤<strong>长度过短的序列和测序质量较低的序列</strong>。在basecalling中我们过滤了Q值小于7的序列，现在还要过滤read长度小于1000bp的序列。过滤后的序列可以直接用于后续的组装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装filtlong软件</span></span><br><span class="line">conda install -y filtlong</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置序列最短为1000bp，压缩结果文件到新文件中</span></span><br><span class="line">filtlong --min_length 1000 pass.fq.gz | gzip &gt; clean_filter.fq.gz</span><br></pre></td></tr></table></figure><p><img src="https://www.shelven.com/tuchuang/20220617/6.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220617/6.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>可以看到过滤了一部分数据，用过滤后的数据再跑一次NanoPlot</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NanoPlot -t 4 --fastq clean_filter.fq.gz --plots hex dot -o filt_nanoplot_out</span><br></pre></td></tr></table></figure><p>测序数据读长分布如下，可以看到已经没有1kb以下的reads了：</p><p><img src="https://www.shelven.com/tuchuang/20220617/8.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220617/8.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><a href="https://www.shelven.com/tuchuang/20220617/NanoPlot-report2.html">点击这里查看过滤后的质控报告</a></p><p>至此质控过滤流程结束，我们可以做一个下机数据质控统计表：</p><table><thead><tr><th>Type</th><th>Bases(bp)</th><th>Reads Number</th><th>Reads mean length(bp)</th><th>Reads N50 length(bp)</th></tr></thead><tbody><tr><td>Raw Reads</td><td>25,584,046,180.0</td><td>1,933,526.0</td><td>13,231.8</td><td>28,127.0</td></tr><tr><td>Filtered Reads</td><td>25,531,304,191.0</td><td>1,834,925.0</td><td>13,914.1</td><td>28,184.0</td></tr></tbody></table></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近拿到一个植物基因组的三代和二代测序数据，想通过以三代测序数据为主，二代测序数据为辅的方式学习一下如何拼接组装一个基因组。但是三代测序数据刚到手就懵了，与之前学习的转录组分析不一样，三代测序返回的几个文件不是单纯的fq文件，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;h</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="基因组三代测序分析" scheme="http://www.shelven.com/categories/%E5%9F%BA%E5%9B%A0%E7%BB%84%E4%B8%89%E4%BB%A3%E6%B5%8B%E5%BA%8F%E5%88%86%E6%9E%90/"/>
    
    
    <category term="nanoplot" scheme="http://www.shelven.com/tags/nanoplot/"/>
    
    <category term="filtlong" scheme="http://www.shelven.com/tags/filtlong/"/>
    
  </entry>
  
  <entry>
    <title>NCBI的BLAST+工具本地安装，本地建库和BLAST比对</title>
    <link href="http://www.shelven.com/2022/06/17/a.html"/>
    <id>http://www.shelven.com/2022/06/17/a.html</id>
    <published>2022-06-16T18:33:56.000Z</published>
    <updated>2022-06-17T15:33:13.270Z</updated>
    
    <content type="html"><![CDATA[<p>接触过生物学的小伙伴对<a href="https://blast.ncbi.nlm.nih.gov/Blast.cgi">NCBI在线BLAST网页</a>一定不陌生，简单介绍一下这个网页的5种比对工具：</p><ul><li>blastn    用核苷酸序列检索核苷酸数据库</li><li>blastp    用蛋白质序列检索蛋白质数据库</li><li>blastx    核苷酸序列通过6种阅读框翻译不同蛋白序列后，检索蛋白数据库</li><li>tblastn    蛋白序列比对核酸库，核酸数据库通过6种开放阅读框翻译不同蛋白质</li><li>tblastx    核酸序列和核酸数据库都通过6种开放阅读框翻译后比对</li></ul><p>平常我们用的最多的就是blastn和blastp，进入网页，选择blast方式，然后贴上自己的quary序列，选择数据库，选择比对的物种，设置参数如E值，wordlength长度等等。但是NCBI网站的BLAST在线工具有个让人特别无语的缺点：<strong>国内访问速度巨慢</strong>！不仅仅是比对过程慢，一条序列还好，大批量数据比对就不要想了，有的时候网页都打不开一直转圈圈。因此本地化blast工具还是很有必要的。</p><p>好在NCBI很贴心地提供了blast+工具，我们安装好blast+工具和下载好数据库以后，就可以不依赖网页和NCBI地服务器，在本地服务器上运行了。</p><h2 id="1-安装blast"><a href="#1-安装blast" class="headerlink" title="1 安装blast+"></a>1 安装blast+</h2><div class="story post-story"><p>最新版blast+工具可以通过ftp方式获得，<a href="https://ftp.ncbi.nlm.nih.gov/blast/executables/blast+/LATEST/">点击这里</a></p><p>我是在集群账户下安装，集群机器都是linux操作系统的，因此我选择的最新linux版本</p><p><img src="https://www.shelven.com/tuchuang/20220616/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220616/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><strong>别忘了要连md5校验文件一起下载</strong>，谁都不知道下载过程中是否会出错，因此大的文件下载完以后都是需要验证文件完整性的！</p><p>将上面的ftp地址拼凑一下，网速好的话可以直接用wget下载，但是我这边服务器连NCBI网速实在太慢了，wget只有10Kb&#x2F;s的速度，甚至还会断开重连。看的我高血压都要犯了，无奈之下挂了个梯子，在自己电脑上下载好这两份文件，通过xftp传到了服务器上。</p><p>在服务器上首先校验文件完整性:</p><p><code>md5sum -c ncbi-blast-2.13.0+-x64-linux.tar.gz.md5</code></p><p>显示结果OK后，解压：</p><p><code>tar -zxvf ncbi-blast-2.13.0+-x64-linux.tar.gz</code></p><p>名字太长了，不方便以后找，顺便改个名就叫blast：</p><p><code>mv ncbi-blast-2.13.0+-x64-linux.tar.gz blast</code></p><p>然后是配置环境变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc       # 编辑环境变量文件</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在.bashrc文件最后一行加入如下内容（根据自己路径修改）</span></span><br><span class="line">export PATH=&quot;/public/home/wlxie/blast/bin:$PATH&quot;</span><br></pre></td></tr></table></figure><p>保存退出后重新source一下.bashrc文件，blast+工具就安装好了。</p></div><h2 id="2-下载nr-x2F-nt数据库"><a href="#2-下载nr-x2F-nt数据库" class="headerlink" title="2 下载nr&#x2F;nt数据库"></a>2 下载nr&#x2F;nt数据库</h2><div class="story post-story"><p>我们比对一般用的是NCBI的非冗余蛋白&#x2F;核酸数据库，有两种方法下载nr&#x2F;nt数据库：</p><ul><li><p>1.通过blast+工具自带的更新程序下载</p></li><li><p>2.通过aspera工具下载</p></li></ul><p>同样是网速的问题，如果用第一种方法下载，我们可以在~&#x2F;blast&#x2F;bin目录下找到如下的perl程序</p><p><img src="https://www.shelven.com/tuchuang/20220616/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220616/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>直接运行命令 <code>perl update_blastdb.pl nt</code></p><p>但是10几kb&#x2F;s的速度真的让人抓狂，所以我推荐第二种方法：用IBM公司开发的快速下载神器——aspera</p><h3 id="安装aspera"><a href="#安装aspera" class="headerlink" title="安装aspera"></a>安装aspera</h3><p>在我之前写的一篇博客里推荐过sra-tools工具中的prefetch，用来下载SRA数据中存放的高通量测序原始数据。prefetch软件就是默认通过aspera工具进行下载的。</p><p>如果之前没有安装过aspera，可以用conda直接安装，命令如下：</p><p><code>conda install -c hcc aspera-cli</code></p><p>这里注意下aspera-cli是aspera的命令行版本，各种不同版本的本质上下载都是调用ascp程序，并且需要<strong>openssh公钥认证</strong>，不同版本的aspera公钥文件存放的位置不同。因为我们是通过conda安装的aspera，aspera-cli公钥文件的位置在<strong>你的conda环境目录下的etc文件夹中</strong>，比如我的aspera-cli公钥文件在&#x2F;public&#x2F;home&#x2F;wlxie&#x2F;miniconda3&#x2F;envs&#x2F;biosoft&#x2F;etc</p><p>而且因为是conda安装的，我们不需要修改什么配置文件和依赖关系，还是挺省事的。</p><h3 id="用aspera下载数据库nr-x2F-nt"><a href="#用aspera下载数据库nr-x2F-nt" class="headerlink" title="用aspera下载数据库nr&#x2F;nt"></a>用aspera下载数据库nr&#x2F;nt</h3><p>nr&#x2F;nt数据库也可以通过ftp方式获得，<a href="https://ftp.ncbi.nlm.nih.gov/blast/db/FASTA/">点击这里查看ftp网址</a></p><p>为了方便找到下载到本地的数据库，先在家目录新建db&#x2F;blast文件夹，进入这个文件夹后，在当前目录下运行如下命令：</p><p><code>ascp -QT -i /public/home/wlxie/miniconda3/envs/biosoft/etc/asperaweb_id_dsa.openssh -k1 -l 500m anonftp@ftp.ncbi.nlm.nih.gov:/blast/db/FASTA/nt.gz ./</code></p><p>这里是其中一个nt数据库，nr数据库只要改一个字母就行了，两个数据库都要下载。</p><p>稍微解释下各参数的含义：</p><ul><li>-Q 用于自适应流量控制，磁盘限制所需；-T 是取消加密，否则有时候数据下载不了。两个参数是搭配一起使用的</li><li>-i 输入私钥文件，注意下载的ascp版本不一样文件位置也不一样</li><li>-k1 这里是加上了断点传续功能</li><li>-l 限制最大下载速度</li><li>后面一串是账户@ftp地址:路径。<strong>注意@和冒号</strong>。NCBI公共账号是<strong>anonftp</strong>，也就是你下载SRA数据库数据也可以用这个账号；EBI公共账号是<strong>era-fasp</strong></li><li>最后指定下载文件的路径，我用了当前路径</li></ul><p><img src="https://www.shelven.com/tuchuang/20220616/3.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220616/3.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>可以看到下载速度杠杠的，提升了不知道多少倍…下载大数据都可以用ascp命令。</p><p><strong>下载好之后同样别忘了校验md5文件，校验后gunzip直接解压到当前文件夹。</strong></p></div><h2 id="3-本地建库"><a href="#3-本地建库" class="headerlink" title="3 本地建库"></a>3 本地建库</h2><div class="story post-story"><p>解压完成以后我们可以看到这两个数据库总大小在980G</p><p><img src="https://www.shelven.com/tuchuang/20220616/5.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220616/5.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>现在还不能用这两个数据库，需要对这两个超大的数据文件建索引，也就是本地建库。</p><p>使用如下命令：</p><p><code>makeblastdb -in nt -dbtype nucl -input_type fasta -out nt</code></p><p><code>makeblastdb -in nr -dbtype prot -input_type fasta -out nr</code></p><ul><li>-in: 待格式化的序列文件</li><li>-dbtype: 数据类型，prot为蛋白序列，nucl为核酸序列</li><li>-input_type: 输入数据的类型，默认为fasta格式</li><li>-out: 自定义的数据库名称</li></ul><p><img src="https://www.shelven.com/tuchuang/20220616/7.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220616/7.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><img src="https://www.shelven.com/tuchuang/20220616/8.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220616/8.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>这一步需要非常长时间，在目录下能看到有文件生成并且没有报错就行了，同样的操作方法可以用<strong>自己的基因组数据建库</strong>。</p><p>这里有两条核苷酸序列可能有问题，序列录到了开头第一行，不过就只有两条序列应该不影响。nt库录入了0.8亿条序列，nr库录入了4.8亿条序列。</p></div><h2 id="4-创建blast全局配置文件"><a href="#4-创建blast全局配置文件" class="headerlink" title="4 创建blast全局配置文件"></a>4 创建blast全局配置文件</h2><div class="story post-story"><p>在家目录下创建blast全局配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">vim .ncbirc        <span class="comment"># 家目录下创建一个新文件.ncbirc，输入如下内容</span></span></span><br><span class="line"></span><br><span class="line">; Start the section for BLAST configuration</span><br><span class="line"></span><br><span class="line">[BLAST]</span><br><span class="line"></span><br><span class="line">; Specifies the path where BLAST databases are installed</span><br><span class="line"></span><br><span class="line">BLASTDB=/public/home/wlxie/db/blast</span><br><span class="line"></span><br><span class="line">; Specifies the data sources to use for automatic resolution</span><br><span class="line"></span><br><span class="line">; for sequence identifiers</span><br><span class="line"></span><br><span class="line">DATA_LOADERS=blastdb</span><br><span class="line"></span><br><span class="line">; Specifies the BLAST database to use resolve protein sequences</span><br><span class="line"></span><br><span class="line">BLASTDB_PROT_DATA_LOADER=/public/home/wlxie/db/blast/nr</span><br><span class="line"></span><br><span class="line">; Specifies the BLAST database to use resolve protein sequences</span><br><span class="line"></span><br><span class="line">BLASTDB_NUCL_DATA_LOADER=/public/home/wlxie/db/blast/nt</span><br><span class="line"></span><br><span class="line">BATCH_SIZE=10G</span><br><span class="line"></span><br><span class="line">; Windowmasker settings</span><br><span class="line"></span><br><span class="line">[WINDOW_MASKER]</span><br><span class="line"></span><br><span class="line">WINDOW_MASKER_PATH=/public/home/wlxie/db/blast/windowmasker</span><br><span class="line"></span><br><span class="line">; end of file</span><br></pre></td></tr></table></figure><p>以上设置中定义了blastn和blastp默认的地址，这样我们在比对数据库的时候可以直接输入数据库的名称而不用给出绝对路径，方便一点（这步不是必须的，可选）。</p></div><h2 id="5-运行blast程序"><a href="#5-运行blast程序" class="headerlink" title="5 运行blast程序"></a>5 运行blast程序</h2><div class="story post-story"><p>以上准备工作完成后，准备一段query序列试一下，我的query序列名称是gene.fna</p><p>运行blastn程序：</p><p><code>blastn -query gene.fna -out gene_blastn_nr.out -db nt -outfmt 6 -evalue 1e-5 -num_threads 10</code></p><ul><li>-query: 用来查询的输入序列</li><li>-db: 指定的数据库名称</li><li>-out: 自定义输出的结果文件，最好统一格式。我是基因名_比对方法_数据库.out，这样比较直观知道比对了什么，怎么比对的</li><li>-outfmt: blast结果的呈现形式，<strong>一般用6比较多</strong>，也就是m8格式，以制表符为分隔符，有部分信息会缺失。5是XML格式比较适合解析，7在6基础上加了表头。</li><li>-evalue: 限定E值</li><li>-num_threads: 指定多少个核运行blast程序</li></ul><p>还有其他参数比如就不一一介绍了，说明一下，一个序列的blast可以用上面的命令，多个序列的blast同样适用，把多个fasta格式的序列放进去即可。</p><p>当然，批量blast的结果需要限定匹配的结果数量，毕竟我们不可能几百上千个序列一一查看，可以指定参数-max_target_seqs 5限制每个序列的最大匹配数量，这个数值推荐是在5以上，5以下会有警告信息。</p><p>blast结果m8格式如下：</p><p><img src="https://www.shelven.com/tuchuang/20220616/9.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220616/9.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>一共12列，分别能获得如下信息：</p><blockquote><p>1、Query id：查询序列ID标识</p><p>2、Subject id：比对上的目标序列ID标识</p><p>3、% identity：序列比对的<strong>一致性</strong>百分比</p><p>4、alignment length：符合比对的比对区域的长度</p><p>5、mismatches：比对区域的错配数</p><p>6、gap openings：比对区域的gap数目</p><p>7、q. start：比对区域在查询序列(Query id)上的起始位点</p><p>8、q. end：比对区域在查询序列(Query id)上的终止位点</p><p>9、s. start：比对区域在目标序列(Subject id)上的起始位点</p><p>10、s. end：比对区域在目标序列(Subject id)上的终止位点</p><p>11、e-value：比对结果的期望值，解释是大概多少次随即比对才能出现一次这个score，Evalue越小，表明这种情况从概率上越不可能发生，那么发生了即说明这更有可能是真实的相似序列</p><p>12、bit score：比对结果的bit score值，越高越好</p></blockquote></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;接触过生物学的小伙伴对&lt;a href=&quot;https://blast.ncbi.nlm.nih.gov/Blast.cgi&quot;&gt;NCBI在线BLAST网页&lt;/a&gt;一定不陌生，简单介绍一下这个网页的5种比对工具：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;blastn    用核苷酸序列检索核苷</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="基因组三代测序分析" scheme="http://www.shelven.com/categories/%E5%9F%BA%E5%9B%A0%E7%BB%84%E4%B8%89%E4%BB%A3%E6%B5%8B%E5%BA%8F%E5%88%86%E6%9E%90/"/>
    
    
    <category term="BLAST+" scheme="http://www.shelven.com/tags/BLAST/"/>
    
    <category term="aspera" scheme="http://www.shelven.com/tags/aspera/"/>
    
  </entry>
  
  <entry>
    <title>perl语言学习笔记（1）</title>
    <link href="http://www.shelven.com/2022/06/16/a.html"/>
    <id>http://www.shelven.com/2022/06/16/a.html</id>
    <published>2022-06-15T16:07:31.000Z</published>
    <updated>2022-06-15T16:10:16.104Z</updated>
    
    <content type="html"><![CDATA[<p>最近在处理三代测序的下机数据，用到了一些挺好用的perl脚本，但是苦于没接触这种类型的编程语言，想根据情况改一些代码却看不懂实现方式**&#x3D; &#x3D;**</p><p>前面说学习perl可以只学怎么调用模块，马上啪啪打脸了，这货和python还是有点不一样的，还是抽空补补基础吧~现在做生信用的最多的就是R、python和perl，多掌握一门编程语言还是挺有必要的。记录一下自学的过程和笔记，自学视频来源是b站up主<a href="https://space.bilibili.com/338686099?spm_id_from=333.337.0.0">生信技能树-jimmy</a></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><div class="story post-story"><p>首先了解一下perl脚本的结构，以blast结果过滤的perl脚本为例，输入文件blast_m8.out是一个12列，分隔符为空格的文件：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/perl -w      # 选择解释器类型为perl，-w是运行错误时提供警告信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> IN,<span class="string">&quot;blast_m8.out&quot;</span>;     <span class="comment"># 打开文件，m8格式输出的blastout文件。每次只读一行</span></span><br><span class="line"><span class="keyword">while</span> (&lt;IN&gt;) &#123;      <span class="comment"># 大括号为程序块，每个程序块是一个独立的部分，执行相对独立的功能</span></span><br><span class="line">    <span class="keyword">chomp</span>;      <span class="comment"># 去掉读进来数据结尾的换行符\n（没有换行符则不起作用）</span></span><br><span class="line">    <span class="keyword">my</span> @line=<span class="keyword">split</span> <span class="regexp">/\s+/</span>,$_;        <span class="comment"># 以空白分割(\s是匹配任何空白符，+表示匹配任意多个),存入数组中</span></span><br><span class="line">    <span class="keyword">if</span> ($line[<span class="number">2</span>] &gt;=<span class="number">50</span> &amp;&amp; $line[<span class="number">3</span>] &gt;=<span class="number">100</span>) &#123;</span><br><span class="line">        <span class="keyword">print</span> <span class="string">&quot;$_\n&quot;</span>;       <span class="comment"># 将第三列identity值大于50，第四列序列长度大于100的blast结果输出</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">next</span>;       <span class="comment"># 否则进入下一个循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">close</span> IN;</span><br><span class="line"><span class="comment"># 这个脚本第四行的my也要注意下，一般是需要申明use strict;也就是使用严谨的方式，在这种方式下，任何变量都必须先定义，不使用my的话定义第一次出现的$和@运行会报错。初学可以不使用use strict。</span></span><br><span class="line"><span class="comment"># $_这个变量是使用非常多的，如果没有定义变量名称，则默认使用$_</span></span><br></pre></td></tr></table></figure><p>OK，格式与python不一样，以<strong>分号</strong>作为每一行结尾，基础语法类似但不完全一样，先从基础学起。</p></div><h2 id="1-标量数据"><a href="#1-标量数据" class="headerlink" title="1 标量数据"></a>1 标量数据</h2><div class="story post-story"><h3 id="标量数据特点"><a href="#标量数据特点" class="headerlink" title="标量数据特点"></a>标量数据特点</h3><ul><li>perl中最基本的数据类型</li><li>可以是数字、字母</li><li>无需定义类型（所有perl语言的数据都是双精度浮点型，<strong>不需要对数据类型进行定义</strong>，代价是消耗内存）</li><li>“单数为标量”</li></ul><h3 id="字符串运算"><a href="#字符串运算" class="headerlink" title="字符串运算"></a>字符串运算</h3><ul><li>字符串就是一连串字符组合，可以是字母数字标点等</li><li>对DNA序列处理本质上就是处理字符串</li><li>字符串可以为空</li><li>需要“引号”，尽量使用双引号</li><li>字符串连接“.”或者“x”  如 “hello” . “world”</li></ul><h3 id="标量变量"><a href="#标量变量" class="headerlink" title="标量变量"></a>标量变量</h3><p>标量变量用来动态存储标量值，以美元符号$表示（定义数组用@符号），<strong>和linux一样不能以数字开头</strong></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一个=表示赋值，两个==表示判断，这里和python是一样的</span></span><br><span class="line">$gene_num=<span class="number">3</span></span><br><span class="line">$gene_num=$gene_num+<span class="number">4</span></span><br><span class="line">$gene_num+=<span class="number">4</span>        <span class="comment"># 双目运算符，运算所需变量为两个运算符，这个简写是非常常用的</span></span><br><span class="line">$dna=<span class="string">&quot;ATCGGGTATCG&quot;</span></span><br><span class="line">$dna.=<span class="string">&quot;ATCGGGTCG&quot;</span>       <span class="comment"># 双目运算符同样可以用于字符串操作，得到标量变量为连接的字符串</span></span><br></pre></td></tr></table></figure></div><h2 id="2-数组和列表"><a href="#2-数组和列表" class="headerlink" title="2 数组和列表"></a>2 数组和列表</h2><div class="story post-story"><h3 id="数组构建"><a href="#数组构建" class="headerlink" title="数组构建"></a>数组构建</h3><p>列表（list）指标量的有序集合，数组（array）则是存储列表的变量</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@array=（<span class="number">1</span>,<span class="string">&quot;hello&quot;</span>,<span class="keyword">undef</span>,$dna,<span class="number">5</span>）;      <span class="comment"># 左边为数组，右边为列表，构建列表中间用逗号隔开</span></span><br><span class="line">$array[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">$array[<span class="number">1</span>]=<span class="string">&quot;hello&quot;</span>       <span class="comment"># 注意下标数字从0开始，0表示第一个元素</span></span><br><span class="line">数组的最后一个元素角标$#array，因此数组元素个数=$#array+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">@number=(<span class="number">1</span>..<span class="number">100</span>)        <span class="comment"># 范围操作符(..)每次加一</span></span><br><span class="line">@string=<span class="string">qw (fred barney betty wilma dino)</span>       <span class="comment"># qw操作符可以省略逗号</span></span><br></pre></td></tr></table></figure><h3 id="split和join函数"><a href="#split和join函数" class="headerlink" title="split和join函数"></a>split和join函数</h3><ul><li>split将字符串根据固定的分隔符进行切割，切割后得到一个数组</li><li>join与split相反，将数组连接成一个标量</li></ul><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/perl</span></span><br><span class="line"></span><br><span class="line">$scalar=<span class="string">&quot;a:bcd:123:de&quot;</span>;</span><br><span class="line">@array=<span class="keyword">split</span> <span class="regexp">/:/</span>,$scalar;       <span class="comment"># 以冒号作为分隔符分割</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;@array\n&quot;</span></span><br><span class="line"></span><br><span class="line">$new_scalar=<span class="keyword">join</span> <span class="string">&quot;\t&quot;</span>,@array;       <span class="comment"># 以制表符作为分割符，好处是excel里打开每个元素在不同单元格</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;$new_scalar\n&quot;</span></span><br></pre></td></tr></table></figure><h3 id="pop和push函数"><a href="#pop和push函数" class="headerlink" title="pop和push函数"></a>pop和push函数</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/perl</span></span><br><span class="line">@number=(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">$value=<span class="keyword">pop</span> @number;     <span class="comment"># pop提取数组的最后一个元素</span></span><br><span class="line"><span class="keyword">push</span> @number,<span class="number">6</span>;     <span class="comment"># push添加一个元素到数组的末尾</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;$value\n@number\n&quot;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://www.shelven.com/tuchuang/20220615/01.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220615/01.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="shift和unshift函数"><a href="#shift和unshift函数" class="headerlink" title="shift和unshift函数"></a>shift和unshift函数</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/perl</span></span><br><span class="line">@number=(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">$value=<span class="keyword">shift</span> @number;       <span class="comment"># shift提取数组第一个元素</span></span><br><span class="line"><span class="keyword">unshift</span> @number,<span class="number">10</span>;     <span class="comment"># unshift添加一个元素到数组的开头</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;$value\n@number\n&quot;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://www.shelven.com/tuchuang/20220615/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220615/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>一般来说pop和shift用的比较多，一个提取数组末尾元素，一个提取数组开头元素。</p><p>因为我们用perl处理的往往是矩阵文件，第一行是ID信息，我们往往是读入一行数据，去掉换行符，存储为标量，分割数组。这个时候就要用shift函数，将ID提取出来，这样呢后面都是<strong>同一种类型的数据</strong>，方便我们操作，也就是底下这个框架：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/perl</span></span><br><span class="line"><span class="keyword">while</span> (&lt;IN&gt;) &#123;</span><br><span class="line">    <span class="keyword">chomp</span>;</span><br><span class="line">    <span class="keyword">my</span> @line=<span class="keyword">split</span> <span class="regexp">/\s+/</span>,$_;</span><br><span class="line">    <span class="keyword">my</span> @id=<span class="keyword">shift</span> @line；</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot;$id\n&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sort和reverse函数"><a href="#sort和reverse函数" class="headerlink" title="sort和reverse函数"></a>sort和reverse函数</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/perl</span></span><br><span class="line">@number=(<span class="number">1</span>..<span class="number">10</span>);</span><br><span class="line">@number_sort=<span class="keyword">sort</span> @number;      <span class="comment"># sort函数使数组按照ASCII码大小排序</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;@number_sort\n&quot;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://www.shelven.com/tuchuang/20220615/3.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220615/3.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>可以看到10在1的后面，因为sort函数是以<strong>ASCII码大小</strong>进行排序的。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/perl</span></span><br><span class="line">$dna=<span class="string">&quot;ATCGCGTAGCATCGATGCTGATCATGC&quot;</span>;</span><br><span class="line">$dna_reverse=<span class="keyword">reverse</span> $dna;      <span class="comment"># reverse函数可以使数组或者字符串反转</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;$dna_reverse\n&quot;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://www.shelven.com/tuchuang/20220615/4.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220615/4.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>reverse函数在做DNA反向互补配对的时候能用到。</p><h3 id="foreach遍历数组"><a href="#foreach遍历数组" class="headerlink" title="foreach遍历数组"></a>foreach遍历数组</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/perl</span></span><br><span class="line">@number=(<span class="number">1</span>..<span class="number">10</span>);</span><br><span class="line"><span class="keyword">foreach</span> $num (@number) &#123;        <span class="comment"># 遍历数组中的值依迭代</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot;$num\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以省略一部分内容</span></span><br><span class="line"><span class="comment">#!/bin/perl</span></span><br><span class="line">@number=(<span class="number">1</span>..<span class="number">10</span>);</span><br><span class="line"><span class="keyword">foreach</span> (@number) &#123;     <span class="comment"># 省略了$num，存储到默认的$_中</span></span><br><span class="line">    <span class="keyword">print</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在处理三代测序的下机数据，用到了一些挺好用的perl脚本，但是苦于没接触这种类型的编程语言，想根据情况改一些代码却看不懂实现方式**&amp;#x3D; &amp;#x3D;**&lt;/p&gt;
&lt;p&gt;前面说学习perl可以只学怎么调用模块，马上啪啪打脸了，这货和python还是有点不一样的，</summary>
      
    
    
    
    <category term="编程自学" scheme="http://www.shelven.com/categories/%E7%BC%96%E7%A8%8B%E8%87%AA%E5%AD%A6/"/>
    
    
    <category term="perl" scheme="http://www.shelven.com/tags/perl/"/>
    
  </entry>
  
  <entry>
    <title>基因组注释文件gbff格式转换gff3格式</title>
    <link href="http://www.shelven.com/2022/06/14/a.html"/>
    <id>http://www.shelven.com/2022/06/14/a.html</id>
    <published>2022-06-13T17:09:45.000Z</published>
    <updated>2022-06-13T17:24:07.097Z</updated>
    
    <content type="html"><![CDATA[<p>前几天老师布置了一个任务，寻找夹竹桃科Apocynaceae分类下的物种参考基因组，我在plaBiPD网站和NCBI的genome数据库中只找到包括罗布麻在内的5个已发表物种参考基因组，且都是<strong>gbff</strong>格式的。提交之后被告知需要<strong>gff</strong>格式的，因为gbf格式中没有基因相关结构的位置信息。</p><p>emmmmm….其实不是很理解，因为gbff格式和gff格式是可以相互转换的，如果gbff注释文件中有信息缺失，那么gff格式也同样没有相关信息….不管怎么样先转换个格式交差，网上搜了下有前人写的<strong>perl脚本</strong>可以用，但是我以前没接触过perl语言，这里做个笔记写一下自己瞎捣鼓的过程。</p><h2 id="1-perl语言和CPAN模块库"><a href="#1-perl语言和CPAN模块库" class="headerlink" title="1. perl语言和CPAN模块库"></a>1. perl语言和CPAN模块库</h2><div class="story post-story"><p>从<a href="https://baike.baidu.com/item/perl/851577?fr=aladdin">百度百科</a>中引用对perl语言的一段描述：</p><blockquote><p>Perl是一种功能丰富的计算机程序语言，易于使用、高效、完整，而不是美观（小巧，优雅，简约）。同时支持过程和面向对象编程，对文本处理具有强大的内置支持，并且拥有第三方模块集合之一。 Perl借取了C、sed、awk、shell脚本语言以及很多其他程序语言的特性，其中最重要的特性是它内部集成了正则表达式的功能，以及巨大的第三方代码库CPAN。</p></blockquote><p>看到这个简介，个人的理解就是perl语言就像python一样，自己有丰富的第三方库可以调用。同样，我们不需要具体了解每个模块的实现方式和底层代码，只要知道会调用相关的模块实现自己的目标即可。</p><p>CPAN是perl的一个第三方源码模块库，里面有上百万的perl模块，用于支撑perl的各种功能。为了方便安装perl的各种模块，前人做了一个CPAN模块，用cpan命令来安装perl的各个模块。也可以通过cpan命令来安装bioperl模块，里面有非常多的有关生信分析的perl脚本。</p></div><h2 id="2-安装和配置bioperl"><a href="#2-安装和配置bioperl" class="headerlink" title="2. 安装和配置bioperl"></a>2. 安装和配置bioperl</h2><div class="story post-story"><p>运行gbff转换gff3的perl脚本需要调用bioperl的一些模块，因此第一步需要安装bioperl，以及配置相应的环境。</p><p>登录学校集群，发现系统自带安装了perl程序和CPAN模块，我们可以用CPAN来安装bioperl。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在命令行进入CPAN交互式界面</span></span><br><span class="line">perl -MCPAN -e shell</span><br></pre></td></tr></table></figure><p>进入CPAN交互式界面如下：</p><p><img src="https://www.shelven.com/tuchuang/20220613/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220613/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在线寻找bioperl安装包</span></span><br><span class="line">cpan&gt;d /bioperl/</span><br><span class="line"><span class="comment"># 安装对应版本的bioperl，注意目录和版本号根据搜出来的结果不同而不同</span></span><br><span class="line">cpan&gt;install S/SE/SENDU/bioperl-<span class="number">1.5</span>.<span class="number">2_100</span>.tar.gz </span><br></pre></td></tr></table></figure><p>之后就是漫长的安装过程了，所有依赖关系也会一并安装，安装的时间较长，大概需要半个小时。</p><p>安装完成之后是配置环境变量，不配置的话即使安装了bioperl，也会找不到对应的模块。我的bioperl安装路径是&#x2F;public&#x2F;home&#x2F;wlxie&#x2F;miniconda3&#x2F;envs&#x2F;biosoft&#x2F;lib&#x2F;perl5&#x2F;site_perl&#x2F;5.22.0&#x2F;Bio&#x2F;，可以通过<code>echo $PERL5LIB</code>来查看当前perl模块的调用路径，然后在家目录的.bashrc环境变量文件中将bioperl的模块路径加到perl模块调用的路径当中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在。bashrc文件最后一行加入bioperl模块调用路径</span></span><br><span class="line">export PERL5LIB=&quot;/public/home/wlxie/miniconda3/envs/biosoft/lib/perl5/site_perl/5.22.0/:$PERL5LIB&quot;</span><br></pre></td></tr></table></figure><p>这样所有的配置就完成了。</p></div><h2 id="3-gbff格式转换gff3"><a href="#3-gbff格式转换gff3" class="headerlink" title="3. gbff格式转换gff3"></a>3. gbff格式转换gff3</h2><div class="story post-story"><p>github上有许多gbff格式转gff3格式的脚本代码，有用biopython做的，也有bioperl做的，可能是我配置的问题，试了几个脚本后只有一个可以顺利转换。本来想研究一下脚本的实现方式，可是源代码2000多行看的我实在不知从何下手，这里只记录一下使用方法和备份脚本文件。</p><p>源代码的出处已经找不到了…<a href="https://www.shelven.com/script_backup/bp_genbank2gff3.pl">点击这里查看源代码在本站的备份</a></p><p>使用方法：</p><p>将脚本文件bp_genbank2gff3.pl放在要转换格式的gbff文件<strong>同一个目录下</strong>，运行命令</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># perl bp_genbank2gff3.pl gbff文件名</span></span><br><span class="line">perl bp_genbank2gff3.pl Asclepias_syriaca-GCA_002018285.<span class="number">1_</span>ASM201828v1_genomic.gbff</span><br></pre></td></tr></table></figure><p>脚本自动运行，结束后会在当前目录生成<strong>同名的gff3文件</strong></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前几天老师布置了一个任务，寻找夹竹桃科Apocynaceae分类下的物种参考基因组，我在plaBiPD网站和NCBI的genome数据库中只找到包括罗布麻在内的5个已发表物种参考基因组，且都是&lt;strong&gt;gbff&lt;/strong&gt;格式的。提交之后被告知需要&lt;strong</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="bioperl" scheme="http://www.shelven.com/tags/bioperl/"/>
    
    <category term="perl" scheme="http://www.shelven.com/tags/perl/"/>
    
  </entry>
  
  <entry>
    <title>集群和slurm调度系统使用心得</title>
    <link href="http://www.shelven.com/2022/05/25/a.html"/>
    <id>http://www.shelven.com/2022/05/25/a.html</id>
    <published>2022-05-24T18:05:26.000Z</published>
    <updated>2022-06-21T11:27:33.293Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><div class="story post-story"><p>随着各种组学技术和生物信息学技术的发展，高通量测序现在已经广泛应用到生命科学的多个领域，这些测序数据动辄几个G甚至几十上百G（主要看物种和测序深度），个人电脑对这些大量的数据处理时有些力不从心。</p><p>比如我的小破电脑，4核，2G运行内存，在对16个10X测序深度的拟南芥转录组数据进行回帖参考基因组时，cpu满载的情况下跑了整整一个晚上，拟南芥的参考基因组还是比较小的（只有116M大小）。因此在需要做大量数据处理的时候我们往往都会用到<strong>计算机集群</strong>。</p></div><h2 id="1-计算机集群介绍"><a href="#1-计算机集群介绍" class="headerlink" title="1. 计算机集群介绍"></a>1. 计算机集群介绍</h2><div class="story post-story"><p>先上一段<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%9B%86%E7%BE%A4/1728905?fr=aladdin">百度百科</a>的介绍</p><blockquote><p><strong>计算机集群</strong>简称<strong>集群，</strong>是一种计算机系统， 它通过一组松散集成的计算机软件或硬件连接起来高度紧密地协作完成计算工作。在某种意义上，他们可以被看作是一台计算机。</p><p>集群系统中的单个计算机通常称为节点，通常通过局域网连接，但也有其它的可能连接方式。集群计算机通常用来改进单个计算机的计算速度和&#x2F;或可靠性。一般情况下集群计算机比单个计算机，比如工作站或超级计算机性能价格比要高得多。</p></blockquote><p>简单来说集群就是一群电脑连接在一起完成同一个工作，自然是比单个电脑工作效率高得多。</p><p>塔大有着南疆最大的超算中心，我用测试账号登录大致看了下节点配置信息和存储规模：</p><p><img src="https://www.shelven.com/tuchuang/20220524/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220524/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><img src="https://www.shelven.com/tuchuang/20220524/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220524/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>可以看到塔大集群有三个分区：debug、normal和operation，其中debug是默认分区。</p><p>每个分区下都有admin91、admin92和computer1-6共计8个节点，从状态栏可以看到admin91节点处于down状态，一般来说只有故障节点才会显示状态down，但是我看了下登录节点的hostname就是admin91（<strong>admin91是登录节点</strong>），可能就是这样设置的，防止用户申请到登录节点资源（学校规定禁止在登录节点运行脚本程序，为了防止用户占用太多登录节点资源）。<strong>computer1-6都是计算节点</strong>，可以看到状态栏是idle也就是空闲的。<strong>admin92是个胖节点</strong>，状态却是drain也就是不能分配，这个我不理解，如果要运行并行命令就要用到胖节点。</p><p>裸储存容量算个大概<strong>450TB</strong>左右，不算大不算小，够用就行。</p><p>顺便看一下各个节点的性能：</p><p><img src="https://www.shelven.com/tuchuang/20220524/3.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220524/3.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><img src="https://www.shelven.com/tuchuang/20220524/4.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220524/4.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><img src="https://www.shelven.com/tuchuang/20220524/5.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220524/5.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>稍微计算一下可以发现，计算节点computer1-6每个节点有128个核，每个核2G运行内存；登录节点admin91有64个核，每个核4G运行内存<del>（不是很理解登录节点为什么要这么豪华……）</del>；胖节点admin92有256个核，每个核4G运行内存。总的来说，放在内地比可能确实不怎么样，但是在新疆可以说是奢华顶配了……</p></div><h2 id="2-slurm调度系统介绍"><a href="#2-slurm调度系统介绍" class="headerlink" title="2. slurm调度系统介绍"></a>2. slurm调度系统介绍</h2><div class="story post-story"><p>塔大集群用的是slurm调度系统，简单来说就是借助slurm这个资源管理系统，将超算中心的集群计算机统一管理。slurm是个开源分布式资源管理软件，管理这种大型的计算机集群还是比较高效的，比如天河二号上就使用了 该资源管理系统。集群操作和个人电脑操作不一样的地方是，<strong>我们需要申请计算节点然后才能运行计算的命令</strong>，需要了解一下slurm的作业调度系统。</p><p>了解一下基本概念：一个分区（partition）就是节点的逻辑分组，可以有不同的节点（node）；可以调用几个节点的资源创建作业步（job step），一个作业（job）就是一次资源分配，可以有多个作业步并且可以并发运行。</p><p><img src="https://www.shelven.com/tuchuang/20220524/7.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220524/7.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>再来看一下slurm调度系统的组成成分：</p><p><img src="https://www.shelven.com/tuchuang/20220524/6.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220524/6.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>主要有控制进程slurmcld，记账存储进程Slurmdbd（有的集群是收费的），节点监控进程slurmd，作业管理进程slurmstepd和用户命令工具组成，我们可以不用了解这些进程之间的相互关系，熟悉用户命令比如创建作业，提交作业和查看作业状态即可。</p><h3 id="2-1-创建和提交作业"><a href="#2-1-创建和提交作业" class="headerlink" title="2.1 创建和提交作业"></a>2.1 创建和提交作业</h3><p>slurm作业调度系统有三种模式创建和提交作业：<strong>交互模式——srun</strong>，<strong>批处理模式——sbatch</strong>和<strong>分配模式——salloc</strong>，分别介绍一下~还是再次强调一下，学校集群禁止在登录界面直接运行计算命令，第一次发现会强制终止进程，第二次管理员会注销用户账号。</p><h4 id="2-1-1-交互模式——srun"><a href="#2-1-1-交互模式——srun" class="headerlink" title="2.1.1 交互模式——srun"></a>2.1.1 交互模式——srun</h4><p>交互模式说白了就是我们通过命令行与集群产生可以互动的“交流”，具体过程如下：</p><ul><li>通过终端提交资源分配请求，指定资源数目和限制</li><li>等待资源分配</li><li>获得资源后，自动加载计算任务</li><li>运行中，任务I&#x2F;O传递终端，可与任务进行交互</li><li>任务结束后，资源被释放</li></ul><p>一次执行srun生成一个作业步，也就是一次任务加载，执行一次最简单的hostname命令如下：</p><p><img src="https://www.shelven.com/tuchuang/20220524/9.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220524/9.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>-n 参数指定核数，-w参数指定节点，因此显示的hostname就是computer3。<strong>运行结束后直接释放资源</strong>。</p><p>上面的例子可能没有体现出交互的意义，因为程序比较简单。有些程序在运行的过程中需要人为调整，srun才能体现出优势。</p><h4 id="2-1-2-批处理模式——sbatch"><a href="#2-1-2-批处理模式——sbatch" class="headerlink" title="2.1.2 批处理模式——sbatch"></a>2.1.2 批处理模式——sbatch</h4><p>批处理模式顾名思义特点在于需要自己写批处理脚本，具体过程如下：</p><ul><li>编写作业脚本，指定资源数目和限制</li><li>sbatch提交作业</li><li>作业排队等待资源分配</li><li>分配到资源后在首节点加载执行作业脚本</li><li>任务结束释放资源</li><li>运行结果定向到指定文件夹</li></ul><p>这个模式也是用的最多的，登录塔大集群可以在用户家目录下找到job_example文件夹，里面有不同的slurm脚本提供参考，举个最简单的例子sleep.slurm，我们cat一下看看脚本内容：</p><p><img src="https://www.shelven.com/tuchuang/20220524/8.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220524/8.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>第一行#! 指定解释器类型，和其他脚本都一样；</p><p>第二行开始后面几行的#SBATCH都被识别为sbatch命令，因此后面都加上了对应参数，这里只有sbatch这一行会被识别成命令，注意不是被注释了。如果脚本里写了对应参数内容，命令运行脚本的时候就可以不用加入这些参数。</p><p>第六行开始也就是#以后的部分，才是我们编写脚本要运行的命令。</p><p>参考这个格式，我写了如下一个建立拟南芥参考基因组索引文件的hisat2.slurm脚本：</p><p><img src="https://www.shelven.com/tuchuang/20220524/10.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220524/10.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>申请了job名为job1，一个节点，一个核，显示队列，显示程序运行开始时间，运行程序，显示结束时间。</p><p>提交直接用<code>sbatch hisat2.slurm</code>，很快就获得资源跑完了程序，当前目录下生成了索引文件和默认输出文件slurm-job号.out</p><p><img src="https://www.shelven.com/tuchuang/20220524/11.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220524/11.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>因为输出结果在结果文件里，所以我们屏幕上是看不到运行过程的，要想监控运行过程只能在运行时输入squeue查看，后面会说。<strong>运行结束后同样会自动释放资源。</strong></p><h4 id="2-1-3-分配模式——salloc"><a href="#2-1-3-分配模式——salloc" class="headerlink" title="2.1.3 分配模式——salloc"></a>2.1.3 分配模式——salloc</h4><p>分配模式相比前面两个模式更灵活一些，简单来说就是申请资源，执行运算任务后<strong>手动释放资源</strong>，可以用来在正式提交sbatch前做程序测试，检查代码正确后再写成脚本提交（不过也可以直接提交，不用sbatch）。流程如下：</p><ul><li>提交资源分配请求</li><li>排队等待资源分配</li><li>命令行执行指定的命令</li><li>命令执行结束，exit手动释放资源</li></ul><p>这个比较简单，直接salloc后面接参数申请指定的资源就行，最后一定要exit手动释放资源。</p><p>申请后可以用hostname命令看看申请的是哪个节点，确认是计算节点后再运行计算命令。</p><h4 id="2-1-4-作业提交参数"><a href="#2-1-4-作业提交参数" class="headerlink" title="2.1.4 作业提交参数"></a>2.1.4 作业提交参数</h4><p>知道了三个模式的具体用法，只需要添加对应的参数就行了。没有人会具体记住所有参数，上面只有常用的几个需要记一下。这里记录一下其他常用提交参数：</p><table><thead><tr><th>参数</th><th>含义</th><th>类型</th><th>示例</th></tr></thead><tbody><tr><td>-J</td><td>作业名，squeue看到的作业名</td><td>字符串</td><td>-J wrf；表示作业名称为“wrf”</td></tr><tr><td>-n</td><td>作业申请的总cpu核心数</td><td>数值</td><td>-n 4；表示作业申请4个cpu核心</td></tr><tr><td>-N</td><td>作业申请的节点数</td><td>数值</td><td>-N 1 表示作业申请1个计算节点</td></tr><tr><td>-p</td><td>指定作业提交的分区</td><td>字符串</td><td>-psilicon表示将作业提交到silicon分区</td></tr><tr><td>-t</td><td>指定作业的执行时间</td><td>数值</td><td>-t 30 表示作业的执行时间不超过30分钟</td></tr><tr><td>-o</td><td>指定作业标准输出文件的名称</td><td>字符串</td><td>-o %j，表示使用作业号作为作业标准输出文件的名称</td></tr><tr><td>-e</td><td>指定作业标准错误输出文件名称</td><td>字符串</td><td>-e %j，表示使用作业号作为作业标准错误输出文件名</td></tr><tr><td>-w</td><td>指定分配特定的计算节点</td><td>字符串</td><td>-w computer3 表示使用computer3节点</td></tr><tr><td>-d</td><td>作业依赖关系设置</td><td>字符串</td><td>-d after:123 表示本作业须待作业123开始以后再执行</td></tr></tbody></table><p>顺便最后再提一下交互模式和批处理模式是可以相互结合的，脚本中可以加入srun命令，可以自行尝试。</p><p><img src="https://www.shelven.com/tuchuang/20220524/12.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220524/12.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>如上，可以用sbatch一次性创建100个job，每个job运行一次srun后面的内容，也就是提交并行的100个计算作业。也可以不加–array这个参数，srun最后加上符号&amp;在后台挂起，下一行继续用srun命令，以此来实现并行计算，不过要注意最后一行命令用<strong>wait</strong>等待所有命令运行结束后一起结束，否则读完sbatch就结束了。</p><h3 id="2-2-其他用户命令"><a href="#2-2-其他用户命令" class="headerlink" title="2.2 其他用户命令"></a>2.2 其他用户命令</h3><p>这里再简单列举记录一些常用的用户命令和参数，方便自己后续用到时查阅~</p><h4 id="2-2-1-sinfo-查询信息"><a href="#2-2-1-sinfo-查询信息" class="headerlink" title="2.2.1 sinfo 查询信息"></a>2.2.1 sinfo 查询信息</h4><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-a</td><td>查看所有分区信息（含隐藏分区）</td></tr><tr><td>-d</td><td>查看dead状态（通信异常）的节点和分区的信息，与-r参数对应</td></tr><tr><td>-l</td><td>打印分区（或节点）的详细信息</td></tr><tr><td>-n</td><td>查看指定节点的信息</td></tr><tr><td>-p</td><td>查看指定分区的状态</td></tr><tr><td>-r</td><td>查看计算节点（内部通信）正常的节点和分区的状态，与-d参数对应</td></tr><tr><td>-R</td><td>查看节点不可用的原因，包括管理操作设置的异常</td></tr><tr><td>-t</td><td>查询指定节点状态的分区或节点的信息</td></tr><tr><td>–federation</td><td>显示所有集群的分区（或节点）的信息</td></tr><tr><td>–local</td><td>仅显示当前集群的分区（或节点）的信息</td></tr></tbody></table><h4 id="2-2-2-squeue-查询作业"><a href="#2-2-2-squeue-查询作业" class="headerlink" title="2.2.2 squeue 查询作业"></a>2.2.2 squeue 查询作业</h4><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-A</td><td>查看指定账号的作业</td></tr><tr><td>-a</td><td>显示所有分区（包含隐藏）下的作业和作业步</td></tr><tr><td>-r</td><td>按行显示作业组的每一个作业</td></tr><tr><td>–hide</td><td>不显示隐藏分区或者无权访问的分区中的作业</td></tr><tr><td>-j</td><td>根据指定的作业号查询作业信息</td></tr><tr><td>-l</td><td>长格式显示作业信息</td></tr><tr><td>–federation</td><td>显示所有集群下的作业</td></tr><tr><td>–local</td><td>仅仅查看当前集群的作业</td></tr><tr><td>-n</td><td>按作业名查询作业或作业步</td></tr><tr><td>-p</td><td>按分区查询作业</td></tr><tr><td>-s</td><td>查询作业步</td></tr><tr><td>-t</td><td>指定要显示的作业的状态</td></tr></tbody></table><h4 id="2-2-3-scancel-删除作业"><a href="#2-2-3-scancel-删除作业" class="headerlink" title="2.2.3 scancel 删除作业"></a>2.2.3 scancel 删除作业</h4><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>&lt;job id&gt;</td><td>删除指定job id作业</td></tr><tr><td>–t</td><td>删除指定状态的作业</td></tr><tr><td>–account&#x3D;</td><td>删除指定账号的作业</td></tr><tr><td>–name&#x3D;</td><td>删除指定名称的作业</td></tr><tr><td>–partition&#x3D;</td><td>删除指定分区的作业</td></tr><tr><td>–reservation&#x3D;</td><td>删除指定预约名称的作业</td></tr><tr><td>–user&#x3D;</td><td>删除指定用户的作业</td></tr><tr><td>–nodelist&#x3D;</td><td>删除指定节点的作业</td></tr></tbody></table><h4 id="2-2-4-scontrol-查询详细信息"><a href="#2-2-4-scontrol-查询详细信息" class="headerlink" title="2.2.4 scontrol 查询详细信息"></a>2.2.4 scontrol 查询详细信息</h4><p>这个命令和sinfo相比更为详细，主要能获得4个方面的详细信息</p><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>scontrol show node &lt;name&gt;</td><td>查询指定节点信息</td></tr><tr><td>scontrol show partition &lt;name&gt;</td><td>查询指定分区信息</td></tr><tr><td>scontrol show job</td><td>查询job信息，注意是所有的</td></tr><tr><td>scontrol show config</td><td>查询配置信息，也是所有的</td></tr></tbody></table></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;div class=&quot;story post-story&quot;&gt;&lt;p&gt;随着各种组学技术和生物信息学技术的发展，高通量测序现在已经广泛应用到生命科学的多</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="集群" scheme="http://www.shelven.com/tags/%E9%9B%86%E7%BE%A4/"/>
    
    <category term="slurm" scheme="http://www.shelven.com/tags/slurm/"/>
    
  </entry>
  
  <entry>
    <title>转录组数据分析笔记（10）——初识GO/KEGG富集分析</title>
    <link href="http://www.shelven.com/2022/05/16/a.html"/>
    <id>http://www.shelven.com/2022/05/16/a.html</id>
    <published>2022-05-15T19:47:39.000Z</published>
    <updated>2022-05-15T20:04:18.802Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><div class="story post-story"><p>前面介绍了如何找到差异基因，我们通过R包DESeq2获得了差异表达基因，在此基础上做了更为直观的火山图和差异表达基因热图。但是仅仅知道差异表达基因的名字还不够，我们还要知道它到底有哪些功能和特征，就比如我看到一个很养眼的动漫角色，我就要去查查出自哪部番，是怎么样的人设和背景故事，一样的道理。</p><p>一个基因没有注释信息，那就只是一段核苷酸序列，有了注释信息我们才能知道这个基因在染色体上的定位，在具体的某个代谢途径上发挥什么功能等等。网上能找到很多注释信息的数据库，比如模式生物拟南芥TAIR，人类基因组hg19等等，Bioconductor有一个专门用来搜集注释信息数据库的工具包——AnnotationHub。</p></div><h2 id="1-AnnotationHub注释数据库搜索工具"><a href="#1-AnnotationHub注释数据库搜索工具" class="headerlink" title="1. AnnotationHub注释数据库搜索工具"></a>1. AnnotationHub注释数据库搜索工具</h2><div class="story post-story"><p>用bioconductor下载Annotationhub包，载入（<strong>注：为演示结果，以下命令均在Rstudio终端输入</strong>）</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> library<span class="punctuation">(</span><span class="string">&quot;Annotationhub&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> hub <span class="operator">&lt;-</span> AnnotationHub<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line">C<span class="operator">:</span><span class="punctuation">\</span>Users<span class="punctuation">\</span>HUAWEI<span class="punctuation">\</span>AppData<span class="punctuation">\</span>Local<span class="operator">/</span>R<span class="operator">/</span>cache<span class="operator">/</span>R<span class="operator">/</span>AnnotationHub</span><br><span class="line">  does not exist<span class="punctuation">,</span> create directory<span class="operator">?</span> <span class="punctuation">(</span>yes<span class="operator">/</span>no<span class="punctuation">)</span><span class="operator">:</span> yes</span><br><span class="line">  <span class="operator">|</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">=</span><span class="operator">|</span> <span class="number">100</span>%</span><br><span class="line"></span><br><span class="line">snapshotDate<span class="punctuation">(</span><span class="punctuation">)</span><span class="operator">:</span> <span class="number">2021</span><span class="operator">-</span><span class="number">10</span><span class="operator">-</span><span class="number">20</span></span><br><span class="line"><span class="operator">&gt;</span> hub</span><br><span class="line">AnnotationHub with <span class="number">62386</span> records</span><br><span class="line"><span class="comment"># snapshotDate(): 2021-10-20</span></span><br><span class="line"><span class="comment"># $dataprovider: Ensembl, BroadInstitute, UCSC, ftp://ftp...</span></span><br><span class="line"><span class="comment"># $species: Homo sapiens, Mus musculus, Drosophila melano...</span></span><br><span class="line"><span class="comment"># $rdataclass: GRanges, TwoBitFile, BigWigFile, EnsDb, Rl...</span></span><br><span class="line"><span class="comment"># additional mcols(): taxonomyid, genome,</span></span><br><span class="line"><span class="comment">#   description, coordinate_1_based, maintainer,</span></span><br><span class="line"><span class="comment">#   rdatadateadded, preparerclass, tags, rdatapath,</span></span><br><span class="line"><span class="comment">#   sourceurl, sourcetype </span></span><br><span class="line"><span class="comment"># retrieve records with, e.g., &#x27;object[[&quot;AH5012&quot;]]&#x27; </span></span><br></pre></td></tr></table></figure><p>第一次使用AnnotationHub需要创建一个AnnotationHub对象。为了更直观地使用，我们将AnnotationHub对象赋值给hub变量。查看这个变量，我们可以得到如下的信息。</p><ul><li>数据库版本是2021-10-20，目前有62386条记录</li><li>可以用$dataprovider 方式查看数据来源，比如数据来自于Ensembl，UCSC等等</li><li>可以用$species 方式查看数据库有哪些物种，比如人类、小鼠等等</li><li>可以用$rdataclass 方式查看数据类型</li><li>可以通过函数<code>mcols()</code>查看更多信息</li><li>获取数据的方式是<code>object[[&quot;AH5012&quot;]]</code> object指你命名的变量名</li></ul><p>以上就是AnnotationHub的标准用法，比如我想获得拟南芥的注释数据库，我就输入以下命令查找：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> query<span class="punctuation">(</span>hub<span class="punctuation">,</span> <span class="string">&quot;Arabidopsis thaliana&quot;</span><span class="punctuation">)</span></span><br><span class="line">AnnotationHub with <span class="number">13</span> records</span><br><span class="line"><span class="comment"># snapshotDate(): 2021-10-20</span></span><br><span class="line"><span class="comment"># $dataprovider: UCSC, PathBank, NCBI,DBCLS, FANTOM5,DLRP...</span></span><br><span class="line"><span class="comment"># $species: Arabidopsis thaliana</span></span><br><span class="line"><span class="comment"># $rdataclass: SQLiteFile, TxDb, Tibble, list, OrgDb, Inp...</span></span><br><span class="line"><span class="comment"># additional mcols(): taxonomyid, genome,</span></span><br><span class="line"><span class="comment">#   description, coordinate_1_based, maintainer,</span></span><br><span class="line"><span class="comment">#   rdatadateadded, preparerclass, tags, rdatapath,</span></span><br><span class="line"><span class="comment">#   sourceurl, sourcetype </span></span><br><span class="line"><span class="comment"># retrieve records with, e.g., &#x27;object[[&quot;AH10456&quot;]]&#x27; </span></span><br><span class="line"></span><br><span class="line">            title                                           </span><br><span class="line">  AH10456 <span class="operator">|</span> hom.Arabidopsis_thaliana.inp8.sqlite            </span><br><span class="line">  AH52245 <span class="operator">|</span> TxDb.Athaliana.BioMart.plantsmart22.sqlite      </span><br><span class="line">  AH52246 <span class="operator">|</span> TxDb.Athaliana.BioMart.plantsmart25.sqlite      </span><br><span class="line">  AH52247 <span class="operator">|</span> TxDb.Athaliana.BioMart.plantsmart28.sqlite      </span><br><span class="line">  AH87070 <span class="operator">|</span> pathbank_Arabidopsis_thaliana_metabolites.rda   </span><br><span class="line">  ...       ...                                             </span><br><span class="line">  AH91794 <span class="operator">|</span> wikipathways_Arabidopsis_thaliana_metabolites...</span><br><span class="line">  AH95585 <span class="operator">|</span> Alternative Splicing Annotation <span class="keyword">for</span> Arabidops...</span><br><span class="line">  AH95951 <span class="operator">|</span> org.At.tair.db.sqlite                           </span><br><span class="line">  AH97723 <span class="operator">|</span> LRBaseDb <span class="keyword">for</span> Arabidopsis thaliana <span class="punctuation">(</span>Thale cres...</span><br><span class="line">  AH97844 <span class="operator">|</span> MeSHDb <span class="keyword">for</span> Arabidopsis thaliana <span class="punctuation">(</span>Thale cress<span class="punctuation">,</span>...</span><br></pre></td></tr></table></figure><p><code>query()</code>函数查找，输入拟南芥的学名Arabidopsis thaliana我们可以看到一共找出了13个数据库。可以看到AH95951这个编号的数据库来源就是最大的拟南芥数据库TAIR（OrgDb，<strong>存储不同数据库基因ID之间对应关系，以及基因与GO等注释的对应关系</strong>，后面ID转换和GO分析要用到），我们就用这个数据库的注释资源。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> hub<span class="punctuation">[[</span><span class="string">&quot;AH95951&quot;</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line">downloading <span class="number">1</span> resources</span><br><span class="line">retrieving <span class="number">1</span> resource</span><br><span class="line">  <span class="operator">|</span>                                                   <span class="operator">|</span>   <span class="number">0</span>%</span><br></pre></td></tr></table></figure><p>前面说过<code>object[[&quot;AH5012&quot;]]</code>是获取数据的方式。以上，就可以挂后台自动下载了。我这里因为网速的原因不下了，从前面的基因名也能看出来，我筛选的差异基因都是AT开头的，而且之前的基因组注释文件也是TAIR下载的，我可以<strong>直接用bioconductor安装org.At.tair.db包</strong>，这里用AnnotationHub只是提供一个找注释数据库的思路。</p></div><h2 id="2-GO-x2F-KEGG富集分析"><a href="#2-GO-x2F-KEGG富集分析" class="headerlink" title="2. GO&#x2F;KEGG富集分析"></a>2. GO&#x2F;KEGG富集分析</h2><div class="story post-story"><h3 id="2-1-基因ID转换"><a href="#2-1-基因ID转换" class="headerlink" title="2.1 基因ID转换"></a>2.1 基因ID转换</h3><p>找到和下载注释数据库只是第一步，接下来GO&#x2F;KEGG富集分析需要用到R包<strong>clusterProfiler和org.At.tair.db</strong></p><p>先来看一下我们基因名是什么格式的：</p><p><img src="https://www.shelven.com/tuchuang/20220515/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220515/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>很明显，我们的基因ID是TAIR类型<del>（废话，我从TAIR下的）</del>，org.At.tair.db包可以转换基因ID类型</p><p>可以用<code>keytypes(org.At.tair.db)</code>或者<code>columns(org.At.tair.db)</code>查看可以转换的基因ID类型</p><p><img src="https://www.shelven.com/tuchuang/20220515/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220515/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>转换基因ID代码如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">library<span class="punctuation">(</span><span class="string">&quot;org.At.tair.db&quot;</span><span class="punctuation">)</span></span><br><span class="line">columns<span class="punctuation">(</span>org.At.tair.db<span class="punctuation">)</span>     <span class="comment"># 查看能转换基因的ID类型</span></span><br><span class="line">diffgen <span class="operator">&lt;-</span> nDEGs<span class="punctuation">[</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">]</span>       <span class="comment"># 注意只需要基因名</span></span><br><span class="line">diff_gen <span class="operator">&lt;-</span> bitr<span class="punctuation">(</span>diffgen<span class="punctuation">,</span></span><br><span class="line">                 fromType <span class="operator">=</span> <span class="string">&quot;TAIR&quot;</span><span class="punctuation">,</span></span><br><span class="line">                 toType <span class="operator">=</span> <span class="string">&quot;ENTREZID&quot;</span><span class="punctuation">,</span>   <span class="comment"># 基因ID类型TAIR转换为ENTREZID</span></span><br><span class="line">                 OrgDb <span class="operator">=</span> <span class="string">&quot;org.At.tair.db&quot;</span><span class="punctuation">)</span>      <span class="comment"># 该函数是基于org.At.tair.db包的</span></span><br><span class="line">diff_gen</span><br></pre></td></tr></table></figure><p>这一步我的基因ID转换率<strong>只有60%左右</strong>，有<strong>将近一半</strong>的TAIR基因ID不能成功转换成ENTREZID，可能是Gene ID的版本问题，同一个基因在不同版本genecode中结果不一样，下载的注释文件原始版本我这里找不到了…暂时无法解决这个问题。只能不转换基因ID先跑一遍GO&#x2F;KEGG富集分析。</p><p>看了很多教程都说clusterProfiler需要的ID类型是ENTREZID，<strong>这里我持怀疑态度</strong>，不转换后续也能得到结果，我看了函数<code>enrichGO()</code>默认的基因ID是ENTREZID并不代表不能改变，有可能是误传。<a href="http://www.360doc.com/content/17/0919/14/19913717_688385068.shtml">查阅了一些资料</a>，简单来说Entrez ID是来自于NCBI旗下Entrez gene数据库的编号系统，基因编号系统之间是可以相互转换的，这些ID可以在对应的数据库找到基因注释信息，就是说也可以在网页上手动注释。</p><h3 id="2-2-GO-x2F-KEGG分析"><a href="#2-2-GO-x2F-KEGG分析" class="headerlink" title="2.2 GO&#x2F;KEGG分析"></a>2.2 GO&#x2F;KEGG分析</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">library<span class="punctuation">(</span><span class="string">&quot;clusterProfiler&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># GO富集分析</span></span><br><span class="line">enrich_GO <span class="operator">&lt;-</span> enrichGO<span class="punctuation">(</span>gene <span class="operator">=</span> diffgen<span class="punctuation">,</span>   <span class="comment"># 基因名列表</span></span><br><span class="line">                      OrgDb <span class="operator">=</span> <span class="string">&#x27;org.At.tair.db&#x27;</span><span class="punctuation">,</span> <span class="comment"># 输入OrgDb数据库（注释对象信息）</span></span><br><span class="line">                      keyType <span class="operator">=</span> <span class="string">&#x27;TAIR&#x27;</span><span class="punctuation">,</span>     <span class="comment"># 输入的基因名ID类型</span></span><br><span class="line">                      ont <span class="operator">=</span> <span class="string">&#x27;ALL&#x27;</span><span class="punctuation">,</span>      <span class="comment"># 输出的GO分类</span></span><br><span class="line">                      pAdjustMethod <span class="operator">=</span> <span class="string">&#x27;fdr&#x27;</span><span class="punctuation">,</span></span><br><span class="line">                      pvalueCutoff <span class="operator">=</span> <span class="number">0.05</span><span class="punctuation">,</span></span><br><span class="line">                      qvalueCutoff <span class="operator">=</span> <span class="number">0.2</span><span class="punctuation">,</span></span><br><span class="line">                      readable <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line">GO_result <span class="operator">&lt;-</span> enrich_GO<span class="operator">@</span>result</span><br><span class="line">write.table<span class="punctuation">(</span>GO_result<span class="punctuation">,</span> <span class="string">&#x27;GO_result.csv&#x27;</span><span class="punctuation">,</span> sep <span class="operator">=</span> <span class="string">&#x27;,&#x27;</span><span class="punctuation">,</span> <span class="built_in">quote</span> <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span> row.names <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># KEGG富集分析</span></span><br><span class="line">enrich_KEGG <span class="operator">&lt;-</span> enrichKEGG<span class="punctuation">(</span>gene <span class="operator">=</span> diffgen<span class="punctuation">,</span></span><br><span class="line">                        keyType <span class="operator">=</span> <span class="string">&quot;kegg&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        organism <span class="operator">=</span> <span class="string">&quot;ath&quot;</span><span class="punctuation">,</span>   <span class="comment"># 输入的物种名</span></span><br><span class="line">                        pvalueCutoff <span class="operator">=</span> <span class="number">0.05</span><span class="punctuation">,</span></span><br><span class="line">                        qvalueCutoff <span class="operator">=</span> <span class="number">0.2</span><span class="punctuation">)</span></span><br><span class="line">KEGG_result <span class="operator">&lt;-</span> enrich_KEGG<span class="operator">@</span>result</span><br><span class="line">write.table<span class="punctuation">(</span>KEGG_result<span class="punctuation">,</span> <span class="string">&#x27;KEGG_result.csv&#x27;</span><span class="punctuation">,</span> sep <span class="operator">=</span> <span class="string">&#x27;,&#x27;</span><span class="punctuation">,</span> <span class="built_in">quote</span> <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span> row.names <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>clusterProfiler这个包进行GO和KEGG富集分析就这两个函数</p><p>这里我的GO只富集到两条细胞组分的内容：</p><p><img src="https://www.shelven.com/tuchuang/20220515/3.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220515/3.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>说一下各列代表的意思：</p><ul><li>ONTOLOGY GO分类BP（生物学过程）、CC（细胞组分）或MF（分子功能）</li><li>ID 富集到的GO id号</li><li>Description 富集到的GO描述</li><li>GeneRatio和BgRatio 分别为富集到该GO条目中的基因数目&#x2F;给定基因的总数目，以及该条目中背景基因总数目&#x2F;该物种所有已知的GO功能基因数目</li><li>pvalue、p.adjust和qvalue p值、校正后p值和q值信息</li><li>geneID和Count，富集到该GO条目中的基因名称和数目</li></ul><p>KEGG富集分析结果表如下：</p><p><img src="https://www.shelven.com/tuchuang/20220515/5.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220515/5.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><ul><li>ID和Description 分别代表富集到KEGG的ID和描述，其他和GO富集都类似</li></ul><p>KEGG富集分析的时候有一点需要注意，输入的organism名称需要在<strong>官网的KEGG Organisms列表中能找到</strong>，否则是不能进行分析的！<a href="https://www.genome.jp/kegg/catalog/org_list.html">点击这里进入KEGG Organisms: Complete Genomes</a></p><p>还发现一个很奇怪的问题，我在官网的Organisms列表能找到拟南芥Arabidopsis thaliana，但是在上面的函数中对参数赋值<code>organism = &quot;Arabidopsis thaliana&quot;</code>会显示HTTP 400错误，也就是发出的url请求有问题，但是输入<code>organism = &quot;ath&quot;</code>程序可以正常运行，以后注意写缩写吧（<strong>应该是只有缩写才行</strong>，会通过联网自动获取该物种的pathway注释信息）。</p></div><h2 id="3-可视化"><a href="#3-可视化" class="headerlink" title="3. 可视化"></a>3. 可视化</h2><div class="story post-story"><p>clusterProfiler包还提供了GO&#x2F;KEGG富集结果的可视化方案，此处代码参考<a href="https://blog.csdn.net/qq_50898257/article/details/120588222">CSDN，作者：Tian問</a></p><p>这里因为我的GO结果不好，只简单写一下流程，详细作图函数参数使用方法和效果同样可以参考上面的链接~</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## GO富集分析可视化</span></span><br><span class="line"><span class="comment">#barplot</span></span><br><span class="line">barplot<span class="punctuation">(</span>enrich_GO<span class="punctuation">,</span> showCategory <span class="operator">=</span> <span class="number">10</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#dotplot</span></span><br><span class="line">dotplot<span class="punctuation">(</span>enrich_GO<span class="punctuation">,</span> showCategory <span class="operator">=</span> <span class="number">10</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#DAG有向无环图</span></span><br><span class="line">plotGOgraph<span class="punctuation">(</span>enrich_GO<span class="punctuation">)</span>  <span class="comment">#矩形代表富集到的top10个GO terms, 颜色从黄色过滤到红色，对应p值从大到小。</span></span><br><span class="line"><span class="comment">#igraph布局的DAG</span></span><br><span class="line">goplot<span class="punctuation">(</span>enrich_GO<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#GO terms关系网络图（通过差异基因关联）</span></span><br><span class="line">emapplot<span class="punctuation">(</span>enrich_GO<span class="punctuation">,</span> showCategory <span class="operator">=</span> <span class="number">30</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#GO term与差异基因关系网络图</span></span><br><span class="line">cnetplot<span class="punctuation">(</span>enrich_GO<span class="punctuation">,</span> showCategory <span class="operator">=</span> <span class="number">5</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## KEGG富集分析可视化</span></span><br><span class="line"><span class="comment">#barplot</span></span><br><span class="line">barplot<span class="punctuation">(</span>enrich_KEGG<span class="punctuation">,</span> showCategory <span class="operator">=</span> <span class="number">10</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#dotplot</span></span><br><span class="line">dotplot<span class="punctuation">(</span>enrich_KEGG<span class="punctuation">,</span> showCategory <span class="operator">=</span> <span class="number">10</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#pathway关系网络图（通过差异基因关联）</span></span><br><span class="line">emapplot<span class="punctuation">(</span>enrich_KEGG<span class="punctuation">,</span>  showCategory <span class="operator">=</span> <span class="number">30</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#pathway与差异基因关系网络图</span></span><br><span class="line">cnetplot<span class="punctuation">(</span>enrich_KEGG<span class="punctuation">,</span> showCategory <span class="operator">=</span> <span class="number">5</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#pathway映射</span></span><br><span class="line">browseKEGG<span class="punctuation">(</span>enrich_KEGG<span class="punctuation">,</span> <span class="string">&quot;ath03060&quot;</span><span class="punctuation">)</span> <span class="comment">#在pathway通路图上标记富集到的基因，会弹出页面链接到KEGG官网</span></span><br></pre></td></tr></table></figure><p>关于GO&#x2F;KEGG富集分析，还有非常多的操作和应用，我只是简单做个最基础的富集分析的学习，没有涉及到手动注释，构建orgdb等等更多操作。电脑快没电了，这篇笔记先暂时记这些，以后需要用到再补充~</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;div class=&quot;story post-story&quot;&gt;&lt;p&gt;前面介绍了如何找到差异基因，我们通过R包DESeq2获得了差异表达基因，在此基础</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="转录组数据分析" scheme="http://www.shelven.com/categories/%E8%BD%AC%E5%BD%95%E7%BB%84%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
    <category term="AnnotationHub" scheme="http://www.shelven.com/tags/AnnotationHub/"/>
    
    <category term="GO/KEGG" scheme="http://www.shelven.com/tags/GO-KEGG/"/>
    
    <category term="org.At.tair.db" scheme="http://www.shelven.com/tags/org-At-tair-db/"/>
    
  </entry>
  
  <entry>
    <title>视频一键转字符动画——python函数封装和调用练习</title>
    <link href="http://www.shelven.com/2022/05/08/a.html"/>
    <id>http://www.shelven.com/2022/05/08/a.html</id>
    <published>2022-05-07T17:43:17.000Z</published>
    <updated>2022-05-07T18:35:00.862Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><div class="story post-story"><p>捣鼓了几天python代码，我现在也越来越发现python的魅力所在，它的强大之处在于有非常多的第三方库可以随意调用。我不需要知道这些第三方库各种函数的实现方式，只要知道这些函数有什么作用，能得到什么结果。只要构思好自己的想法，找到对应的库就可以一步步按照我的思路编写程序，实现我想要的结果，整个构思到实现的过程让我非常愉悦~</p><p>写这篇博客纯粹是个人爱好，也是一个巧合~</p><p>前几天刷b站看到有人做了个剪影的字符动画，我就很好奇python是否可以实现。参考了一下github上大佬们的图片转字符画的代码，对这些代码做了点深入研究，总算搞明白了其实现方式，并且自己动手修改代码，在原有基础上改了几个bug，新增几个模块的调用，最后一步封装写成了下面这个脚本。这个脚本的功能是<strong>只要输入视频文件和你想要的视频帧率，就可以自动将视频转化为字符动画</strong>。</p><p>可以先看一下视频效果~ <a href="https://www.bilibili.com/video/BV14S4y187Az?spm_id_from=333.999.0.0">或者点击这里进入b站观看</a></p><div class="video"><video controls preload><source src='https://www.shelven.com/tuchuang/20220508/590001100-1-112.mov' type='video/mp4'>Your browser does not support the video tag.</video></div></div><h2 id="2-实现思路"><a href="#2-实现思路" class="headerlink" title="2. 实现思路"></a>2. 实现思路</h2><div class="story post-story"><ul><li>调用ffmpeg根据帧率将视频切割成图片</li><li>调用pillow库作图，每张图片转换字符画</li><li>调用ffmpeg合并字符画并输出动画</li></ul></div><h2 id="3-脚本代码及详解"><a href="#3-脚本代码及详解" class="headerlink" title="3. 脚本代码及详解"></a>3. 脚本代码及详解</h2><div class="story post-story"><p>思路很清晰，接下来是写代码实现的过程，细节方面需要调用其他库</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageDraw, ImageFont <span class="comment"># pillow库作图</span></span><br><span class="line"><span class="keyword">import</span> subprocess   <span class="comment"># 执行命令行命令，为了调用ffmpeg</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os   <span class="comment"># 操作目录用</span></span><br><span class="line"><span class="keyword">import</span> shutil   <span class="comment"># 删除目录用</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  <span class="comment"># 转化numpy数组</span></span><br><span class="line"><span class="keyword">import</span> gc   <span class="comment"># 优化运行内存用到</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义输入值，这个脚本需要两个输入值：file_input和FPS</span></span><br><span class="line">file_input = sys.argv[<span class="number">1</span>]</span><br><span class="line">FPS = sys.argv[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">do_turn</span>(<span class="params">file_input, FPS</span>):</span><br><span class="line">    <span class="comment"># 调用ffmpeg切割视频</span></span><br><span class="line">    os.makedirs(<span class="string">&quot;tempfile/cut/&quot;</span>)    <span class="comment"># 当前目录新建存放切割图片的临时文件夹</span></span><br><span class="line">    shell_vedio = <span class="string">&quot;ffmpeg -i &quot;</span> + file_input + <span class="string">&quot; -r &quot;</span> + FPS + <span class="string">&quot; -qscale:v 2 ./tempfile/cut/%05d.jpg&quot;</span>     <span class="comment"># 按照XXXXX序号切割</span></span><br><span class="line">    shell_voice = <span class="string">&quot;ffmpeg -i &quot;</span> + file_input + <span class="string">&quot; ./tempfile/out.mp3&quot;</span></span><br><span class="line">    subprocess.call(shell_vedio, shell=<span class="literal">True</span>)    <span class="comment"># 切割视频</span></span><br><span class="line">    subprocess.call(shell_voice, shell=<span class="literal">True</span>)    <span class="comment"># 分离音频</span></span><br><span class="line">    count =<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> os.listdir(<span class="string">&quot;./tempfile/cut/&quot;</span>):</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;成功分离音频，截图开始转换字符画......&quot;</span> + <span class="string">&quot;共计&quot;</span> + <span class="built_in">str</span>(count) + <span class="string">&quot;张&quot;</span>)    <span class="comment"># 统计切割图张数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 图片转换字符画</span></span><br><span class="line">    list_p = os.listdir(<span class="string">&quot;./tempfile/cut/&quot;</span>)  </span><br><span class="line">    cwd = os.getcwd()</span><br><span class="line">    os.mkdir(<span class="string">&quot;./tempfile/new/&quot;</span>)     <span class="comment"># 新建存放字符画的临时文件夹</span></span><br><span class="line">    process = <span class="number">1</span>     <span class="comment"># 统计完成转换的字符画数量</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">id</span> <span class="keyword">in</span> list_p:   <span class="comment"># 遍历cut文件夹所有切割后的图片做字符画转换</span></span><br><span class="line">        address = <span class="built_in">str</span>(<span class="string">&quot;&quot;</span>.join(cwd + <span class="string">&#x27;/tempfile/cut/&#x27;</span> + <span class="built_in">id</span>)) <span class="comment"># 拼接文件的绝对路径</span></span><br><span class="line">        im = Image.<span class="built_in">open</span>(address)    <span class="comment"># 调用image打开图片</span></span><br><span class="line">        font = ImageFont.truetype(<span class="string">&quot;DejaVuSans-Bold&quot;</span>, size=<span class="number">20</span>)      <span class="comment"># 字体模式，可更改</span></span><br><span class="line">        rate = <span class="number">0.1</span>    <span class="comment"># 缩放比（不调整的话像素点过多，这里统一调整）</span></span><br><span class="line">        aspect_ratio = font.getsize(<span class="string">&quot;x&quot;</span>)[<span class="number">0</span>] / font.getsize(<span class="string">&quot;x&quot;</span>)[<span class="number">1</span>]  <span class="comment"># 获得字符长宽比 </span></span><br><span class="line">        new_im_size = np.array([im.size[<span class="number">0</span>] * rate, im.size[<span class="number">1</span>] * rate * aspect_ratio]).astype(<span class="built_in">int</span>)    <span class="comment"># 转换numpy数组，调整大小</span></span><br><span class="line">        im = im.resize(new_im_size)   </span><br><span class="line">        im = np.array(im.convert(<span class="string">&quot;L&quot;</span>))       <span class="comment"># 转换灰阶图，生成numpy数组</span></span><br><span class="line">        </span><br><span class="line">        symbols = np.array(<span class="built_in">list</span>(<span class="string">&quot; .-vM@&quot;</span>))  <span class="comment"># 建立字符索引，注意要按照亮度手动排序</span></span><br><span class="line">        <span class="keyword">if</span> im.<span class="built_in">max</span>() == im.<span class="built_in">min</span>():      <span class="comment"># 全黑和全是一种颜色进行区分</span></span><br><span class="line">            <span class="keyword">if</span> im.<span class="built_in">max</span>() &gt; <span class="number">0</span>:    <span class="comment"># 全是一种颜色，亮度值大于0，则全部用最亮的字符数值</span></span><br><span class="line">                im = (im / im) * (symbols.size - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                im[np.isnan(im)] = <span class="number">0</span>    <span class="comment"># 全黑时亮度值为NaN(非数值)，则全部用最暗字符的字符数值，也就是全黑</span></span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            im = (im - im.<span class="built_in">min</span>()) / (im.<span class="built_in">max</span>() - im.<span class="built_in">min</span>()) * (symbols.size - <span class="number">1</span>) <span class="comment"># 根据索引赋予相应像素点相应的数值</span></span><br><span class="line">        <span class="built_in">ascii</span> = symbols[im.astype(<span class="built_in">int</span>)]    </span><br><span class="line">        letter_size = font.getsize(<span class="string">&quot;x&quot;</span>)   <span class="comment"># 获取字符大小，与前面一定要对应</span></span><br><span class="line">        im_out_size = new_im_size * letter_size    <span class="comment"># 这里乘以字符长宽，否则字符只有一个像素点大小</span></span><br><span class="line">        im_out = Image.new(<span class="string">&quot;RGB&quot;</span>, <span class="built_in">tuple</span>(im_out_size), <span class="string">&quot;black&quot;</span>)  <span class="comment"># 设置输出图片，背景</span></span><br><span class="line">        draw = ImageDraw.Draw(im_out)   </span><br><span class="line">        </span><br><span class="line">        y = <span class="number">0</span>   <span class="comment"># 两个循环穷举赋值，做字符画图片</span></span><br><span class="line">        <span class="keyword">for</span> i, m <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">ascii</span>):</span><br><span class="line">            <span class="keyword">for</span> j, n <span class="keyword">in</span> <span class="built_in">enumerate</span>(m): </span><br><span class="line">                draw.text((letter_size[<span class="number">0</span>] * j, y), n, font=font) </span><br><span class="line">            y += letter_size[<span class="number">1</span>]     <span class="comment"># 注意+=，这里赋值字符宽度给y值</span></span><br><span class="line">        im_out.save(<span class="string">&quot;./tempfile/new/&quot;</span> + <span class="built_in">id</span> + <span class="string">&quot;.png&quot;</span>)  <span class="comment"># 定义输出位置和图片格式</span></span><br><span class="line">        <span class="built_in">print</span>(address + <span class="string">&quot;转换成功！当前进度：&quot;</span> + <span class="built_in">str</span>(process) + <span class="string">&quot;/&quot;</span> + <span class="built_in">str</span>(count))       <span class="comment"># 显示进度</span></span><br><span class="line">        process += <span class="number">1</span></span><br><span class="line">        gc.collect()    <span class="comment"># 重要！每次循环结束释放一次内存，否则容易内存溢出</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;转换成功！开始生成视频，请稍候......&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 调用ffmpeg合并字符画为视频，并且合并分离的音频</span></span><br><span class="line">    outvedio = <span class="string">&quot;ffmpeg -r &quot;</span> + FPS + <span class="string">&quot; -i ./tempfile/new/%05d.jpg.png ./tempfile/out.mp4&quot;</span></span><br><span class="line">    subprocess.call(outvedio, shell=<span class="literal">True</span>)</span><br><span class="line">    final_vedio = <span class="string">&quot;ffmpeg -i ./tempfile/out.mp4 -i ./tempfile/out.mp3 final.mp4&quot;</span></span><br><span class="line">    subprocess.call(final_vedio, shell=<span class="literal">True</span>)</span><br><span class="line">    shutil.rmtree(<span class="string">&quot;./tempfile&quot;</span>)     <span class="comment"># 删除临时文件夹</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;字符动画final.mp4已生成!已移除临时文件夹&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入格式错误则显示该条用法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">usage</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;usage:&quot;</span>, sys.argv[<span class="number">0</span>], <span class="string">&quot;&lt;file_input&gt; &lt;FPS&gt;&quot;</span>) </span><br><span class="line">    exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:  <span class="comment"># 封装，只有在文件作为脚本直接执行时后面的语句才会被执行，而 import 到其他脚本中后面的语句是不会被执行的</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) != <span class="number">3</span>:  <span class="comment"># 判断输入的值是否为两个，没错，是判断两个</span></span><br><span class="line">        usage()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        do_turn(file_input, FPS)</span><br></pre></td></tr></table></figure></div><h2 id="4-注意要点"><a href="#4-注意要点" class="headerlink" title="4. 注意要点"></a>4. 注意要点</h2><div class="story post-story"><p>调用numpy模块生成数组，是因为python本身虽然可以建立多维度的数组，但是书写起来非常麻烦。numpy可以很好地解决这个问题，可以理解为能构建一个更好用的数组。在对数组进行遍历穷举，要注意两次穷举分别生成两个<strong>数组</strong>，第二次生成的数组只有一个数，所以下面draw.text第二个参数text可以用n，也可以用n[0]列举第一个数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">y = <span class="number">0</span>   </span><br><span class="line"><span class="keyword">for</span> i, m <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">ascii</span>):   <span class="comment"># 这里i是用不到的</span></span><br><span class="line">    <span class="keyword">for</span> j, n <span class="keyword">in</span> <span class="built_in">enumerate</span>(m): </span><br><span class="line">        draw.text((letter_size[<span class="number">0</span>] * j, y), n, font=font)  <span class="comment"># 第一个参数是确定坐标</span></span><br><span class="line">    y += letter_size[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>字符大小，字符格式，以什么字符为参照，都是可以调整的。只要注意一点，我们是按照像素点的亮度来赋于这个像素点用什么字符的，所以索引列比较重要，要自己按照字符亮度排序，添加字符注意改值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">symbols = np.array(<span class="built_in">list</span>(<span class="string">&quot; .-vM@&quot;</span>))      <span class="comment"># 可以改成自己想要用的字符，注意按照亮度升序</span></span><br></pre></td></tr></table></figure><p>还有，在计算亮度和赋予索引值的时候，我们是按照相对亮度来计算的。因此，当图片所有像素点都是一种颜色的时候，im.max() 和 im.min()值是相等的，相对亮度会出现0&#x2F;0的值，导致报错。所以我加了以下判断条件：纯色黑色和其他颜色属于两种不同情况，黑色时numpy数组亮度是非数值NaN，需要将数组全部值进行替换为亮度最小的字符的值；因为是RGB取值，其他颜色值固定在0-255之间，颜色均一，相对亮度就没有意义了，因此全部调整为最亮字符的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> im.<span class="built_in">max</span>() == im.<span class="built_in">min</span>():</span><br><span class="line">    <span class="keyword">if</span> im.<span class="built_in">max</span>() &gt; <span class="number">0</span>:</span><br><span class="line">        im = (im / im) * (symbols.size - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        im[np.isnan(im)] = <span class="number">0</span></span><br><span class="line"><span class="keyword">else</span>: </span><br><span class="line">    im = (im - im.<span class="built_in">min</span>()) / (im.<span class="built_in">max</span>() - im.<span class="built_in">min</span>()) * (symbols.size - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>顺便再说一个很有意思的模块subprocess，subprocess.call()函数可以执行命令行的命令，并且这个命令是在子进程实行的，只有子程序结束才会继续执行其他命令，使用起来真的特别方便！比如有些程序我的python库里没有但是我的linux里有，在python脚本的某一步我需要用到linux里的软件去处理，这个时候就可以调用subprocess.call()函数去执行linux命令行的命令了。</p><p><strong>还有一个函数虽然不显眼，但是起着至关重要的作用</strong> <code>gc.collect()</code></p><p>没有这个函数部分运行内存不够的电脑会崩……我在这里踩了个大坑……</p><p>在对程序进行简化以后，我以为优化地差不多了，然后发现有的时候程序会被莫名其妙killed……</p><p><code>vi /var/log/messages</code> 查看运行日志，好家伙，内存溢出了</p><p><img src="https://www.shelven.com/tuchuang/20220508/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220508/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>经过一番度娘，我检查了一下自己也没有用到循环引用的变量啊，那么真相只有一个了：转换字符画部分程序有3个for循环嵌套，<strong>可能是for循环引用的对象没有及时回收导致内存不断增长，最后被系统kill掉（个人猜测）</strong>。虽然python本身有垃圾回收功能，而在程序运行的时候清理地并不是很及时，引入的gc模块是python的垃圾收集器模块，与默认的回收方式算法不同，<code>gc.collect()</code>函数可以强制进行垃圾回收。因此我在每个转化字符画的for循环执行一次结束后强制回收内存，如下：</p><p><img src="https://www.shelven.com/tuchuang/20220508/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220508/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>效果是立竿见影的，内存占用再也没超过5%了，非常的稳定！</p></div><h2 id="5-食用方法"><a href="#5-食用方法" class="headerlink" title="5. 食用方法"></a>5. 食用方法</h2><div class="story post-story"><p>缺什么第三方库就装什么，主要是pillow库、numpy库和ffmpeg，用conda可以直接安装。上面那段脚本代码复制粘贴，保存为ascii.py，运行命令：</p><p><code>python ascii.py &lt;视频文件&gt; &lt;你想要的视频帧率&gt;</code></p><p>回车，OK，静静等屏幕上的提示就好了。视频文件不在当前文件夹的话自行加上绝对路径，完成以后只会在<strong>当前目录</strong>生成一个out.mp4的输出文件。</p><p>源代码将同步上传<a href="https://github.com/Phantom-Aria/ascii/blob/main/ascii.py">我的github</a>。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h2&gt;&lt;div class=&quot;story post-story&quot;&gt;&lt;p&gt;捣鼓了几天python代码，我现在也越来越发现python的</summary>
      
    
    
    
    <category term="编程自学" scheme="http://www.shelven.com/categories/%E7%BC%96%E7%A8%8B%E8%87%AA%E5%AD%A6/"/>
    
    
    <category term="python" scheme="http://www.shelven.com/tags/python/"/>
    
    <category term="ffmpeg" scheme="http://www.shelven.com/tags/ffmpeg/"/>
    
    <category term="numpy" scheme="http://www.shelven.com/tags/numpy/"/>
    
    <category term="pillow" scheme="http://www.shelven.com/tags/pillow/"/>
    
  </entry>
  
  <entry>
    <title>转录组数据分析笔记（9）——pheatmap绘制差异表达基因热图</title>
    <link href="http://www.shelven.com/2022/05/05/a.html"/>
    <id>http://www.shelven.com/2022/05/05/a.html</id>
    <published>2022-05-04T17:16:14.000Z</published>
    <updated>2022-05-04T17:40:38.589Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><div class="story post-story"><p>前面说到怎么用ggplot做一个火山图来查看各个基因的表达情况，火山图是以log2FC值为横坐标，以-log10（FDR）值作为纵坐标，将<strong>所有的基因</strong>都做了点状图。虽然能比较直观地看到所有基因表达情况，但我们真正感兴趣的是处理后差异表达的基因。因此，我们也可以通过前面得到的表达矩阵获得差异表达的基因名，对raw count数据进行提取和均一化，然后做一个差异基因的热图，能更直观地看到差异基因在各个样本中的上调下调情况。</p><p>做热图我们用的最多的R包是<strong>pheatmap</strong>，可以直接用biocmanager下载。</p><p>后面所有Rstudio操作都是在同一个Rproject中进行，<strong>引用的变量如果不理解就翻前面的笔记</strong>，最后我会把一整个转录组下游分析的R流程代码写成一个文件上传到github备份。</p></div><h2 id="2-热图介绍"><a href="#2-热图介绍" class="headerlink" title="2. 热图介绍"></a>2. 热图介绍</h2><div class="story post-story"><p>废话不多说，先上一段热图的定义介绍：<strong>热图</strong>是用来对采集的<strong>因子响应强度</strong>或其他的一些因素进行均一化，从而利用<strong>颜色条的变化</strong>来直观地表示不同<strong>样本</strong>之间的含量变化情况的图。</p><p>定义很简单，这里我们的因子响应强度就是每个基因的<strong>raw count值</strong>，但是raw count值从0到几千上万差别非常之大，作图不方便。所以我们通常会用<strong>均一化</strong>的方法，使每个基因的raw count值变化程度处于同一个数量级，再通过不同颜色变化得到基因在不同样品的含量变化。</p><p>R自带的均一化函数是<strong>scale()<strong>，注意下scale默认的均一化方式是</strong>按列进行的</strong>，我们还可以通过函数 <strong>t()</strong> 进行矩阵的行列转化，只需要将差异基因挑出来按行（也就是基因名）进行均一化，导入pheatmap包即可做成一个最简单的热图。</p></div><h2 id="3-简化版代码"><a href="#3-简化版代码" class="headerlink" title="3. 简化版代码"></a>3. 简化版代码</h2><div class="story post-story"><p>先上一个最最简易版的，比如我要分析前25个最可能发生差异表达的基因，代码如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">library<span class="punctuation">(</span><span class="string">&quot;pheatmap&quot;</span><span class="punctuation">)</span></span><br><span class="line">nDEGs <span class="operator">&lt;-</span> gene<span class="punctuation">[</span>which<span class="punctuation">(</span>gene<span class="operator">$</span>group <span class="operator">!=</span> <span class="string">&quot;NOT_CHANGE&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span><span class="punctuation">]</span>   <span class="comment"># 筛选差异基因</span></span><br><span class="line">sort_DEGs <span class="operator">&lt;-</span> arrange<span class="punctuation">(</span>nDEGs<span class="punctuation">,</span>padj<span class="punctuation">)</span>        <span class="comment"># 按照padj值升序排序</span></span><br><span class="line">choose_gene <span class="operator">&lt;-</span> head<span class="punctuation">(</span>sort_DEGs<span class="punctuation">[</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="number">25</span><span class="punctuation">)</span>       <span class="comment"># 取padj值最小的前25个基因</span></span><br><span class="line">choose_matrix <span class="operator">&lt;-</span> mycounts<span class="punctuation">[</span>choose_gene<span class="punctuation">,</span><span class="punctuation">]</span>     <span class="comment"># 从raw count矩阵中挑出这25个基因数据</span></span><br><span class="line">heat_matrix <span class="operator">&lt;-</span> t<span class="punctuation">(</span>scale<span class="punctuation">(</span>t<span class="punctuation">(</span>choose_matrix<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span>   <span class="comment"># 转换了两次行列并均一化，实际就是按row进行了均一化</span></span><br><span class="line">pheatmap<span class="punctuation">(</span>heat_matrix<span class="punctuation">)</span>   <span class="comment"># 以默认参数做热图</span></span><br></pre></td></tr></table></figure><p>在plots窗口可以预览生成的热图：</p><p><img src="https://www.shelven.com/tuchuang/20220504_1/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220504_1/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>因为没有加任何参数调整，所以不好看（已经比R自带的热图函数做出来的好看了），先解释一下上面代码实现的原理。gene是我们前面做火山图的矩阵，里面已经有了我们差异基因分组的一列group</p><p><code>nDEGs &lt;- gene[which(gene$group != &quot;NOT_CHANGE&quot;),]</code> 这个代码是将group列中字符不等于“NOT_CHANGE”的数据挑出来赋值给nDEGs，注意下赋值后的nDEGs也是矩阵，可以直接查看。</p><p><img src="https://www.shelven.com/tuchuang/20220504_1/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220504_1/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><code>sort_DEGs &lt;- arrange(nDEGs,padj)</code> arrange() 函数的功能是升序排列，这里按照padj值升序排列。</p><p><code>choose_gene &lt;- head(sort_DEGs[,1],25)</code> head()函数用法不说了，取了前25个基因。注意下我们取的第一列是基因名，如果你前面已经将基因名作为rownames导入了，那就要用rowname。</p><p><code>choose_matrix &lt;- mycounts[choose_gene,]</code>，返回到我们前面的raw count矩阵，将基因名对应的数据挑出来，可以看下这个时候的choose_matrix矩阵是怎么样的：</p><p><img src="https://www.shelven.com/tuchuang/20220504_1/4.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220504_1/4.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><code>heat_matrix &lt;- t(scale(t(choose_matrix)))</code> 先进行一次行列转换，对列数据进行均一化，再进行一次行列转换，<strong>说白了就是对每行基因的raw count数据进行均一化</strong>，得到如下矩阵：</p><p><img src="https://www.shelven.com/tuchuang/20220504_1/3.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220504_1/3.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><code>pheatmap(heat_matrix)</code>以默认参数做热图，大功告成。</p><p>如果要对所有差异表达的基因做热图，只需要修改一下输入的矩阵就行：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">all_matrix <span class="operator">&lt;-</span> mycounts<span class="punctuation">[</span><span class="punctuation">(</span>sort_DEGs<span class="punctuation">[</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">)</span><span class="punctuation">,</span><span class="punctuation">]</span></span><br><span class="line">heat_matrix_all <span class="operator">&lt;-</span> t<span class="punctuation">(</span>scale<span class="punctuation">(</span>t<span class="punctuation">(</span>all_matrix<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">pheatmap<span class="punctuation">(</span>heat_matrix_all<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>因为这是<strong>默认参数作图</strong>，所以输出结果非常感人：</p><p><img src="https://www.shelven.com/tuchuang/20220504_1/5.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220504_1/5.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>你论文敢用这种图？所以还是需要了解一下pheatmap包的各种参数，对热图进行调整和修改。</p></div><h2 id="4-参数详解"><a href="#4-参数详解" class="headerlink" title="4. 参数详解"></a>4. 参数详解</h2><div class="story post-story"><p>此部分内容参考CSDN博客：<a href="https://blog.csdn.net/qq_43210428/article/details/120020284">跳动的喵尾巴</a></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pheatmap<span class="punctuation">(</span>mat<span class="punctuation">,</span> color <span class="operator">=</span> colorRampPalette<span class="punctuation">(</span>rev<span class="punctuation">(</span>brewer.pal<span class="punctuation">(</span>n <span class="operator">=</span> <span class="number">7</span><span class="punctuation">,</span> name <span class="operator">=</span></span><br><span class="line">  <span class="string">&quot;RdYlBu&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">(</span><span class="number">100</span><span class="punctuation">)</span><span class="punctuation">,</span> kmeans_k <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span> breaks <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span> border_color <span class="operator">=</span> <span class="string">&quot;grey60&quot;</span><span class="punctuation">,</span></span><br><span class="line">  cellwidth <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span> cellheight <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span> scale <span class="operator">=</span> <span class="string">&quot;none&quot;</span><span class="punctuation">,</span> cluster_rows <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span></span><br><span class="line">  cluster_cols <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> clustering_distance_rows <span class="operator">=</span> <span class="string">&quot;euclidean&quot;</span><span class="punctuation">,</span></span><br><span class="line">  clustering_distance_cols <span class="operator">=</span> <span class="string">&quot;euclidean&quot;</span><span class="punctuation">,</span> clustering_method <span class="operator">=</span> <span class="string">&quot;complete&quot;</span><span class="punctuation">,</span></span><br><span class="line">  clustering_callback <span class="operator">=</span> identity2<span class="punctuation">,</span> cutree_rows <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span> cutree_cols <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span></span><br><span class="line">  treeheight_row <span class="operator">=</span> ifelse<span class="punctuation">(</span><span class="punctuation">(</span><span class="built_in">class</span><span class="punctuation">(</span>cluster_rows<span class="punctuation">)</span> <span class="operator">==</span> <span class="string">&quot;hclust&quot;</span><span class="punctuation">)</span> <span class="operator">||</span> cluster_rows<span class="punctuation">,</span></span><br><span class="line">  <span class="number">50</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">)</span><span class="punctuation">,</span> treeheight_col <span class="operator">=</span> ifelse<span class="punctuation">(</span><span class="punctuation">(</span><span class="built_in">class</span><span class="punctuation">(</span>cluster_cols<span class="punctuation">)</span> <span class="operator">==</span> <span class="string">&quot;hclust&quot;</span><span class="punctuation">)</span> <span class="operator">||</span></span><br><span class="line">  cluster_cols<span class="punctuation">,</span> <span class="number">50</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">)</span><span class="punctuation">,</span> legend <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> legend_breaks <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span></span><br><span class="line">  legend_labels <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span> annotation_row <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span> annotation_col <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span></span><br><span class="line">  annotation <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span> annotation_colors <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span> annotation_legend <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span></span><br><span class="line">  annotation_names_row <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> annotation_names_col <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span></span><br><span class="line">  drop_levels <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> show_rownames <span class="operator">=</span> <span class="built_in">T</span><span class="punctuation">,</span> show_colnames <span class="operator">=</span> <span class="built_in">T</span><span class="punctuation">,</span> main <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span></span><br><span class="line">  fontsize <span class="operator">=</span> <span class="number">10</span><span class="punctuation">,</span> fontsize_row <span class="operator">=</span> fontsize<span class="punctuation">,</span> fontsize_col <span class="operator">=</span> fontsize<span class="punctuation">,</span></span><br><span class="line">  angle_col <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;270&quot;</span><span class="punctuation">,</span> <span class="string">&quot;0&quot;</span><span class="punctuation">,</span> <span class="string">&quot;45&quot;</span><span class="punctuation">,</span> <span class="string">&quot;90&quot;</span><span class="punctuation">,</span> <span class="string">&quot;315&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> display_numbers <span class="operator">=</span> <span class="built_in">F</span><span class="punctuation">,</span></span><br><span class="line">  number_format <span class="operator">=</span> <span class="string">&quot;%.2f&quot;</span><span class="punctuation">,</span> number_color <span class="operator">=</span> <span class="string">&quot;grey30&quot;</span><span class="punctuation">,</span> fontsize_number <span class="operator">=</span> <span class="number">0.8</span></span><br><span class="line">  <span class="operator">*</span> fontsize<span class="punctuation">,</span> gaps_row <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> gaps_col <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> labels_row <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span></span><br><span class="line">  labels_col <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> filename <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span> width <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span> height <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span></span><br><span class="line">  silent <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span> na_col <span class="operator">=</span> <span class="string">&quot;#DDDDDD&quot;</span><span class="punctuation">,</span> ...<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>参数内容非常之多，我这里仅挑选一些可能用得上的做个记录：</p><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">color</td><td align="center">表示热图颜色，colorRampPalette(rev(brewer.pal(n &#x3D; 7, name &#x3D; “RdYlBu”)))(100)表示颜色渐变调色板，“n” 的数量取决于调色板中颜色的数量，“name” 为调色板的名称，(100)表示100个等级；color &#x3D; colorRampPalette(c(“blue”, “white”, “red”))(100)则是通过设置三种不同的颜色进行渐变显示</td></tr><tr><td align="center">scale</td><td align="center">表示进行均一化的方向，值为 “row”, “column” 或者”none”</td></tr><tr><td align="center">kmeans_k</td><td align="center">默认为NA，即不会对行进行聚类；如果想在进行层次聚类之前，先对行特征(因子)进行 k-means 聚类，则可在此调整热图的行聚类数</td></tr><tr><td align="center">cluster_rows</td><td align="center">表示仅对行聚类，值为TRUE或FALSE</td></tr><tr><td align="center">cluster_cols</td><td align="center">表示仅对列聚类，值为TRUE或FALSE</td></tr><tr><td align="center">clustering_distance_cols</td><td align="center">表示列聚类使用的度量方法，与行聚类的度量方法一致</td></tr><tr><td align="center">clustering_method</td><td align="center">表示聚类方法，包括：‘ward’, ‘ward.D’, ‘ward.D2’, ‘single’, ‘complete’, ‘average’, ‘mcquitty’, ‘median’, ‘centroid’</td></tr><tr><td align="center">cutree_rows</td><td align="center">若进行了行聚类，根据行聚类数量分隔热图行</td></tr><tr><td align="center">cutree_cols</td><td align="center">若进行了列聚类，根据列聚类数量分隔热图列</td></tr><tr><td align="center">treeheight_row</td><td align="center">若进行了行聚类，其热图行的聚类树高度，默认为 “50”</td></tr><tr><td align="center">treeheight_col</td><td align="center">若进行了列聚类，其热图列的聚类树高度，默认为 “50”</td></tr><tr><td align="center">breaks</td><td align="center">用来定义数值和颜色的对应关系，默认为 “NA”</td></tr><tr><td align="center">border_color</td><td align="center">表示热图每个小的单元格边框的颜色，默认为 “NA”</td></tr><tr><td align="center">cellwidth</td><td align="center">表示单个单元格的宽度，默认为 “NA”，即根据窗口自动调整</td></tr><tr><td align="center">cellheight</td><td align="center">表示单个单元格的高度，默认为 “NA”，即根据窗口自动调整</td></tr><tr><td align="center">fontsize</td><td align="center">表示热图中字体大小</td></tr><tr><td align="center">fontsize_row</td><td align="center">表示行名字体大小，默认与fontsize一致</td></tr><tr><td align="center">fontsize_col</td><td align="center">表示列名字体大小，默认与fontsize一致</td></tr><tr><td align="center">fontsize_number</td><td align="center">表示热图上显示数字的字体大小</td></tr><tr><td align="center">angle_col</td><td align="center">表示列标签的角度，可选择 “0”，“45”，“90”，“270”，“315”</td></tr><tr><td align="center">display_numbers</td><td align="center">表示是否在单元格上显示原始数值或按照特殊条件进行区分标记</td></tr><tr><td align="center">number_format</td><td align="center">表示热图单元格上显示的数据格式，如 “%.2f” 表示两位小数； “%.1e” 表示科学计数法</td></tr><tr><td align="center">number_color</td><td align="center">表示热图单元格上显示的数据字体颜色</td></tr><tr><td align="center">legend</td><td align="center">表示是否显示图例，值为TRUE或FALSE</td></tr><tr><td align="center">annotation_row</td><td align="center">表示是否对行进行注释</td></tr><tr><td align="center">annotation_col</td><td align="center">表示是否对列进行注释</td></tr><tr><td align="center">annotation_colors</td><td align="center">表示行注释及列注释的颜色</td></tr><tr><td align="center">annotation_legend</td><td align="center">表示是否显示注释的图例信息</td></tr><tr><td align="center">annotation_names_row</td><td align="center">表示是否显示行注释的名称</td></tr><tr><td align="center">annotation_names_col</td><td align="center">表示是否显示列注释的名称</td></tr><tr><td align="center">show_rownames</td><td align="center">表示是否显示行名</td></tr><tr><td align="center">show_colnames</td><td align="center">表示是否显示列名</td></tr><tr><td align="center">main</td><td align="center">表示热图的标题名字</td></tr><tr><td align="center">gaps_row</td><td align="center">仅在未进行行聚类时使用，表示在行方向上热图的隔断位置，如 gaps_row &#x3D; c(２, 4)表示在第２与第4列进行隔断</td></tr><tr><td align="center">gaps_col</td><td align="center">仅在未进行列聚类时使用，表示在列方向上热图的隔断位置，同 gaps_row</td></tr><tr><td align="center">labels_row</td><td align="center">表示使用行标签代替行名</td></tr><tr><td align="center">labels_col</td><td align="center">表示使用列标签代替列名</td></tr><tr><td align="center">filename</td><td align="center">表示保存图片的位置及命名</td></tr><tr><td align="center">width</td><td align="center">表示输出绘制热图的宽度</td></tr><tr><td align="center">height</td><td align="center">表示输出绘制热图的高度</td></tr><tr><td align="center">margins</td><td align="center">表示热图距画布的空白距离</td></tr></tbody></table><p>好吧，看上去基本上都能用到。制作热图应用的统计学原理就不多说了，我也没研究明白，我们用上面的这些参数能做出好看点的图就行。所以其实pheatmap中也有对应的参数scale来对行或列进行均一化，在pheatmap中设置参数或者多加一行代码做个均一化转换都是一样的。</p></div><h2 id="5-最终流程代码"><a href="#5-最终流程代码" class="headerlink" title="5. 最终流程代码"></a>5. 最终流程代码</h2><div class="story post-story"><p>知道了简化版代码的各行命令和pheatmap各参数作用，稍加一点点修改得到最终流程代码：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">library<span class="punctuation">(</span><span class="string">&quot;pheatmap&quot;</span><span class="punctuation">)</span></span><br><span class="line">nDEGs <span class="operator">&lt;-</span> gene<span class="punctuation">[</span>which<span class="punctuation">(</span>gene<span class="operator">$</span>group <span class="operator">!=</span> <span class="string">&quot;NOT_CHANGE&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span><span class="punctuation">]</span></span><br><span class="line">sort_DEGs <span class="operator">&lt;-</span> arrange<span class="punctuation">(</span>nDEGs<span class="punctuation">,</span>padj<span class="punctuation">)</span></span><br><span class="line">all_matrix <span class="operator">&lt;-</span> mycounts<span class="punctuation">[</span><span class="punctuation">(</span>sort_DEGs<span class="punctuation">[</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">)</span><span class="punctuation">,</span><span class="punctuation">]</span></span><br><span class="line">heat_matrix_all <span class="operator">&lt;-</span> t<span class="punctuation">(</span>scale<span class="punctuation">(</span>t<span class="punctuation">(</span>all_matrix<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 要做热图的每列分组，底下两行代码是必须的</span></span><br><span class="line">annotation_col <span class="operator">&lt;-</span> data.frame<span class="punctuation">(</span>sample <span class="operator">=</span> factor<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="built_in">rep</span><span class="punctuation">(</span><span class="string">&quot;SD&quot;</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">)</span><span class="punctuation">,</span><span class="built_in">rep</span><span class="punctuation">(</span><span class="string">&quot;LD1&quot;</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="comment"># 简单粗暴地写一个分组矩阵</span></span><br><span class="line">row.names<span class="punctuation">(</span>annotation_col<span class="punctuation">)</span> <span class="operator">&lt;-</span> colnames<span class="punctuation">(</span>heat_matrix_all<span class="punctuation">)</span></span><br><span class="line">pheatmap<span class="punctuation">(</span>heat_matrix_all<span class="punctuation">,</span></span><br><span class="line">         color <span class="operator">=</span> colorRampPalette<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;blue&quot;</span><span class="punctuation">,</span> <span class="string">&quot;white&quot;</span><span class="punctuation">,</span> <span class="string">&quot;red&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">(</span><span class="number">100</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">         treeheight_col <span class="operator">=</span> <span class="number">30</span><span class="punctuation">,</span></span><br><span class="line">         treeheight_row <span class="operator">=</span> <span class="number">10</span><span class="punctuation">,</span></span><br><span class="line">         show_rownames <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span></span><br><span class="line">         angle_col <span class="operator">=</span> <span class="number">45</span><span class="punctuation">,</span></span><br><span class="line">         annotation_col <span class="operator">=</span> annotation_col<span class="punctuation">,</span></span><br><span class="line">         filename <span class="operator">=</span> <span class="string">&quot;test.pdf&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p><img src="https://www.shelven.com/tuchuang/20220504_1/test.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220504_1/test.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>保存后的差异基因热图如上所示，左边4列是LD长日照1天组，右边4列是SD短日照对照组。数据不是特别好，但是两组还是能区分开的，至少也比第一次做的顺眼一点了。</p><p><strong>标题参数main有个小bug</strong>，加了参数在plots区域预览是正常的，但是用filename保存到输出文件如果标题是中文会出错，无法显示中文标题。这个小bug倒是无伤大雅，图在plots区也可以直接保存输出，不是非得要用filname参数指定输出文件输出的。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h2&gt;&lt;div class=&quot;story post-story&quot;&gt;&lt;p&gt;前面说到怎么用ggplot做一个火山图来查看各个基因的表达情</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="转录组数据分析" scheme="http://www.shelven.com/categories/%E8%BD%AC%E5%BD%95%E7%BB%84%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
    <category term="R语言" scheme="http://www.shelven.com/tags/R%E8%AF%AD%E8%A8%80/"/>
    
    <category term="pheatmap" scheme="http://www.shelven.com/tags/pheatmap/"/>
    
  </entry>
  
  <entry>
    <title>获得测序原始数据——初探GEO和SRA数据库</title>
    <link href="http://www.shelven.com/2022/05/04/a.html"/>
    <id>http://www.shelven.com/2022/05/04/a.html</id>
    <published>2022-05-03T20:02:37.000Z</published>
    <updated>2022-05-03T20:26:55.722Z</updated>
    
    <content type="html"><![CDATA[<h2 id="初探GEO数据库和SRA数据库"><a href="#初探GEO数据库和SRA数据库" class="headerlink" title="初探GEO数据库和SRA数据库"></a>初探GEO数据库和SRA数据库</h2><div class="story post-story"><p>最近在看转录组数据分析的文献，想下载一些原始数据自己跑一跑的，发现自己对于几个高通量测序数据库还是有些不太熟悉。以我现在的经验来看，EBI数据库的原始测序数据最容易获得，可以直接在EBI官网下载需要的fastq格式文件，但是NCBI的SRA数据库下载数据还是有些麻烦的，做个学习笔记记录下。</p></div><h2 id="1-GEO数据库"><a href="#1-GEO数据库" class="headerlink" title="1. GEO数据库"></a>1. GEO数据库</h2><div class="story post-story"><p><a href="https://www.ncbi.nlm.nih.gov/geo/">先上数据库链接，点击这里</a></p><p>GEO数据库全称Gene Expression Omnibus database，是由美国国立生物技术信息中心NCBI创建并维护的基因表达数据库。它创建于2000年，收录了世界各国研究机构提交的大多数高通量基因表达数据，GEO除了二代测序数据，还包含<strong>芯片测序</strong>、<strong>单细胞测序数据</strong>。</p><p>GEO数据库有四种数据存放类型**GSE数据编号(Series)、GPL数据编号(GEO platforms)、GSM数据编号(Samples)和GDS数据编号(Datasets)**。</p><p>一篇文章可以有一个或者多个GSE(Series)数据集，一个GSE里面可以有一个或者多个GSM(Samples)样本，如果做的是基因芯片，那每个数据集也会有自己对应的芯片平台，就是GPL(GEO platforms)。GSE编号一般为作者提交时生成的原始数据编号，后续NCBI中的工作人员会根据研究目的、样品类型等信息归纳整合为一个GDS(Datasets)，整理后的数据还会有GEO profile数据，也就是基因在这次实验中的表达数据。我平常文献里看到最多的就是GSE编号，可以直接在GEO数据库的搜索框里输入查看。</p><p><img src="https://www.shelven.com/tuchuang/20220504/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220504/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>我个人比较关注的是tools栏目里的<strong>FTP Site</strong>功能。ftp是文件传输协议，ftp访问的界面非常干净，如果我只需要下载GEO数据库里的文件，而不关注其他多余信息的话，可以通过这个界面非常快速地找到对应GSE编号下所有作者上传到GEO数据库的文件，目录结构层次一目了然。如下图所示，datasets对应GDS编号；platforms对应GPL编号；samples对应GSM编号；series对应GSE编号，网站还很贴心地给了README.txt里面写了帮助文档，包括怎么用ftp访问等等</p><p><img src="https://www.shelven.com/tuchuang/20220504/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220504/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><img src="https://www.shelven.com/tuchuang/20220504/3.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220504/3.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>在Browse Content这个栏目里，我们也能看到这个数据库的一些概览，比如现在有多少数据集，多少个芯片平台，多少上传的样品等等信息。我翻看了一下两年前jimmy出的教程，那个时候的GEO数据库收录的信息只有现在的一半不到，两年时间这些数据呈井喷式的发展，大数据时代信息发展之快也确实让我挺震惊。</p><p>尤其是点开基因芯片的平台，以上传的样品数量对这些芯片平台进行排序，发现两年前独占鳌头的Affymetrix公司的HG-U133（也是最古老的基因芯片）已经被illumina公司高通量测序芯片全面超越了接近两倍，这也意味着高通量测序在这两年发展已经不仅仅是快速发展了，简直是火箭式发展……这也是大势所趋。</p><p><img src="https://www.shelven.com/tuchuang/20220504/4.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220504/4.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>GEO数据库的搜索地址也很有规律性，比如只有最后的GSE编号不同，其他网址字段都是一模一样的，这也算是方便搜索的一个没什么用处的小技巧？……</p><p><img src="https://www.shelven.com/tuchuang/20220504/5.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220504/5.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>看点有用的，我们根据文献得到的GSE编号进行搜索，可以看到如下页面，前半部分是作者的一些信息，我们可以获得测序物种、作者的联系方式、发表的文章PMID等等，而我们更需要获取的信息在后半部分：</p><p><img src="https://www.shelven.com/tuchuang/20220504/7.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220504/7.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>样本信息这里解释一下，有三种主要的数据类型：</p><ul><li><p>SOFT  平台信息芯片中探针与基因的对应关系注释文件，样品单独的表达量，所有信息文件</p></li><li><p>MINiML  XML格式的所有数据，同SOFT文件单格式不同，和HTML格式差不多</p></li><li><p>TXT  这是样品表达矩阵的数据文件，我的理解是总结类型文件，不如用底下的原始数据</p></li></ul><p>原始数据信息也说一下，<strong>这里可能会给原始测序的raw data，也可能不给；有的时候会给raw count表达矩阵，也有的时候不给；样品表达矩阵也是有的时候给的raw count，有的时候给的FPKM</strong>（比如上面这种情况）。就…挺离谱的，没有标准，如果我们要跑Deseq2复现作者的结论，通过FPKM得到的表达矩阵还不能用。希望网站能制定点相关标准吧（题外话，不然对于我们这种小白，找不到数据直接痛苦面具）</p><p>我个人觉得，这个数据库比较重要的是可以获得样品分组信息和SRA数据库的链接地址，方便我们下载测序原始数据（后面介绍怎么下载）。<strong>如果不想跑原始数据，也可以直接拿样品表达矩阵来跑转录组下游分析</strong>。直接用表达矩阵就是要当心作者拿漂亮数据坑你。</p></div><h2 id="2-SRA数据库"><a href="#2-SRA数据库" class="headerlink" title="2. SRA数据库"></a>2. SRA数据库</h2><div class="story post-story"><p><a href="https://www.ncbi.nlm.nih.gov/sra">同样的先上数据库链接，点这里</a></p><p>其实从网址上就可以看出端倪，这俩数据库都是NCBI旗下的俩兄弟，都是NCBI一个亲爹亲妈养的。我百度的时候也发现，很多人把这两个数据库混在一起，或者叫GEO&#x2F;SRA数据库，其实两者还是有区别的。</p><p>SRA数据库是三大核酸数据库之一，我之前的笔记也有介绍过<a href="https://www.shelven.com/2022/04/14/a.html?keyword=%E8%81%94%E7%9B%9F">（点击这里查看）</a>。我个人的理解是，SRA数据库存放的是原始测序文件，而GEO数据库存放的大部分是经过作者处理以后的数据文件（有的也包括了原始测序文件），相对而言SRA数据库更大也更存粹，而NCBI官方也给了下载SRA数据的小工具——<strong>SRA Toolkit</strong>。</p><p>SRA数据类型包含如下四种，看到前缀知道这是SRA数据库，了解一下就行：</p><ul><li><p>Studies  研究课题（前缀为ERP或SRP，包含多个Experiment)</p></li><li><p>Experiments  实验设计（前缀为SRS，包含Sample、DNA source、测序平台和测序数据等信息）</p></li><li><p>Samples  样品信息（前缀为SRX，包含一个或多个Runs)</p></li><li><p>Runs  测序结果集（SSR开头的记录，代表测序仪器所产生的reads）</p></li></ul><h3 id="主要说说数据下载方式"><a href="#主要说说数据下载方式" class="headerlink" title="主要说说数据下载方式"></a><strong>主要说说数据下载方式</strong></h3><p>前几天也有同学问我sra数据库的原始测序数据怎么下载的，找不到下载方式，看的教程都是NCBI上直接下载的。emmmmmm我的第一反应是这不就是NCBI旗下的子数据库嘛……还能从哪儿下载…</p><p>废话不多说，直接看官网给的下载工具——<a href="https://trace.ncbi.nlm.nih.gov/Traces/sra/sra.cgi?view=software">SRA Toolkit</a></p><p><img src="https://www.shelven.com/tuchuang/20220504/8.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220504/8.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>这是一个官方给的小工具合集，提供我们各种操作系统下的安装包，我把linux和windows安装包都下了。安装步骤都是一样的，解压，把bin文件夹路径加到系统环境变量，搞定。windows需要打开cmd命令行运行一次prefetch（下载命令），按照提示输入<code>vdb-config --interactive</code>起到类似激活的作用就行了。linux里甚至都不需要编译（也可以conda安装）。可能有的同学对自己的windows系统不熟悉，不知道怎么改自己的系统环境变量，其实这个比linux改环境变量更容易，百度一下吧&#x3D; &#x3D;</p><p><img src="https://www.shelven.com/tuchuang/20220504/9.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220504/9.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><strong>我个人更推荐在windows系统安装SRA Toolkit</strong>，SRA数据库本身服务器在国外，国内访问下载速度慢到令人发指（个位数Kb&#x2F;s，甚至直接没有），而类似转录组这种数据，细菌可能还好点，动植物做个10X测序动不动就是几个G十几个G，加上分组和生物学重复动辄几十上百G，那点速度下到天荒地老也下不完。纯命令行的linux系统使用代理服务相对windows系统来说要麻烦一点，说白了，windows系统更容易科学上网，为了下载数据没有别的办法。</p><p>我们用的就是SRA Toolkit工具包里的<strong>prefetch命令</strong>下载原始数据，prefetch有个最大的好处是只要知道SRA数据库的数据类型编号，就可以<strong>直接下载</strong>对应的原始数据。如果要批量下载，可以将数据编号写入txt文件中再运行prefetch命令，或者直接写个循环语句。所以这里的关键是怎么得到数据编号，比如SRR编号等等。</p><p>前面GEO数据库提供了SRA数据库的链接，我们可以直接点开（或者点击原始数据底下的<strong>SRA Run Selector</strong>）：</p><p><img src="https://www.shelven.com/tuchuang/20220504/10.jpg.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220504/10.jpg.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>点击右上角的<strong>Send results to Run selector</strong>:</p><p><img src="https://www.shelven.com/tuchuang/20220504/11.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220504/11.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>我们可以看到，这个项目一共有16个基因组测序数据，难道要16个wget命令一个一个下载麽？不需要，如果要下载的基因组数据数量多肯定不行。我们可以从Accession list里获取不同前缀的各种run数据，后面用prefetch命令结合循环语句，直接一步下载。</p><p><img src="https://www.shelven.com/tuchuang/20220504/12.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220504/12.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>把Accession list的编号全部复制下来，以linux为例运行<code>cat &gt; id</code>，回车后粘贴编号，按ctrl+c退出，这样就生成了一个名为id的文件，里面内容是我们要下载的基因组测序数据编号。</p><p>写一个循环语句<code>cat id | while read id ;do prefetch $id &amp;;done</code> ，就可以全部下载了，这里没有指定输出目录，最终所有原始测序数据会输出到<strong>根目录下。</strong></p><p><img src="https://www.shelven.com/tuchuang/20220504/13.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220504/13.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><img src="https://www.shelven.com/tuchuang/20220504/14.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220504/14.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>最后顺便说一句，下载测序原始数据的方法很多，不仅仅是官方给的这个小工具。还可以用aspera遵循一定的下载格式也可以下载原始数据，或者用最原始的wget简单粗暴直接下载，只是说这些方法都或多或少受到网络限制的影响，prefetch也只是相对稳定一点。前面的笔记我也介绍过爬虫的编程方法，分解网页结构，批量抓取我们需要的信息，这也不失为一种方法。人是活的，不要拘泥于一种思路。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;初探GEO数据库和SRA数据库&quot;&gt;&lt;a href=&quot;#初探GEO数据库和SRA数据库&quot; class=&quot;headerlink&quot; title=&quot;初探GEO数据库和SRA数据库&quot;&gt;&lt;/a&gt;初探GEO数据库和SRA数据库&lt;/h2&gt;&lt;div class=&quot;story pos</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="SRA" scheme="http://www.shelven.com/tags/SRA/"/>
    
    <category term="SRA Toolkit" scheme="http://www.shelven.com/tags/SRA-Toolkit/"/>
    
    <category term="GEO" scheme="http://www.shelven.com/tags/GEO/"/>
    
  </entry>
  
  <entry>
    <title>简易爬虫程序编程记录——以微博热搜为例</title>
    <link href="http://www.shelven.com/2022/05/03/a.html"/>
    <id>http://www.shelven.com/2022/05/03/a.html</id>
    <published>2022-05-02T16:05:41.000Z</published>
    <updated>2022-05-02T16:07:59.402Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-关于爬虫"><a href="#1-关于爬虫" class="headerlink" title="1. 关于爬虫"></a>1. 关于爬虫</h2><div class="story post-story"><p>百度百科对于爬虫的定义是，网络爬虫（又被称为网页蜘蛛、网络机器人，在 FOAF 社区中，经常被称为网页追逐者），是一种按照一定的规则，自动抓取互联网信息的程序或者脚本。另外一些不常使用的名字还有蚂蚁、自动索引、模拟程序或者蠕虫。</p><p>我们只需要知道爬虫的作用是抓取网页的信息，其实现在互联网上充斥着大量的爬虫，包括不局限于火车票抢票软件，各种实时数据分析网站等等，本质上都是发起大量的http请求获得信息。爬虫技术的滥用会导致目标网站在短时间内收到大量的访问请求，进而导致服务器瘫痪，相当于是ddos攻击了。但是爬虫的便利性是不可否认的，尤其是批量操作数据和获取信息，比如批量下载我们需要的文献等等。犯罪的永远是凶手而不是工具，我们在合法的范围内应用好工具，能为我们生活提供非常大的便利。</p><p>知其然知其所以然，了解这个技术的最好方法是自己去学，因此写了这个小爬虫程序。为什么拿微博热搜来练手呢，因为微博热搜网页结构非常简单明了，很容易上手……</p><p>写的这个小爬虫程序主要是应用requests库和lxml包的etree库，简单介绍一下。</p><h3 id="1-1-requests"><a href="#1-1-requests" class="headerlink" title="1.1 requests"></a>1.1 requests</h3><p>requests是最常用的Python HTTP客户端库，编写爬虫和测试服务器响应数据时经常会用到，专门用于发送HTTP请求。说白了requests最大的作用就是发起http请求，返回我们需要的网页数据，所谓爬虫就是从网页上抓取和整理我们需要的<strong>公开的</strong>信息，对于<strong>非公开的信息抓取是违法的</strong>。</p><p>requests请求方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">requests.get(url, kwargs)：     发送GET请求</span><br><span class="line">requests.post(url, kwargs)：        发送POST请求</span><br><span class="line">requests.put(url, kwargs)：     发送PUT请求</span><br><span class="line">requests.delete(url, kwargs)：  发送DELETE请求</span><br><span class="line">requests.head(url, kwargs)：        发送head请求</span><br><span class="line">erquests.options(url, kwargs)： 发送options请求</span><br><span class="line">这些请求方法的参数和用法一致，必选参数为url，其他参数为可选参数</span><br></pre></td></tr></table></figure><h3 id="1-2-etree"><a href="#1-2-etree" class="headerlink" title="1.2 etree"></a>1.2 etree</h3><p>lxml的etree是从上面requests返回的html源码中提取信息用的，我们可以通过xpath解析网页的dom树，从中获取我们需要的元素和内容。</p><p>主要用的也就是<code>etree.HTML()</code>，可以用来解析字符串格式的html文档对象，更方便对我们需要的元素和对象进行抓取，后面演示会说到。</p></div><h2 id="2-代码和结果展示"><a href="#2-代码和结果展示" class="headerlink" title="2. 代码和结果展示"></a>2. 代码和结果展示</h2><div class="story post-story"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://s.weibo.com/top/summary/&#x27;</span></span><br><span class="line">header = &#123;<span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.127 Safari/537.36&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;cookie&#x27;</span>: <span class="string">&quot;UOR=www.baidu.com,s.weibo.com,www.baidu.com; SINAGLOBAL=2417808258422.6777.1651037395174; _s_tentry=-; Apache=9947874618898.105.1651493077297; ULV=1651493077318:2:1:1:9947874618898.105.1651493077297:1651037395190; PC_TOKEN=04cd3c070b; login_sid_t=80fe8e3820060c4330191a42b71357dd; cross_origin_proto=SSL; ALF=1683032497; SSOLoginState=1651496497; SUB=_2A25Pa6ZiDeRhGeFL6lAT-CzMyj-IHXVsAJCqrDV8PUNbmtB-LUjdkW9NQm3k0nVgyW6LFmyhR5luy-dtvVNK1VjC; SUBP=0033WrSXqPxfM725Ws9jqgMF55529P9D9WWTcwdUO8qo5ZVwP9-2e8C.5JpX5KzhUgL.FoMfeKzE1hz7eKe2dJLoIp7LxKML1KBLBKnLxKqL1hnLBoMNSK2EeonEeh20&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">resp = requests.get(url, headers=header)</span><br><span class="line">resp1 = resp.content.decode(encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">resp2 = etree.HTML(resp1)</span><br><span class="line">title = resp2.xpath(<span class="string">&#x27;//*[@id=&quot;pl_top_realtimehot&quot;]/table/tbody/tr/td/a/text()&#x27;</span>)</span><br><span class="line">clout = resp2.xpath(<span class="string">&#x27;//*[@id=&quot;pl_top_realtimehot&quot;]/table/tbody/tr/td/span/text()&#x27;</span>)</span><br><span class="line">addresses = resp2.xpath(<span class="string">&#x27;//*[@id=&quot;pl_top_realtimehot&quot;]/table/tbody/tr/td/a/@href&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(time.strftime(<span class="string">&quot;%F,%R&quot;</span>)+<span class="string">&#x27;\n50条实时微博热搜\n&#x27;</span>+<span class="string">&#x27;\n排列方式：序号+关键词+热度\n&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">51</span>):</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(<span class="string">&#x27;置顶&#x27;</span>+<span class="string">&#x27;\t&#x27;</span>+title[i]+<span class="string">&#x27;\n&#x27;</span>+<span class="string">&#x27;https://s.weibo.com&#x27;</span>+addresses[i]), <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(<span class="built_in">str</span>(i)+<span class="string">&#x27;\t&#x27;</span>+title[i]+<span class="string">&#x27;\t&#x27;</span>+clout[i-<span class="number">1</span>]+<span class="string">&#x27;\n&#x27;</span>+<span class="string">&#x27;https://s.weibo.com&#x27;</span>+addresses[i]), <span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure><p>未对代码进行封装，源代码就这么十几行，实现的结果是，执行一次就在当前终端屏幕上输出实时的50条微博热搜话题，并显示序号和热度，每条热搜话题下一行生成微博超链接。</p><p><img src="https://www.shelven.com/tuchuang/20220502/1.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220502/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div><h2 id="3-代码详解"><a href="#3-代码详解" class="headerlink" title="3. 代码详解"></a>3. 代码详解</h2><div class="story post-story"><p>建立python脚本，导入模块这步不解释了。</p><p>url是我们要抓取信息的网站地址，这个很好理解。header是我们调用requests模块需要的一个重要参数，里面提供了我们访问需要的认证信息cookie，http请求本身是无状态的，网站无法确认前一次发出请求的人和后一次发出请求的人是否为同一人，因此需要让网站记住我们的登录信息cookie以响应我们的请求。没有header可能无法返回网页信息，那这一大堆东西是怎么来的呢？需要我们审查网页元素。</p><h3 id="3-1-获得cookie和user-agent"><a href="#3-1-获得cookie和user-agent" class="headerlink" title="3.1 获得cookie和user-agent"></a>3.1 获得cookie和user-agent</h3><p>打开微博热搜首页，登录微博，随便什么空白的地方右键，点击检查，找到network（网络）。</p><p>上面的为网页元素，日志控制台，网络，资源，性能和内存等等标签，下面的就是对应的内容，往往点击第一个总结类的文件可以获得request headers信息，这里面最重要的两个信息：<strong>cookie和User-Agent</strong></p><p><img src="https://www.shelven.com/tuchuang/20220502/2.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220502/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>将cookie和user-agent内容全部写到header变量中，这样每次访问网站就带上了我们唯一的标志信息</p><p><code>resp = requests.get(url, headers=header)</code> 访问目标网址，返回的html源码赋值给resp，然而我们看不到返回的值是怎么样的，什么类型的，这里我就要介绍一下vscode的AREPL插件了。</p><h3 id="3-2-AREPL查看变量和审查网站元素"><a href="#3-2-AREPL查看变量和审查网站元素" class="headerlink" title="3.2 AREPL查看变量和审查网站元素"></a>3.2 AREPL查看变量和审查网站元素</h3><p>前面介绍vscode插件说过，AREPL可以实时打印出当前的变量信息而不需要运行代码，极大地方便了我们查看返回的值和信息，知道每一行代码发挥了什么作用。</p><p>我们看一下自定义的resp变量是什么：</p><p><img src="https://www.shelven.com/tuchuang/20220502/3.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220502/3.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>status_code值为200，很明显成功返回了html源码信息，但是点开来看却得不到我们需要的网页文字信息，因为还没有进行解码。我们可以看到编码方式是UTF-8，自然而然的，我们就要对resp变量值进行对应的UTF-8解码，也就是后面的代码<code>resp1 = resp.content.decode(encoding=&#39;utf-8&#39;)</code>，这里注意一点要用content不能用text</p><p>再来点开看看解码后的resp1：</p><p><img src="https://www.shelven.com/tuchuang/20220502/4.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220502/4.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>如果有点html基础的话会发现，怎么样，是不是很熟悉！没错！这就是我们在审查网页元素获得的网页的前端结构，这里包括了所有的网页信息，再也不用点开原网站一个一个元素去找啦！（<del>就比如我这小破站的网页元素看地我脑瓜子嗡嗡的）</del>这里可以很轻易地看到各个节点信息，极大方便了我写上面的爬虫代码。</p><p>这里我需要三个信息，热搜的标题、热度和网址，我们来展开看一看网页结构：</p><p><img src="https://www.shelven.com/tuchuang/20220502/5.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220502/5.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>像洋葱一样一层一层拨开网页结构，我们可以清楚地看到table&#x2F;tbody&#x2F;tr&#x2F;td&#x2F;a节点的内容是微博热搜标题，a这个节点的标签href就是网址，table&#x2F;tbody&#x2F;tr&#x2F;td&#x2F;span节点的内容就是热度，至此，网页结构一清二楚，我们要做的就是把信息提取出来，提取的方式就是etree解析这个字符串格式的html文档，生成对应的元素路径。</p><h3 id="3-3-解析html文档"><a href="#3-3-解析html文档" class="headerlink" title="3.3 解析html文档"></a>3.3 解析html文档</h3><p><code>resp2 = etree.HTML(resp1)</code>就是用来解析字符串格式的HTML文档对象的，将传进去的字符串转变成元素对象</p><p>转换后的resp2如下，我们可以看到每个节点都被转换成了_Element对象：</p><p><img src="https://www.shelven.com/tuchuang/20220502/6.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220502/6.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>接下来就是顺理成章地用xpath寻找元素路径，将对应内容提取出来，我的元素路径中应用了正则表达式，这里也不解释了。</p><p>最后可以将提取出来的三个信息一一打印出来看看是否有问题<del>（AREPL插件真的立大功）</del>，有了信息接下来就是整理和排版，那就是print函数和循环语句的基本用法了。虽然python中的print函数和循环语句与R或者linux中略有不同，这个基础知识这里也不再赘述。</p><p>唯一我觉得需要注意的是，range() 函数提供的是0-51的整数；官网置顶的微博没有热度显示，所以我写了一个if判断语句区别；排版的时候注意转义字符，其他都是细节微调部分，怎么美观怎么顺眼怎么来。</p></div><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><div class="story post-story"><p>因为这个网页没有做反爬（或许是我没注意到）手段，至少我获取这些公开信息还是没有遇到阻碍的，这也是最最简单的一个爬虫脚本了，调用第三方模块，解析网页，最后提取信息和整理，就是这么简单也很好理解。</p><p>我最近还接触到一个<strong>明日方舟</strong>抽卡记录汇总的小程序，我看了下小程序的方法，猜测这类程序也是类似的爬虫程序。先登录官方网站，需要你输入一个网址，提供token_by_cookie这个值，这个值在network标签中能找到，并且能发现resquest url就是获取token_by_cookie值的网站。</p><p><img src="https://www.shelven.com/tuchuang/20220502/7.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220502/7.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>获得这个token之后，我们可以看到抽卡记录可以通过另一个需要token的网址中直接获取，明日方舟的抽卡记录只能保存10页，因此，只需要输入token，直接更改page值1-10，就能获得详尽的抽卡信息。而做成好看的图表也<strong>无非是把爬虫程序和作图程序结合一下</strong>，封装，最后在小程序调用，思路就是这样的。</p><p><img src="https://www.shelven.com/tuchuang/20220502/8.jpg" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220502/8.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>同时也能发现，如果我们提供token值给别人，除了抽卡记录以外，还能提取我们的充值信息和源石消费信息等等这类隐私信息。要掌握隐私信息无非是程序的作者想不想做的问题，毕竟还是把隐私信息握在自己手里比较好。</p><p>学习就是学习这些技术的思路并为自己所用。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-关于爬虫&quot;&gt;&lt;a href=&quot;#1-关于爬虫&quot; class=&quot;headerlink&quot; title=&quot;1. 关于爬虫&quot;&gt;&lt;/a&gt;1. 关于爬虫&lt;/h2&gt;&lt;div class=&quot;story post-story&quot;&gt;&lt;p&gt;百度百科对于爬虫的定义是，网络爬虫（又被称为</summary>
      
    
    
    
    <category term="编程自学" scheme="http://www.shelven.com/categories/%E7%BC%96%E7%A8%8B%E8%87%AA%E5%AD%A6/"/>
    
    
    <category term="python" scheme="http://www.shelven.com/tags/python/"/>
    
    <category term="爬虫" scheme="http://www.shelven.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>vscode远程连接和快速搭建python环境</title>
    <link href="http://www.shelven.com/2022/04/29/a.html"/>
    <id>http://www.shelven.com/2022/04/29/a.html</id>
    <published>2022-04-29T10:17:01.000Z</published>
    <updated>2022-04-29T16:04:10.698Z</updated>
    
    <content type="html"><![CDATA[<p>最近在自学python，刚入门苦于不知道从何下手，也不知道用什么编辑器比较适合。在度娘上搜了十几款编辑器，最终决定用微软的vscode，这个编辑器可以配置Python、Java、C ++等编程环境，而且有非常强大的插件功能，界面看着也挺友好，写个日志记录下自己瞎捣鼓的配置。</p><p>本来是想在我的云服务器上装vscode，但是我的云服务器上没有可视化界面……于是在我的小破笔记本上安装了vscode，后来又发现有一个插件可以ssh连接上服务器，只要能ssh连接就可以直接调用服务器上事先安装好的各种python库，真香~</p><p>从头开始记录下使用方法和自己的设置</p><h2 id="1-下载vscode"><a href="#1-下载vscode" class="headerlink" title="1. 下载vscode"></a>1. 下载vscode</h2><div class="story post-story"><p>vscode可以直接上官网下载（速度很慢，建议科学上网），选择自己的操作系统，我用的windows</p><p><img src="https://shelven.com/tuchuang/20220429/1.jpg" class="lazyload" data-srcset="https://shelven.com/tuchuang/20220429/1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>一直下一步就可以了，唯一需要注意的是把vscode加入系统环境变量中（默认选项），安装以后能够在cmd命令行通过code打开说明就改了环境变量。当然也可以在系统环境变量的path中找到，这里不赘述</p></div><h2 id="2-插件下载"><a href="#2-插件下载" class="headerlink" title="2. 插件下载"></a>2. 插件下载</h2><div class="story post-story"><h3 id="2-1-中文语言包"><a href="#2-1-中文语言包" class="headerlink" title="2.1 中文语言包"></a>2.1 中文语言包</h3><p>英文界面对于我这种小白太难了，所以打开软件第一件事就是安装中文插件，这个在左边拓展栏输入chinese直接可以找到（我这里已经装好了，只是演示记录一下）</p><p><img src="https://shelven.com/tuchuang/20220429/2.jpg" class="lazyload" data-srcset="https://shelven.com/tuchuang/20220429/2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="2-2-ssh连接插件"><a href="#2-2-ssh连接插件" class="headerlink" title="2.2 ssh连接插件"></a>2.2 ssh连接插件</h3><p>因为我要远程调用服务器上的python库，所以我首先下载了SSH连接插件</p><p><img src="https://shelven.com/tuchuang/20220429/3.jpg" class="lazyload" data-srcset="https://shelven.com/tuchuang/20220429/3.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>安装以后点击右侧菜单栏的远程资源管理器，可以新建一个远程连接</p><p><img src="https://shelven.com/tuchuang/20220429/4.jpg" class="lazyload" data-srcset="https://shelven.com/tuchuang/20220429/4.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>按照正上方弹出的窗口提示，我们输入自己的用户账号和host地址，之后选择第一个选项，这样我们要连接的远程主机地址就被记录下来了。连接之后输入密码即可远程登录，每次登录都需要输入密码</p><p><img src="https://shelven.com/tuchuang/20220429/8.jpg" class="lazyload" data-srcset="https://shelven.com/tuchuang/20220429/8.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>连接以后可以选择打开文件夹，把根目录文件夹打开就可以调用远程服务器的所有文件了</p><p><img src="https://shelven.com/tuchuang/20220429/10.jpg" class="lazyload" data-srcset="https://shelven.com/tuchuang/20220429/10.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>看到终端成功显示欢迎界面，说明远程登陆成功，终端可以输入和执行命令了</p><p><img src="https://shelven.com/tuchuang/20220429/12.jpg" class="lazyload" data-srcset="https://shelven.com/tuchuang/20220429/12.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="2-3-python拓展插件"><a href="#2-3-python拓展插件" class="headerlink" title="2.3 python拓展插件"></a>2.3 python拓展插件</h3><p>远程登录只是第一步，接下来安装插件都是<strong>远程登录的窗口</strong>，安装在本地的插件一般不能用在远程登录窗口。我要搭建python环境，也是先安装python的拓展插件</p><p><img src="https://shelven.com/tuchuang/20220429/11.jpg" class="lazyload" data-srcset="https://shelven.com/tuchuang/20220429/11.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="2-4-AREPL插件"><a href="#2-4-AREPL插件" class="headerlink" title="2.4 AREPL插件"></a>2.4 AREPL插件</h3><p>这个插件可以在右上角点开，实时打印出你写的python脚本运行结果，变量的赋值等等，还可以检查你写的脚本哪里出错而不需要直接运行代码。这个插件在写爬虫脚本的时候真的非常方便（后面的笔记再分享，写个简单的爬虫脚本就能体会），再也不需要点开网页审查各个元素了，直接在右边框里找到</p><p><img src="https://shelven.com/tuchuang/20220429/13.jpg" class="lazyload" data-srcset="https://shelven.com/tuchuang/20220429/13.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>举个栗子比如我写了个打印皮卡丘的python脚本<del>（滑稽）</del>，我不用运行程序就能在右边看到代码运行的结果</p><p><img src="https://shelven.com/tuchuang/20220429/15.jpg" class="lazyload" data-srcset="https://shelven.com/tuchuang/20220429/15.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div><h2 id="3-脚本调试"><a href="#3-脚本调试" class="headerlink" title="3. 脚本调试"></a>3. 脚本调试</h2><div class="story post-story"><p>下载完插件，写完代码，我们首先要进行的就是代码调试，点击左侧菜单栏的 <strong>运行和调试</strong> ，我们直接点击创建 launch.json文件</p><p><img src="https://shelven.com/tuchuang/20220429/16.jpg" class="lazyload" data-srcset="https://shelven.com/tuchuang/20220429/16.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>在弹出的正上方菜单栏选择第一个调试配置打开的python文件</p><p><img src="https://shelven.com/tuchuang/20220429/17.jpg" class="lazyload" data-srcset="https://shelven.com/tuchuang/20220429/17.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>本质上就是生成一个调试的json文件，不用太多了解，调试当前打开的文件就可以。也可以根据自己需要改成只调试指定名称的python脚本，改的就是红框里的部分</p><p><img src="https://shelven.com/tuchuang/20220429/18.jpg" class="lazyload" data-srcset="https://shelven.com/tuchuang/20220429/18.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>在脚本页面直接按F5就可以运行了，可以在代码的行号前设置红色的断点，用来分段测试代码，在写的代码比较多需要一段段检查错误的时候会比较有用。比如我在上面的皮卡丘脚本的第12行设置一个断点，再按F5运行脚本，就会从第一行报错（因为print函数被断点隔开了），右边是AREPL插件的输出结果，不受代码运行与否和断点的影响，所以能正常显示</p><p><img src="https://shelven.com/tuchuang/20220429/19.jpg" class="lazyload" data-srcset="https://shelven.com/tuchuang/20220429/19.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>我们同时也能看到右下角是bug调试区，也就是说我们在调试区运行程序，会自动给我们分配一个debug控制区的终端，我也可以同时在上面的bash区终端运行别的程序。</p></div><h2 id="4-格式化文档"><a href="#4-格式化文档" class="headerlink" title="4. 格式化文档"></a>4. 格式化文档</h2><div class="story post-story"><p>这几天自学过程中我也发现，python代码是有严格的缩进要求的，不像是linux系统中的shell语言，一行写完可以在另一行随便插几个制表符继续写下一个命令。python严格按照冒号和缩进来区分代码块之间的层次，在 Python 中，对于类定义、函数定义、流程控制语句、异常处理语句等，行尾的冒号和下一行的缩进，表示下一个代码块的开始，而缩进的结束则表示此代码块的结束。哪怕有一个多余的缩进量，就会系统报错</p><p>在赋值前后，运算符前后，#号注释之后等一些不用区分代码块层次的地方，python对空格要求却不是那么严格。虽然要求不严格，但是不小心手滑多打了或者少打了空格总归影响美观<del>（我真的有强迫症）</del>，这个时候可以用右键的格式化文档功能，一键自动改成标准格式</p><p><img src="https://shelven.com/tuchuang/20220429/20.jpg" class="lazyload" data-srcset="https://shelven.com/tuchuang/20220429/20.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>比如上面这个丑不拉几的程序虽然能跑出来结果，但是强迫症看完会当场去世。这个时候可以用右键的格式化文档功能一键对齐，如下</p><p><img src="https://shelven.com/tuchuang/20220429/21.jpg" class="lazyload" data-srcset="https://shelven.com/tuchuang/20220429/21.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>如果点格式化文档显示的是要装autopep8拓展，那就点确认安装。这个功能就是靠autopep8这个软件实现的，但是这个拓展软件是靠pip安装的，有的人没有安装pip，或者有的人（比如我）pip有问题，一直显示ssl证书不能获取拒绝安装，改pip源也无法解决问题<del>（又是套娃解决问题的一天）</del>，就要去github下载autopep8本地安装，更改环境变量才可以使用。也可以用conda直接一步安装，不得不说conda管理python环境变量是真的香</p><p>格式化文档也不是万能的，比方说我在父目录下封装了一个函数，我想在子目录下调用，vscode有一个缺点就是需要把当前目录加到环境变量里，然后才能调用我封装好的函数，<strong>但是！</strong>添加环境变量之后再调用，这个时候运行格式化文档的功能，<strong>系统会自动把调用模块排在添加环境变量步骤之前</strong>，因为软件的设计就是把调用模块一定放在第一位。</p><p>打个比方，我在父目录demo下封装了printpikaqiu()这个函数，这个函数作用是打印皮卡丘。文件目录如下</p><p><img src="https://shelven.com/tuchuang/20220429/22.jpg" class="lazyload" data-srcset="https://shelven.com/tuchuang/20220429/22.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>然后我在子目录test下调用，就需要先拓展环境变量再调用，代码如下图，f5运行没毛病，打印出一只皮卡丘：</p><p><img src="https://shelven.com/tuchuang/20220429/23.jpg" class="lazyload" data-srcset="https://shelven.com/tuchuang/20220429/23.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>但是右键格式化文档之后，代码直接变了，再运行直接红色的报错跳脸上</p><p><img src="https://shelven.com/tuchuang/20220429/24.jpg" class="lazyload" data-srcset="https://shelven.com/tuchuang/20220429/24.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>因为代码顺序改了，没有添加环境变量，找不到父目录demo怎么可能调用pikaqiu模块呢？这就非常尴尬了</p><p>因此在调用自己封装的函数和模块的时候，不要用格式化文档。现在暂时还没找到可靠的解决方法</p></div><h2 id="5-其他设置"><a href="#5-其他设置" class="headerlink" title="5. 其他设置"></a>5. 其他设置</h2><div class="story post-story"><p>vscode主菜单栏 文件—首选项 底下有非常多非常详细的设置选项，而且可以不同设备进行同步，这个是其优点之一。并且可以通过ctrl + shift + p 快速打开设置，支持直接修改配置的json文件，这个暂时还没用到，我只是改了个字体大小，以后有重要修改的时候再做记录，方便后续查看。</p><p>顺便提一嘴，我的云服务器是安装了anaconda管理python环境的，用vscode远程ssh登录云服务器后，仍然可以在右下角选择我用anaconda安装的各个版本python，依然是一键切换环境，真的太方便了。之前没用编辑器码代码，每次都要在linux里通过vim码好保存退出，再运行。。。各种意义上的身心折磨。。。</p><p><strong>现在就一个字，香！</strong></p><p><img src="https://shelven.com/tuchuang/20220429/26.jpg" class="lazyload" data-srcset="https://shelven.com/tuchuang/20220429/26.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在自学python，刚入门苦于不知道从何下手，也不知道用什么编辑器比较适合。在度娘上搜了十几款编辑器，最终决定用微软的vscode，这个编辑器可以配置Python、Java、C ++等编程环境，而且有非常强大的插件功能，界面看着也挺友好，写个日志记录下自己瞎捣鼓的配置。</summary>
      
    
    
    
    <category term="编程自学" scheme="http://www.shelven.com/categories/%E7%BC%96%E7%A8%8B%E8%87%AA%E5%AD%A6/"/>
    
    
    <category term="vscode" scheme="http://www.shelven.com/tags/vscode/"/>
    
    <category term="python" scheme="http://www.shelven.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>转录组数据分析笔记（8）——ggplot2和ggrepel绘制火山图</title>
    <link href="http://www.shelven.com/2022/04/25/a.html"/>
    <id>http://www.shelven.com/2022/04/25/a.html</id>
    <published>2022-04-24T20:53:27.000Z</published>
    <updated>2022-05-23T20:02:51.280Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><div class="story post-story"><p>前面介绍了怎么用DESeq2做两组样本的差异基因表达分析，以及怎么用dplyr包给DESeq2运行结果增加一列分组信息，我们先看下两个R包运行结束后生成的gene_0_1.csv文件是怎么样的：</p><p><img src="https://www.shelven.com/tuchuang/20220425/1.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220425/1.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>A-G列结果是DESeq2跑的，我们用到的只有基因名，log2FoldChange和padj这三列，通过log2FoldChange绝对值大于1，调整后的pvalue也就是padj（即FDR值）小于0.05筛选除差异表达基因，最后加上group列方便查看。</p><p>到这里已经可以通过排序找到我们感兴趣的基因了，但是这样的数据不够直观，我们还可以用最著名的绘图R包ggplot2做个火山图。这里需要准备的绘图R包是<strong>ggplot2</strong>，还有添加标签的R包<strong>ggrepel</strong>。</p><h3 id="1-2-两个注意点"><a href="#1-2-两个注意点" class="headerlink" title="1.2 两个注意点"></a>1.2 两个注意点</h3><p>什么是火山图就不多bb了，重要的是知道我们可以从火山图获得两个信息：差异表达倍数（FoldChange值）和统计学显著性的标志p值。为了更方便比较和作图，我们一般用<strong>log2FC</strong>代替Fold Change值并作为X轴数据，表示两样品（组）间表达量的比值，对其取以2为底的对数即为log2FC，一般默认取log2FC绝对值大于1为差异基因的筛选标准；用<strong>FDR</strong>（也就是padj值）代替pvalue，并取-log10（FDR）值作为Y轴，FDR是错误发现率，是pvalue值进行校正得到的。</p><p>log2FC有正有负很好理解，可能有同学发现，有的基因明明有pvalue值，但是校正之后的FDR值却是NA，如下：</p><p><img src="https://www.shelven.com/tuchuang/20220425/2.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220425/2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>查阅了<a href="http://www.360doc.com/content/18/1007/19/51784026_792756710.shtml">一些资料</a>，当基因的在所有样本中表达量为0，则两个值都为NA；当read count数较低时，DESeq2进行Independent Filtering过滤了一部分可能造成假阳性的结果，此时padj值为NA。因此，这部分数据在做火山图的时候因为没有对应的Y值也会被过滤掉。</p></div><h2 id="2-流程代码"><a href="#2-流程代码" class="headerlink" title="2. 流程代码"></a>2. 流程代码</h2><div class="story post-story"><p>这部分需要一点R语言基础，需要知道怎么改自己的参数。假设前面没有用dplyr包做差异筛选（做了也不影响，只是多一列数据而已）只用DESeq2跑了个结果，我们同样可以用ggplot2包做筛选，用ggrepel包美化做标签。继续用前面DESeq2生成的csv文件，流程代码如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">library<span class="punctuation">(</span><span class="string">&quot;ggplot2&quot;</span><span class="punctuation">)</span></span><br><span class="line">gene <span class="operator">&lt;-</span> read.csv<span class="punctuation">(</span><span class="string">&quot;gene_0_1.csv&quot;</span><span class="punctuation">,</span> stringsAsFactors <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">)</span></span><br><span class="line">gene<span class="punctuation">[</span>which<span class="punctuation">(</span>gene<span class="operator">$</span>log2FoldChange <span class="operator">&lt;=</span> <span class="operator">-</span><span class="number">1</span> <span class="operator">&amp;</span> gene<span class="operator">$</span>padj <span class="operator">&lt;</span> <span class="number">0.05</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="string">&quot;GROUP&quot;</span><span class="punctuation">]</span> <span class="operator">&lt;-</span> <span class="string">&quot;DOWN&quot;</span></span><br><span class="line">gene<span class="punctuation">[</span>which<span class="punctuation">(</span>gene<span class="operator">$</span>log2FoldChange <span class="operator">&gt;=</span> <span class="number">1</span> <span class="operator">&amp;</span> gene<span class="operator">$</span>padj <span class="operator">&lt;</span> <span class="number">0.05</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="string">&quot;GROUP&quot;</span><span class="punctuation">]</span> <span class="operator">&lt;-</span> <span class="string">&quot;UP&quot;</span></span><br><span class="line">gene<span class="punctuation">[</span>which<span class="punctuation">(</span><span class="built_in">abs</span><span class="punctuation">(</span>gene<span class="operator">$</span>log2FoldChange<span class="punctuation">)</span> <span class="operator">&lt;</span> <span class="number">1</span> <span class="operator">|</span> gene<span class="operator">$</span>padj <span class="operator">&gt;=</span> <span class="number">0.05</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="string">&quot;GROUP&quot;</span><span class="punctuation">]</span> <span class="operator">&lt;-</span> <span class="string">&quot;NOT CHANGE&quot;</span> <span class="comment"># |代表或，和linux里的管道是完全不一样的。以上三步新建了一列GROUP，筛选并赋予了三个值。</span></span><br><span class="line">res <span class="operator">&lt;-</span> ggplot<span class="punctuation">(</span>gene<span class="punctuation">,</span>     <span class="comment"># ggplot数据来源，这里省略了data = 和mapping = </span></span><br><span class="line">       aes<span class="punctuation">(</span>x <span class="operator">=</span> log2FoldChange<span class="punctuation">,</span>      <span class="comment"># 表示映射关系，就是定义xy</span></span><br><span class="line">           y <span class="operator">=</span> <span class="operator">-</span>log10<span class="punctuation">(</span>padj<span class="punctuation">)</span><span class="punctuation">,</span> </span><br><span class="line">           col <span class="operator">=</span> GROUP<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span>      <span class="comment"># 注意这里定义颜色用col，以GROUP值区分</span></span><br><span class="line">         geom_point<span class="punctuation">(</span>alpha <span class="operator">=</span> <span class="number">0.5</span><span class="punctuation">,</span>    <span class="comment"># ggplot做散点图，设置点透明度和大小</span></span><br><span class="line">                    size <span class="operator">=</span> <span class="number">1</span><span class="punctuation">)</span> <span class="operator">+</span> </span><br><span class="line">         scale_color_manual<span class="punctuation">(</span>values <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;red&quot;</span><span class="punctuation">,</span><span class="string">&quot;blue&quot;</span><span class="punctuation">,</span><span class="string">&quot;grey&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">                            limits <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;UP&quot;</span><span class="punctuation">,</span><span class="string">&quot;DOWN&quot;</span><span class="punctuation">,</span><span class="string">&quot;NOT CHANGE&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span>     <span class="comment"># 自定义颜色 </span></span><br><span class="line">         theme<span class="punctuation">(</span>panel.grid <span class="operator">=</span> element_blank<span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">,</span>    <span class="comment"># 去网格线</span></span><br><span class="line">               panel.background <span class="operator">=</span> element_rect<span class="punctuation">(</span>color <span class="operator">=</span> <span class="string">&quot;black&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                               fill <span class="operator">=</span> <span class="string">&quot;transparent&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span>   <span class="comment"># 去背景色，透明</span></span><br><span class="line">               plot.title <span class="operator">=</span> element_text<span class="punctuation">(</span>hjust <span class="operator">=</span> <span class="number">0.5</span><span class="punctuation">)</span><span class="punctuation">,</span>      <span class="comment"># 调整图标标题位置为中间</span></span><br><span class="line">               legend.key <span class="operator">=</span> element_rect<span class="punctuation">(</span>fill <span class="operator">=</span> <span class="string">&quot;transparent&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">               legend.background <span class="operator">=</span> element_rect<span class="punctuation">(</span>fill <span class="operator">=</span> <span class="string">&quot;transparent&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">               legend.position <span class="operator">=</span> <span class="string">&quot;right&quot;</span><span class="punctuation">)</span> <span class="operator">+</span>     <span class="comment"># 设置legend图标</span></span><br><span class="line">         geom_vline<span class="punctuation">(</span>xintercept <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="operator">-</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">                    color <span class="operator">=</span> <span class="string">&quot;gray&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    size <span class="operator">=</span> <span class="number">0.3</span><span class="punctuation">)</span> <span class="operator">+</span>       <span class="comment"># 设置x轴辅助线</span></span><br><span class="line">         geom_hline<span class="punctuation">(</span>yintercept <span class="operator">=</span> <span class="operator">-</span>log10<span class="punctuation">(</span><span class="number">0.05</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">                    color <span class="operator">=</span> <span class="string">&quot;gray&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    size <span class="operator">=</span> <span class="number">0.3</span><span class="punctuation">)</span> <span class="operator">+</span>       <span class="comment"># 设置y轴辅助线</span></span><br><span class="line">         labs<span class="punctuation">(</span>x <span class="operator">=</span> <span class="string">&quot;log2 Fold Change&quot;</span><span class="punctuation">,</span></span><br><span class="line">              y <span class="operator">=</span> <span class="string">&quot;-log10(FDR) &quot;</span><span class="punctuation">,</span></span><br><span class="line">              title <span class="operator">=</span> <span class="string">&quot;LD 1 day vs LD 0 day&quot;</span><span class="punctuation">)</span>       <span class="comment"># 设置坐标轴标题和火山图标题</span></span><br><span class="line">res     <span class="comment"># 查看结果，plots中可以查看</span></span><br><span class="line"></span><br><span class="line">library<span class="punctuation">(</span><span class="string">&quot;ggrepel&quot;</span><span class="punctuation">)</span></span><br><span class="line">up <span class="operator">&lt;-</span> subset<span class="punctuation">(</span>gene<span class="punctuation">,</span> GROUP <span class="operator">==</span> <span class="string">&quot;UP&quot;</span><span class="punctuation">)</span>       <span class="comment"># subset从数据框中筛选符合条件的数据</span></span><br><span class="line">up <span class="operator">&lt;-</span> up<span class="punctuation">[</span>order<span class="punctuation">(</span>up<span class="operator">$</span>padj<span class="punctuation">)</span><span class="punctuation">,</span> <span class="punctuation">]</span><span class="punctuation">[</span><span class="number">1</span><span class="operator">:</span><span class="number">5</span><span class="punctuation">,</span> <span class="punctuation">]</span>       <span class="comment"># order升序排序，取前5个</span></span><br><span class="line">down <span class="operator">&lt;-</span> subset<span class="punctuation">(</span>gene<span class="punctuation">,</span> GROUP <span class="operator">==</span> <span class="string">&quot;DOWN&quot;</span><span class="punctuation">)</span></span><br><span class="line">down <span class="operator">&lt;-</span> down<span class="punctuation">[</span>order<span class="punctuation">(</span>down<span class="operator">$</span>padj<span class="punctuation">)</span><span class="punctuation">,</span> <span class="punctuation">]</span><span class="punctuation">[</span><span class="number">1</span><span class="operator">:</span><span class="number">5</span><span class="punctuation">,</span> <span class="punctuation">]</span></span><br><span class="line">resdata <span class="operator">&lt;-</span> res <span class="operator">+</span> </span><br><span class="line">  geom_text_repel<span class="punctuation">(</span>data <span class="operator">=</span> rbind<span class="punctuation">(</span>up<span class="punctuation">,</span> down<span class="punctuation">)</span><span class="punctuation">,</span>       <span class="comment"># ggrepel特有的函数</span></span><br><span class="line">                  aes<span class="punctuation">(</span>x <span class="operator">=</span> log2FoldChange<span class="punctuation">,</span></span><br><span class="line">                      y <span class="operator">=</span> <span class="operator">-</span>log10<span class="punctuation">(</span>padj<span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">                      label <span class="operator">=</span> X <span class="punctuation">)</span><span class="punctuation">,</span>      <span class="comment"># label值指定哪列做标签</span></span><br><span class="line">                  size <span class="operator">=</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">                  box.padding <span class="operator">=</span> unit<span class="punctuation">(</span><span class="number">0.5</span><span class="punctuation">,</span> <span class="string">&quot;lines&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">                  segment.color <span class="operator">=</span> <span class="string">&quot;#cccccc&quot;</span><span class="punctuation">,</span></span><br><span class="line">                  show.legend <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">)</span>      <span class="comment"># 以上都是特有参数</span></span><br><span class="line">resdata     <span class="comment"># 查看结果</span></span><br><span class="line">ggsave<span class="punctuation">(</span><span class="string">&quot;gene_0_1.png&quot;</span><span class="punctuation">,</span> resdata<span class="punctuation">,</span> width <span class="operator">=</span> <span class="number">10</span><span class="punctuation">,</span> height <span class="operator">=</span> <span class="number">10</span><span class="punctuation">)</span>        <span class="comment"># 输出结果文件</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h2 id="3-代码详解"><a href="#3-代码详解" class="headerlink" title="3. 代码详解"></a>3. 代码详解</h2><div class="story post-story"><h3 id="3-1-ggplot2"><a href="#3-1-ggplot2" class="headerlink" title="3.1 ggplot2"></a>3.1 ggplot2</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gene<span class="punctuation">[</span>which<span class="punctuation">(</span>gene<span class="operator">$</span>log2FoldChange <span class="operator">&lt;=</span> <span class="operator">-</span><span class="number">1</span> <span class="operator">&amp;</span> gene<span class="operator">$</span>padj <span class="operator">&lt;</span> <span class="number">0.05</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="string">&quot;GROUP&quot;</span><span class="punctuation">]</span> <span class="operator">&lt;-</span> <span class="string">&quot;DOWN&quot;</span></span><br><span class="line">gene<span class="punctuation">[</span>which<span class="punctuation">(</span>gene<span class="operator">$</span>log2FoldChange <span class="operator">&gt;=</span> <span class="number">1</span> <span class="operator">&amp;</span> gene<span class="operator">$</span>padj <span class="operator">&lt;</span> <span class="number">0.05</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="string">&quot;GROUP&quot;</span><span class="punctuation">]</span> <span class="operator">&lt;-</span> <span class="string">&quot;UP&quot;</span></span><br><span class="line">gene<span class="punctuation">[</span>which<span class="punctuation">(</span><span class="built_in">abs</span><span class="punctuation">(</span>gene<span class="operator">$</span>log2FoldChange<span class="punctuation">)</span> <span class="operator">&lt;</span> <span class="number">1</span> <span class="operator">|</span> gene<span class="operator">$</span>padj <span class="operator">&gt;=</span> <span class="number">0.05</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="string">&quot;GROUP&quot;</span><span class="punctuation">]</span> <span class="operator">&lt;-</span> <span class="string">&quot;NOT CHANGE&quot;</span>  </span><br></pre></td></tr></table></figure><p>之前这里稍微解释一下，即使前面没有用dplyr包，用别的方法同样可以筛选差异基因并且新增一列分组数据，万变不离其宗，核心的判断方式是一样的。如果前面学了linux，注意最后 | 这个符号在R里表示<strong>或</strong>，不要和管道混淆。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ggplot<span class="punctuation">(</span>data <span class="operator">=</span> 输入的数据<span class="punctuation">,</span></span><br><span class="line">      mapping <span class="operator">=</span> aes<span class="punctuation">(</span>x <span class="operator">=</span> 定义值<span class="punctuation">,</span></span><br><span class="line">                   y <span class="operator">=</span> 定义值<span class="punctuation">,</span></span><br><span class="line">                   其他参数<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">      genom_point<span class="punctuation">(</span>参数<span class="punctuation">)</span> <span class="operator">+</span>       <span class="comment"># 选择作图方法和参数 </span></span><br><span class="line">    其他设置函数和参数              <span class="comment"># 可有可无，美观相关的东西</span></span><br></pre></td></tr></table></figure><p>我总结了一下ggplot最基本的结构，data和mapping是<strong>缺省值</strong>，可以<strong>不写</strong>。</p><p>输入的数据可以是表格，可以是数据框等等；aes自定义点的映射范围，大小，颜色等等；作图方法有很多，比如点状图是genom_point。自由度很高，能设置的东西也非常之多，只有两点需要注意，<strong>同一个函数不同参数用 , 隔开；不同函数用 + 隔开</strong>。</p><hr><p>中间的设置函数也稍微解释一下：</p><p><code>scale_color_manual()</code>  该函数是R中的一种自定义配色方法，手动把颜色赋值给参数value。我这里将UP的点赋予了红色，DOWN的点赋予蓝色，其他点赋予灰色。</p><p><code>theme()</code> 该函数与主题配置有关，参数非常多，可以选取需要的比如背景色、网格线等等进行设置。这里举个例子，legend是图标，在ggplot中legend有四部分： legend.tittle, legend.text, legend.key和legend.backgroud，而每一个部分都有四种函数可以嵌套（也是是对应4种处理方式）：<code>element_text()</code>绘制标题相关；<code>element_rect()</code>绘制背景相关；<code>element_blank()</code>空主题，对元素不分配绘图空间；<code>element_get()</code>得到当前主题的设置。每个函数还有相应的参数，说起来就没完没了了。。。常用的设置知道就行。</p><p><code>geom_vline() 和 geom_hline()</code> 这两个函数分别设置x轴y轴辅助线，目的是使我的火山图更直观，从图上可以直接看到我的分类依据。</p><p><code>labs()</code>  该函数自定义x轴y轴标签和图标标题。这里提一嘴，火山图标题也是一个注意点，一般是 <strong>处理组vs对照组</strong> ，因此前面也说到DESeq2处理数据要注意顺序问题，不然会得出完全相反的结论，在火山图上的表现为与实际火山图呈镜像对称，这也很好理解。</p><p>这里看一下res结果，我们可以在plots中看到缩略的预览图：</p><p><img src="https://www.shelven.com/tuchuang/20220425/3.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220425/3.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="3-3-ggrepel"><a href="#3-3-ggrepel" class="headerlink" title="3.3 ggrepel"></a>3.3 ggrepel</h3><p>在过滤掉4000多个FDR值为NA的点，我们获得了一个不怎么像火山的火山图 <del>（简直丑爆了）</del> ，但是数据还是挺美丽的，上调区域和下调区域都有前后对比差异非常大的基因：log2FC绝对值越大，差异越明显；-log10（FDR）值越大，可信度越高。</p><p>但是这个图还有个缺点，我不知道这些代表性的差异点对应什么基因名，我还要回到excel里去筛选排序。因此，我推荐用ggrepel包对火山图进一步美化，加上基因标签，能一眼看到我感兴趣的基因。</p><hr><p>这个包的原理和发展咱就不说了，已经是半夜4点了。。。简单介绍下中间用到的函数的结构。</p><p><code>subset()</code> 从数据框中筛选符合条件的数据，我将UP的点和DOWN的点都提取出来。</p><p><code>order()</code> order是升序排序，因为上调和下调的基因都比较多，全部打上基因名标签是不现实也没有意义的。我按照padj列也就是FDR值进行升序排序，取前5个可信度最高的基因打上基因名标签。当基因较少的时候是可以全部打上标签的。</p><p>在前面ggplot2作图的基础上，我们加上<code>geom_text_repel()</code>这个特殊的ggreple包函数，这个函数是基于函数<code>geom_label()</code>做的改良，它将标签置于一个方框中，并且每个标签有算法优化不会重叠。该函数的结构与前面的ggplot前半部分类似：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">geom_text_repel<span class="punctuation">(</span>data <span class="operator">=</span> 输入数据<span class="punctuation">,</span></span><br><span class="line">                aes<span class="punctuation">(</span>x <span class="operator">=</span> 定义值<span class="punctuation">,</span></span><br><span class="line">                   y <span class="operator">=</span> 定义值<span class="punctuation">,</span></span><br><span class="line">                   label <span class="operator">=</span> X <span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">                其他参数</span><br></pre></td></tr></table></figure><p>这里所有参数设置都是平行的，所以只需要 , 隔开。</p><p>我之前说到提取了up和down的数据，这里我把它们rbind一下合在一起，就形成了新的数据框数据，也就是我只对前面排序筛选的上调下调各5个基因打标签。这里注意下<code>aes()</code>这里的 <strong>label</strong> 是指定标签的，也就是我们这里的基因名，应该用的行名才能和数据一一对应，这里我用X是偶然发现的一个很有趣的事：</p><p>前面导入gene数据框的时候，自动把行名加到了第一列成了单独的一列，且<strong>该列列名系统定义为X</strong>，我们可以进入environment找到gene点开看看这个数据框结构，如下所示：</p><p><img src="https://www.shelven.com/tuchuang/20220425/4.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220425/4.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>因此这里直接用<code>label = X</code>就能完美解决问题。反而我回头用<code>row.names = 1</code>用第一列做行名修改了gene数据框的读取方式，再在这里用<code>label = rowname(gene)</code>会提示长度错误或者不匹配，个中原因我暂时还没想明白。</p><hr><p>其他特有参数就解释一下我用到的几个：</p><p>size: 标签大小</p><p>box.padding: 标签连接方式，我用了线</p><p>segment.color: 线段颜色，可以用RGB颜色代码</p><p>show.legend: 是否显示标签的标签   &#x3D;_&#x3D;好像有点绕，说白了就是要不要再图标上再打标签…</p><hr><p>同样放一张plots里的缩略图，是不是要直观一点了呢？</p><p><img src="https://www.shelven.com/tuchuang/20220425/5.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220425/5.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="3-4-结果输出"><a href="#3-4-结果输出" class="headerlink" title="3.4 结果输出"></a>3.4 结果输出</h3><p><code>ggsave()</code>是ggplot2包里的输出结果的函数，自定义输出的文件类型，比如pdf、png等等，还可以自定义输出图片大小，这里不赘述，主要放一个完成图看看和plots里的缩略图做个比较。完成图如下：</p><p><img src="https://www.shelven.com/tuchuang/20220425/6.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220425/6.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>可能还是有些不美观，但是这些数据很不错，极端点偏离X轴和Y轴较远，都是我们需要重点关注的基因。</p><p>如果我们记下了这几个极端点，我们还可以通过在ggplot中限制X轴和Y轴范围比如<code>xlim(-10, 10) + ylim(0, 14)</code>，再次缩小范围，得到一个更像火山的火山图 <del>(没有意义，纯粹吃饱了撑的)</del> 如下：</p><p><img src="https://www.shelven.com/tuchuang/20220425/7.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220425/7.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h2&gt;&lt;div class=&quot;story post-story&quot;&gt;&lt;p&gt;前面介绍了怎么用DESeq2做两组样本的差异基因表达分析，以</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="转录组数据分析" scheme="http://www.shelven.com/categories/%E8%BD%AC%E5%BD%95%E7%BB%84%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
    <category term="R语言" scheme="http://www.shelven.com/tags/R%E8%AF%AD%E8%A8%80/"/>
    
    <category term="ggplot2" scheme="http://www.shelven.com/tags/ggplot2/"/>
    
    <category term="ggrepel" scheme="http://www.shelven.com/tags/ggrepel/"/>
    
  </entry>
  
  <entry>
    <title>linux操作指令总结整理</title>
    <link href="http://www.shelven.com/2022/04/20/b.html"/>
    <id>http://www.shelven.com/2022/04/20/b.html</id>
    <published>2022-04-20T15:44:49.000Z</published>
    <updated>2022-05-23T19:55:33.840Z</updated>
    
    <content type="html"><![CDATA[<p>该篇内容非常之多，主要记录自己能用的上的linux操作指令和自己的一些理解，想要用的时候方便站内搜索直接查找</p><h2 id="1-linux常用命令"><a href="#1-linux常用命令" class="headerlink" title="1. linux常用命令"></a>1. linux常用命令</h2><div class="story post-story"><p><strong>cd</strong><br>cd：Change directory<br>修改（进入）工作目录，只对目录文件有效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /    进入根(root)目录</span><br><span class="line">cd -    返回上次的目录</span><br><span class="line">cd      返回家(home)目录</span><br><span class="line">cd ~    返回家目录</span><br><span class="line">cd ..   返回上一级目录</span><br></pre></td></tr></table></figure><hr><p><strong>ls</strong></p><p>ls：List files<br>ls计算不了目录内文件大小，所以显示的目录大小不是实际的，要看目录实际大小用du命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-a  列出包括.a开头的隐藏文件的所有文件</span><br><span class="line">-A  通-a，但不列出&quot;.&quot;和&quot;..&quot;</span><br><span class="line">-l  列出文件的详细信息</span><br><span class="line">-c  根据ctime排序显示</span><br><span class="line">-t  根据文件修改时间排序</span><br><span class="line">-h  将文件大小按照易于读懂的方式显示（多少M，多少G）</span><br></pre></td></tr></table></figure><p>ll和ls-l是同样的用法，linux可用，mac中不能用，可以改环境变量文件自定义ll用法</p><hr><p><strong>pwd</strong><br>pwd：print working directory，打印当前所在目录</p><hr><p><strong>cp</strong><br>cp: Copy file<br>拷贝并粘贴文件，并且可以重命名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-b  覆盖前做备份</span><br><span class="line">-f  如存在不询问而强制覆盖</span><br><span class="line">-i  如存在则询问是否覆盖</span><br><span class="line">-u  较新才覆盖</span><br><span class="line">-t  将多个源文件移动到统一目录下，目录参数在前，文件参数在后</span><br></pre></td></tr></table></figure><p><code>$ cp ../data/xist.fa xist_seq.fa         # 复制上一个目录data目录下的xist.fa到当前目录，并重命名为xist_seq.fa</code><br><code>$ cp -r 003/ 007         # 递归的方式，复制003目录到007目录，目录复制到目录要用递归</code></p><hr><p><strong>mv</strong><br>mv: Move file<br>移动文件，相当于windows下的剪切粘贴，如果剪切粘贴到同一目录下，则为重命名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-b  覆盖前做备份</span><br><span class="line">-f  如存在不询问而强制覆盖</span><br><span class="line">-i  如存在则询问是否覆盖</span><br><span class="line">-u  较新才覆盖</span><br><span class="line">-t  将多个源文件移动到统一目录下，目录参数在前，文件参数在后</span><br></pre></td></tr></table></figure><p><code>$ mv a1.index.sh ../         # 移动到上一目录</code><br><code>$ mv a1.index.sh a2.index.sh     # 重命名为a2.index.sh</code><br><code>$ rename txt doc *    # 把所有txt改成doc，批量文件重命名可以用rename</code></p><hr><p><strong>rm</strong><br>rm: Remove file<br>删除文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-r  删除文件夹（就是删除目录）</span><br><span class="line">-f  删除不提示</span><br><span class="line">-i  删除提示</span><br><span class="line">-v  详细显示进行步骤</span><br></pre></td></tr></table></figure><p>一定要慎重使用，命令行模式下删除文件不可恢复<br><code>$ rm -rf *.fna  #删除目录下所有以.fna结尾的文件</code></p><hr><p><strong>ln</strong><br>ln: Link files<br>创建连接文件，包括软连接和硬链接，一般软连接比较常用，相当于windows下的快捷方式；硬链接相当于重要文件的备份，默认硬链接<br><strong>删除原文件，硬链接文件不受影响，软连接文件则无效</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-s  建立软连接  </span><br><span class="line">-v  显示详细的处理过程</span><br></pre></td></tr></table></figure><hr><p><strong>mkdir</strong><br>mkdir：Make directory<br>创建文件夹(目录)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-p  递归创建目录，若父目录不存在则依次创建</span><br><span class="line">-m  自定义创建目录的权限</span><br><span class="line">-v  显示创建目录的详细信息</span><br></pre></td></tr></table></figure><p><code>$ mkdir rnaseq   #创建一个名为rnaseq的目录</code></p><hr><p><strong>touch</strong><br>建新的空文件(可写入的文件)<br><code>$ touch 1.txt 2.txt 3.txt    # 同时新建三个文件，一个文件可以直接vim建立</code></p><hr><p><strong>cat</strong><br>cat: concatenate 连接<br>cat的一个作用是查看文件，一般是比较小的文件，行数小于一个屏幕，最多不要超过两个屏幕，否则会刷屏（屏幕输出的方式）<br>cat另一个作用是合并多个文件，一般配合重定向合并为一个新文件或者将一个文件内容追加到另一个文件结尾<br><code>$ cat a1.txt a2.txt &gt;all.txt     # 合并文件，并不会删除原文件，覆盖新文件内容，新文件为all.txt</code><br><code>$ cat a1.txt &gt;&gt;a2.txt    # 同样是合并，a1重定向到a2结尾</code><br><code>$ cat &gt;id.txt        # 回车输入内容，可新建id.txt文件，ctrl+c退出  echo不可以这样新建，只能echo &quot;内容&quot;&gt;id.txt</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-A  显示文件内的空白信息</span><br></pre></td></tr></table></figure><p><strong>linux系统下是换行\n；mac系统下是回车\r；windows系统下回车加换行两个字符\r\n</strong> 三者都是空白，用less无法看出区别，只能在cat -A下看到不同操作系统的换行符信息</p><hr><p><strong>less &#x2F; more</strong><br>less和more都是文件查看工具，但是less功能更多一些，在windows系统下打开一个10G的文件比较困难，但是在Linux下非常方便，less可以打开非常大的文件，压缩格式也可以直接打开。注意后面接文件，不能接目录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-m  显示类似于more命令的百分比</span><br><span class="line">-N  显示行号</span><br></pre></td></tr></table></figure><p>more：q退出，space向下翻一页，enter向下滚动一行，b往前翻一页，会加载全部显示浏览到百分之几，退出后会加载显示的所有内容<br>less：类似，还可以用pageup和pagedown，不会加载全部，退出后不会加载文件内容显示到当前界面<br>less下按h进入帮助界面；按&#x2F;向下搜索字符串，按？向上搜索字符串，搜索状态下n和p前后跳转；按v进入编辑</p><hr><p><strong>head &#x2F; tail</strong><br>这两个命令比较简单，只是取一个文件的头部和尾部多少行，默认10行，可以加-n进行设置，利用管道可以取文件中间行<br><code>$ head -40 a.txt | tail -20  #取文件第21~40行</code><br><code>$ tail -n +20 notes.log  #取文件的第20行到文件末尾</code></p><hr><p><strong>g(un)zip&#x2F; b(un)zip2</strong><br>gzip和bzip2是文件压缩工具，默认直接对源文件进行处理，压缩比率在2&#x2F;3左右，都可以进行设置<br>加上un，为unpack的意思，表示解压缩<br>linux压缩文件格式是.gz和.bz2<br>windows压缩文件有.rar文件，可以下载rarlinux工具解压缩；.zip文件可以通过unzip命令解压<br>bzip2压缩比更高（尽量下载bz2压缩文件），但是占用更多CPU<br><code>$ gzip a.txt     # 压缩a.txt文件</code><br><code>$ gunzip a.txt.gz    # 解压a.txt.gz文件</code><br>压缩的文件可以用<strong>less</strong>或者<strong>zcat</strong>打开文件</p><hr><p><strong>tar</strong>（很多生物软件是打包并压缩的）<br>tar：Tape archive （磁带档案）<br>tar主要用于打包，由于tar能调用gzip或者bzip2进行压缩，而打包和压缩经常如windows系统一样合并为一个过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-c  建立打包档案，可搭配 -v 来察看过程中被打包的档名(filename)</span><br><span class="line">-t  察看打包档案的内容含有哪些档名，重点在察看文档名就是了（同less功能）</span><br><span class="line">-x  解打包或解压缩的功能，可以搭配 -C (大写) 在特定目录解开</span><br></pre></td></tr></table></figure><p><strong>以上三个命令不能同时使用，只能三选一</strong><br>辅选项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-j  透过 bzip2 的支持进行压缩/解压缩：此时档名最好为 *.tar.bz2</span><br><span class="line">-z  透过 gzip 的支持进行压缩/解压缩：此时档名最好为 *.tar.gz</span><br><span class="line">-v  在压缩/解压缩的过程中，将正在处理的文件名显示出来！</span><br><span class="line">-f  filename -f 后面要立刻接要被处理的档名！f很重要，每次执行tar命令都要加上</span><br></pre></td></tr></table></figure><p>对于初学者，记住<strong>c是creat，创建，x是解包，z对应gzip，j对应bzip2</strong>即可，所以常用的命令如下：<br><code>$ tar -jcvf filename.tar.bz2 A B C     #打包压缩为bz2结尾文件</code><br><code>$ tar -jxvf filename.tar.bz2       # 解压缩.tar.bz2结尾文件</code><br><code>$ tar -zcvf filename.tar.gz A B C  #打包压缩为gz结尾文件</code><br><code>$ tar -zxvf filename.tar.gz        # 解压缩.tar.gz 结尾文件</code><br><code>$ tar -jxvf filename.tar.bz2 -C 目录名     #解压缩到指定目录，注意是大写C</code><br>less命令可以不解压只查看（真的强大），tar -tf filename同样<br>如果只需解压其中一个文档，可以先通过-t查看文档名并复制，再在前面解压缩的命令基础上加空格和文档名</p><hr><p><strong>wc</strong><br>wc &#x3D; Word Count<br>统计一个文件中，行数，单词数（有空格或者换行符的字符串），字符数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-l  filename 报告行数</span><br><span class="line">-c  filename 报告字节数</span><br><span class="line">-m  filename 报告字符数</span><br><span class="line">-w  filename 报告单词数</span><br></pre></td></tr></table></figure><p>统计当前目录下有多少文件<br><code>$ ll | wc    # 注意显示行数比实际多两行，因为还有隐藏的当前目录.和上一层目录.. 可通过ls -a查看</code></p><hr><p><strong>sort</strong><br>排序，默认按第一列排序，可以通过-k进行设置；默认排序规则为按ASCII码排序，可以通过-n进行修改；-r取相反方向；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-n  依照数值的大小排序。</span><br><span class="line">-o  将排序后的结果存入指定的文件。</span><br><span class="line">-r  以相反的顺序来排序。</span><br><span class="line">-t  指定排序时所用的栏位分隔字符。</span><br><span class="line">-k  选择以哪个区间进行排序。</span><br></pre></td></tr></table></figure><p><code>$ sort -nk2 -k1 01.txt | less      # 在01.txt文件中，根据第二列数字大小进行排序，数字一样的比较第一列并排序</code></p><hr><p><strong>uniq</strong><br>用于检查及删除文本文件中重复出现的行列，一般与 sort 命令结合使用，排序之后使用uniq</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-u  显示未重复的行</span><br><span class="line">-c  统计重复行的数量（在行首标注）</span><br><span class="line">-ci 忽略大小写统计重复行</span><br><span class="line">-d  显示重复出现的行</span><br></pre></td></tr></table></figure><p><code># cut -f 1 blast.out | sort -t &quot;|&quot; -nk2 | uniq | wc -l    #从blast.out文件中提取第一列（f代表字段），第一列字段以“|”分割并比较第二段的数字大小进行排序，去除重复行，并记录行数   即记录有多少条比对上的基因</code></p><hr><p><strong>df</strong><br>df: disk free<br>df用于查看磁盘消耗，显示磁盘可用空间数目信息及空间结点信息。一般加一个-h选项，然后接要查看的磁盘，默认所有磁盘。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-a  显示全部文件系统</span><br><span class="line">-h  文件大小友好显示</span><br><span class="line">-l  只显示本地文件系统</span><br><span class="line">-i  显示inode信息</span><br><span class="line">-T  显示文件系统类型</span><br></pre></td></tr></table></figure><hr><p><strong>du</strong><br>du: Disk usage<br>df用于查看磁盘使用情况，du用于查看目录所占磁盘大小，一般也加-h选项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-h  方便阅读的方式（显示带单位）</span><br><span class="line">-s  只显示总和的大小</span><br></pre></td></tr></table></figure><hr><p><strong>find</strong><br>find顾名思义，主要用于查找文件。因为当文件越来越多的时候，由于Linux是文本界面，不方便可视化文件，这个时候就可以利用find快速找到需要的文件。find支持多种搜索方式<br>主要用的搜索方式：<code>find 目录 Expression 条件</code><br><code>$ find /media/ -name *.fna    #查找media目录下所有.fna结尾的文件</code><br><code>$ find /media/ -size 100M    #查找media目录下所有大于100M的文件</code></p><hr><p><strong>which</strong><br><code>$ which filename # 查看可执行文件的位置，在PATH变量指定的路径中查看系统命令是否存在及其位置</code></p><hr><p><strong>whereis</strong><br>该指令只能用于查找二进制文件、源代码文件和man手册页，一般文件的定位需使用locate命令</p><hr><p><strong>locate</strong><br>是find -name的另一种写法，但是要比后者快得多，原因在于它不搜索具体目录，而是搜索一个数据库&#x2F;var&#x2F;lib&#x2F;locatedb，这个数据库中含有本地所有文件信息。Linux系统自动创建这个数据库，并且每天自动更新一次，所以使用locate命令查不到最新变动过的文件。为了避免这种情况，<strong>可以在使用locate之前，先使用updatedb命令，手动更新数据库</strong></p><hr><p><strong>top</strong><br>top可以动态显示（3s一次）系统进程使用情况，类似于windows系统的任务管理器。可以显示当前系统正在执行的进程的相关信息，包括进程ID、内存占用率、CPU占用率等。</p><hr><p><strong>ps</strong><br>ps: process status<br>ps也是系统进程管理工具，与top不同的是，top可以动态显示，而ps则是静态显示，是某一时刻的快照，静态显示的好处是便于其他程序捕获结果，进行处理。</p><hr><p><strong>kill</strong><br>kill的作用是杀死进程，给定一个任务的PID号，可以通过top或者ps命令获得，例如当前有一个sleep进程，pid号为12000；通过kill -9可以强制杀死<br><code>$ kill -9 12000</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1   终端断线</span><br><span class="line">2   中断，相当于ctrl+c</span><br><span class="line">2   退出，同ctrl+\</span><br><span class="line">9   强制终止</span><br><span class="line">15  终止进程，默认为15</span><br><span class="line">18  继续，与STOP相反，fg/bg命令</span><br><span class="line">19  暂停，同ctrl+z</span><br></pre></td></tr></table></figure><hr><p><strong>chmod</strong><br>chmod: Change mode<br>用于修改文件权限，Linux基础权限可以包括ugo模式（文字设定法）以及421模式（数字设定法），可以用通配符一次修改所有类型的文件<br>文字设定法：<br>u表示属主(user)，g表示同组群用户(group)，o表示其他用户(other)，a表示所有用户(all)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+  添加权限</span><br><span class="line">-  删除权限</span><br><span class="line">=  赋予给定权限，并取消其他所有权限</span><br><span class="line">r  可读(read)</span><br><span class="line">w  可写(write)</span><br><span class="line">x  可执行(execute)</span><br></pre></td></tr></table></figure><p>数字设定法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0表示没有权限，1表示可执行权限，2表示可写权限，4表示可读权限</span><br><span class="line">7：可读可写可执行 4+2+1</span><br><span class="line">6：可读可写 4+2</span><br><span class="line">5：可读可执行4+1</span><br></pre></td></tr></table></figure><p><code>$ chmod 721 a1.index.sh    # 421模式修改</code><br>与之类似的还有chown与chgrp，这两个权限更大，需要root权限；<br><strong>chown</strong>: Change owner<br><code>$ chown 用户名 目录名/     # 修改目录的属主</code><br><strong>chgrp</strong>: Change group<br><code>$ chgrp 组名 目录名/       # 修改目录的组名</code></p><hr><p><strong>exit</strong><br>退出登录，exit是正确退出，最好不要直接点windows关闭窗口按钮退出，也不要使用ctrl+D给定退出信号退出。</p><hr><p><strong>man</strong><br>详细解释命令，系统命令可以用这个找，下载的程序往往是–help</p><hr><p><strong>wget</strong><br>后面接下载网址，可以直接由地址获取下载文件</p><hr><p><strong>su</strong>：super user<br>获得超级管理员权限，root权限，需要输入密码<br><strong>sudo</strong>：super user do<br>暂时取得root权限，配置系统经常能看到sudo yum</p><hr><p><strong>echo</strong><br>在标准输出（屏幕）上显示文字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-n  输出之后不换行，去除结尾的换行符。注意默认一行后有一个换行符</span><br><span class="line">-e  转义字符按照对应方式处理</span><br></pre></td></tr></table></figure><hr><p><strong>yum</strong>（centos是yum，ubuntu是apt）</p><p>Yellow dog Updater Modified是一个软件包管理器，能够从指定的服务器自动下载rpm包进行安装并且自动处理依赖性关系，yum优点提供了查找、安装、删除某一个、一组甚至全部软件包的命令，并且命令简洁便于使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">yum clean all               # 清除原有yum缓存</span><br><span class="line">yum repolist                # 列出仓库信息</span><br><span class="line">yum install software        # 安装</span><br><span class="line">yum update                  # 更新</span><br><span class="line">yum list software           # 查看软件</span><br><span class="line">yum list all                # 查看所有软件</span><br><span class="line">yum list installed          # 列出已安装软件</span><br><span class="line">yum list available          # 列出可安装软件</span><br><span class="line">yum reinstall software      # 重新安装</span><br><span class="line">yum remove software         # 卸载</span><br><span class="line">yum info software           # 查看软件信息</span><br><span class="line">yum search software         # 根据软件信息查找软件</span><br><span class="line">yum whatprovides file       # 根据文件找出包含此文件的软件</span><br><span class="line">yum history                 # 查看系统中软件管理信息</span><br><span class="line">yum history info 数字        # 对该数字为id的信息进行显示</span><br><span class="line">yum groups list             # 列出软件组 </span><br><span class="line">yum groups info             # 查看软件组的信息</span><br><span class="line">yum groups install sfgroup  # 安装软甲组</span><br><span class="line">yum groups remove sfgroup   # 卸载软件组</span><br><span class="line">yum repolist                # 查看yum源信息</span><br></pre></td></tr></table></figure><hr><p><strong>cut</strong><br>命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段写至标准输出<br>如果不指定 File 参数，cut 命令将读取标准输入。必须指定 -b、-c 或 -f 标志之一</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-b  以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了 -n 标志</span><br><span class="line">-c  以字符为单位进行分割</span><br><span class="line">-d  自定义分隔符，默认为制表符</span><br><span class="line">-f  与-d一起使用，指定显示哪个区域</span><br></pre></td></tr></table></figure><hr><p><strong>xargs</strong><br>与管道不同，xargs可以给下个命令传递参数。<br><code>$ ls *.gz | head   #只可以输出前10个文件名</code><br><code>$ ls *.gz | xargs head     #输出.gz结尾的所有文件前10行</code><br>这里要注意下其实命令是有省略的，完整应该是<code>ls *.gz | xargs -i head&#123;&#125;    #传递参数到head的花括号中</code></p><hr><p><strong>jobs</strong><br>查看当前在后台执行的命令，可查看命令进程号码</p><hr><p><strong>&amp;</strong><br>运行命令时，在命令末尾加上&amp;可让命令在后台执行</p><p>顺便说一下 |  ; &amp;&amp; ||区别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&amp;&amp;     左边命令成功运行了，右边命令才会运行，就是逻辑与的功能</span><br><span class="line">;      不管左边命令有没有成功运行，右边命令都会运行，两者之间独立</span><br><span class="line">|      左边命令的结果作为右边命令的参数，注意与xargs区分</span><br><span class="line">||     左边运行的命令失败，右边的命令才会运行，否则只显示左边命令运行结果</span><br></pre></td></tr></table></figure><hr><p><strong>nohup</strong><br>命令可以使命令永久的执行下去，和终端没有关系，退出终端也不会影响程序的运行； &amp; 是后台运行的意思，但当用户退出的时候，命令自动也跟着退出。 那么，把两个结合起来nohup 命令 &amp;这样就能使命令永久的在后台执行</p><hr><p><strong>fg N</strong><br>将命令进程号码为N的命令进程放到前台执行，同%N  #注意是进程号不是PID！kill程序需要PID</p><p><strong>bg N</strong><br>将命令进程号码为N的命令进程放到后台执行</p><p><strong>cal</strong> 显示日历</p><p><strong>date</strong>    显示时间</p></div><h2 id="2-基本操作"><a href="#2-基本操作" class="headerlink" title="2. 基本操作"></a>2. 基本操作</h2><div class="story post-story"><p><strong>源码编译</strong><br>安装软件都有Readme文件或者install文件说明安装方式，一般是以下步骤：<br>1、运行configue脚本 #检查系统环境配置情况，缺少哪些东西，缺少的可以yum下载安装<br>2、运行make check命令（可选）<br>3、敲make命令进行编译<br>4、make install命令安装，出现可执行程序</p><hr><p><strong>文件校验</strong><br>下载大的文件会附带.md5文件<br>任意长度信息逐位计算，产生128位hash值，不可逆。也就是说MD5算法可以位任何文件产生一个独一无二的数据指纹，通过校验下载前后的MD5值是否发生改变，就可以知道源文件是否被改动<br><code>$ md5sum filename &gt; data.md5   # 对文件（可多个文件）生成md5校验码（32位，16进制），并命名为data.md5</code><br><code>$ md5sum -c data.md5       # 校验文件，如果校验码相同则显示OK</code></p><hr><p><strong>重定向</strong><br>本质是将输出到屏幕的内容重定向到一个新的文件夹中，大于号和小于号都是代表数据的流向<br><code>$ echo “想要的内容”&gt; 文件名  #覆盖原文件的内容</code><br><code>$ echo “想要的内容”&gt;&gt; 文件名  #想要的内容追加到文件后，原文件内容不修改</code><br>一个&gt;是覆盖，两个&gt;&gt;是追加</p><hr><p><strong>Ctrl+C</strong><br><strong>终止</strong>并退出前台命令的执行，回到SHELL</p><p><strong>Ctrl+Z</strong><br><strong>暂停</strong>前台命令的执行，将该进程放入后台，回到SHELL</p><hr></div><h2 id="3-vim"><a href="#3-vim" class="headerlink" title="3. vim"></a>3. vim</h2><div class="story post-story"><p>vim（主要用来写脚本，编辑文件）<br>vim是Linux系统自带的文本编辑器，可以理解成为windows系统下的word软件，适合编辑小文件，会一次加载全部内容到内存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:w filename 将文件以指定的文件名保存起来  </span><br><span class="line">:wq         保存并退出</span><br><span class="line">:q!         不保存而强制退出</span><br></pre></td></tr></table></figure><p>注意vim是vi的拓展，有些自定义设置要在vim下生效，最好是用vim<br>用户设置优先级高于全局设置，设置文件都在家目录~下设置，且均为点开头的隐藏文件，如下<br>~&#x2F;.vimrc<br>~&#x2F;.bashrc</p><h3 id="3-1-命令行模式功能键："><a href="#3-1-命令行模式功能键：" class="headerlink" title="3.1 命令行模式功能键："></a>3.1 命令行模式功能键：</h3><p><strong>1）插入模式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i   切换进入插入模式 insert mode ，按&quot;i&quot;进入插入模式后是从光标当前位置开始输入文件</span><br><span class="line">a   进入插入模式后，是从目前光标所在位置的下一个位置开始输入文字</span><br><span class="line">o   进入插入模式后，是插入新的一行，从行首开始输入文字</span><br></pre></td></tr></table></figure><p><strong>2）从插入模式切换为命令行模式</strong><br>按 ESC 键<br><strong>3）移动光标</strong><br>直接用键盘上的光标来上下左右移动，也可以用小写英文字母h、j、k、l，分别控制光标左、下、上、右移一格。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">G   移动到文件末尾，15G移动光标至文章的第15行行首</span><br><span class="line">gg  移动到文件开头</span><br><span class="line">$   移动到光标所在行的行尾</span><br><span class="line">^   移动到光标所在行的行首</span><br><span class="line">H   光标移动到这个屏幕的最上方那一行的第一个字符</span><br><span class="line">M   光标移动到这个屏幕的中央那一行的第一个字符</span><br><span class="line">L   光标移动到这个屏幕的最下方那一行的第一个字符</span><br></pre></td></tr></table></figure><p><strong>4）删除文字</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x   每按一次，删除光标所在位置的后面一个字符</span><br><span class="line">X   大写的X，每按一次，删除光标所在位置的前面一个字符</span><br><span class="line">dd  删除光标所在行 1,6d删除1到6行</span><br></pre></td></tr></table></figure><p><strong>5）回复上一次操作</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u   如果误执行一个命令，可以回到上一个操作。按多次u可以执行多次回复</span><br></pre></td></tr></table></figure><p><strong>6）继续下一个操作</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n或. 比如查找一个字符串以后，继续寻找下一个字符串，按多次n执行多次操作</span><br><span class="line">N    与 n 刚好相反，为反向进行前一个搜寻动作</span><br></pre></td></tr></table></figure><h3 id="3-2-底线命令模式"><a href="#3-2-底线命令模式" class="headerlink" title="3.2 底线命令模式"></a>3.2 底线命令模式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">:/word          # 查找word字符串</span><br><span class="line">:%s/x/y/gc      # 所有x被y替换 g代表全局，c代表交互模式（每次替代会提示）</span><br><span class="line">:!命令             # 命令先执行，vim被挂起。执行后按enter回到vim</span><br><span class="line">:split          # 横屏分屏显示 ctrl+ww切换上下屏</span><br><span class="line">:vsplit         # 纵向分屏</span><br><span class="line">:only           # 取消分屏</span><br><span class="line">:n1,n2s/word1/word2/g   # 在第n1与n2行之间寻找word1这个字符串，并将该字符串取代为word2</span><br></pre></td></tr></table></figure><p>vim还有专门的键盘图。。。放一个简略版的</p><p><img src="https://www.shelven.com/tuchuang/20220420_1/1.png" class="lazyload" data-srcset="https://www.shelven.com/tuchuang/20220420_1/1.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div><h2 id="4-基础命令三剑客"><a href="#4-基础命令三剑客" class="headerlink" title="4. 基础命令三剑客"></a>4. 基础命令三剑客</h2><div class="story post-story"><p>三剑客的命令非常之多，完全可以出一本书，这里只放一些简单的和我能用得到的</p><h3 id="4-1-三剑客之grep"><a href="#4-1-三剑客之grep" class="headerlink" title="4.1 三剑客之grep"></a>4.1 三剑客之grep</h3><p>grep（找基因信息比较方便）<br>Global Regular Expression Print，全局正则表达式版本<br>文本搜索工具，类似于正则表达式搜索，可以在一个大的文件中快速搜索到满足一定规则的内容。</p><p><code>$ grep &quot;&gt;&quot;  gene.fna | wc -l   # 统计gene.fna文件中序列的条数</code><br><code>$ grep -A 2 &quot;3 gi 29732 34486&quot; lastz.axt  #将满足条件的行和下面两行显示出来</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grep -E         # grep的拓展模式</span><br><span class="line">grep -P         # 适应perl语言的正则表达式</span><br></pre></td></tr></table></figure><p>区分一下：find是搜索目录下满足条件的文件，grep是搜索文件内满足条件的内容</p><h3 id="4-2-三剑客之sed"><a href="#4-2-三剑客之sed" class="headerlink" title="4.2 三剑客之sed"></a>4.2 三剑客之sed</h3><p>sed<br>sed &#x3D; Stream Editor<br>流处理器，数据流过这个工具，格式化成固定的格式<br><code>sed + 选项参数 + &#39;模式&#39; + 文本或文件</code></p><p><strong>选项参数</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-e  替换，并输出到屏幕（搭配重定向）</span><br><span class="line">-i  原文件修改</span><br><span class="line">-f  根据模式替换</span><br><span class="line">-r  拓展的正则表达式</span><br><span class="line">-n  输出</span><br></pre></td></tr></table></figure><p><strong>模式：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g   全局</span><br><span class="line">s   替换，一个字符替换另一个</span><br><span class="line">d   删除</span><br><span class="line">p   打印</span><br></pre></td></tr></table></figure><p><strong>输出固定的行</strong><br><code>$ sed -n &#39;1307p&#39;  seq.fna      # 输出文件第1307行；</code><br><code>$ sed -n &#39;100,200p&#39; seq.fna    # 输出文件第100到200行；</code></p><p><strong>替换操作</strong><br><code>$ sed -e &#39;s/gi/GI/&#39; seq.fna    # 将文件中gi全部替换为大写GI；s为替换</code><br><code>$ sed -i &#39;s/gi/GI/g&#39; seq.fna       # 在原文件上进行替换，并且进行全部替换，g为全局（默认只进行一次替换）</code></p><p><strong>删除操作</strong><br><code>$ sed -e &#39;/^\s$/d&#39;  seq.fna    # 删除文件中的空白行，命令d为删除符合条件的行。\s为空白；^行首，$行尾</code><br><code>$ sed -e &#39;/&gt;/d&#39; seq.fna        # 删除包含ref的行，每个ref行都有&gt;</code><br><code>$ sed -e &#39;s/:.*//g&#39; seq.fna    # 删除冒号之后的所有内容</code></p><h3 id="4-3-三剑客之awk"><a href="#4-3-三剑客之awk" class="headerlink" title="4.3 三剑客之awk"></a>4.3 三剑客之awk</h3><p>awk也是非常强大的文本处理工具，awk本身也是一门编程语言<br><strong>输出一个列表任意列</strong><br><code>$ awk &#39;&#123;print $1,$NF&#125;&#39; 1.txt   # 输出1.txt的第一列和最后一列</code></p><p><strong>过滤文件结果</strong><br><code>$ awk &#39;&#123;if ($3&gt;=80 &amp;&amp; $4&gt;=100) print $0&#125;&#39;  blast_m8.out  # 过滤文件比对结果，将第三列值大于80，并且第四列值大于100的所有结果输出</code></p><p><strong>比较</strong><br><code>$ awk &#39;$8&gt;$10&#39; input.txt   # 输出第8列数值大于第10列数值的行</code></p><p><strong>输出固定行内容</strong><br><code>$ awk &#39;NR&gt;=20&amp;&amp;NR&lt;=80&#39; input.txt  #输出第20到第80行内容</code></p></div><h2 id="5-正则表达式"><a href="#5-正则表达式" class="headerlink" title="5. 正则表达式"></a>5. 正则表达式</h2><div class="story post-story"><p>正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">^   匹配输入字行首      ^eat,识别eat开头的字符串</span><br><span class="line">$   匹配输入行尾    eat$,识别eat结尾的字符串 </span><br><span class="line">\b  单词锚定符          \beat\b ,只识别eat字符串</span><br><span class="line">.   匹配除“\n”和&quot;\r&quot;之外的任何单个字符</span><br><span class="line">\   转译字符         比如匹配. 则\.</span><br><span class="line">*   匹配前面的子表达式任意次</span><br><span class="line">+   匹配前面的子表达式一次或多次(大于等于1次，例如“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”）# 需要grep -E支持（拓展）</span><br><span class="line">?   匹配前面的子表达式零次或一次  # 需要grep -E支持（拓展）</span><br><span class="line">[xyz]   字符集合。匹配所包含的任意一个字符</span><br><span class="line">x|y     匹配x或y。“z|food”能匹配“z”或“food”。“[z|f]ood”则匹配“zood”或“food”，择译匹配</span><br><span class="line">[a-z]   字符范围</span><br><span class="line">\d  匹配所有数字，等同[0-9]</span><br><span class="line">\s  空白，是字符集换页、制表、换行、回车以及空格的简写[\f\t\n\r]</span><br><span class="line">\w  [A-Za-z0-9_]单词包括大小写字母、数字和下划线</span><br><span class="line">^   负值字符范围。匹配任何不在指定范围内的任意字符。（倒三角）</span><br><span class="line">\D  非数字</span><br><span class="line">\W  非字符</span><br><span class="line">\S  非空白字符</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;该篇内容非常之多，主要记录自己能用的上的linux操作指令和自己的一些理解，想要用的时候方便站内搜索直接查找&lt;/p&gt;
&lt;h2 id=&quot;1-linux常用命令&quot;&gt;&lt;a href=&quot;#1-linux常用命令&quot; class=&quot;headerlink&quot; title=&quot;1. linux</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://www.shelven.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="linux指令" scheme="http://www.shelven.com/tags/linux%E6%8C%87%E4%BB%A4/"/>
    
  </entry>
  
</feed>
